
----------------------------------------/dataset/nuaa/anaconda3/envs/redis6.1.1/lib/python3.9/site-packages/redis/__init__.py----------------------------------------
A:redis.__init__.VERSION->tuple(map(int_or_str, __version__.split('.')))
redis.__init__.int_or_str(value)


----------------------------------------/dataset/nuaa/anaconda3/envs/redis6.1.1/lib/python3.9/site-packages/redis/retry.py----------------------------------------
A:redis.retry.T->TypeVar('T')
A:redis.retry.self._supported_errors->tuple(set(self._supported_errors + tuple(specified_errors)))
A:redis.retry.backoff->self._backoff.compute(failures)
redis.retry.Retry(self,backoff:'AbstractBackoff',retries:int,supported_errors:Tuple[Type[Exception],...]=(ConnectionError,TimeoutError,socket.timeout))
redis.retry.Retry.__eq__(self,other:Any)->bool
redis.retry.Retry.__hash__(self)->int
redis.retry.Retry.__init__(self,backoff:'AbstractBackoff',retries:int,supported_errors:Tuple[Type[Exception],...]=(ConnectionError,TimeoutError,socket.timeout))
redis.retry.Retry.call_with_retry(self,do:Callable[[],T],fail:Callable[[Exception],Any])->T
redis.retry.Retry.get_retries(self)->int
redis.retry.Retry.update_retries(self,value:int)->None
redis.retry.Retry.update_supported_errors(self,specified_errors:Iterable[Type[Exception]])->None


----------------------------------------/dataset/nuaa/anaconda3/envs/redis6.1.1/lib/python3.9/site-packages/redis/lock.py----------------------------------------
A:redis.lock.logger->logging.getLogger(__name__)
A:redis.lock.self.thread_local->bool(thread_local)
A:redis.lock.cls.lua_release->client.register_script(cls.LUA_RELEASE_SCRIPT)
A:redis.lock.cls.lua_extend->client.register_script(cls.LUA_EXTEND_SCRIPT)
A:redis.lock.cls.lua_reacquire->client.register_script(cls.LUA_REACQUIRE_SCRIPT)
A:redis.lock.token->self.redis.get_encoder().encode(token)
A:redis.lock.encoder->self.redis.get_encoder()
A:redis.lock.timeout->int(self.timeout * 1000)
A:redis.lock.stored_token->self.redis.get_encoder().encode(stored_token)
A:redis.lock.additional_time->int(additional_time * 1000)
redis.lock.Lock(self,redis,name:str,timeout:Optional[Number]=None,sleep:Number=0.1,blocking:bool=True,blocking_timeout:Optional[Number]=None,thread_local:bool=True,raise_on_release_error:bool=True)
redis.lock.Lock.__enter__(self)->'Lock'
redis.lock.Lock.__exit__(self,exc_type:Optional[Type[BaseException]],exc_value:Optional[BaseException],traceback:Optional[TracebackType])->None
redis.lock.Lock.__init__(self,redis,name:str,timeout:Optional[Number]=None,sleep:Number=0.1,blocking:bool=True,blocking_timeout:Optional[Number]=None,thread_local:bool=True,raise_on_release_error:bool=True)
redis.lock.Lock.acquire(self,sleep:Optional[Number]=None,blocking:Optional[bool]=None,blocking_timeout:Optional[Number]=None,token:Optional[str]=None)
redis.lock.Lock.do_acquire(self,token:str)->bool
redis.lock.Lock.do_extend(self,additional_time:Number,replace_ttl:bool)->bool
redis.lock.Lock.do_reacquire(self)->bool
redis.lock.Lock.do_release(self,expected_token:str)->None
redis.lock.Lock.extend(self,additional_time:Number,replace_ttl:bool=False)->bool
redis.lock.Lock.locked(self)->bool
redis.lock.Lock.owned(self)->bool
redis.lock.Lock.reacquire(self)->bool
redis.lock.Lock.register_scripts(self)->None
redis.lock.Lock.release(self)->None


----------------------------------------/dataset/nuaa/anaconda3/envs/redis6.1.1/lib/python3.9/site-packages/redis/backoff.py----------------------------------------
A:redis.backoff.max_backoff->max(self._base, self._previous_backoff * 3)
A:redis.backoff.temp->random.uniform(self._base, max_backoff)
A:redis.backoff.self._previous_backoff->min(self._cap, temp)
redis.backoff.AbstractBackoff(ABC)
redis.backoff.AbstractBackoff.compute(self,failures:int)->float
redis.backoff.AbstractBackoff.reset(self)
redis.backoff.ConstantBackoff(self,backoff:float)
redis.backoff.ConstantBackoff.__eq__(self,other)->bool
redis.backoff.ConstantBackoff.__hash__(self)->int
redis.backoff.ConstantBackoff.__init__(self,backoff:float)
redis.backoff.ConstantBackoff.compute(self,failures:int)->float
redis.backoff.DecorrelatedJitterBackoff(self,cap:float=DEFAULT_CAP,base:float=DEFAULT_BASE)
redis.backoff.DecorrelatedJitterBackoff.__eq__(self,other)->bool
redis.backoff.DecorrelatedJitterBackoff.__hash__(self)->int
redis.backoff.DecorrelatedJitterBackoff.__init__(self,cap:float=DEFAULT_CAP,base:float=DEFAULT_BASE)
redis.backoff.DecorrelatedJitterBackoff.compute(self,failures:int)->float
redis.backoff.DecorrelatedJitterBackoff.reset(self)->None
redis.backoff.EqualJitterBackoff(self,cap:float=DEFAULT_CAP,base:float=DEFAULT_BASE)
redis.backoff.EqualJitterBackoff.__eq__(self,other)->bool
redis.backoff.EqualJitterBackoff.__hash__(self)->int
redis.backoff.EqualJitterBackoff.__init__(self,cap:float=DEFAULT_CAP,base:float=DEFAULT_BASE)
redis.backoff.EqualJitterBackoff.compute(self,failures:int)->float
redis.backoff.ExponentialBackoff(self,cap:float=DEFAULT_CAP,base:float=DEFAULT_BASE)
redis.backoff.ExponentialBackoff.__eq__(self,other)->bool
redis.backoff.ExponentialBackoff.__hash__(self)->int
redis.backoff.ExponentialBackoff.__init__(self,cap:float=DEFAULT_CAP,base:float=DEFAULT_BASE)
redis.backoff.ExponentialBackoff.compute(self,failures:int)->float
redis.backoff.ExponentialWithJitterBackoff(self,cap:float=DEFAULT_CAP,base:float=DEFAULT_BASE)
redis.backoff.ExponentialWithJitterBackoff.__eq__(self,other)->bool
redis.backoff.ExponentialWithJitterBackoff.__hash__(self)->int
redis.backoff.ExponentialWithJitterBackoff.__init__(self,cap:float=DEFAULT_CAP,base:float=DEFAULT_BASE)
redis.backoff.ExponentialWithJitterBackoff.compute(self,failures:int)->float
redis.backoff.FullJitterBackoff(self,cap:float=DEFAULT_CAP,base:float=DEFAULT_BASE)
redis.backoff.FullJitterBackoff.__eq__(self,other)->bool
redis.backoff.FullJitterBackoff.__hash__(self)->int
redis.backoff.FullJitterBackoff.__init__(self,cap:float=DEFAULT_CAP,base:float=DEFAULT_BASE)
redis.backoff.FullJitterBackoff.compute(self,failures:int)->float
redis.backoff.NoBackoff(self)
redis.backoff.NoBackoff.__init__(self)
redis.backoff.default_backoff()
redis.default_backoff()


----------------------------------------/dataset/nuaa/anaconda3/envs/redis6.1.1/lib/python3.9/site-packages/redis/client.py----------------------------------------
A:redis.client.data->CaseInsensitiveDict(data)
A:redis.client.single_connection_client->kwargs.pop('single_connection_client', False)
A:redis.client.connection_pool->ConnectionPool(**kwargs)
A:redis.client.client->cls(connection_pool=connection_pool)
A:redis.client.self._event_dispatcher->EventDispatcher()
A:redis.client.self.single_connection_lock->threading.Lock()
A:redis.client.self.connection->self.connection_pool.get_connection()
A:redis.client.self.response_callbacks->CaseInsensitiveDict(_RedisCallbacks)
A:redis.client.shard_hint->kwargs.pop('shard_hint', None)
A:redis.client.value_from_callable->kwargs.pop('value_from_callable', False)
A:redis.client.watch_delay->kwargs.pop('watch_delay', None)
A:redis.client.func_value->func(pipe)
A:redis.client.exec_value->pipe.execute()
A:redis.client.response->self.parse_response(connection, '_')
A:redis.client.monitor_re->re.compile('\\[(\\d+) (.*?)\\] (.*)')
A:redis.client.command_re->re.compile('"(.*?)(?<!\\\\)"')
A:redis.client.(command_time, command_data)->self.parse_response(connection, '_').split(' ', 1)
A:redis.client.m->self.monitor_re.match(command_data)
A:redis.client.(db_id, client_info, command)->self.monitor_re.match(command_data).groups()
A:redis.client.command->command.replace('\\"', '"').replace('\\"', '"')
A:redis.client.(client_address, client_port)->client_info.rsplit(':', 1)
A:redis.client.self.subscribed_event->threading.Event()
A:redis.client.self._lock->threading.Lock()
A:redis.client.self.encoder->self.connection_pool.get_encoder()
A:redis.client.self.health_check_response_b->self.encoder.encode(self.HEALTH_CHECK_MESSAGE)
A:redis.client.self.pending_unsubscribe_channels->set()
A:redis.client.self.pending_unsubscribe_shard_channels->set()
A:redis.client.self.pending_unsubscribe_patterns->set()
A:redis.client.args->list_or_args(args[0], args[1:])
A:redis.client.new_patterns->self._normalize_keys(new_patterns)
A:redis.client.ret_val->self.execute_command('SSUBSCRIBE', *new_s_channels.keys())
A:redis.client.patterns->self._normalize_keys(dict.fromkeys(args))
A:redis.client.new_channels->self._normalize_keys(new_channels)
A:redis.client.channels->self._normalize_keys(dict.fromkeys(args))
A:redis.client.new_s_channels->self._normalize_keys(new_s_channels)
A:redis.client.s_channels->self._normalize_keys(dict.fromkeys(args))
A:redis.client.start_time->time.monotonic()
A:redis.client.timeout->max(0.0, timeout - time_spent)
A:redis.client.message_type->str_if_bytes(response[0])
A:redis.client.handler->self.channels.get(message['channel'], None)
A:redis.client.thread->PubSubWorkerThread(self, sleep_time, daemon=daemon, exception_handler=exception_handler)
A:redis.client.self._running->threading.Event()
A:redis.client.self.scripts->set()
A:redis.client.conn->self.connection_pool.get_connection()
A:redis.client.cmds->chain([(('MULTI',), {})], commands, [(('EXEC',), {})])
A:redis.client.all_cmds->connection.pack_commands([args for (args, _) in commands])
A:redis.client.r->self.response_callbacks[command_name](r, **options)
A:redis.client.cmd->' '.join(map(safe_str, command))
A:redis.client.result->Redis.parse_response(self, connection, command_name, **options)
A:redis.client.scripts->list(self.scripts)
A:redis.client.exists->immediate('SCRIPT EXISTS', *shas)
A:redis.client.s.sha->immediate('SCRIPT LOAD', s.script)
redis.Redis(self,host:str='localhost',port:int=6379,db:int=0,password:Optional[str]=None,socket_timeout:Optional[float]=None,socket_connect_timeout:Optional[float]=None,socket_keepalive:Optional[bool]=None,socket_keepalive_options:Optional[Mapping[int,Union[int,bytes]]]=None,connection_pool:Optional[ConnectionPool]=None,unix_socket_path:Optional[str]=None,encoding:str='utf-8',encoding_errors:str='strict',decode_responses:bool=False,retry_on_timeout:bool=False,retry:Retry=Retry(backoff=ExponentialWithJitterBackoff(base=1,cap=10),retries=3),retry_on_error:Optional[List[Type[Exception]]]=None,ssl:bool=False,ssl_keyfile:Optional[str]=None,ssl_certfile:Optional[str]=None,ssl_cert_reqs:Union[str,'ssl.VerifyMode']='required',ssl_ca_certs:Optional[str]=None,ssl_ca_path:Optional[str]=None,ssl_ca_data:Optional[str]=None,ssl_check_hostname:bool=True,ssl_password:Optional[str]=None,ssl_validate_ocsp:bool=False,ssl_validate_ocsp_stapled:bool=False,ssl_ocsp_context:Optional['OpenSSL.SSL.Context']=None,ssl_ocsp_expected_cert:Optional[str]=None,ssl_min_version:Optional['ssl.TLSVersion']=None,ssl_ciphers:Optional[str]=None,max_connections:Optional[int]=None,single_connection_client:bool=False,health_check_interval:int=0,client_name:Optional[str]=None,lib_name:Optional[str]='redis-py',lib_version:Optional[str]=get_lib_version(),username:Optional[str]=None,redis_connect_func:Optional[Callable[[],None]]=None,credential_provider:Optional[CredentialProvider]=None,protocol:Optional[int]=2,cache:Optional[CacheInterface]=None,cache_config:Optional[CacheConfig]=None,event_dispatcher:Optional[EventDispatcher]=None)
redis.Redis.__del__(self)
redis.Redis.__enter__(self)
redis.Redis.__exit__(self,exc_type,exc_value,traceback)
redis.Redis.__repr__(self)->str
redis.Redis._close_connection(self,conn)->None
redis.Redis._execute_command(self,*args,**options)
redis.Redis._send_command_parse_response(self,conn,command_name,*args,**options)
redis.Redis.client(self)
redis.Redis.close(self)->None
redis.Redis.execute_command(self,*args,**options)
redis.Redis.from_pool(cls:Type['Redis'],connection_pool:ConnectionPool)->'Redis'
redis.Redis.from_url(cls,url:str,**kwargs)->'Redis'
redis.Redis.get_cache(self)->Optional[CacheInterface]
redis.Redis.get_connection_kwargs(self)->Dict
redis.Redis.get_encoder(self)->'Encoder'
redis.Redis.get_retry(self)->Optional[Retry]
redis.Redis.load_external_module(self,funcname,func)->None
redis.Redis.lock(self,name:str,timeout:Optional[float]=None,sleep:float=0.1,blocking:bool=True,blocking_timeout:Optional[float]=None,lock_class:Union[None,Any]=None,thread_local:bool=True,raise_on_release_error:bool=True)
redis.Redis.monitor(self)
redis.Redis.parse_response(self,connection,command_name,**options)
redis.Redis.pipeline(self,transaction=True,shard_hint=None)->'Pipeline'
redis.Redis.pubsub(self,**kwargs)
redis.Redis.set_response_callback(self,command:str,callback:Callable)->None
redis.Redis.set_retry(self,retry:Retry)->None
redis.Redis.transaction(self,func:Callable[['Pipeline'],None],*watches,**kwargs)->None
redis.client.AbstractRedis
redis.client.CaseInsensitiveDict(self,data:Dict[str,str])
redis.client.CaseInsensitiveDict.__contains__(self,k)
redis.client.CaseInsensitiveDict.__delitem__(self,k)
redis.client.CaseInsensitiveDict.__getitem__(self,k)
redis.client.CaseInsensitiveDict.__init__(self,data:Dict[str,str])
redis.client.CaseInsensitiveDict.__setitem__(self,k,v)
redis.client.CaseInsensitiveDict.get(self,k,default=None)
redis.client.CaseInsensitiveDict.update(self,data)
redis.client.Monitor(self,connection_pool)
redis.client.Monitor.__enter__(self)
redis.client.Monitor.__exit__(self,*args)
redis.client.Monitor.__init__(self,connection_pool)
redis.client.Monitor.listen(self)
redis.client.Monitor.next_command(self)
redis.client.Pipeline(self,connection_pool:ConnectionPool,response_callbacks,transaction,shard_hint)
redis.client.Pipeline.__bool__(self)->bool
redis.client.Pipeline.__del__(self)
redis.client.Pipeline.__enter__(self)->'Pipeline'
redis.client.Pipeline.__exit__(self,exc_type,exc_value,traceback)
redis.client.Pipeline.__init__(self,connection_pool:ConnectionPool,response_callbacks,transaction,shard_hint)
redis.client.Pipeline.__len__(self)->int
redis.client.Pipeline._disconnect_raise_on_watching(self,conn:AbstractConnection,error:Exception)->None
redis.client.Pipeline._disconnect_reset_raise_on_watching(self,conn:AbstractConnection,error:Exception)->None
redis.client.Pipeline._execute_pipeline(self,connection,commands,raise_on_error)
redis.client.Pipeline._execute_transaction(self,connection:Connection,commands,raise_on_error)->List
redis.client.Pipeline.annotate_exception(self,exception,number,command)
redis.client.Pipeline.close(self)->None
redis.client.Pipeline.discard(self)
redis.client.Pipeline.execute(self,raise_on_error:bool=True)->List[Any]
redis.client.Pipeline.execute_command(self,*args,**kwargs)
redis.client.Pipeline.immediate_execute_command(self,*args,**options)
redis.client.Pipeline.load_scripts(self)
redis.client.Pipeline.multi(self)->None
redis.client.Pipeline.parse_response(self,connection,command_name,**options)
redis.client.Pipeline.pipeline_execute_command(self,*args,**options)->'Pipeline'
redis.client.Pipeline.raise_first_error(self,commands,response)
redis.client.Pipeline.reset(self)->None
redis.client.Pipeline.unwatch(self)->bool
redis.client.Pipeline.watch(self,*names)
redis.client.PubSub(self,connection_pool,shard_hint=None,ignore_subscribe_messages:bool=False,encoder:Optional['Encoder']=None,push_handler_func:Union[None,Callable[[str],None]]=None,event_dispatcher:Optional['EventDispatcher']=None)
redis.client.PubSub.__del__(self)->None
redis.client.PubSub.__enter__(self)->'PubSub'
redis.client.PubSub.__exit__(self,exc_type,exc_value,traceback)->None
redis.client.PubSub.__init__(self,connection_pool,shard_hint=None,ignore_subscribe_messages:bool=False,encoder:Optional['Encoder']=None,push_handler_func:Union[None,Callable[[str],None]]=None,event_dispatcher:Optional['EventDispatcher']=None)
redis.client.PubSub._execute(self,conn,command,*args,**kwargs)
redis.client.PubSub._normalize_keys(self,data)->Dict
redis.client.PubSub._reconnect(self,conn)->None
redis.client.PubSub.check_health(self)->None
redis.client.PubSub.clean_health_check_responses(self)->None
redis.client.PubSub.close(self)->None
redis.client.PubSub.execute_command(self,*args)
redis.client.PubSub.get_message(self,ignore_subscribe_messages:bool=False,timeout:float=0.0)
redis.client.PubSub.handle_message(self,response,ignore_subscribe_messages=False)
redis.client.PubSub.is_health_check_response(self,response)->bool
redis.client.PubSub.listen(self)
redis.client.PubSub.on_connect(self,connection)->None
redis.client.PubSub.parse_response(self,block=True,timeout=0)
redis.client.PubSub.ping(self,message:Union[str,None]=None)->bool
redis.client.PubSub.psubscribe(self,*args,**kwargs)
redis.client.PubSub.punsubscribe(self,*args)
redis.client.PubSub.reset(self)->None
redis.client.PubSub.run_in_thread(self,sleep_time:float=0.0,daemon:bool=False,exception_handler:Optional[Callable]=None)->'PubSubWorkerThread'
redis.client.PubSub.ssubscribe(self,*args,target_node=None,**kwargs)
redis.client.PubSub.subscribe(self,*args,**kwargs)
redis.client.PubSub.subscribed(self)->bool
redis.client.PubSub.sunsubscribe(self,*args,target_node=None)
redis.client.PubSub.unsubscribe(self,*args)
redis.client.PubSubWorkerThread(self,pubsub,sleep_time:float,daemon:bool=False,exception_handler:Union[Callable[[Exception,'PubSub','PubSubWorkerThread'],None],None]=None)
redis.client.PubSubWorkerThread.__init__(self,pubsub,sleep_time:float,daemon:bool=False,exception_handler:Union[Callable[[Exception,'PubSub','PubSubWorkerThread'],None],None]=None)
redis.client.PubSubWorkerThread.run(self)->None
redis.client.PubSubWorkerThread.stop(self)->None
redis.client.Redis(self,host:str='localhost',port:int=6379,db:int=0,password:Optional[str]=None,socket_timeout:Optional[float]=None,socket_connect_timeout:Optional[float]=None,socket_keepalive:Optional[bool]=None,socket_keepalive_options:Optional[Mapping[int,Union[int,bytes]]]=None,connection_pool:Optional[ConnectionPool]=None,unix_socket_path:Optional[str]=None,encoding:str='utf-8',encoding_errors:str='strict',decode_responses:bool=False,retry_on_timeout:bool=False,retry:Retry=Retry(backoff=ExponentialWithJitterBackoff(base=1,cap=10),retries=3),retry_on_error:Optional[List[Type[Exception]]]=None,ssl:bool=False,ssl_keyfile:Optional[str]=None,ssl_certfile:Optional[str]=None,ssl_cert_reqs:Union[str,'ssl.VerifyMode']='required',ssl_ca_certs:Optional[str]=None,ssl_ca_path:Optional[str]=None,ssl_ca_data:Optional[str]=None,ssl_check_hostname:bool=True,ssl_password:Optional[str]=None,ssl_validate_ocsp:bool=False,ssl_validate_ocsp_stapled:bool=False,ssl_ocsp_context:Optional['OpenSSL.SSL.Context']=None,ssl_ocsp_expected_cert:Optional[str]=None,ssl_min_version:Optional['ssl.TLSVersion']=None,ssl_ciphers:Optional[str]=None,max_connections:Optional[int]=None,single_connection_client:bool=False,health_check_interval:int=0,client_name:Optional[str]=None,lib_name:Optional[str]='redis-py',lib_version:Optional[str]=get_lib_version(),username:Optional[str]=None,redis_connect_func:Optional[Callable[[],None]]=None,credential_provider:Optional[CredentialProvider]=None,protocol:Optional[int]=2,cache:Optional[CacheInterface]=None,cache_config:Optional[CacheConfig]=None,event_dispatcher:Optional[EventDispatcher]=None)
redis.client.Redis.__del__(self)
redis.client.Redis.__enter__(self)
redis.client.Redis.__exit__(self,exc_type,exc_value,traceback)
redis.client.Redis.__init__(self,host:str='localhost',port:int=6379,db:int=0,password:Optional[str]=None,socket_timeout:Optional[float]=None,socket_connect_timeout:Optional[float]=None,socket_keepalive:Optional[bool]=None,socket_keepalive_options:Optional[Mapping[int,Union[int,bytes]]]=None,connection_pool:Optional[ConnectionPool]=None,unix_socket_path:Optional[str]=None,encoding:str='utf-8',encoding_errors:str='strict',decode_responses:bool=False,retry_on_timeout:bool=False,retry:Retry=Retry(backoff=ExponentialWithJitterBackoff(base=1,cap=10),retries=3),retry_on_error:Optional[List[Type[Exception]]]=None,ssl:bool=False,ssl_keyfile:Optional[str]=None,ssl_certfile:Optional[str]=None,ssl_cert_reqs:Union[str,'ssl.VerifyMode']='required',ssl_ca_certs:Optional[str]=None,ssl_ca_path:Optional[str]=None,ssl_ca_data:Optional[str]=None,ssl_check_hostname:bool=True,ssl_password:Optional[str]=None,ssl_validate_ocsp:bool=False,ssl_validate_ocsp_stapled:bool=False,ssl_ocsp_context:Optional['OpenSSL.SSL.Context']=None,ssl_ocsp_expected_cert:Optional[str]=None,ssl_min_version:Optional['ssl.TLSVersion']=None,ssl_ciphers:Optional[str]=None,max_connections:Optional[int]=None,single_connection_client:bool=False,health_check_interval:int=0,client_name:Optional[str]=None,lib_name:Optional[str]='redis-py',lib_version:Optional[str]=get_lib_version(),username:Optional[str]=None,redis_connect_func:Optional[Callable[[],None]]=None,credential_provider:Optional[CredentialProvider]=None,protocol:Optional[int]=2,cache:Optional[CacheInterface]=None,cache_config:Optional[CacheConfig]=None,event_dispatcher:Optional[EventDispatcher]=None)
redis.client.Redis.__repr__(self)->str
redis.client.Redis._close_connection(self,conn)->None
redis.client.Redis._execute_command(self,*args,**options)
redis.client.Redis._send_command_parse_response(self,conn,command_name,*args,**options)
redis.client.Redis.client(self)
redis.client.Redis.close(self)->None
redis.client.Redis.execute_command(self,*args,**options)
redis.client.Redis.from_pool(cls:Type['Redis'],connection_pool:ConnectionPool)->'Redis'
redis.client.Redis.from_url(cls,url:str,**kwargs)->'Redis'
redis.client.Redis.get_cache(self)->Optional[CacheInterface]
redis.client.Redis.get_connection_kwargs(self)->Dict
redis.client.Redis.get_encoder(self)->'Encoder'
redis.client.Redis.get_retry(self)->Optional[Retry]
redis.client.Redis.load_external_module(self,funcname,func)->None
redis.client.Redis.lock(self,name:str,timeout:Optional[float]=None,sleep:float=0.1,blocking:bool=True,blocking_timeout:Optional[float]=None,lock_class:Union[None,Any]=None,thread_local:bool=True,raise_on_release_error:bool=True)
redis.client.Redis.monitor(self)
redis.client.Redis.parse_response(self,connection,command_name,**options)
redis.client.Redis.pipeline(self,transaction=True,shard_hint=None)->'Pipeline'
redis.client.Redis.pubsub(self,**kwargs)
redis.client.Redis.set_response_callback(self,command:str,callback:Callable)->None
redis.client.Redis.set_retry(self,retry:Retry)->None
redis.client.Redis.transaction(self,func:Callable[['Pipeline'],None],*watches,**kwargs)->None


----------------------------------------/dataset/nuaa/anaconda3/envs/redis6.1.1/lib/python3.9/site-packages/redis/utils.py----------------------------------------
A:redis.utils.p->redis_obj.pipeline()
A:redis.utils.result->set()
A:redis.utils.provided_args->dict(zip(arg_names, args))
A:redis.utils.logger->logging.getLogger('push_response')
A:redis.utils.handler->logging.StreamHandler()
A:redis.utils.libver->importlib.metadata.version('redis')
A:redis.utils.num_versions1->list(map(int, version1.split('.')))
A:redis.utils.num_versions2->list(map(int, version2.split('.')))
A:redis.utils.exat->int(exat.timestamp())
A:redis.utils.pxat->int(pxat.timestamp() * 1000)
redis.from_url(url,**kwargs)
redis.utils._set_info_logger()
redis.utils.compare_versions(version1:str,version2:str)->int
redis.utils.deprecated_args(args_to_warn:list=['*'],allowed_args:list=[],reason:str='',version:str='')
redis.utils.deprecated_function(reason='',version='',name=None)
redis.utils.dict_merge(*dicts:Mapping[str,Any])->Dict[str, Any]
redis.utils.ensure_string(key)
redis.utils.extract_expire_flags(ex:Optional[ExpiryT]=None,px:Optional[ExpiryT]=None,exat:Optional[AbsExpiryT]=None,pxat:Optional[AbsExpiryT]=None)->List[EncodableT]
redis.utils.format_error_message(host_error:str,exception:BaseException)->str
redis.utils.from_url(url,**kwargs)
redis.utils.get_lib_version()
redis.utils.list_keys_to_dict(key_list,callback)
redis.utils.merge_result(command,res)
redis.utils.pipeline(redis_obj)
redis.utils.safe_str(value)
redis.utils.str_if_bytes(value:Union[str,bytes])->str
redis.utils.truncate_text(txt,max_length=100)
redis.utils.warn_deprecated(name,reason='',version='',stacklevel=2)
redis.utils.warn_deprecated_arg_usage(arg_name:Union[list,str],function_name:str,reason:str='',version:str='',stacklevel:int=2)


----------------------------------------/dataset/nuaa/anaconda3/envs/redis6.1.1/lib/python3.9/site-packages/redis/exceptions.py----------------------------------------
A:redis.exceptions.(slot_id, new_node)->resp.split(' ')
A:redis.exceptions.(host, port)->new_node.rsplit(':', 1)
A:redis.exceptions.self.slot_id->int(slot_id)
redis.AuthenticationError(ConnectionError)
redis.AuthenticationWrongNumberOfArgsError(ResponseError)
redis.BusyLoadingError(ConnectionError)
redis.ChildDeadlockedError(Exception)
redis.ConnectionError(RedisError)
redis.CrossSlotTransactionError(RedisClusterException)
redis.DataError(RedisError)
redis.InvalidPipelineStack(RedisClusterException)
redis.InvalidResponse(RedisError)
redis.OutOfMemoryError(ResponseError)
redis.PubSubError(RedisError)
redis.ReadOnlyError(ResponseError)
redis.RedisClusterException(Exception)
redis.RedisError(Exception)
redis.ResponseError(RedisError)
redis.TimeoutError(RedisError)
redis.WatchError(RedisError)
redis.exceptions.AskError(self,resp)
redis.exceptions.AskError.__init__(self,resp)
redis.exceptions.AuthenticationError(ConnectionError)
redis.exceptions.AuthenticationWrongNumberOfArgsError(ResponseError)
redis.exceptions.AuthorizationError(ConnectionError)
redis.exceptions.BusyLoadingError(ConnectionError)
redis.exceptions.ChildDeadlockedError(Exception)
redis.exceptions.ClusterCrossSlotError(ResponseError)
redis.exceptions.ClusterDownError(self,resp)
redis.exceptions.ClusterDownError.__init__(self,resp)
redis.exceptions.ClusterError(RedisError)
redis.exceptions.ConnectionError(RedisError)
redis.exceptions.CrossSlotTransactionError(RedisClusterException)
redis.exceptions.DataError(RedisError)
redis.exceptions.ExecAbortError(ResponseError)
redis.exceptions.InvalidPipelineStack(RedisClusterException)
redis.exceptions.InvalidResponse(RedisError)
redis.exceptions.LockError(self,message=None,lock_name=None)
redis.exceptions.LockError.__init__(self,message=None,lock_name=None)
redis.exceptions.LockNotOwnedError(LockError)
redis.exceptions.MasterDownError(ClusterDownError)
redis.exceptions.MaxConnectionsError(ConnectionError)
redis.exceptions.ModuleError(ResponseError)
redis.exceptions.MovedError(AskError)
redis.exceptions.NoPermissionError(ResponseError)
redis.exceptions.NoScriptError(ResponseError)
redis.exceptions.OutOfMemoryError(ResponseError)
redis.exceptions.PubSubError(RedisError)
redis.exceptions.ReadOnlyError(ResponseError)
redis.exceptions.RedisClusterException(Exception)
redis.exceptions.RedisError(Exception)
redis.exceptions.ResponseError(RedisError)
redis.exceptions.SlotNotCoveredError(RedisClusterException)
redis.exceptions.TimeoutError(RedisError)
redis.exceptions.TryAgainError(self,*args,**kwargs)
redis.exceptions.TryAgainError.__init__(self,*args,**kwargs)
redis.exceptions.WatchError(RedisError)


----------------------------------------/dataset/nuaa/anaconda3/envs/redis6.1.1/lib/python3.9/site-packages/redis/event.py----------------------------------------
A:redis.event.listeners->self._event_listeners_mapping.get(type(event))
redis.event.AfterAsyncClusterInstantiationEvent(self,nodes:dict,credential_provider:Optional[CredentialProvider]=None)
redis.event.AfterAsyncClusterInstantiationEvent.__init__(self,nodes:dict,credential_provider:Optional[CredentialProvider]=None)
redis.event.AfterAsyncClusterInstantiationEvent.credential_provider(self)->Union[CredentialProvider, None]
redis.event.AfterAsyncClusterInstantiationEvent.nodes(self)->dict
redis.event.AfterConnectionReleasedEvent(self,connection)
redis.event.AfterConnectionReleasedEvent.__init__(self,connection)
redis.event.AfterConnectionReleasedEvent.connection(self)
redis.event.AfterPooledConnectionsInstantiationEvent(self,connection_pools:List,client_type:ClientType,credential_provider:Optional[CredentialProvider]=None)
redis.event.AfterPooledConnectionsInstantiationEvent.__init__(self,connection_pools:List,client_type:ClientType,credential_provider:Optional[CredentialProvider]=None)
redis.event.AfterPooledConnectionsInstantiationEvent.client_type(self)->ClientType
redis.event.AfterPooledConnectionsInstantiationEvent.connection_pools(self)
redis.event.AfterPooledConnectionsInstantiationEvent.credential_provider(self)->Union[CredentialProvider, None]
redis.event.AfterPubSubConnectionInstantiationEvent(self,pubsub_connection,connection_pool,client_type:ClientType,connection_lock:Union[threading.Lock,asyncio.Lock])
redis.event.AfterPubSubConnectionInstantiationEvent.__init__(self,pubsub_connection,connection_pool,client_type:ClientType,connection_lock:Union[threading.Lock,asyncio.Lock])
redis.event.AfterPubSubConnectionInstantiationEvent.client_type(self)->ClientType
redis.event.AfterPubSubConnectionInstantiationEvent.connection_lock(self)->Union[threading.Lock, asyncio.Lock]
redis.event.AfterPubSubConnectionInstantiationEvent.connection_pool(self)
redis.event.AfterPubSubConnectionInstantiationEvent.pubsub_connection(self)
redis.event.AfterSingleConnectionInstantiationEvent(self,connection,client_type:ClientType,connection_lock:Union[threading.Lock,asyncio.Lock])
redis.event.AfterSingleConnectionInstantiationEvent.__init__(self,connection,client_type:ClientType,connection_lock:Union[threading.Lock,asyncio.Lock])
redis.event.AfterSingleConnectionInstantiationEvent.client_type(self)->ClientType
redis.event.AfterSingleConnectionInstantiationEvent.connection(self)
redis.event.AfterSingleConnectionInstantiationEvent.connection_lock(self)->Union[threading.Lock, asyncio.Lock]
redis.event.AsyncAfterConnectionReleasedEvent(AfterConnectionReleasedEvent)
redis.event.AsyncEventListenerInterface(ABC)
redis.event.AsyncEventListenerInterface.listen(self,event:object)
redis.event.AsyncReAuthConnectionListener(AsyncEventListenerInterface)
redis.event.AsyncReAuthConnectionListener.listen(self,event:AsyncAfterConnectionReleasedEvent)
redis.event.ClientType(Enum)
redis.event.EventDispatcher(self)
redis.event.EventDispatcher.__init__(self)
redis.event.EventDispatcher.dispatch(self,event:object)
redis.event.EventDispatcher.dispatch_async(self,event:object)
redis.event.EventDispatcherInterface(ABC)
redis.event.EventDispatcherInterface.dispatch(self,event:object)
redis.event.EventDispatcherInterface.dispatch_async(self,event:object)
redis.event.EventException(self,exception:Exception,event:object)
redis.event.EventException.__init__(self,exception:Exception,event:object)
redis.event.EventListenerInterface(ABC)
redis.event.EventListenerInterface.listen(self,event:object)
redis.event.ReAuthConnectionListener(EventListenerInterface)
redis.event.ReAuthConnectionListener.listen(self,event:AfterConnectionReleasedEvent)
redis.event.RegisterReAuthForAsyncClusterNodes(self)
redis.event.RegisterReAuthForAsyncClusterNodes.__init__(self)
redis.event.RegisterReAuthForAsyncClusterNodes._raise_on_error(self,error:Exception)
redis.event.RegisterReAuthForAsyncClusterNodes._re_auth(self,token:TokenInterface)
redis.event.RegisterReAuthForAsyncClusterNodes.listen(self,event:AfterAsyncClusterInstantiationEvent)
redis.event.RegisterReAuthForPooledConnections(self)
redis.event.RegisterReAuthForPooledConnections.__init__(self)
redis.event.RegisterReAuthForPooledConnections._raise_on_error(self,error:Exception)
redis.event.RegisterReAuthForPooledConnections._raise_on_error_async(self,error:Exception)
redis.event.RegisterReAuthForPooledConnections._re_auth(self,token)
redis.event.RegisterReAuthForPooledConnections._re_auth_async(self,token)
redis.event.RegisterReAuthForPooledConnections.listen(self,event:AfterPooledConnectionsInstantiationEvent)
redis.event.RegisterReAuthForPubSub(self)
redis.event.RegisterReAuthForPubSub.__init__(self)
redis.event.RegisterReAuthForPubSub._raise_on_error(self,error:Exception)
redis.event.RegisterReAuthForPubSub._raise_on_error_async(self,error:Exception)
redis.event.RegisterReAuthForPubSub._re_auth(self,token:TokenInterface)
redis.event.RegisterReAuthForPubSub._re_auth_async(self,token:TokenInterface)
redis.event.RegisterReAuthForPubSub.listen(self,event:AfterPubSubConnectionInstantiationEvent)
redis.event.RegisterReAuthForSingleConnection(self)
redis.event.RegisterReAuthForSingleConnection.__init__(self)
redis.event.RegisterReAuthForSingleConnection._raise_on_error(self,error:Exception)
redis.event.RegisterReAuthForSingleConnection._raise_on_error_async(self,error:Exception)
redis.event.RegisterReAuthForSingleConnection._re_auth(self,token)
redis.event.RegisterReAuthForSingleConnection._re_auth_async(self,token)
redis.event.RegisterReAuthForSingleConnection.listen(self,event:AfterSingleConnectionInstantiationEvent)


----------------------------------------/dataset/nuaa/anaconda3/envs/redis6.1.1/lib/python3.9/site-packages/redis/cluster.py----------------------------------------
A:redis.cluster.(cursor, r)->parse_scan(response, **options)
A:redis.cluster.numsub_d->OrderedDict()
A:redis.cluster.current_host->options.get('current_host', '')
A:redis.cluster.COMMAND_FLAGS->dict_merge(list_keys_to_dict(['ACL CAT', 'ACL DELUSER', 'ACL DRYRUN', 'ACL GENPASS', 'ACL GETUSER', 'ACL HELP', 'ACL LIST', 'ACL LOG', 'ACL LOAD', 'ACL SAVE', 'ACL SETUSER', 'ACL USERS', 'ACL WHOAMI', 'AUTH', 'CLIENT LIST', 'CLIENT SETINFO', 'CLIENT SETNAME', 'CLIENT GETNAME', 'CONFIG SET', 'CONFIG REWRITE', 'CONFIG RESETSTAT', 'TIME', 'PUBSUB CHANNELS', 'PUBSUB NUMPAT', 'PUBSUB NUMSUB', 'PUBSUB SHARDCHANNELS', 'PUBSUB SHARDNUMSUB', 'PING', 'INFO', 'SHUTDOWN', 'KEYS', 'DBSIZE', 'BGSAVE', 'SLOWLOG GET', 'SLOWLOG LEN', 'SLOWLOG RESET', 'WAIT', 'WAITAOF', 'SAVE', 'MEMORY PURGE', 'MEMORY MALLOC-STATS', 'MEMORY STATS', 'LASTSAVE', 'CLIENT TRACKINGINFO', 'CLIENT PAUSE', 'CLIENT UNPAUSE', 'CLIENT UNBLOCK', 'CLIENT ID', 'CLIENT REPLY', 'CLIENT GETREDIR', 'CLIENT INFO', 'CLIENT KILL', 'READONLY', 'CLUSTER INFO', 'CLUSTER MEET', 'CLUSTER MYSHARDID', 'CLUSTER NODES', 'CLUSTER REPLICAS', 'CLUSTER RESET', 'CLUSTER SET-CONFIG-EPOCH', 'CLUSTER SLOTS', 'CLUSTER SHARDS', 'CLUSTER COUNT-FAILURE-REPORTS', 'CLUSTER KEYSLOT', 'COMMAND', 'COMMAND COUNT', 'COMMAND LIST', 'COMMAND GETKEYS', 'CONFIG GET', 'DEBUG', 'RANDOMKEY', 'READONLY', 'READWRITE', 'TIME', 'TFUNCTION LOAD', 'TFUNCTION DELETE', 'TFUNCTION LIST', 'TFCALL', 'TFCALLASYNC', 'LATENCY HISTORY', 'LATENCY LATEST', 'LATENCY RESET', 'MODULE LIST', 'MODULE LOAD', 'MODULE UNLOAD', 'MODULE LOADEX'], DEFAULT_NODE), list_keys_to_dict(['FLUSHALL', 'FLUSHDB', 'FUNCTION DELETE', 'FUNCTION FLUSH', 'FUNCTION LIST', 'FUNCTION LOAD', 'FUNCTION RESTORE', 'SCAN', 'SCRIPT EXISTS', 'SCRIPT FLUSH', 'SCRIPT LOAD'], PRIMARIES), list_keys_to_dict(['FUNCTION DUMP'], RANDOM), list_keys_to_dict(['CLUSTER COUNTKEYSINSLOT', 'CLUSTER DELSLOTS', 'CLUSTER DELSLOTSRANGE', 'CLUSTER GETKEYSINSLOT', 'CLUSTER SETSLOT'], SLOT_ID))
A:redis.cluster.RESULT_CALLBACKS->dict_merge(list_keys_to_dict(['PUBSUB NUMSUB', 'PUBSUB SHARDNUMSUB'], parse_pubsub_numsub), list_keys_to_dict(['PUBSUB NUMPAT'], lambda command, res: sum(list(res.values()))), list_keys_to_dict(['KEYS', 'PUBSUB CHANNELS', 'PUBSUB SHARDCHANNELS'], merge_result), list_keys_to_dict(['PING', 'CONFIG SET', 'CONFIG REWRITE', 'CONFIG RESETSTAT', 'CLIENT SETNAME', 'BGSAVE', 'SLOWLOG RESET', 'SAVE', 'MEMORY PURGE', 'CLIENT PAUSE', 'CLIENT UNPAUSE'], lambda command, res: all(res.values()) if isinstance(res, dict) else res), list_keys_to_dict(['DBSIZE', 'WAIT'], lambda command, res: sum(res.values()) if isinstance(res, dict) else res), list_keys_to_dict(['CLIENT UNBLOCK'], lambda command, res: 1 if sum(res.values()) > 0 else 0), list_keys_to_dict(['SCAN'], parse_scan_result), list_keys_to_dict(['SCRIPT LOAD'], lambda command, res: list(res.values()).pop()), list_keys_to_dict(['SCRIPT EXISTS'], lambda command, res: [all(k) for k in zip(*res.values())]), list_keys_to_dict(['SCRIPT FLUSH'], lambda command, res: all(res.values())))
A:redis.cluster.curr_node->self.get_default_node()
A:redis.cluster.self.nodes_manager.default_node->random.choice(replicas)
A:redis.cluster.url_options->parse_url(url)
A:redis.cluster.host->str_if_bytes(replica_node[0])
A:redis.cluster.port->int(replica_node[1])
A:redis.cluster.self.user_on_connect_func->cleanup_kwargs(**kwargs).pop('redis_connect_func', None)
A:redis.cluster.kwargs->cleanup_kwargs(**kwargs)
A:redis.cluster.self.retry->Retry(backoff=ExponentialWithJitterBackoff(base=1, cap=10), retries=cluster_error_retry_attempts)
A:redis.cluster.self.encoder->Encoder(kwargs.get('encoding', 'utf-8'), kwargs.get('encoding_errors', 'strict'), kwargs.get('decode_responses', False))
A:redis.cluster.protocol->cleanup_kwargs(**kwargs).get('protocol', None)
A:redis.cluster.self.command_flags->self.__class__.COMMAND_FLAGS.copy()
A:redis.cluster.self.node_flags->self.__class__.NODE_FLAGS.copy()
A:redis.cluster.self._event_dispatcher->EventDispatcher()
A:redis.cluster.self.nodes_manager->NodesManager(startup_nodes=startup_nodes, from_url=from_url, require_full_coverage=require_full_coverage, dynamic_startup_nodes=dynamic_startup_nodes, address_remap=address_remap, cache=cache, cache_config=cache_config, event_dispatcher=self._event_dispatcher, **kwargs)
A:redis.cluster.self.cluster_response_callbacks->CaseInsensitiveDict(self.__class__.CLUSTER_COMMANDS_RESPONSE_CALLBACKS)
A:redis.cluster.self.result_callbacks->CaseInsensitiveDict(self.__class__.RESULT_CALLBACKS)
A:redis.cluster.self.commands_parser->CommandsParser(self)
A:redis.cluster.self._lock->threading.RLock()
A:redis.cluster.slot->self._pipe.determine_slot(*args)
A:redis.cluster.slot_cache->self.nodes_manager.slots_cache.get(slot)
A:redis.cluster.target_node->self._get_or_create_cluster_node(host, port, PRIMARY, tmp_nodes_cache)
A:redis.cluster.command->f'{args[0]} {args[1]}'.upper()
A:redis.cluster.nodes_flag->cleanup_kwargs(**kwargs).pop('nodes_flag', None)
A:redis.cluster.command_flag->self._pipe.command_flags.get(command)
A:redis.cluster.node->self._nodes_manager.find_connection_owner(self._transaction_connection)
A:redis.cluster.k->self.encoder.encode(key)
A:redis.cluster.num_actual_keys->int(args[2])
A:redis.cluster.keys->self._get_command_keys(*args)
A:redis.cluster.nodes->self._determine_nodes(*c.args, node_flag=passed_targets).values()
A:redis.cluster.passed_targets->c.options.pop('target_nodes', None)
A:redis.cluster.target_nodes->self._determine_nodes(*c.args, node_flag=passed_targets)
A:redis.cluster.res[node.name]->self._execute_command(node, *args, **kwargs)
A:redis.cluster.ttl->int(self.RedisClusterRequestTTL)
A:redis.cluster.redis_node->self._pipe.get_redis_connection(node)
A:redis.cluster.connection->get_connection(redis_node)
A:redis.cluster.response->self._pipe.get_redis_connection(node).parse_response(connection, 'EXEC')
A:redis.cluster.redirect_addr->get_node_name(host=e.host, port=e.port)
A:redis.cluster.shard_hint->cleanup_kwargs(**kwargs).pop('shard_hint', None)
A:redis.cluster.value_from_callable->cleanup_kwargs(**kwargs).pop('value_from_callable', False)
A:redis.cluster.watch_delay->cleanup_kwargs(**kwargs).pop('watch_delay', None)
A:redis.cluster.func_value->func(pipe)
A:redis.cluster.exec_value->pipe.execute()
A:redis.cluster.self.name->get_node_name(host, port)
A:redis.cluster.server_index->self.primary_to_idx.setdefault(primary, self.start_index)
A:redis.cluster.self.read_load_balancer->LoadBalancer()
A:redis.cluster.lock->threading.RLock()
A:redis.cluster.self._credential_provider->self.connection_kwargs.get('credential_provider', None)
A:redis.cluster.redirected_node->ClusterNode(e.host, e.port, PRIMARY)
A:redis.cluster.node_idx->random.randint(1, len(self.slots_cache[slot]) - 1)
A:redis.cluster.node.redis_connection->self.create_redis_node(host=node.host, port=node.port, **self.connection_kwargs)
A:redis.cluster.node_retry_config->Retry(backoff=NoBackoff(), retries=0, supported_errors=(ConnectionError,))
A:redis.cluster.r->self._pipe.cluster_response_callbacks[command_name](r, **cmd.options)
A:redis.cluster.node_name->get_node_name(connection.host, connection.port)
A:redis.cluster.cluster_slots->str_if_bytes(r.execute_command('CLUSTER SLOTS'))
A:redis.cluster.(host, port)->self.remap_host_port(host, port)
A:redis.cluster.target_replica_node->self._get_or_create_cluster_node(host, port, REPLICA, tmp_nodes_cache)
A:redis.cluster.fully_covered->self.check_slots_coverage(tmp_slots)
A:redis.cluster.self._cache->self._cache_factory.get_cache()
A:redis.cluster.self._pubsubs_generator->self._pubsubs_generator()
A:redis.cluster.redis_connection->self.cluster.get_redis_connection(node)
A:redis.cluster.self.connection->self.connection_pool.get_connection()
A:redis.cluster.pubsub->self._get_node_pubsub(node)
A:redis.cluster.message->self._sharded_message_generator()
A:redis.cluster.args->list_or_args(args[0], args[1:])
A:redis.cluster.s_channels->dict.fromkeys(args)
A:redis.cluster.p->self._get_node_pubsub(node)
A:redis.cluster.c.result->self._pipe.cluster_response_callbacks[c.args[0]](c.result, **c.options)
A:redis.cluster.cmd->' '.join(map(safe_str, command))
A:redis.cluster.retry_attempts->self._pipe.retry.get_retries()
A:redis.cluster.attempt->sorted((c for c in attempt if isinstance(c.result, ClusterPipeline.ERRORS_ALLOW_RETRY)), key=lambda x: x.position)
A:redis.cluster.nodes[node_name]->NodeCommands(redis_node.parse_response, redis_node.connection_pool, connection)
A:redis.cluster.node_commands->self._determine_nodes(*c.args, node_flag=passed_targets).values().values()
A:redis.cluster.self._retry->copy(self._pipe.retry)
A:redis.cluster.previous_node->self._nodes_manager.find_connection_owner(self._transaction_connection)
A:redis.cluster.self._transaction_connection->get_connection(redis_node)
A:redis.cluster.slot_number->self._pipe.determine_slot(*args)
A:redis.cluster.(redis_node, connection)->self._get_client_and_connection_for_transaction()
A:redis.cluster.output->self._pipe.get_redis_connection(node).parse_response(conn, command_name, **options)
A:redis.cluster.stack->chain([PipelineCommand(('MULTI',))], stack, [PipelineCommand(('EXEC',))])
A:redis.cluster.packed_commands->get_connection(redis_node).pack_commands(commands)
A:redis.cluster._->self._pipe.get_redis_connection(node).parse_response(connection, '_')
A:redis.cluster.self._pipeline_slots->set()
redis.RedisCluster(self,host:Optional[str]=None,port:int=6379,startup_nodes:Optional[List['ClusterNode']]=None,cluster_error_retry_attempts:int=3,retry:Optional['Retry']=None,require_full_coverage:bool=True,reinitialize_steps:int=5,read_from_replicas:bool=False,load_balancing_strategy:Optional['LoadBalancingStrategy']=None,dynamic_startup_nodes:bool=True,url:Optional[str]=None,address_remap:Optional[Callable[[Tuple[str,int]],Tuple[str,int]]]=None,cache:Optional[CacheInterface]=None,cache_config:Optional[CacheConfig]=None,event_dispatcher:Optional[EventDispatcher]=None,**kwargs)
redis.RedisCluster.__del__(self)
redis.RedisCluster.__enter__(self)
redis.RedisCluster.__exit__(self,exc_type,exc_value,traceback)
redis.RedisCluster._determine_nodes(self,*args,**kwargs)->List['ClusterNode']
redis.RedisCluster._execute_command(self,target_node,*args,**kwargs)
redis.RedisCluster._get_command_keys(self,*args)
redis.RedisCluster._internal_execute_command(self,*args,**kwargs)
redis.RedisCluster._is_nodes_flag(self,target_nodes)
redis.RedisCluster._parse_target_nodes(self,target_nodes)
redis.RedisCluster._process_result(self,command,res,**kwargs)
redis.RedisCluster._should_reinitialized(self)
redis.RedisCluster.close(self)->None
redis.RedisCluster.determine_slot(self,*args)->int
redis.RedisCluster.disconnect_connection_pools(self)
redis.RedisCluster.execute_command(self,*args,**kwargs)
redis.RedisCluster.from_url(cls,url,**kwargs)
redis.RedisCluster.get_connection_kwargs(self)
redis.RedisCluster.get_default_node(self)
redis.RedisCluster.get_encoder(self)
redis.RedisCluster.get_node(self,host=None,port=None,node_name=None)
redis.RedisCluster.get_node_from_key(self,key,replica=False)
redis.RedisCluster.get_nodes(self)
redis.RedisCluster.get_primaries(self)
redis.RedisCluster.get_random_node(self)
redis.RedisCluster.get_redis_connection(self,node:'ClusterNode')->Redis
redis.RedisCluster.get_replicas(self)
redis.RedisCluster.keyslot(self,key)
redis.RedisCluster.load_external_module(self,funcname,func)
redis.RedisCluster.lock(self,name,timeout=None,sleep=0.1,blocking=True,blocking_timeout=None,lock_class=None,thread_local=True,raise_on_release_error:bool=True)
redis.RedisCluster.monitor(self,target_node=None)
redis.RedisCluster.on_connect(self,connection)
redis.RedisCluster.pipeline(self,transaction=None,shard_hint=None)
redis.RedisCluster.pubsub(self,node=None,host=None,port=None,**kwargs)
redis.RedisCluster.set_default_node(self,node)
redis.RedisCluster.set_response_callback(self,command,callback)
redis.RedisCluster.set_retry(self,retry:Retry)->None
redis.RedisCluster.transaction(self,func,*watches,**kwargs)
redis.cluster.AbstractRedisCluster
redis.cluster.AbstractRedisCluster.replace_default_node(self,target_node:'ClusterNode'=None)->None
redis.cluster.AbstractStrategy(self,pipe:ClusterPipeline)
redis.cluster.AbstractStrategy.__init__(self,pipe:ClusterPipeline)
redis.cluster.AbstractStrategy.annotate_exception(self,exception,number,command)
redis.cluster.AbstractStrategy.command_queue(self)
redis.cluster.AbstractStrategy.command_queue(self,queue:List[PipelineCommand])
redis.cluster.AbstractStrategy.eval(self)
redis.cluster.AbstractStrategy.execute(self,raise_on_error:bool=True)->List[Any]
redis.cluster.AbstractStrategy.execute_command(self,*args,**kwargs)
redis.cluster.AbstractStrategy.exists(self,*keys)
redis.cluster.AbstractStrategy.load_scripts(self)
redis.cluster.AbstractStrategy.pipeline_execute_command(self,*args,**options)
redis.cluster.AbstractStrategy.reset(self)
redis.cluster.AbstractStrategy.script_load_for_pipeline(self,*args,**kwargs)
redis.cluster.AbstractStrategy.send_cluster_commands(self,stack,raise_on_error=True,allow_redirections=True)
redis.cluster.ClusterNode(self,host,port,server_type=None,redis_connection=None)
redis.cluster.ClusterNode.__del__(self)
redis.cluster.ClusterNode.__eq__(self,obj)
redis.cluster.ClusterNode.__init__(self,host,port,server_type=None,redis_connection=None)
redis.cluster.ClusterNode.__repr__(self)
redis.cluster.ClusterPipeline(self,nodes_manager:'NodesManager',commands_parser:'CommandsParser',result_callbacks:Optional[Dict[str,Callable]]=None,cluster_response_callbacks:Optional[Dict[str,Callable]]=None,startup_nodes:Optional[List['ClusterNode']]=None,read_from_replicas:bool=False,load_balancing_strategy:Optional[LoadBalancingStrategy]=None,cluster_error_retry_attempts:int=3,reinitialize_steps:int=5,retry:Optional[Retry]=None,lock=None,transaction=False,**kwargs)
redis.cluster.ClusterPipeline.__bool__(self)
redis.cluster.ClusterPipeline.__del__(self)
redis.cluster.ClusterPipeline.__enter__(self)
redis.cluster.ClusterPipeline.__exit__(self,exc_type,exc_value,traceback)
redis.cluster.ClusterPipeline.__init__(self,nodes_manager:'NodesManager',commands_parser:'CommandsParser',result_callbacks:Optional[Dict[str,Callable]]=None,cluster_response_callbacks:Optional[Dict[str,Callable]]=None,startup_nodes:Optional[List['ClusterNode']]=None,read_from_replicas:bool=False,load_balancing_strategy:Optional[LoadBalancingStrategy]=None,cluster_error_retry_attempts:int=3,reinitialize_steps:int=5,retry:Optional[Retry]=None,lock=None,transaction=False,**kwargs)
redis.cluster.ClusterPipeline.__len__(self)
redis.cluster.ClusterPipeline.__repr__(self)
redis.cluster.ClusterPipeline.annotate_exception(self,exception,number,command)
redis.cluster.ClusterPipeline.delete(self,*names)
redis.cluster.ClusterPipeline.discard(self)
redis.cluster.ClusterPipeline.eval(self)
redis.cluster.ClusterPipeline.execute(self,raise_on_error:bool=True)->List[Any]
redis.cluster.ClusterPipeline.execute_command(self,*args,**kwargs)
redis.cluster.ClusterPipeline.exists(self,*keys)
redis.cluster.ClusterPipeline.load_scripts(self)
redis.cluster.ClusterPipeline.multi(self)
redis.cluster.ClusterPipeline.pipeline_execute_command(self,*args,**options)
redis.cluster.ClusterPipeline.reset(self)
redis.cluster.ClusterPipeline.script_load_for_pipeline(self,*args,**kwargs)
redis.cluster.ClusterPipeline.send_cluster_commands(self,stack,raise_on_error=True,allow_redirections=True)
redis.cluster.ClusterPipeline.unlink(self,*names)
redis.cluster.ClusterPipeline.unwatch(self)
redis.cluster.ClusterPipeline.watch(self,*names)
redis.cluster.ClusterPubSub(self,redis_cluster,node=None,host=None,port=None,push_handler_func=None,event_dispatcher:Optional['EventDispatcher']=None,**kwargs)
redis.cluster.ClusterPubSub.__init__(self,redis_cluster,node=None,host=None,port=None,push_handler_func=None,event_dispatcher:Optional['EventDispatcher']=None,**kwargs)
redis.cluster.ClusterPubSub._get_node_pubsub(self,node)
redis.cluster.ClusterPubSub._pubsubs_generator(self)
redis.cluster.ClusterPubSub._raise_on_invalid_node(self,redis_cluster,node,host,port)
redis.cluster.ClusterPubSub._sharded_message_generator(self)
redis.cluster.ClusterPubSub.disconnect(self)
redis.cluster.ClusterPubSub.execute_command(self,*args)
redis.cluster.ClusterPubSub.get_pubsub_node(self)
redis.cluster.ClusterPubSub.get_redis_connection(self)
redis.cluster.ClusterPubSub.get_sharded_message(self,ignore_subscribe_messages=False,timeout=0.0,target_node=None)
redis.cluster.ClusterPubSub.set_pubsub_node(self,cluster,node=None,host=None,port=None)
redis.cluster.ClusterPubSub.ssubscribe(self,*args,**kwargs)
redis.cluster.ClusterPubSub.sunsubscribe(self,*args)
redis.cluster.ExecutionStrategy(ABC)
redis.cluster.ExecutionStrategy.annotate_exception(self,exception,number,command)
redis.cluster.ExecutionStrategy.command_queue(self)
redis.cluster.ExecutionStrategy.delete(self,*names)
redis.cluster.ExecutionStrategy.discard(self)
redis.cluster.ExecutionStrategy.eval(self)
redis.cluster.ExecutionStrategy.execute(self,raise_on_error:bool=True)->List[Any]
redis.cluster.ExecutionStrategy.execute_command(self,*args,**kwargs)
redis.cluster.ExecutionStrategy.exists(self,*keys)
redis.cluster.ExecutionStrategy.load_scripts(self)
redis.cluster.ExecutionStrategy.multi(self)
redis.cluster.ExecutionStrategy.pipeline_execute_command(self,*args,**options)
redis.cluster.ExecutionStrategy.reset(self)
redis.cluster.ExecutionStrategy.script_load_for_pipeline(self,*args,**kwargs)
redis.cluster.ExecutionStrategy.send_cluster_commands(self,stack,raise_on_error=True,allow_redirections=True)
redis.cluster.ExecutionStrategy.unlink(self,*names)
redis.cluster.ExecutionStrategy.unwatch(self)
redis.cluster.ExecutionStrategy.watch(self,*names)
redis.cluster.LoadBalancer(self,start_index:int=0)
redis.cluster.LoadBalancer.__init__(self,start_index:int=0)
redis.cluster.LoadBalancer._get_random_replica_index(self,list_size:int)->int
redis.cluster.LoadBalancer._get_round_robin_index(self,primary:str,list_size:int,replicas_only:bool)->int
redis.cluster.LoadBalancer.get_server_index(self,primary:str,list_size:int,load_balancing_strategy:LoadBalancingStrategy=LoadBalancingStrategy.ROUND_ROBIN)->int
redis.cluster.LoadBalancer.reset(self)->None
redis.cluster.LoadBalancingStrategy(Enum)
redis.cluster.NodeCommands(self,parse_response,connection_pool,connection)
redis.cluster.NodeCommands.__init__(self,parse_response,connection_pool,connection)
redis.cluster.NodeCommands.append(self,c)
redis.cluster.NodeCommands.read(self)
redis.cluster.NodeCommands.write(self)
redis.cluster.NodesManager(self,startup_nodes,from_url=False,require_full_coverage=False,lock=None,dynamic_startup_nodes=True,connection_pool_class=ConnectionPool,address_remap:Optional[Callable[[Tuple[str,int]],Tuple[str,int]]]=None,cache:Optional[CacheInterface]=None,cache_config:Optional[CacheConfig]=None,cache_factory:Optional[CacheFactoryInterface]=None,event_dispatcher:Optional[EventDispatcher]=None,**kwargs)
redis.cluster.NodesManager.__init__(self,startup_nodes,from_url=False,require_full_coverage=False,lock=None,dynamic_startup_nodes=True,connection_pool_class=ConnectionPool,address_remap:Optional[Callable[[Tuple[str,int]],Tuple[str,int]]]=None,cache:Optional[CacheInterface]=None,cache_config:Optional[CacheConfig]=None,cache_factory:Optional[CacheFactoryInterface]=None,event_dispatcher:Optional[EventDispatcher]=None,**kwargs)
redis.cluster.NodesManager._get_or_create_cluster_node(self,host,port,role,tmp_nodes_cache)
redis.cluster.NodesManager._update_moved_slots(self)
redis.cluster.NodesManager.check_slots_coverage(self,slots_cache)
redis.cluster.NodesManager.close(self)->None
redis.cluster.NodesManager.create_redis_connections(self,nodes)
redis.cluster.NodesManager.create_redis_node(self,host,port,**kwargs)
redis.cluster.NodesManager.find_connection_owner(self,connection:Connection)->Optional[Redis]
redis.cluster.NodesManager.get_node(self,host=None,port=None,node_name=None)
redis.cluster.NodesManager.get_node_from_slot(self,slot,read_from_replicas=False,load_balancing_strategy=None,server_type=None)->ClusterNode
redis.cluster.NodesManager.get_nodes_by_server_type(self,server_type)
redis.cluster.NodesManager.initialize(self)
redis.cluster.NodesManager.populate_startup_nodes(self,nodes)
redis.cluster.NodesManager.remap_host_port(self,host:str,port:int)->Tuple[str, int]
redis.cluster.NodesManager.reset(self)
redis.cluster.NodesManager.update_moved_exception(self,exception)
redis.cluster.PipelineCommand(self,args,options=None,position=None)
redis.cluster.PipelineCommand.__init__(self,args,options=None,position=None)
redis.cluster.PipelineStrategy(self,pipe:ClusterPipeline)
redis.cluster.PipelineStrategy.__init__(self,pipe:ClusterPipeline)
redis.cluster.PipelineStrategy._determine_nodes(self,*args,**kwargs)->List['ClusterNode']
redis.cluster.PipelineStrategy._is_nodes_flag(self,target_nodes)
redis.cluster.PipelineStrategy._parse_target_nodes(self,target_nodes)
redis.cluster.PipelineStrategy._raise_first_error(self,stack)
redis.cluster.PipelineStrategy._send_cluster_commands(self,stack,raise_on_error=True,allow_redirections=True)
redis.cluster.PipelineStrategy.delete(self,*names)
redis.cluster.PipelineStrategy.discard(self)
redis.cluster.PipelineStrategy.execute(self,raise_on_error:bool=True)->List[Any]
redis.cluster.PipelineStrategy.execute_command(self,*args,**kwargs)
redis.cluster.PipelineStrategy.multi(self)
redis.cluster.PipelineStrategy.reset(self)
redis.cluster.PipelineStrategy.send_cluster_commands(self,stack,raise_on_error=True,allow_redirections=True)
redis.cluster.PipelineStrategy.unlink(self,*names)
redis.cluster.PipelineStrategy.unwatch(self,*names)
redis.cluster.PipelineStrategy.watch(self,*names)
redis.cluster.RedisCluster(self,host:Optional[str]=None,port:int=6379,startup_nodes:Optional[List['ClusterNode']]=None,cluster_error_retry_attempts:int=3,retry:Optional['Retry']=None,require_full_coverage:bool=True,reinitialize_steps:int=5,read_from_replicas:bool=False,load_balancing_strategy:Optional['LoadBalancingStrategy']=None,dynamic_startup_nodes:bool=True,url:Optional[str]=None,address_remap:Optional[Callable[[Tuple[str,int]],Tuple[str,int]]]=None,cache:Optional[CacheInterface]=None,cache_config:Optional[CacheConfig]=None,event_dispatcher:Optional[EventDispatcher]=None,**kwargs)
redis.cluster.RedisCluster.__del__(self)
redis.cluster.RedisCluster.__enter__(self)
redis.cluster.RedisCluster.__exit__(self,exc_type,exc_value,traceback)
redis.cluster.RedisCluster.__init__(self,host:Optional[str]=None,port:int=6379,startup_nodes:Optional[List['ClusterNode']]=None,cluster_error_retry_attempts:int=3,retry:Optional['Retry']=None,require_full_coverage:bool=True,reinitialize_steps:int=5,read_from_replicas:bool=False,load_balancing_strategy:Optional['LoadBalancingStrategy']=None,dynamic_startup_nodes:bool=True,url:Optional[str]=None,address_remap:Optional[Callable[[Tuple[str,int]],Tuple[str,int]]]=None,cache:Optional[CacheInterface]=None,cache_config:Optional[CacheConfig]=None,event_dispatcher:Optional[EventDispatcher]=None,**kwargs)
redis.cluster.RedisCluster._determine_nodes(self,*args,**kwargs)->List['ClusterNode']
redis.cluster.RedisCluster._execute_command(self,target_node,*args,**kwargs)
redis.cluster.RedisCluster._get_command_keys(self,*args)
redis.cluster.RedisCluster._internal_execute_command(self,*args,**kwargs)
redis.cluster.RedisCluster._is_nodes_flag(self,target_nodes)
redis.cluster.RedisCluster._parse_target_nodes(self,target_nodes)
redis.cluster.RedisCluster._process_result(self,command,res,**kwargs)
redis.cluster.RedisCluster._should_reinitialized(self)
redis.cluster.RedisCluster.close(self)->None
redis.cluster.RedisCluster.determine_slot(self,*args)->int
redis.cluster.RedisCluster.disconnect_connection_pools(self)
redis.cluster.RedisCluster.execute_command(self,*args,**kwargs)
redis.cluster.RedisCluster.from_url(cls,url,**kwargs)
redis.cluster.RedisCluster.get_connection_kwargs(self)
redis.cluster.RedisCluster.get_default_node(self)
redis.cluster.RedisCluster.get_encoder(self)
redis.cluster.RedisCluster.get_node(self,host=None,port=None,node_name=None)
redis.cluster.RedisCluster.get_node_from_key(self,key,replica=False)
redis.cluster.RedisCluster.get_nodes(self)
redis.cluster.RedisCluster.get_primaries(self)
redis.cluster.RedisCluster.get_random_node(self)
redis.cluster.RedisCluster.get_redis_connection(self,node:'ClusterNode')->Redis
redis.cluster.RedisCluster.get_replicas(self)
redis.cluster.RedisCluster.keyslot(self,key)
redis.cluster.RedisCluster.load_external_module(self,funcname,func)
redis.cluster.RedisCluster.lock(self,name,timeout=None,sleep=0.1,blocking=True,blocking_timeout=None,lock_class=None,thread_local=True,raise_on_release_error:bool=True)
redis.cluster.RedisCluster.monitor(self,target_node=None)
redis.cluster.RedisCluster.on_connect(self,connection)
redis.cluster.RedisCluster.pipeline(self,transaction=None,shard_hint=None)
redis.cluster.RedisCluster.pubsub(self,node=None,host=None,port=None,**kwargs)
redis.cluster.RedisCluster.set_default_node(self,node)
redis.cluster.RedisCluster.set_response_callback(self,command,callback)
redis.cluster.RedisCluster.set_retry(self,retry:Retry)->None
redis.cluster.RedisCluster.transaction(self,func,*watches,**kwargs)
redis.cluster.TransactionStrategy(self,pipe:ClusterPipeline)
redis.cluster.TransactionStrategy.__init__(self,pipe:ClusterPipeline)
redis.cluster.TransactionStrategy._execute_transaction(self,stack:List['PipelineCommand'],raise_on_error:bool)
redis.cluster.TransactionStrategy._execute_transaction_with_retries(self,stack:List['PipelineCommand'],raise_on_error:bool)
redis.cluster.TransactionStrategy._get_client_and_connection_for_transaction(self)->Tuple[Redis, Connection]
redis.cluster.TransactionStrategy._get_connection_and_send_command(self,*args,**options)
redis.cluster.TransactionStrategy._immediate_execute_command(self,*args,**options)
redis.cluster.TransactionStrategy._raise_first_error(self,responses,stack)
redis.cluster.TransactionStrategy._reinitialize_on_error(self,error)
redis.cluster.TransactionStrategy._send_command_parse_response(self,conn,redis_node:Redis,command_name,*args,**options)
redis.cluster.TransactionStrategy._validate_watch(self)
redis.cluster.TransactionStrategy.delete(self,*names)
redis.cluster.TransactionStrategy.discard(self)
redis.cluster.TransactionStrategy.execute(self,raise_on_error:bool=True)->List[Any]
redis.cluster.TransactionStrategy.execute_command(self,*args,**kwargs)
redis.cluster.TransactionStrategy.multi(self)
redis.cluster.TransactionStrategy.reset(self)
redis.cluster.TransactionStrategy.send_cluster_commands(self,stack,raise_on_error=True,allow_redirections=True)
redis.cluster.TransactionStrategy.unlink(self,*names)
redis.cluster.TransactionStrategy.unwatch(self)
redis.cluster.TransactionStrategy.watch(self,*names)
redis.cluster.block_pipeline_command(name:str)->Callable[..., Any]
redis.cluster.cleanup_kwargs(**kwargs)
redis.cluster.get_connection(redis_node:Redis,*args,**options)->Connection
redis.cluster.get_node_name(host:str,port:Union[str,int])->str
redis.cluster.parse_cluster_myshardid(resp,**options)
redis.cluster.parse_cluster_shards(resp,**options)
redis.cluster.parse_cluster_slots(resp:Any,**options:Any)->Dict[Tuple[int, int], Dict[str, Any]]
redis.cluster.parse_pubsub_numsub(command,res,**options)
redis.cluster.parse_scan_result(command,res,**options)


----------------------------------------/dataset/nuaa/anaconda3/envs/redis6.1.1/lib/python3.9/site-packages/redis/sentinel.py----------------------------------------
A:redis.sentinel.self.connection_pool->kwargs.pop('connection_pool')
A:redis.sentinel.self.connection_pool_ref->weakref.ref(connection_pool)
A:redis.sentinel.master_address->self.sentinel_manager.discover_master(self.service_name)
A:redis.sentinel.connection_pool->self.connection_pool_ref()
A:redis.sentinel.slaves->self.filter_slaves(slaves)
A:redis.sentinel.self.slave_rr_counter->random.randint(0, len(slaves) - 1)
A:redis.sentinel.kwargs['connection_class']->kwargs.get('connection_class', SentinelManagedSSLConnection if kwargs.pop('ssl', False) else SentinelManagedConnection)
A:redis.sentinel.self.is_master->kwargs.pop('is_master', True)
A:redis.sentinel.self.check_connection->kwargs.pop('check_connection', False)
A:redis.sentinel.self.proxy->SentinelConnectionPoolProxy(connection_pool=self, is_master=self.is_master, check_connection=self.check_connection, service_name=service_name, sentinel_manager=sentinel_manager)
A:redis.sentinel.parent->super()
A:redis.sentinel.once->bool(kwargs.get('once', False))
A:redis.sentinel.collected_errors->list()
A:redis.sentinel.masters->sentinel.sentinel_masters()
A:redis.sentinel.state->sentinel.sentinel_masters().get(service_name)
A:redis.sentinel.connection_kwargs->dict(self.connection_kwargs)
redis.Sentinel(self,sentinels,min_other_sentinels=0,sentinel_kwargs=None,force_master_ip=None,**connection_kwargs)
redis.Sentinel.__repr__(self)
redis.Sentinel.check_master_state(self,state,service_name)
redis.Sentinel.discover_master(self,service_name)
redis.Sentinel.discover_slaves(self,service_name)
redis.Sentinel.execute_command(self,*args,**kwargs)
redis.Sentinel.filter_slaves(self,slaves)
redis.Sentinel.master_for(self,service_name,redis_class=Redis,connection_pool_class=SentinelConnectionPool,**kwargs)
redis.Sentinel.slave_for(self,service_name,redis_class=Redis,connection_pool_class=SentinelConnectionPool,**kwargs)
redis.SentinelConnectionPool(self,service_name,sentinel_manager,**kwargs)
redis.SentinelConnectionPool.__repr__(self)
redis.SentinelConnectionPool.get_master_address(self)
redis.SentinelConnectionPool.master_address(self)
redis.SentinelConnectionPool.owns_connection(self,connection)
redis.SentinelConnectionPool.reset(self)
redis.SentinelConnectionPool.rotate_slaves(self)
redis.SentinelConnectionPoolProxy(self,connection_pool,is_master,check_connection,service_name,sentinel_manager)
redis.SentinelConnectionPoolProxy.get_master_address(self)
redis.SentinelConnectionPoolProxy.reset(self)
redis.SentinelConnectionPoolProxy.rotate_slaves(self)
redis.SentinelManagedConnection(self,**kwargs)
redis.SentinelManagedConnection.__repr__(self)
redis.SentinelManagedConnection._connect_retry(self)
redis.SentinelManagedConnection.connect(self)
redis.SentinelManagedConnection.connect_to(self,address)
redis.SentinelManagedConnection.read_response(self,disable_decoding=False,*,disconnect_on_error:Optional[bool]=False,push_request:Optional[bool]=False)
redis.SentinelManagedSSLConnection(SentinelManagedConnection,SSLConnection)
redis.sentinel.MasterNotFoundError(ConnectionError)
redis.sentinel.Sentinel(self,sentinels,min_other_sentinels=0,sentinel_kwargs=None,force_master_ip=None,**connection_kwargs)
redis.sentinel.Sentinel.__init__(self,sentinels,min_other_sentinels=0,sentinel_kwargs=None,force_master_ip=None,**connection_kwargs)
redis.sentinel.Sentinel.__repr__(self)
redis.sentinel.Sentinel.check_master_state(self,state,service_name)
redis.sentinel.Sentinel.discover_master(self,service_name)
redis.sentinel.Sentinel.discover_slaves(self,service_name)
redis.sentinel.Sentinel.execute_command(self,*args,**kwargs)
redis.sentinel.Sentinel.filter_slaves(self,slaves)
redis.sentinel.Sentinel.master_for(self,service_name,redis_class=Redis,connection_pool_class=SentinelConnectionPool,**kwargs)
redis.sentinel.Sentinel.slave_for(self,service_name,redis_class=Redis,connection_pool_class=SentinelConnectionPool,**kwargs)
redis.sentinel.SentinelConnectionPool(self,service_name,sentinel_manager,**kwargs)
redis.sentinel.SentinelConnectionPool.__init__(self,service_name,sentinel_manager,**kwargs)
redis.sentinel.SentinelConnectionPool.__repr__(self)
redis.sentinel.SentinelConnectionPool.get_master_address(self)
redis.sentinel.SentinelConnectionPool.master_address(self)
redis.sentinel.SentinelConnectionPool.owns_connection(self,connection)
redis.sentinel.SentinelConnectionPool.reset(self)
redis.sentinel.SentinelConnectionPool.rotate_slaves(self)
redis.sentinel.SentinelConnectionPoolProxy(self,connection_pool,is_master,check_connection,service_name,sentinel_manager)
redis.sentinel.SentinelConnectionPoolProxy.__init__(self,connection_pool,is_master,check_connection,service_name,sentinel_manager)
redis.sentinel.SentinelConnectionPoolProxy.get_master_address(self)
redis.sentinel.SentinelConnectionPoolProxy.reset(self)
redis.sentinel.SentinelConnectionPoolProxy.rotate_slaves(self)
redis.sentinel.SentinelManagedConnection(self,**kwargs)
redis.sentinel.SentinelManagedConnection.__init__(self,**kwargs)
redis.sentinel.SentinelManagedConnection.__repr__(self)
redis.sentinel.SentinelManagedConnection._connect_retry(self)
redis.sentinel.SentinelManagedConnection.connect(self)
redis.sentinel.SentinelManagedConnection.connect_to(self,address)
redis.sentinel.SentinelManagedConnection.read_response(self,disable_decoding=False,*,disconnect_on_error:Optional[bool]=False,push_request:Optional[bool]=False)
redis.sentinel.SentinelManagedSSLConnection(SentinelManagedConnection,SSLConnection)
redis.sentinel.SlaveNotFoundError(ConnectionError)


----------------------------------------/dataset/nuaa/anaconda3/envs/redis6.1.1/lib/python3.9/site-packages/redis/ocsp.py----------------------------------------
A:redis.ocsp.pubkey->certificate.public_key()
A:redis.ocsp.ocsp_response->cryptography.x509.ocsp.load_der_ocsp_response(ocsp_bytes)
A:redis.ocsp.responder_certs->_get_certificates(certs, issuer_cert, responder_name, responder_hash)
A:redis.ocsp.ext->responder_cert.extensions.get_extension_for_class(x509.ExtendedKeyUsage)
A:redis.ocsp.h->certificate.public_key().public_bytes(Encoding.DER, PublicFormat.SubjectPublicKeyInfo)
A:redis.ocsp.sha1->Hash(SHA1(), backend=backends.default_backend())
A:redis.ocsp.peer_cert->con.get_peer_certificate().to_cryptography()
A:redis.ocsp.cert->cryptography.x509.load_pem_x509_certificate(pem.encode(), backends.default_backend())
A:redis.ocsp.e->cryptography.x509.load_pem_x509_certificate(expected)
A:redis.ocsp.pem->ssl.get_server_certificate((self.HOST, self.PORT), ca_certs=self.CA_CERTS)
A:redis.ocsp.der->self.SOCK.getpeercert(True)
A:redis.ocsp.orb->orb.add_certificate(cert, issuer_cert, cryptography.hazmat.primitives.hashes.SHA256()).add_certificate(cert, issuer_cert, cryptography.hazmat.primitives.hashes.SHA256())
A:redis.ocsp.request->orb.add_certificate(cert, issuer_cert, cryptography.hazmat.primitives.hashes.SHA256()).add_certificate(cert, issuer_cert, cryptography.hazmat.primitives.hashes.SHA256()).build()
A:redis.ocsp.path->base64.b64encode(request.public_bytes(hazmat.primitives.serialization.Encoding.DER))
A:redis.ocsp.url->urljoin(server, path.decode('ascii'))
A:redis.ocsp.r->requests.get(ocsp_url, headers=header)
A:redis.ocsp.issuer_cert->self._bin2ascii(der)
A:redis.ocsp.ocsp_url->self.build_certificate_url(server, cert, issuer_cert)
A:redis.ocsp.(cert, issuer_url, ocsp_server)->self.components_from_direct_connection()
redis.ocsp.OCSPVerifier(self,sock,host,port,ca_certs=None)
redis.ocsp.OCSPVerifier.__init__(self,sock,host,port,ca_certs=None)
redis.ocsp.OCSPVerifier._bin2ascii(self,der)
redis.ocsp.OCSPVerifier._certificate_components(self,cert)
redis.ocsp.OCSPVerifier.build_certificate_url(self,server,cert,issuer_cert)
redis.ocsp.OCSPVerifier.check_certificate(self,server,cert,issuer_url)
redis.ocsp.OCSPVerifier.components_from_direct_connection(self)
redis.ocsp.OCSPVerifier.components_from_socket(self)
redis.ocsp.OCSPVerifier.is_valid(self)
redis.ocsp._check_certificate(issuer_cert,ocsp_bytes,validate=True)
redis.ocsp._get_certificates(certs,issuer_cert,responder_name,responder_hash)
redis.ocsp._get_pubkey_hash(certificate)
redis.ocsp._verify_response(issuer_cert,ocsp_response)
redis.ocsp.ocsp_staple_verifier(con,ocsp_bytes,expected=None)


----------------------------------------/dataset/nuaa/anaconda3/envs/redis6.1.1/lib/python3.9/site-packages/redis/credentials.py----------------------------------------
A:redis.credentials.logger->logging.getLogger(__name__)
redis.CredentialProvider
redis.CredentialProvider.get_credentials(self)->Union[Tuple[str], Tuple[str, str]]
redis.CredentialProvider.get_credentials_async(self)->Union[Tuple[str], Tuple[str, str]]
redis.UsernamePasswordCredentialProvider(self,username:Optional[str]=None,password:Optional[str]=None)
redis.UsernamePasswordCredentialProvider.get_credentials(self)
redis.UsernamePasswordCredentialProvider.get_credentials_async(self)->Union[Tuple[str], Tuple[str, str]]
redis.credentials.CredentialProvider
redis.credentials.CredentialProvider.get_credentials(self)->Union[Tuple[str], Tuple[str, str]]
redis.credentials.CredentialProvider.get_credentials_async(self)->Union[Tuple[str], Tuple[str, str]]
redis.credentials.StreamingCredentialProvider(CredentialProvider,ABC)
redis.credentials.StreamingCredentialProvider.is_streaming(self)->bool
redis.credentials.StreamingCredentialProvider.on_error(self,callback:Callable[[Exception],None])
redis.credentials.StreamingCredentialProvider.on_next(self,callback:Callable[[Any],None])
redis.credentials.UsernamePasswordCredentialProvider(self,username:Optional[str]=None,password:Optional[str]=None)
redis.credentials.UsernamePasswordCredentialProvider.__init__(self,username:Optional[str]=None,password:Optional[str]=None)
redis.credentials.UsernamePasswordCredentialProvider.get_credentials(self)
redis.credentials.UsernamePasswordCredentialProvider.get_credentials_async(self)->Union[Tuple[str], Tuple[str, str]]


----------------------------------------/dataset/nuaa/anaconda3/envs/redis6.1.1/lib/python3.9/site-packages/redis/cache.py----------------------------------------
A:redis.cache.self._cache->OrderedDict()
A:redis.cache.self._eviction_policy->self._cache_config.get_eviction_policy().value()
A:redis.cache.entry->self._cache.get(key, None)
A:redis.cache.redis_key->redis_key.decode().decode()
A:redis.cache.elem_count->len(self._cache)
A:redis.cache.popped_entry->self._cache.collection.popitem(last=False)
A:redis.cache.self._config->CacheConfig()
A:redis.cache.cache_class->self._config.get_cache_class()
redis.cache.CacheConfig(self,max_size:int=DEFAULT_MAX_SIZE,cache_class:Any=DEFAULT_CACHE_CLASS,eviction_policy:EvictionPolicy=DEFAULT_EVICTION_POLICY)
redis.cache.CacheConfig.__init__(self,max_size:int=DEFAULT_MAX_SIZE,cache_class:Any=DEFAULT_CACHE_CLASS,eviction_policy:EvictionPolicy=DEFAULT_EVICTION_POLICY)
redis.cache.CacheConfig.get_cache_class(self)
redis.cache.CacheConfig.get_eviction_policy(self)->EvictionPolicy
redis.cache.CacheConfig.get_max_size(self)->int
redis.cache.CacheConfig.is_allowed_to_cache(self,command:str)->bool
redis.cache.CacheConfig.is_exceeds_max_size(self,count:int)->bool
redis.cache.CacheConfigurationInterface(ABC)
redis.cache.CacheConfigurationInterface.get_cache_class(self)
redis.cache.CacheConfigurationInterface.get_eviction_policy(self)
redis.cache.CacheConfigurationInterface.get_max_size(self)->int
redis.cache.CacheConfigurationInterface.is_allowed_to_cache(self,command:str)->bool
redis.cache.CacheConfigurationInterface.is_exceeds_max_size(self,count:int)->bool
redis.cache.CacheEntry(self,cache_key:CacheKey,cache_value:bytes,status:CacheEntryStatus,connection_ref)
redis.cache.CacheEntry.__eq__(self,other)
redis.cache.CacheEntry.__hash__(self)
redis.cache.CacheEntry.__init__(self,cache_key:CacheKey,cache_value:bytes,status:CacheEntryStatus,connection_ref)
redis.cache.CacheEntryStatus(Enum)
redis.cache.CacheFactory(self,cache_config:Optional[CacheConfig]=None)
redis.cache.CacheFactory.__init__(self,cache_config:Optional[CacheConfig]=None)
redis.cache.CacheFactory.get_cache(self)->CacheInterface
redis.cache.CacheFactoryInterface(ABC)
redis.cache.CacheFactoryInterface.get_cache(self)->CacheInterface
redis.cache.CacheInterface(ABC)
redis.cache.CacheInterface.collection(self)->OrderedDict
redis.cache.CacheInterface.config(self)->CacheConfigurationInterface
redis.cache.CacheInterface.delete_by_cache_keys(self,cache_keys:List[CacheKey])->List[bool]
redis.cache.CacheInterface.delete_by_redis_keys(self,redis_keys:List[bytes])->List[bool]
redis.cache.CacheInterface.eviction_policy(self)->EvictionPolicyInterface
redis.cache.CacheInterface.flush(self)->int
redis.cache.CacheInterface.get(self,key:CacheKey)->Union[CacheEntry, None]
redis.cache.CacheInterface.is_cachable(self,key:CacheKey)->bool
redis.cache.CacheInterface.set(self,entry:CacheEntry)->bool
redis.cache.CacheInterface.size(self)->int
redis.cache.CacheKey
redis.cache.DefaultCache(self,cache_config:CacheConfigurationInterface)
redis.cache.DefaultCache.__init__(self,cache_config:CacheConfigurationInterface)
redis.cache.DefaultCache.collection(self)->OrderedDict
redis.cache.DefaultCache.config(self)->CacheConfigurationInterface
redis.cache.DefaultCache.delete_by_cache_keys(self,cache_keys:List[CacheKey])->List[bool]
redis.cache.DefaultCache.delete_by_redis_keys(self,redis_keys:List[bytes])->List[bool]
redis.cache.DefaultCache.eviction_policy(self)->EvictionPolicyInterface
redis.cache.DefaultCache.flush(self)->int
redis.cache.DefaultCache.get(self,key:CacheKey)->Union[CacheEntry, None]
redis.cache.DefaultCache.is_cachable(self,key:CacheKey)->bool
redis.cache.DefaultCache.set(self,entry:CacheEntry)->bool
redis.cache.DefaultCache.size(self)->int
redis.cache.EvictionPolicy(Enum)
redis.cache.EvictionPolicyInterface(ABC)
redis.cache.EvictionPolicyInterface.cache(self)
redis.cache.EvictionPolicyInterface.cache(self,value)
redis.cache.EvictionPolicyInterface.evict_many(self,count:int)->List[CacheKey]
redis.cache.EvictionPolicyInterface.evict_next(self)->CacheKey
redis.cache.EvictionPolicyInterface.touch(self,cache_key:CacheKey)->None
redis.cache.EvictionPolicyInterface.type(self)->EvictionPolicyType
redis.cache.EvictionPolicyType(Enum)
redis.cache.LRUPolicy(self)
redis.cache.LRUPolicy.__init__(self)
redis.cache.LRUPolicy._assert_cache(self)
redis.cache.LRUPolicy.cache(self)
redis.cache.LRUPolicy.cache(self,cache:CacheInterface)
redis.cache.LRUPolicy.evict_many(self,count:int)->List[CacheKey]
redis.cache.LRUPolicy.evict_next(self)->CacheKey
redis.cache.LRUPolicy.touch(self,cache_key:CacheKey)->None
redis.cache.LRUPolicy.type(self)->EvictionPolicyType


----------------------------------------/dataset/nuaa/anaconda3/envs/redis6.1.1/lib/python3.9/site-packages/redis/typing.py----------------------------------------
A:redis.typing.AnyKeyT->TypeVar('AnyKeyT', bytes, str, memoryview)
A:redis.typing.AnyFieldT->TypeVar('AnyFieldT', bytes, str, memoryview)
A:redis.typing.AnyChannelT->TypeVar('AnyChannelT', bytes, str, memoryview)
redis.typing.ClusterCommandsProtocol(CommandsProtocol)
redis.typing.CommandsProtocol(Protocol)
redis.typing.CommandsProtocol.execute_command(self,*args,**options)->ResponseT


----------------------------------------/dataset/nuaa/anaconda3/envs/redis6.1.1/lib/python3.9/site-packages/redis/connection.py----------------------------------------
A:redis.connection.SENTINEL->object()
A:redis.connection.(_, value, traceback)->sys.exc_info()
A:redis.connection.buff->SYM_EMPTY.join((buff, SYM_DOLLAR, str(arg_length).encode(), SYM_CRLF, arg, SYM_CRLF))
A:redis.connection.arg_length->len(arg)
A:redis.connection.self._event_dispatcher->EventDispatcher()
A:redis.connection.self.pid->os.getpid()
A:redis.connection.self.retry->Retry(NoBackoff(), 0)
A:redis.connection.self.encoder->Encoder(encoding, encoding_errors, decode_responses)
A:redis.connection.p->int(protocol)
A:redis.connection.self._command_packer->self._construct_command_packer(command_packer)
A:redis.connection.repr_args->','.join([f'{k}={v}' for (k, v) in self.repr_pieces()])
A:redis.connection.wm->weakref.WeakMethod(callback)
A:redis.connection.self._parser->parser_class(socket_read_size=self._socket_read_size)
A:redis.connection.sock->socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
A:redis.connection.callback->ref()
A:redis.connection.auth_args->cred_provider.get_credentials()
A:redis.connection.self.handshake_metadata->self.read_response()
A:redis.connection.auth_response->self.read_response()
A:redis.connection.host_error->self._host_error()
A:redis.connection.response->self._conn.read_response(disable_decoding=disable_decoding, disconnect_on_error=disconnect_on_error, push_request=push_request)
A:redis.connection.chunklen->len(chunk)
A:redis.connection.self.port->int(port)
A:redis.connection.self._cache_lock->threading.RLock()
A:redis.connection.server_name->ensure_string(server_name)
A:redis.connection.server_ver->ensure_string(server_ver)
A:redis.connection.self._current_command_cache_key->CacheKey(command=args[0], redis_keys=tuple(kwargs.get('keys')))
A:redis.connection.entry->self._cache.get(self._current_command_cache_key)
A:redis.connection.res->copy.deepcopy(self._cache.get(self._current_command_cache_key).cache_value)
A:redis.connection.cache_entry->self._cache.get(self._current_command_cache_key)
A:redis.connection.context->ssl.create_default_context()
A:redis.connection.sslsock->ssl.create_default_context().wrap_socket(sock, server_hostname=self.host)
A:redis.connection.staple_ctx->OpenSSL.SSL.Context(OpenSSL.SSL.SSLv23_METHOD)
A:redis.connection.con->OpenSSL.SSL.Connection(staple_ctx, socket.socket())
A:redis.connection.o->OCSPVerifier(sslsock, self.host, self.port, self.ca_certs)
A:redis.connection.url->urlparse(url)
A:redis.connection.value->unquote(value[0])
A:redis.connection.parser->URL_QUERY_ARGUMENT_PARSERS.get(name)
A:redis.connection.kwargs[name]->parser(value)
A:redis.connection.kwargs['username']->unquote(url.username)
A:redis.connection.kwargs['password']->unquote(url.password)
A:redis.connection.kwargs['path']->unquote(url.path)
A:redis.connection.kwargs['host']->unquote(url.hostname)
A:redis.connection.kwargs['port']->int(url.port)
A:redis.connection.kwargs['db']->int(unquote(url.path).replace('/', ''))
A:redis.connection._CP->TypeVar('_CP', bound='ConnectionPool')
A:redis.connection.url_options->parse_url(url)
A:redis.connection.cache->self.connection_kwargs.get('cache')
A:redis.connection.self.cache->CacheFactory(self.connection_kwargs.get('cache_config')).get_cache()
A:redis.connection.self._fork_lock->threading.RLock()
A:redis.connection.self._lock->threading.Lock()
A:redis.connection.self._in_use_connections->set()
A:redis.connection.acquired->self._fork_lock.acquire(timeout=5)
A:redis.connection.connection->self.make_connection()
A:redis.connection.connections->chain(self._available_connections, self._in_use_connections)
A:redis.connection.self.pool->self.queue_class(self.max_connections)
redis.BlockingConnectionPool(self,max_connections=50,timeout=20,connection_class=Connection,queue_class=LifoQueue,**connection_kwargs)
redis.BlockingConnectionPool.disconnect(self)
redis.BlockingConnectionPool.get_connection(self,command_name=None,*keys,**options)
redis.BlockingConnectionPool.make_connection(self)
redis.BlockingConnectionPool.release(self,connection)
redis.BlockingConnectionPool.reset(self)
redis.Connection(self,host='localhost',port=6379,socket_keepalive=False,socket_keepalive_options=None,socket_type=0,**kwargs)
redis.Connection._connect(self)
redis.Connection._host_error(self)
redis.Connection.repr_pieces(self)
redis.ConnectionInterface
redis.ConnectionInterface.can_read(self,timeout=0)
redis.ConnectionInterface.check_health(self)
redis.ConnectionInterface.connect(self)
redis.ConnectionInterface.deregister_connect_callback(self,callback)
redis.ConnectionInterface.disconnect(self,*args)
redis.ConnectionInterface.get_protocol(self)
redis.ConnectionInterface.handshake_metadata(self)->Union[Dict[bytes, bytes], Dict[str, str]]
redis.ConnectionInterface.on_connect(self)
redis.ConnectionInterface.pack_command(self,*args)
redis.ConnectionInterface.pack_commands(self,commands)
redis.ConnectionInterface.re_auth(self)
redis.ConnectionInterface.read_response(self,disable_decoding=False,*,disconnect_on_error=True,push_request=False)
redis.ConnectionInterface.register_connect_callback(self,callback)
redis.ConnectionInterface.repr_pieces(self)
redis.ConnectionInterface.send_command(self,*args,**kwargs)
redis.ConnectionInterface.send_packed_command(self,command,check_health=True)
redis.ConnectionInterface.set_parser(self,parser_class)
redis.ConnectionInterface.set_re_auth_token(self,token:TokenInterface)
redis.ConnectionPool(self,connection_class=Connection,max_connections:Optional[int]=None,cache_factory:Optional[CacheFactoryInterface]=None,**connection_kwargs)
redis.ConnectionPool.__repr__(self)->(str, str)
redis.ConnectionPool._checkpid(self)->None
redis.ConnectionPool._mock(self,error:RedisError)
redis.ConnectionPool.close(self)->None
redis.ConnectionPool.disconnect(self,inuse_connections:bool=True)->None
redis.ConnectionPool.from_url(cls:Type[_CP],url:str,**kwargs)->_CP
redis.ConnectionPool.get_connection(self,command_name=None,*keys,**options)->'Connection'
redis.ConnectionPool.get_encoder(self)->Encoder
redis.ConnectionPool.get_protocol(self)
redis.ConnectionPool.make_connection(self)->'ConnectionInterface'
redis.ConnectionPool.owns_connection(self,connection:'Connection')->int
redis.ConnectionPool.re_auth_callback(self,token:TokenInterface)
redis.ConnectionPool.release(self,connection:'Connection')->None
redis.ConnectionPool.reset(self)->None
redis.ConnectionPool.set_retry(self,retry:Retry)->None
redis.SSLConnection(self,ssl_keyfile=None,ssl_certfile=None,ssl_cert_reqs='required',ssl_ca_certs=None,ssl_ca_data=None,ssl_check_hostname=True,ssl_ca_path=None,ssl_password=None,ssl_validate_ocsp=False,ssl_validate_ocsp_stapled=False,ssl_ocsp_context=None,ssl_ocsp_expected_cert=None,ssl_min_version=None,ssl_ciphers=None,**kwargs)
redis.SSLConnection._connect(self)
redis.SSLConnection._wrap_socket_with_ssl(self,sock)
redis.UnixDomainSocketConnection(self,path='',socket_timeout=None,**kwargs)
redis.UnixDomainSocketConnection._connect(self)
redis.UnixDomainSocketConnection._host_error(self)
redis.UnixDomainSocketConnection.repr_pieces(self)
redis.connection.AbstractConnection(self,db:int=0,password:Optional[str]=None,socket_timeout:Optional[float]=None,socket_connect_timeout:Optional[float]=None,retry_on_timeout:bool=False,retry_on_error=SENTINEL,encoding:str='utf-8',encoding_errors:str='strict',decode_responses:bool=False,parser_class=DefaultParser,socket_read_size:int=65536,health_check_interval:int=0,client_name:Optional[str]=None,lib_name:Optional[str]='redis-py',lib_version:Optional[str]=get_lib_version(),username:Optional[str]=None,retry:Union[Any,None]=None,redis_connect_func:Optional[Callable[[],None]]=None,credential_provider:Optional[CredentialProvider]=None,protocol:Optional[int]=2,command_packer:Optional[Callable[[],None]]=None,event_dispatcher:Optional[EventDispatcher]=None)
redis.connection.AbstractConnection.__del__(self)
redis.connection.AbstractConnection.__init__(self,db:int=0,password:Optional[str]=None,socket_timeout:Optional[float]=None,socket_connect_timeout:Optional[float]=None,retry_on_timeout:bool=False,retry_on_error=SENTINEL,encoding:str='utf-8',encoding_errors:str='strict',decode_responses:bool=False,parser_class=DefaultParser,socket_read_size:int=65536,health_check_interval:int=0,client_name:Optional[str]=None,lib_name:Optional[str]='redis-py',lib_version:Optional[str]=get_lib_version(),username:Optional[str]=None,retry:Union[Any,None]=None,redis_connect_func:Optional[Callable[[],None]]=None,credential_provider:Optional[CredentialProvider]=None,protocol:Optional[int]=2,command_packer:Optional[Callable[[],None]]=None,event_dispatcher:Optional[EventDispatcher]=None)
redis.connection.AbstractConnection.__repr__(self)
redis.connection.AbstractConnection._connect(self)
redis.connection.AbstractConnection._construct_command_packer(self,packer)
redis.connection.AbstractConnection._error_message(self,exception)
redis.connection.AbstractConnection._host_error(self)
redis.connection.AbstractConnection._ping_failed(self,error)
redis.connection.AbstractConnection._send_ping(self)
redis.connection.AbstractConnection.can_read(self,timeout=0)
redis.connection.AbstractConnection.check_health(self)
redis.connection.AbstractConnection.connect(self)
redis.connection.AbstractConnection.connect_check_health(self,check_health:bool=True)
redis.connection.AbstractConnection.deregister_connect_callback(self,callback)
redis.connection.AbstractConnection.disconnect(self,*args)
redis.connection.AbstractConnection.get_protocol(self)->Union[int, str]
redis.connection.AbstractConnection.handshake_metadata(self)->Union[Dict[bytes, bytes], Dict[str, str]]
redis.connection.AbstractConnection.handshake_metadata(self,value:Union[Dict[bytes,bytes],Dict[str,str]])
redis.connection.AbstractConnection.on_connect(self)
redis.connection.AbstractConnection.on_connect_check_health(self,check_health:bool=True)
redis.connection.AbstractConnection.pack_command(self,*args)
redis.connection.AbstractConnection.pack_commands(self,commands)
redis.connection.AbstractConnection.re_auth(self)
redis.connection.AbstractConnection.read_response(self,disable_decoding=False,*,disconnect_on_error=True,push_request=False)
redis.connection.AbstractConnection.register_connect_callback(self,callback)
redis.connection.AbstractConnection.repr_pieces(self)
redis.connection.AbstractConnection.send_command(self,*args,**kwargs)
redis.connection.AbstractConnection.send_packed_command(self,command,check_health=True)
redis.connection.AbstractConnection.set_parser(self,parser_class)
redis.connection.AbstractConnection.set_re_auth_token(self,token:TokenInterface)
redis.connection.BlockingConnectionPool(self,max_connections=50,timeout=20,connection_class=Connection,queue_class=LifoQueue,**connection_kwargs)
redis.connection.BlockingConnectionPool.__init__(self,max_connections=50,timeout=20,connection_class=Connection,queue_class=LifoQueue,**connection_kwargs)
redis.connection.BlockingConnectionPool.disconnect(self)
redis.connection.BlockingConnectionPool.get_connection(self,command_name=None,*keys,**options)
redis.connection.BlockingConnectionPool.make_connection(self)
redis.connection.BlockingConnectionPool.release(self,connection)
redis.connection.BlockingConnectionPool.reset(self)
redis.connection.CacheProxyConnection(self,conn:ConnectionInterface,cache:CacheInterface,pool_lock:threading.Lock)
redis.connection.CacheProxyConnection.__init__(self,conn:ConnectionInterface,cache:CacheInterface,pool_lock:threading.Lock)
redis.connection.CacheProxyConnection._connect(self)
redis.connection.CacheProxyConnection._enable_tracking_callback(self,conn:ConnectionInterface)->None
redis.connection.CacheProxyConnection._host_error(self)
redis.connection.CacheProxyConnection._on_invalidation_callback(self,data:List[Union[str,Optional[List[bytes]]]])
redis.connection.CacheProxyConnection._process_pending_invalidations(self)
redis.connection.CacheProxyConnection.can_read(self,timeout=0)
redis.connection.CacheProxyConnection.check_health(self)
redis.connection.CacheProxyConnection.connect(self)
redis.connection.CacheProxyConnection.deregister_connect_callback(self,callback)
redis.connection.CacheProxyConnection.disconnect(self,*args)
redis.connection.CacheProxyConnection.get_protocol(self)
redis.connection.CacheProxyConnection.handshake_metadata(self)->Union[Dict[bytes, bytes], Dict[str, str]]
redis.connection.CacheProxyConnection.on_connect(self)
redis.connection.CacheProxyConnection.pack_command(self,*args)
redis.connection.CacheProxyConnection.pack_commands(self,commands)
redis.connection.CacheProxyConnection.re_auth(self)
redis.connection.CacheProxyConnection.read_response(self,disable_decoding=False,*,disconnect_on_error=True,push_request=False)
redis.connection.CacheProxyConnection.register_connect_callback(self,callback)
redis.connection.CacheProxyConnection.repr_pieces(self)
redis.connection.CacheProxyConnection.send_command(self,*args,**kwargs)
redis.connection.CacheProxyConnection.send_packed_command(self,command,check_health=True)
redis.connection.CacheProxyConnection.set_parser(self,parser_class)
redis.connection.CacheProxyConnection.set_re_auth_token(self,token:TokenInterface)
redis.connection.Connection(self,host='localhost',port=6379,socket_keepalive=False,socket_keepalive_options=None,socket_type=0,**kwargs)
redis.connection.Connection.__init__(self,host='localhost',port=6379,socket_keepalive=False,socket_keepalive_options=None,socket_type=0,**kwargs)
redis.connection.Connection._connect(self)
redis.connection.Connection._host_error(self)
redis.connection.Connection.repr_pieces(self)
redis.connection.ConnectionInterface
redis.connection.ConnectionInterface.can_read(self,timeout=0)
redis.connection.ConnectionInterface.check_health(self)
redis.connection.ConnectionInterface.connect(self)
redis.connection.ConnectionInterface.deregister_connect_callback(self,callback)
redis.connection.ConnectionInterface.disconnect(self,*args)
redis.connection.ConnectionInterface.get_protocol(self)
redis.connection.ConnectionInterface.handshake_metadata(self)->Union[Dict[bytes, bytes], Dict[str, str]]
redis.connection.ConnectionInterface.on_connect(self)
redis.connection.ConnectionInterface.pack_command(self,*args)
redis.connection.ConnectionInterface.pack_commands(self,commands)
redis.connection.ConnectionInterface.re_auth(self)
redis.connection.ConnectionInterface.read_response(self,disable_decoding=False,*,disconnect_on_error=True,push_request=False)
redis.connection.ConnectionInterface.register_connect_callback(self,callback)
redis.connection.ConnectionInterface.repr_pieces(self)
redis.connection.ConnectionInterface.send_command(self,*args,**kwargs)
redis.connection.ConnectionInterface.send_packed_command(self,command,check_health=True)
redis.connection.ConnectionInterface.set_parser(self,parser_class)
redis.connection.ConnectionInterface.set_re_auth_token(self,token:TokenInterface)
redis.connection.ConnectionPool(self,connection_class=Connection,max_connections:Optional[int]=None,cache_factory:Optional[CacheFactoryInterface]=None,**connection_kwargs)
redis.connection.ConnectionPool.__init__(self,connection_class=Connection,max_connections:Optional[int]=None,cache_factory:Optional[CacheFactoryInterface]=None,**connection_kwargs)
redis.connection.ConnectionPool.__repr__(self)->(str, str)
redis.connection.ConnectionPool._checkpid(self)->None
redis.connection.ConnectionPool._mock(self,error:RedisError)
redis.connection.ConnectionPool.close(self)->None
redis.connection.ConnectionPool.disconnect(self,inuse_connections:bool=True)->None
redis.connection.ConnectionPool.from_url(cls:Type[_CP],url:str,**kwargs)->_CP
redis.connection.ConnectionPool.get_connection(self,command_name=None,*keys,**options)->'Connection'
redis.connection.ConnectionPool.get_encoder(self)->Encoder
redis.connection.ConnectionPool.get_protocol(self)
redis.connection.ConnectionPool.make_connection(self)->'ConnectionInterface'
redis.connection.ConnectionPool.owns_connection(self,connection:'Connection')->int
redis.connection.ConnectionPool.re_auth_callback(self,token:TokenInterface)
redis.connection.ConnectionPool.release(self,connection:'Connection')->None
redis.connection.ConnectionPool.reset(self)->None
redis.connection.ConnectionPool.set_retry(self,retry:Retry)->None
redis.connection.HiredisRespSerializer
redis.connection.HiredisRespSerializer.pack(self,*args:List)
redis.connection.PythonRespSerializer(self,buffer_cutoff,encode)
redis.connection.PythonRespSerializer.__init__(self,buffer_cutoff,encode)
redis.connection.PythonRespSerializer.pack(self,*args)
redis.connection.SSLConnection(self,ssl_keyfile=None,ssl_certfile=None,ssl_cert_reqs='required',ssl_ca_certs=None,ssl_ca_data=None,ssl_check_hostname=True,ssl_ca_path=None,ssl_password=None,ssl_validate_ocsp=False,ssl_validate_ocsp_stapled=False,ssl_ocsp_context=None,ssl_ocsp_expected_cert=None,ssl_min_version=None,ssl_ciphers=None,**kwargs)
redis.connection.SSLConnection.__init__(self,ssl_keyfile=None,ssl_certfile=None,ssl_cert_reqs='required',ssl_ca_certs=None,ssl_ca_data=None,ssl_check_hostname=True,ssl_ca_path=None,ssl_password=None,ssl_validate_ocsp=False,ssl_validate_ocsp_stapled=False,ssl_ocsp_context=None,ssl_ocsp_expected_cert=None,ssl_min_version=None,ssl_ciphers=None,**kwargs)
redis.connection.SSLConnection._connect(self)
redis.connection.SSLConnection._wrap_socket_with_ssl(self,sock)
redis.connection.UnixDomainSocketConnection(self,path='',socket_timeout=None,**kwargs)
redis.connection.UnixDomainSocketConnection.__init__(self,path='',socket_timeout=None,**kwargs)
redis.connection.UnixDomainSocketConnection._connect(self)
redis.connection.UnixDomainSocketConnection._host_error(self)
redis.connection.UnixDomainSocketConnection.repr_pieces(self)
redis.connection.parse_url(url)
redis.connection.to_bool(value)


----------------------------------------/dataset/nuaa/anaconda3/envs/redis6.1.1/lib/python3.9/site-packages/redis/crc.py----------------------------------------
A:redis.crc.start->key.find(b'{')
A:redis.crc.end->key.find(b'}', start + 1)
redis.crc.key_slot(key:EncodedT,bucket:int=REDIS_CLUSTER_HASH_SLOTS)->int


----------------------------------------/dataset/nuaa/anaconda3/envs/redis6.1.1/lib/python3.9/site-packages/redis/asyncio/__init__.py----------------------------------------


----------------------------------------/dataset/nuaa/anaconda3/envs/redis6.1.1/lib/python3.9/site-packages/redis/asyncio/retry.py----------------------------------------
A:redis.asyncio.retry.T->TypeVar('T')
A:redis.asyncio.retry.self._supported_errors->tuple(set(self._supported_errors + tuple(specified_errors)))
A:redis.asyncio.retry.backoff->self._backoff.compute(failures)
redis.asyncio.retry.Retry(self,backoff:'AbstractBackoff',retries:int,supported_errors:Tuple[Type[RedisError],...]=(ConnectionError,TimeoutError))
redis.asyncio.retry.Retry.__init__(self,backoff:'AbstractBackoff',retries:int,supported_errors:Tuple[Type[RedisError],...]=(ConnectionError,TimeoutError))
redis.asyncio.retry.Retry.call_with_retry(self,do:Callable[[],Awaitable[T]],fail:Callable[[RedisError],Any])->T
redis.asyncio.retry.Retry.get_retries(self)->int
redis.asyncio.retry.Retry.update_retries(self,value:int)->None
redis.asyncio.retry.Retry.update_supported_errors(self,specified_errors:list)


----------------------------------------/dataset/nuaa/anaconda3/envs/redis6.1.1/lib/python3.9/site-packages/redis/asyncio/lock.py----------------------------------------
A:redis.asyncio.lock.logger->logging.getLogger(__name__)
A:redis.asyncio.lock.self.thread_local->bool(thread_local)
A:redis.asyncio.lock.cls.lua_release->client.register_script(cls.LUA_RELEASE_SCRIPT)
A:redis.asyncio.lock.cls.lua_extend->client.register_script(cls.LUA_EXTEND_SCRIPT)
A:redis.asyncio.lock.cls.lua_reacquire->client.register_script(cls.LUA_REACQUIRE_SCRIPT)
A:redis.asyncio.lock.token->self.redis.get_encoder().encode(token)
A:redis.asyncio.lock.encoder->self.redis.get_encoder()
A:redis.asyncio.lock.timeout->int(self.timeout * 1000)
A:redis.asyncio.lock.stored_token->self.redis.get_encoder().encode(stored_token)
A:redis.asyncio.lock.additional_time->int(additional_time * 1000)
redis.asyncio.lock.Lock(self,redis:Union['Redis','RedisCluster'],name:Union[str,bytes,memoryview],timeout:Optional[float]=None,sleep:float=0.1,blocking:bool=True,blocking_timeout:Optional[Number]=None,thread_local:bool=True,raise_on_release_error:bool=True)
redis.asyncio.lock.Lock.__aenter__(self)
redis.asyncio.lock.Lock.__aexit__(self,exc_type,exc_value,traceback)
redis.asyncio.lock.Lock.__init__(self,redis:Union['Redis','RedisCluster'],name:Union[str,bytes,memoryview],timeout:Optional[float]=None,sleep:float=0.1,blocking:bool=True,blocking_timeout:Optional[Number]=None,thread_local:bool=True,raise_on_release_error:bool=True)
redis.asyncio.lock.Lock.acquire(self,blocking:Optional[bool]=None,blocking_timeout:Optional[Number]=None,token:Optional[Union[str,bytes]]=None)
redis.asyncio.lock.Lock.do_acquire(self,token:Union[str,bytes])->bool
redis.asyncio.lock.Lock.do_extend(self,additional_time,replace_ttl)->bool
redis.asyncio.lock.Lock.do_reacquire(self)->bool
redis.asyncio.lock.Lock.do_release(self,expected_token:bytes)->None
redis.asyncio.lock.Lock.extend(self,additional_time:Number,replace_ttl:bool=False)->Awaitable[bool]
redis.asyncio.lock.Lock.locked(self)->bool
redis.asyncio.lock.Lock.owned(self)->bool
redis.asyncio.lock.Lock.reacquire(self)->Awaitable[bool]
redis.asyncio.lock.Lock.register_scripts(self)
redis.asyncio.lock.Lock.release(self)->Awaitable[None]


----------------------------------------/dataset/nuaa/anaconda3/envs/redis6.1.1/lib/python3.9/site-packages/redis/asyncio/client.py----------------------------------------
A:redis.asyncio.client._KeyT->TypeVar('_KeyT', bound=KeyT)
A:redis.asyncio.client._ArgT->TypeVar('_ArgT', KeyT, EncodableT)
A:redis.asyncio.client._RedisT->TypeVar('_RedisT', bound='Redis')
A:redis.asyncio.client._NormalizeKeysT->TypeVar('_NormalizeKeysT', bound=Mapping[ChannelT, object])
A:redis.asyncio.client.connection_pool->ConnectionPool(**kwargs)
A:redis.asyncio.client.client->cls(connection_pool=connection_pool)
A:redis.asyncio.client.self._event_dispatcher->EventDispatcher()
A:redis.asyncio.client.self.response_callbacks->CaseInsensitiveDict(_RedisCallbacks)
A:redis.asyncio.client.self._single_conn_lock->asyncio.Lock()
A:redis.asyncio.client.func_value->func(pipe)
A:redis.asyncio.client.command_name->cast(str, command_name)
A:redis.asyncio.client.retval->self.response_callbacks[command_name](response, **options)
A:redis.asyncio.client.monitor_re->re.compile('\\[(\\d+) (.*?)\\] (.*)')
A:redis.asyncio.client.command_re->re.compile('"(.*?)(?<!\\\\)"')
A:redis.asyncio.client.response->self.connection.encoder.decode(response, force=True)
A:redis.asyncio.client.(command_time, command_data)->self.connection.encoder.decode(response, force=True).split(' ', 1)
A:redis.asyncio.client.m->self.monitor_re.match(command_data)
A:redis.asyncio.client.(db_id, client_info, command)->self.monitor_re.match(command_data).groups()
A:redis.asyncio.client.command->command.replace('\\"', '"').replace('\\"', '"')
A:redis.asyncio.client.(client_address, client_port)->client_info.rsplit(':', 1)
A:redis.asyncio.client.self.encoder->self.connection_pool.get_encoder()
A:redis.asyncio.client.self.pending_unsubscribe_channels->set()
A:redis.asyncio.client.self.pending_unsubscribe_patterns->set()
A:redis.asyncio.client.self._lock->asyncio.Lock()
A:redis.asyncio.client.new_patterns->self._normalize_keys(new_patterns)
A:redis.asyncio.client.parsed_args->list_or_args(args[0], args[1:])
A:redis.asyncio.client.patterns->self._normalize_keys(dict.fromkeys(parsed_args)).keys()
A:redis.asyncio.client.new_channels->self._normalize_keys(new_channels)
A:redis.asyncio.client.channels->self._normalize_keys(dict.fromkeys(parsed_args))
A:redis.asyncio.client.message_type->str_if_bytes(response[0])
A:redis.asyncio.client.handler->self.channels.get(message['channel'], None)
A:redis.asyncio.client.res->exception_handler(e, self)
A:redis.asyncio.client.self.scripts->set()
A:redis.asyncio.client.all_cmds->connection.pack_commands([args for (args, _) in commands])
A:redis.asyncio.client.r->self.response_callbacks[command_name](r, **options)
A:redis.asyncio.client.cmd->' '.join(map(safe_str, command))
A:redis.asyncio.client.scripts->list(self.scripts)
A:redis.asyncio.client.conn->cast(Connection, conn)
redis.asyncio.Redis(self,*,host:str='localhost',port:int=6379,db:Union[str,int]=0,password:Optional[str]=None,socket_timeout:Optional[float]=None,socket_connect_timeout:Optional[float]=None,socket_keepalive:Optional[bool]=None,socket_keepalive_options:Optional[Mapping[int,Union[int,bytes]]]=None,connection_pool:Optional[ConnectionPool]=None,unix_socket_path:Optional[str]=None,encoding:str='utf-8',encoding_errors:str='strict',decode_responses:bool=False,retry_on_timeout:bool=False,retry:Retry=Retry(backoff=ExponentialWithJitterBackoff(base=1,cap=10),retries=3),retry_on_error:Optional[list]=None,ssl:bool=False,ssl_keyfile:Optional[str]=None,ssl_certfile:Optional[str]=None,ssl_cert_reqs:Union[str,VerifyMode]='required',ssl_ca_certs:Optional[str]=None,ssl_ca_data:Optional[str]=None,ssl_check_hostname:bool=True,ssl_min_version:Optional[TLSVersion]=None,ssl_ciphers:Optional[str]=None,max_connections:Optional[int]=None,single_connection_client:bool=False,health_check_interval:int=0,client_name:Optional[str]=None,lib_name:Optional[str]='redis-py',lib_version:Optional[str]=get_lib_version(),username:Optional[str]=None,auto_close_connection_pool:Optional[bool]=None,redis_connect_func=None,credential_provider:Optional[CredentialProvider]=None,protocol:Optional[int]=2,event_dispatcher:Optional[EventDispatcher]=None)
redis.asyncio.Redis.__aenter__(self:_RedisT)->_RedisT
redis.asyncio.Redis.__aexit__(self,exc_type,exc_value,traceback)
redis.asyncio.Redis.__await__(self)
redis.asyncio.Redis.__del__(self,_warn:Any=warnings.warn,_grl:Any=asyncio.get_running_loop)->None
redis.asyncio.Redis.__repr__(self)
redis.asyncio.Redis._close_connection(self,conn:Connection)
redis.asyncio.Redis._send_command_parse_response(self,conn,command_name,*args,**options)
redis.asyncio.Redis.aclose(self,close_connection_pool:Optional[bool]=None)->None
redis.asyncio.Redis.client(self)->'Redis'
redis.asyncio.Redis.close(self,close_connection_pool:Optional[bool]=None)->None
redis.asyncio.Redis.execute_command(self,*args,**options)
redis.asyncio.Redis.from_pool(cls:Type['Redis'],connection_pool:ConnectionPool)->'Redis'
redis.asyncio.Redis.from_url(cls,url:str,single_connection_client:bool=False,auto_close_connection_pool:Optional[bool]=None,**kwargs)
redis.asyncio.Redis.get_connection_kwargs(self)
redis.asyncio.Redis.get_encoder(self)
redis.asyncio.Redis.get_retry(self)->Optional[Retry]
redis.asyncio.Redis.initialize(self:_RedisT)->_RedisT
redis.asyncio.Redis.load_external_module(self,funcname,func)
redis.asyncio.Redis.lock(self,name:KeyT,timeout:Optional[float]=None,sleep:float=0.1,blocking:bool=True,blocking_timeout:Optional[float]=None,lock_class:Optional[Type[Lock]]=None,thread_local:bool=True,raise_on_release_error:bool=True)->Lock
redis.asyncio.Redis.monitor(self)->'Monitor'
redis.asyncio.Redis.parse_response(self,connection:Connection,command_name:Union[str,bytes],**options)
redis.asyncio.Redis.pipeline(self,transaction:bool=True,shard_hint:Optional[str]=None)->'Pipeline'
redis.asyncio.Redis.pubsub(self,**kwargs)->'PubSub'
redis.asyncio.Redis.set_response_callback(self,command:str,callback:ResponseCallbackT)
redis.asyncio.Redis.set_retry(self,retry:Retry)->None
redis.asyncio.Redis.transaction(self,func:Callable[['Pipeline'],Union[Any,Awaitable[Any]]],*watches:KeyT,shard_hint:Optional[str]=None,value_from_callable:bool=False,watch_delay:Optional[float]=None)
redis.asyncio.client.AsyncPubsubWorkerExceptionHandler(self,e:BaseException,pubsub:PubSub)
redis.asyncio.client.AsyncPubsubWorkerExceptionHandler.__call__(self,e:BaseException,pubsub:PubSub)
redis.asyncio.client.AsyncResponseCallbackProtocol(self,response:Any,**kwargs)
redis.asyncio.client.AsyncResponseCallbackProtocol.__call__(self,response:Any,**kwargs)
redis.asyncio.client.Monitor(self,connection_pool:ConnectionPool)
redis.asyncio.client.Monitor.__aenter__(self)
redis.asyncio.client.Monitor.__aexit__(self,*args)
redis.asyncio.client.Monitor.__init__(self,connection_pool:ConnectionPool)
redis.asyncio.client.Monitor.connect(self)
redis.asyncio.client.Monitor.listen(self)->AsyncIterator[MonitorCommandInfo]
redis.asyncio.client.Monitor.next_command(self)->MonitorCommandInfo
redis.asyncio.client.MonitorCommandInfo(TypedDict)
redis.asyncio.client.Pipeline(self,connection_pool:ConnectionPool,response_callbacks:MutableMapping[Union[str,bytes],ResponseCallbackT],transaction:bool,shard_hint:Optional[str])
redis.asyncio.client.Pipeline.__aenter__(self:_RedisT)->_RedisT
redis.asyncio.client.Pipeline.__aexit__(self,exc_type,exc_value,traceback)
redis.asyncio.client.Pipeline.__await__(self)
redis.asyncio.client.Pipeline.__bool__(self)
redis.asyncio.client.Pipeline.__init__(self,connection_pool:ConnectionPool,response_callbacks:MutableMapping[Union[str,bytes],ResponseCallbackT],transaction:bool,shard_hint:Optional[str])
redis.asyncio.client.Pipeline.__len__(self)
redis.asyncio.client.Pipeline._async_self(self)
redis.asyncio.client.Pipeline._disconnect_raise_on_watching(self,conn:Connection,error:Exception)
redis.asyncio.client.Pipeline._disconnect_reset_raise_on_watching(self,conn:Connection,error:Exception)
redis.asyncio.client.Pipeline._execute_pipeline(self,connection:Connection,commands:CommandStackT,raise_on_error:bool)
redis.asyncio.client.Pipeline._execute_transaction(self,connection:Connection,commands:CommandStackT,raise_on_error)
redis.asyncio.client.Pipeline.aclose(self)->None
redis.asyncio.client.Pipeline.annotate_exception(self,exception:Exception,number:int,command:Iterable[object])->None
redis.asyncio.client.Pipeline.discard(self)
redis.asyncio.client.Pipeline.execute(self,raise_on_error:bool=True)->List[Any]
redis.asyncio.client.Pipeline.execute_command(self,*args,**kwargs)->Union['Pipeline', Awaitable['Pipeline']]
redis.asyncio.client.Pipeline.immediate_execute_command(self,*args,**options)
redis.asyncio.client.Pipeline.load_scripts(self)
redis.asyncio.client.Pipeline.multi(self)
redis.asyncio.client.Pipeline.parse_response(self,connection:Connection,command_name:Union[str,bytes],**options)
redis.asyncio.client.Pipeline.pipeline_execute_command(self,*args,**options)
redis.asyncio.client.Pipeline.raise_first_error(self,commands:CommandStackT,response:Iterable[Any])
redis.asyncio.client.Pipeline.reset(self)
redis.asyncio.client.Pipeline.unwatch(self)
redis.asyncio.client.Pipeline.watch(self,*names:KeyT)
redis.asyncio.client.PubSub(self,connection_pool:ConnectionPool,shard_hint:Optional[str]=None,ignore_subscribe_messages:bool=False,encoder=None,push_handler_func:Optional[Callable]=None,event_dispatcher:Optional['EventDispatcher']=None)
redis.asyncio.client.PubSub.__aenter__(self)
redis.asyncio.client.PubSub.__aexit__(self,exc_type,exc_value,traceback)
redis.asyncio.client.PubSub.__del__(self)
redis.asyncio.client.PubSub.__init__(self,connection_pool:ConnectionPool,shard_hint:Optional[str]=None,ignore_subscribe_messages:bool=False,encoder=None,push_handler_func:Optional[Callable]=None,event_dispatcher:Optional['EventDispatcher']=None)
redis.asyncio.client.PubSub._execute(self,conn,command,*args,**kwargs)
redis.asyncio.client.PubSub._normalize_keys(self,data:_NormalizeKeysT)->_NormalizeKeysT
redis.asyncio.client.PubSub._reconnect(self,conn)
redis.asyncio.client.PubSub.aclose(self)
redis.asyncio.client.PubSub.check_health(self)
redis.asyncio.client.PubSub.close(self)->None
redis.asyncio.client.PubSub.connect(self)
redis.asyncio.client.PubSub.execute_command(self,*args:EncodableT)
redis.asyncio.client.PubSub.get_message(self,ignore_subscribe_messages:bool=False,timeout:Optional[float]=0.0)
redis.asyncio.client.PubSub.handle_message(self,response,ignore_subscribe_messages=False)
redis.asyncio.client.PubSub.listen(self)->AsyncIterator
redis.asyncio.client.PubSub.on_connect(self,connection:Connection)
redis.asyncio.client.PubSub.parse_response(self,block:bool=True,timeout:float=0)
redis.asyncio.client.PubSub.ping(self,message=None)->Awaitable
redis.asyncio.client.PubSub.psubscribe(self,*args:ChannelT,**kwargs:PubSubHandler)
redis.asyncio.client.PubSub.punsubscribe(self,*args:ChannelT)->Awaitable
redis.asyncio.client.PubSub.reset(self)->None
redis.asyncio.client.PubSub.run(self,*,exception_handler:Optional['PSWorkerThreadExcHandlerT']=None,poll_timeout:float=1.0)->None
redis.asyncio.client.PubSub.subscribe(self,*args:ChannelT,**kwargs:Callable)
redis.asyncio.client.PubSub.subscribed(self)
redis.asyncio.client.PubSub.unsubscribe(self,*args)->Awaitable
redis.asyncio.client.PubsubWorkerExceptionHandler(self,e:BaseException,pubsub:PubSub)
redis.asyncio.client.PubsubWorkerExceptionHandler.__call__(self,e:BaseException,pubsub:PubSub)
redis.asyncio.client.Redis(self,*,host:str='localhost',port:int=6379,db:Union[str,int]=0,password:Optional[str]=None,socket_timeout:Optional[float]=None,socket_connect_timeout:Optional[float]=None,socket_keepalive:Optional[bool]=None,socket_keepalive_options:Optional[Mapping[int,Union[int,bytes]]]=None,connection_pool:Optional[ConnectionPool]=None,unix_socket_path:Optional[str]=None,encoding:str='utf-8',encoding_errors:str='strict',decode_responses:bool=False,retry_on_timeout:bool=False,retry:Retry=Retry(backoff=ExponentialWithJitterBackoff(base=1,cap=10),retries=3),retry_on_error:Optional[list]=None,ssl:bool=False,ssl_keyfile:Optional[str]=None,ssl_certfile:Optional[str]=None,ssl_cert_reqs:Union[str,VerifyMode]='required',ssl_ca_certs:Optional[str]=None,ssl_ca_data:Optional[str]=None,ssl_check_hostname:bool=True,ssl_min_version:Optional[TLSVersion]=None,ssl_ciphers:Optional[str]=None,max_connections:Optional[int]=None,single_connection_client:bool=False,health_check_interval:int=0,client_name:Optional[str]=None,lib_name:Optional[str]='redis-py',lib_version:Optional[str]=get_lib_version(),username:Optional[str]=None,auto_close_connection_pool:Optional[bool]=None,redis_connect_func=None,credential_provider:Optional[CredentialProvider]=None,protocol:Optional[int]=2,event_dispatcher:Optional[EventDispatcher]=None)
redis.asyncio.client.Redis.__aenter__(self:_RedisT)->_RedisT
redis.asyncio.client.Redis.__aexit__(self,exc_type,exc_value,traceback)
redis.asyncio.client.Redis.__await__(self)
redis.asyncio.client.Redis.__del__(self,_warn:Any=warnings.warn,_grl:Any=asyncio.get_running_loop)->None
redis.asyncio.client.Redis.__init__(self,*,host:str='localhost',port:int=6379,db:Union[str,int]=0,password:Optional[str]=None,socket_timeout:Optional[float]=None,socket_connect_timeout:Optional[float]=None,socket_keepalive:Optional[bool]=None,socket_keepalive_options:Optional[Mapping[int,Union[int,bytes]]]=None,connection_pool:Optional[ConnectionPool]=None,unix_socket_path:Optional[str]=None,encoding:str='utf-8',encoding_errors:str='strict',decode_responses:bool=False,retry_on_timeout:bool=False,retry:Retry=Retry(backoff=ExponentialWithJitterBackoff(base=1,cap=10),retries=3),retry_on_error:Optional[list]=None,ssl:bool=False,ssl_keyfile:Optional[str]=None,ssl_certfile:Optional[str]=None,ssl_cert_reqs:Union[str,VerifyMode]='required',ssl_ca_certs:Optional[str]=None,ssl_ca_data:Optional[str]=None,ssl_check_hostname:bool=True,ssl_min_version:Optional[TLSVersion]=None,ssl_ciphers:Optional[str]=None,max_connections:Optional[int]=None,single_connection_client:bool=False,health_check_interval:int=0,client_name:Optional[str]=None,lib_name:Optional[str]='redis-py',lib_version:Optional[str]=get_lib_version(),username:Optional[str]=None,auto_close_connection_pool:Optional[bool]=None,redis_connect_func=None,credential_provider:Optional[CredentialProvider]=None,protocol:Optional[int]=2,event_dispatcher:Optional[EventDispatcher]=None)
redis.asyncio.client.Redis.__repr__(self)
redis.asyncio.client.Redis._close_connection(self,conn:Connection)
redis.asyncio.client.Redis._send_command_parse_response(self,conn,command_name,*args,**options)
redis.asyncio.client.Redis.aclose(self,close_connection_pool:Optional[bool]=None)->None
redis.asyncio.client.Redis.client(self)->'Redis'
redis.asyncio.client.Redis.close(self,close_connection_pool:Optional[bool]=None)->None
redis.asyncio.client.Redis.execute_command(self,*args,**options)
redis.asyncio.client.Redis.from_pool(cls:Type['Redis'],connection_pool:ConnectionPool)->'Redis'
redis.asyncio.client.Redis.from_url(cls,url:str,single_connection_client:bool=False,auto_close_connection_pool:Optional[bool]=None,**kwargs)
redis.asyncio.client.Redis.get_connection_kwargs(self)
redis.asyncio.client.Redis.get_encoder(self)
redis.asyncio.client.Redis.get_retry(self)->Optional[Retry]
redis.asyncio.client.Redis.initialize(self:_RedisT)->_RedisT
redis.asyncio.client.Redis.load_external_module(self,funcname,func)
redis.asyncio.client.Redis.lock(self,name:KeyT,timeout:Optional[float]=None,sleep:float=0.1,blocking:bool=True,blocking_timeout:Optional[float]=None,lock_class:Optional[Type[Lock]]=None,thread_local:bool=True,raise_on_release_error:bool=True)->Lock
redis.asyncio.client.Redis.monitor(self)->'Monitor'
redis.asyncio.client.Redis.parse_response(self,connection:Connection,command_name:Union[str,bytes],**options)
redis.asyncio.client.Redis.pipeline(self,transaction:bool=True,shard_hint:Optional[str]=None)->'Pipeline'
redis.asyncio.client.Redis.pubsub(self,**kwargs)->'PubSub'
redis.asyncio.client.Redis.set_response_callback(self,command:str,callback:ResponseCallbackT)
redis.asyncio.client.Redis.set_retry(self,retry:Retry)->None
redis.asyncio.client.Redis.transaction(self,func:Callable[['Pipeline'],Union[Any,Awaitable[Any]]],*watches:KeyT,shard_hint:Optional[str]=None,value_from_callable:bool=False,watch_delay:Optional[float]=None)
redis.asyncio.client.ResponseCallbackProtocol(self,response:Any,**kwargs)
redis.asyncio.client.ResponseCallbackProtocol.__call__(self,response:Any,**kwargs)


----------------------------------------/dataset/nuaa/anaconda3/envs/redis6.1.1/lib/python3.9/site-packages/redis/asyncio/utils.py----------------------------------------
redis.asyncio.from_url(url,**kwargs)
redis.asyncio.utils.from_url(url,**kwargs)
redis.asyncio.utils.pipeline(self,redis_obj:'Redis')
redis.asyncio.utils.pipeline.__aenter__(self)->'Pipeline'
redis.asyncio.utils.pipeline.__aexit__(self,exc_type,exc_value,traceback)
redis.asyncio.utils.pipeline.__init__(self,redis_obj:'Redis')


----------------------------------------/dataset/nuaa/anaconda3/envs/redis6.1.1/lib/python3.9/site-packages/redis/asyncio/cluster.py----------------------------------------
A:redis.asyncio.cluster.TargetNodesT->TypeVar('TargetNodesT', str, 'ClusterNode', List['ClusterNode'], Dict[Any, 'ClusterNode'])
A:redis.asyncio.cluster.self.retry->Retry(backoff=ExponentialWithJitterBackoff(base=1, cap=10), retries=cluster_error_retry_attempts)
A:redis.asyncio.cluster.kwargs['response_callbacks']->redis._parsers.helpers._RedisCallbacks.copy()
A:redis.asyncio.cluster.self._event_dispatcher->EventDispatcher()
A:redis.asyncio.cluster.self.nodes_manager->NodesManager(startup_nodes, require_full_coverage, kwargs, address_remap=address_remap, event_dispatcher=self._event_dispatcher)
A:redis.asyncio.cluster.self.encoder->Encoder(encoding, encoding_errors, decode_responses)
A:redis.asyncio.cluster.self.commands_parser->AsyncCommandsParser()
A:redis.asyncio.cluster.self.node_flags->self.__class__.NODE_FLAGS.copy()
A:redis.asyncio.cluster.self.command_flags->self.__class__.COMMAND_FLAGS.copy()
A:redis.asyncio.cluster.self.result_callbacks->self.__class__.RESULT_CALLBACKS.copy()
A:redis.asyncio.cluster.self._lock->asyncio.Lock()
A:redis.asyncio.cluster.slot->key_slot(encoder.encode(pair[0]))
A:redis.asyncio.cluster.slot_cache->self.nodes_manager.slots_cache.get(slot)
A:redis.asyncio.cluster.node_flag->self.command_flags.get(command)
A:redis.asyncio.cluster.nodes->list(target_nodes.values())
A:redis.asyncio.cluster.retry_attempts->self._client.retry.get_retries()
A:redis.asyncio.cluster.passed_targets->cmd.kwargs.pop('target_nodes', None)
A:redis.asyncio.cluster.target_nodes->client._parse_target_nodes(passed_targets)
A:redis.asyncio.cluster.target_node->ClusterNode(host, port, PRIMARY, **self.connection_kwargs)
A:redis.asyncio.cluster.redirect_addr->get_node_name(host=e.host, port=e.port)
A:redis.asyncio.cluster.host->socket.gethostbyname(host)
A:redis.asyncio.cluster.self.name->get_node_name(host, port)
A:redis.asyncio.cluster.self.response_callbacks->self.connection_kwargs.copy().pop('response_callbacks', {})
A:redis.asyncio.cluster.exc->next((res for res in ret if isinstance(res, Exception)), None)
A:redis.asyncio.cluster.retry->Retry(backoff=NoBackoff(), retries=0, supported_errors=(ConnectionError,))
A:redis.asyncio.cluster.connection_kwargs->self.connection_kwargs.copy()
A:redis.asyncio.cluster.connection->self.acquire_connection()
A:redis.asyncio.cluster.tmp_queue->collections.deque()
A:redis.asyncio.cluster.conn->collections.deque().popleft()
A:redis.asyncio.cluster.self.read_load_balancer->LoadBalancer()
A:redis.asyncio.cluster.task->asyncio.create_task(old[name].disconnect())
A:redis.asyncio.cluster.redirected_node->ClusterNode(e.host, e.port, PRIMARY, **self.connection_kwargs)
A:redis.asyncio.cluster.node_idx->self.read_load_balancer.get_server_index(primary_name, len(self.slots_cache[slot]), load_balancing_strategy)
A:redis.asyncio.cluster.port->int(primary_node[1])
A:redis.asyncio.cluster.(host, port)->self.remap_host_port(host, port)
A:redis.asyncio.cluster.target_replica_node->ClusterNode(host, port, REPLICA, **self.connection_kwargs)
A:redis.asyncio.cluster.command->command.replace(' ', '_').lower().replace(' ', '_').lower()
A:redis.asyncio.cluster.default_cluster_node->client.get_default_node()
A:redis.asyncio.cluster.default_node->list(target_nodes.values()).get(default_cluster_node.name)
redis.asyncio.RedisCluster(self,host:Optional[str]=None,port:Union[str,int]=6379,startup_nodes:Optional[List['ClusterNode']]=None,require_full_coverage:bool=True,read_from_replicas:bool=False,load_balancing_strategy:Optional[LoadBalancingStrategy]=None,reinitialize_steps:int=5,cluster_error_retry_attempts:int=3,max_connections:int=2**31,retry:Optional['Retry']=None,retry_on_error:Optional[List[Type[Exception]]]=None,db:Union[str,int]=0,path:Optional[str]=None,credential_provider:Optional[CredentialProvider]=None,username:Optional[str]=None,password:Optional[str]=None,client_name:Optional[str]=None,lib_name:Optional[str]='redis-py',lib_version:Optional[str]=get_lib_version(),encoding:str='utf-8',encoding_errors:str='strict',decode_responses:bool=False,health_check_interval:float=0,socket_connect_timeout:Optional[float]=None,socket_keepalive:bool=False,socket_keepalive_options:Optional[Mapping[int,Union[int,bytes]]]=None,socket_timeout:Optional[float]=None,ssl:bool=False,ssl_ca_certs:Optional[str]=None,ssl_ca_data:Optional[str]=None,ssl_cert_reqs:Union[str,VerifyMode]='required',ssl_certfile:Optional[str]=None,ssl_check_hostname:bool=True,ssl_keyfile:Optional[str]=None,ssl_min_version:Optional[TLSVersion]=None,ssl_ciphers:Optional[str]=None,protocol:Optional[int]=2,address_remap:Optional[Callable[[Tuple[str,int]],Tuple[str,int]]]=None,event_dispatcher:Optional[EventDispatcher]=None)
redis.asyncio.RedisCluster.__aenter__(self)->'RedisCluster'
redis.asyncio.RedisCluster.__aexit__(self,exc_type:None,exc_value:None,traceback:None)->None
redis.asyncio.RedisCluster.__await__(self)->Generator[Any, None, 'RedisCluster']
redis.asyncio.RedisCluster.__del__(self,_warn:Any=warnings.warn,_grl:Any=asyncio.get_running_loop)->None
redis.asyncio.RedisCluster._determine_nodes(self,command:str,*args:Any,node_flag:Optional[str]=None)->List['ClusterNode']
redis.asyncio.RedisCluster._determine_slot(self,command:str,*args:Any)->int
redis.asyncio.RedisCluster._execute_command(self,target_node:'ClusterNode',*args:Union[KeyT,EncodableT],**kwargs:Any)->Any
redis.asyncio.RedisCluster._is_node_flag(self,target_nodes:Any)->bool
redis.asyncio.RedisCluster._parse_target_nodes(self,target_nodes:Any)->List['ClusterNode']
redis.asyncio.RedisCluster.aclose(self)->None
redis.asyncio.RedisCluster.close(self)->None
redis.asyncio.RedisCluster.execute_command(self,*args:EncodableT,**kwargs:Any)->Any
redis.asyncio.RedisCluster.from_url(cls,url:str,**kwargs:Any)->'RedisCluster'
redis.asyncio.RedisCluster.get_connection_kwargs(self)->Dict[str, Optional[Any]]
redis.asyncio.RedisCluster.get_default_node(self)->'ClusterNode'
redis.asyncio.RedisCluster.get_encoder(self)->Encoder
redis.asyncio.RedisCluster.get_node(self,host:Optional[str]=None,port:Optional[int]=None,node_name:Optional[str]=None)->Optional['ClusterNode']
redis.asyncio.RedisCluster.get_node_from_key(self,key:str,replica:bool=False)->Optional['ClusterNode']
redis.asyncio.RedisCluster.get_nodes(self)->List['ClusterNode']
redis.asyncio.RedisCluster.get_primaries(self)->List['ClusterNode']
redis.asyncio.RedisCluster.get_random_node(self)->'ClusterNode'
redis.asyncio.RedisCluster.get_replicas(self)->List['ClusterNode']
redis.asyncio.RedisCluster.initialize(self)->'RedisCluster'
redis.asyncio.RedisCluster.keyslot(self,key:EncodableT)->int
redis.asyncio.RedisCluster.lock(self,name:KeyT,timeout:Optional[float]=None,sleep:float=0.1,blocking:bool=True,blocking_timeout:Optional[float]=None,lock_class:Optional[Type[Lock]]=None,thread_local:bool=True,raise_on_release_error:bool=True)->Lock
redis.asyncio.RedisCluster.on_connect(self,connection:Connection)->None
redis.asyncio.RedisCluster.pipeline(self,transaction:Optional[Any]=None,shard_hint:Optional[Any]=None)->'ClusterPipeline'
redis.asyncio.RedisCluster.set_default_node(self,node:'ClusterNode')->None
redis.asyncio.RedisCluster.set_response_callback(self,command:str,callback:ResponseCallbackT)->None
redis.asyncio.RedisCluster.set_retry(self,retry:Retry)->None
redis.asyncio.cluster.ClusterNode(self,host:str,port:Union[str,int],server_type:Optional[str]=None,*,max_connections:int=2**31,connection_class:Type[Connection]=Connection,**connection_kwargs:Any)
redis.asyncio.cluster.ClusterNode.__del__(self,_warn:Any=warnings.warn,_grl:Any=asyncio.get_running_loop)->None
redis.asyncio.cluster.ClusterNode.__eq__(self,obj:Any)->bool
redis.asyncio.cluster.ClusterNode.__init__(self,host:str,port:Union[str,int],server_type:Optional[str]=None,*,max_connections:int=2**31,connection_class:Type[Connection]=Connection,**connection_kwargs:Any)
redis.asyncio.cluster.ClusterNode.__repr__(self)->str
redis.asyncio.cluster.ClusterNode._mock(self,error:RedisError)
redis.asyncio.cluster.ClusterNode.acquire_connection(self)->Connection
redis.asyncio.cluster.ClusterNode.disconnect(self)->None
redis.asyncio.cluster.ClusterNode.execute_command(self,*args:Any,**kwargs:Any)->Any
redis.asyncio.cluster.ClusterNode.execute_pipeline(self,commands:List['PipelineCommand'])->bool
redis.asyncio.cluster.ClusterNode.parse_response(self,connection:Connection,command:str,**kwargs:Any)->Any
redis.asyncio.cluster.ClusterNode.re_auth_callback(self,token:TokenInterface)
redis.asyncio.cluster.ClusterPipeline(self,client:RedisCluster)
redis.asyncio.cluster.ClusterPipeline.__aenter__(self)->'ClusterPipeline'
redis.asyncio.cluster.ClusterPipeline.__aexit__(self,exc_type:None,exc_value:None,traceback:None)->None
redis.asyncio.cluster.ClusterPipeline.__await__(self)->Generator[Any, None, 'ClusterPipeline']
redis.asyncio.cluster.ClusterPipeline.__bool__(self)->bool
redis.asyncio.cluster.ClusterPipeline.__enter__(self)->'ClusterPipeline'
redis.asyncio.cluster.ClusterPipeline.__exit__(self,exc_type:None,exc_value:None,traceback:None)->None
redis.asyncio.cluster.ClusterPipeline.__init__(self,client:RedisCluster)
redis.asyncio.cluster.ClusterPipeline.__len__(self)->int
redis.asyncio.cluster.ClusterPipeline._execute(self,client:'RedisCluster',stack:List['PipelineCommand'],raise_on_error:bool=True,allow_redirections:bool=True)->List[Any]
redis.asyncio.cluster.ClusterPipeline._split_command_across_slots(self,command:str,*keys:KeyT)->'ClusterPipeline'
redis.asyncio.cluster.ClusterPipeline.execute(self,raise_on_error:bool=True,allow_redirections:bool=True)->List[Any]
redis.asyncio.cluster.ClusterPipeline.execute_command(self,*args:Union[KeyT,EncodableT],**kwargs:Any)->'ClusterPipeline'
redis.asyncio.cluster.ClusterPipeline.initialize(self)->'ClusterPipeline'
redis.asyncio.cluster.ClusterPipeline.mset_nonatomic(self,mapping:Mapping[AnyKeyT,EncodableT])->'ClusterPipeline'
redis.asyncio.cluster.NodesManager(self,startup_nodes:List['ClusterNode'],require_full_coverage:bool,connection_kwargs:Dict[str,Any],address_remap:Optional[Callable[[Tuple[str,int]],Tuple[str,int]]]=None,event_dispatcher:Optional[EventDispatcher]=None)
redis.asyncio.cluster.NodesManager.__init__(self,startup_nodes:List['ClusterNode'],require_full_coverage:bool,connection_kwargs:Dict[str,Any],address_remap:Optional[Callable[[Tuple[str,int]],Tuple[str,int]]]=None,event_dispatcher:Optional[EventDispatcher]=None)
redis.asyncio.cluster.NodesManager._update_moved_slots(self)->None
redis.asyncio.cluster.NodesManager.aclose(self,attr:str='nodes_cache')->None
redis.asyncio.cluster.NodesManager.get_node(self,host:Optional[str]=None,port:Optional[int]=None,node_name:Optional[str]=None)->Optional['ClusterNode']
redis.asyncio.cluster.NodesManager.get_node_from_slot(self,slot:int,read_from_replicas:bool=False,load_balancing_strategy=None)->'ClusterNode'
redis.asyncio.cluster.NodesManager.get_nodes_by_server_type(self,server_type:str)->List['ClusterNode']
redis.asyncio.cluster.NodesManager.initialize(self)->None
redis.asyncio.cluster.NodesManager.remap_host_port(self,host:str,port:int)->Tuple[str, int]
redis.asyncio.cluster.NodesManager.set_nodes(self,old:Dict[str,'ClusterNode'],new:Dict[str,'ClusterNode'],remove_old:bool=False)->None
redis.asyncio.cluster.PipelineCommand(self,position:int,*args:Any,**kwargs:Any)
redis.asyncio.cluster.PipelineCommand.__init__(self,position:int,*args:Any,**kwargs:Any)
redis.asyncio.cluster.PipelineCommand.__repr__(self)->str
redis.asyncio.cluster.RedisCluster(self,host:Optional[str]=None,port:Union[str,int]=6379,startup_nodes:Optional[List['ClusterNode']]=None,require_full_coverage:bool=True,read_from_replicas:bool=False,load_balancing_strategy:Optional[LoadBalancingStrategy]=None,reinitialize_steps:int=5,cluster_error_retry_attempts:int=3,max_connections:int=2**31,retry:Optional['Retry']=None,retry_on_error:Optional[List[Type[Exception]]]=None,db:Union[str,int]=0,path:Optional[str]=None,credential_provider:Optional[CredentialProvider]=None,username:Optional[str]=None,password:Optional[str]=None,client_name:Optional[str]=None,lib_name:Optional[str]='redis-py',lib_version:Optional[str]=get_lib_version(),encoding:str='utf-8',encoding_errors:str='strict',decode_responses:bool=False,health_check_interval:float=0,socket_connect_timeout:Optional[float]=None,socket_keepalive:bool=False,socket_keepalive_options:Optional[Mapping[int,Union[int,bytes]]]=None,socket_timeout:Optional[float]=None,ssl:bool=False,ssl_ca_certs:Optional[str]=None,ssl_ca_data:Optional[str]=None,ssl_cert_reqs:Union[str,VerifyMode]='required',ssl_certfile:Optional[str]=None,ssl_check_hostname:bool=True,ssl_keyfile:Optional[str]=None,ssl_min_version:Optional[TLSVersion]=None,ssl_ciphers:Optional[str]=None,protocol:Optional[int]=2,address_remap:Optional[Callable[[Tuple[str,int]],Tuple[str,int]]]=None,event_dispatcher:Optional[EventDispatcher]=None)
redis.asyncio.cluster.RedisCluster.__aenter__(self)->'RedisCluster'
redis.asyncio.cluster.RedisCluster.__aexit__(self,exc_type:None,exc_value:None,traceback:None)->None
redis.asyncio.cluster.RedisCluster.__await__(self)->Generator[Any, None, 'RedisCluster']
redis.asyncio.cluster.RedisCluster.__del__(self,_warn:Any=warnings.warn,_grl:Any=asyncio.get_running_loop)->None
redis.asyncio.cluster.RedisCluster.__init__(self,host:Optional[str]=None,port:Union[str,int]=6379,startup_nodes:Optional[List['ClusterNode']]=None,require_full_coverage:bool=True,read_from_replicas:bool=False,load_balancing_strategy:Optional[LoadBalancingStrategy]=None,reinitialize_steps:int=5,cluster_error_retry_attempts:int=3,max_connections:int=2**31,retry:Optional['Retry']=None,retry_on_error:Optional[List[Type[Exception]]]=None,db:Union[str,int]=0,path:Optional[str]=None,credential_provider:Optional[CredentialProvider]=None,username:Optional[str]=None,password:Optional[str]=None,client_name:Optional[str]=None,lib_name:Optional[str]='redis-py',lib_version:Optional[str]=get_lib_version(),encoding:str='utf-8',encoding_errors:str='strict',decode_responses:bool=False,health_check_interval:float=0,socket_connect_timeout:Optional[float]=None,socket_keepalive:bool=False,socket_keepalive_options:Optional[Mapping[int,Union[int,bytes]]]=None,socket_timeout:Optional[float]=None,ssl:bool=False,ssl_ca_certs:Optional[str]=None,ssl_ca_data:Optional[str]=None,ssl_cert_reqs:Union[str,VerifyMode]='required',ssl_certfile:Optional[str]=None,ssl_check_hostname:bool=True,ssl_keyfile:Optional[str]=None,ssl_min_version:Optional[TLSVersion]=None,ssl_ciphers:Optional[str]=None,protocol:Optional[int]=2,address_remap:Optional[Callable[[Tuple[str,int]],Tuple[str,int]]]=None,event_dispatcher:Optional[EventDispatcher]=None)
redis.asyncio.cluster.RedisCluster._determine_nodes(self,command:str,*args:Any,node_flag:Optional[str]=None)->List['ClusterNode']
redis.asyncio.cluster.RedisCluster._determine_slot(self,command:str,*args:Any)->int
redis.asyncio.cluster.RedisCluster._execute_command(self,target_node:'ClusterNode',*args:Union[KeyT,EncodableT],**kwargs:Any)->Any
redis.asyncio.cluster.RedisCluster._is_node_flag(self,target_nodes:Any)->bool
redis.asyncio.cluster.RedisCluster._parse_target_nodes(self,target_nodes:Any)->List['ClusterNode']
redis.asyncio.cluster.RedisCluster.aclose(self)->None
redis.asyncio.cluster.RedisCluster.close(self)->None
redis.asyncio.cluster.RedisCluster.execute_command(self,*args:EncodableT,**kwargs:Any)->Any
redis.asyncio.cluster.RedisCluster.from_url(cls,url:str,**kwargs:Any)->'RedisCluster'
redis.asyncio.cluster.RedisCluster.get_connection_kwargs(self)->Dict[str, Optional[Any]]
redis.asyncio.cluster.RedisCluster.get_default_node(self)->'ClusterNode'
redis.asyncio.cluster.RedisCluster.get_encoder(self)->Encoder
redis.asyncio.cluster.RedisCluster.get_node(self,host:Optional[str]=None,port:Optional[int]=None,node_name:Optional[str]=None)->Optional['ClusterNode']
redis.asyncio.cluster.RedisCluster.get_node_from_key(self,key:str,replica:bool=False)->Optional['ClusterNode']
redis.asyncio.cluster.RedisCluster.get_nodes(self)->List['ClusterNode']
redis.asyncio.cluster.RedisCluster.get_primaries(self)->List['ClusterNode']
redis.asyncio.cluster.RedisCluster.get_random_node(self)->'ClusterNode'
redis.asyncio.cluster.RedisCluster.get_replicas(self)->List['ClusterNode']
redis.asyncio.cluster.RedisCluster.initialize(self)->'RedisCluster'
redis.asyncio.cluster.RedisCluster.keyslot(self,key:EncodableT)->int
redis.asyncio.cluster.RedisCluster.lock(self,name:KeyT,timeout:Optional[float]=None,sleep:float=0.1,blocking:bool=True,blocking_timeout:Optional[float]=None,lock_class:Optional[Type[Lock]]=None,thread_local:bool=True,raise_on_release_error:bool=True)->Lock
redis.asyncio.cluster.RedisCluster.on_connect(self,connection:Connection)->None
redis.asyncio.cluster.RedisCluster.pipeline(self,transaction:Optional[Any]=None,shard_hint:Optional[Any]=None)->'ClusterPipeline'
redis.asyncio.cluster.RedisCluster.set_default_node(self,node:'ClusterNode')->None
redis.asyncio.cluster.RedisCluster.set_response_callback(self,command:str,callback:ResponseCallbackT)->None
redis.asyncio.cluster.RedisCluster.set_retry(self,retry:Retry)->None


----------------------------------------/dataset/nuaa/anaconda3/envs/redis6.1.1/lib/python3.9/site-packages/redis/asyncio/sentinel.py----------------------------------------
A:redis.asyncio.sentinel.self.connection_pool->kwargs.pop('connection_pool')
A:redis.asyncio.sentinel.kwargs['connection_class']->kwargs.get('connection_class', SentinelManagedSSLConnection if kwargs.pop('ssl', False) else SentinelManagedConnection)
A:redis.asyncio.sentinel.self.is_master->kwargs.pop('is_master', True)
A:redis.asyncio.sentinel.self.check_connection->kwargs.pop('check_connection', False)
A:redis.asyncio.sentinel.self.connection_kwargs['connection_pool']->weakref.proxy(self)
A:redis.asyncio.sentinel.self.slave_rr_counter->random.randint(0, len(slaves) - 1)
A:redis.asyncio.sentinel.once->bool(kwargs.get('once', False))
A:redis.asyncio.sentinel.collected_errors->list()
A:redis.asyncio.sentinel.state->masters.get(service_name)
A:redis.asyncio.sentinel.slaves->self.filter_slaves(slaves)
A:redis.asyncio.sentinel.connection_kwargs->dict(self.connection_kwargs)
A:redis.asyncio.sentinel.connection_pool->connection_pool_class(service_name, self, **connection_kwargs)
redis.asyncio.Sentinel(self,sentinels,min_other_sentinels=0,sentinel_kwargs=None,force_master_ip=None,**connection_kwargs)
redis.asyncio.Sentinel.__repr__(self)
redis.asyncio.Sentinel.check_master_state(self,state:dict,service_name:str)->bool
redis.asyncio.Sentinel.discover_master(self,service_name:str)
redis.asyncio.Sentinel.discover_slaves(self,service_name:str)->Sequence[Tuple[EncodableT, EncodableT]]
redis.asyncio.Sentinel.execute_command(self,*args,**kwargs)
redis.asyncio.Sentinel.filter_slaves(self,slaves:Iterable[Mapping])->Sequence[Tuple[EncodableT, EncodableT]]
redis.asyncio.Sentinel.master_for(self,service_name:str,redis_class:Type[Redis]=Redis,connection_pool_class:Type[SentinelConnectionPool]=SentinelConnectionPool,**kwargs)
redis.asyncio.Sentinel.slave_for(self,service_name:str,redis_class:Type[Redis]=Redis,connection_pool_class:Type[SentinelConnectionPool]=SentinelConnectionPool,**kwargs)
redis.asyncio.SentinelConnectionPool(self,service_name,sentinel_manager,**kwargs)
redis.asyncio.SentinelConnectionPool.__repr__(self)
redis.asyncio.SentinelConnectionPool.get_master_address(self)
redis.asyncio.SentinelConnectionPool.owns_connection(self,connection:Connection)
redis.asyncio.SentinelConnectionPool.reset(self)
redis.asyncio.SentinelConnectionPool.rotate_slaves(self)->AsyncIterator
redis.asyncio.SentinelManagedConnection(self,**kwargs)
redis.asyncio.SentinelManagedConnection.__repr__(self)
redis.asyncio.SentinelManagedConnection._connect_retry(self)
redis.asyncio.SentinelManagedConnection.connect(self)
redis.asyncio.SentinelManagedConnection.connect_to(self,address)
redis.asyncio.SentinelManagedConnection.read_response(self,disable_decoding:bool=False,timeout:Optional[float]=None,*,disconnect_on_error:Optional[float]=True,push_request:Optional[bool]=False)
redis.asyncio.SentinelManagedSSLConnection(SentinelManagedConnection,SSLConnection)
redis.asyncio.sentinel.MasterNotFoundError(ConnectionError)
redis.asyncio.sentinel.Sentinel(self,sentinels,min_other_sentinels=0,sentinel_kwargs=None,force_master_ip=None,**connection_kwargs)
redis.asyncio.sentinel.Sentinel.__init__(self,sentinels,min_other_sentinels=0,sentinel_kwargs=None,force_master_ip=None,**connection_kwargs)
redis.asyncio.sentinel.Sentinel.__repr__(self)
redis.asyncio.sentinel.Sentinel.check_master_state(self,state:dict,service_name:str)->bool
redis.asyncio.sentinel.Sentinel.discover_master(self,service_name:str)
redis.asyncio.sentinel.Sentinel.discover_slaves(self,service_name:str)->Sequence[Tuple[EncodableT, EncodableT]]
redis.asyncio.sentinel.Sentinel.execute_command(self,*args,**kwargs)
redis.asyncio.sentinel.Sentinel.filter_slaves(self,slaves:Iterable[Mapping])->Sequence[Tuple[EncodableT, EncodableT]]
redis.asyncio.sentinel.Sentinel.master_for(self,service_name:str,redis_class:Type[Redis]=Redis,connection_pool_class:Type[SentinelConnectionPool]=SentinelConnectionPool,**kwargs)
redis.asyncio.sentinel.Sentinel.slave_for(self,service_name:str,redis_class:Type[Redis]=Redis,connection_pool_class:Type[SentinelConnectionPool]=SentinelConnectionPool,**kwargs)
redis.asyncio.sentinel.SentinelConnectionPool(self,service_name,sentinel_manager,**kwargs)
redis.asyncio.sentinel.SentinelConnectionPool.__init__(self,service_name,sentinel_manager,**kwargs)
redis.asyncio.sentinel.SentinelConnectionPool.__repr__(self)
redis.asyncio.sentinel.SentinelConnectionPool.get_master_address(self)
redis.asyncio.sentinel.SentinelConnectionPool.owns_connection(self,connection:Connection)
redis.asyncio.sentinel.SentinelConnectionPool.reset(self)
redis.asyncio.sentinel.SentinelConnectionPool.rotate_slaves(self)->AsyncIterator
redis.asyncio.sentinel.SentinelManagedConnection(self,**kwargs)
redis.asyncio.sentinel.SentinelManagedConnection.__init__(self,**kwargs)
redis.asyncio.sentinel.SentinelManagedConnection.__repr__(self)
redis.asyncio.sentinel.SentinelManagedConnection._connect_retry(self)
redis.asyncio.sentinel.SentinelManagedConnection.connect(self)
redis.asyncio.sentinel.SentinelManagedConnection.connect_to(self,address)
redis.asyncio.sentinel.SentinelManagedConnection.read_response(self,disable_decoding:bool=False,timeout:Optional[float]=None,*,disconnect_on_error:Optional[float]=True,push_request:Optional[bool]=False)
redis.asyncio.sentinel.SentinelManagedSSLConnection(SentinelManagedConnection,SSLConnection)
redis.asyncio.sentinel.SlaveNotFoundError(ConnectionError)


----------------------------------------/dataset/nuaa/anaconda3/envs/redis6.1.1/lib/python3.9/site-packages/redis/asyncio/connection.py----------------------------------------
A:redis.asyncio.connection.sentinel->object()
A:redis.asyncio.connection.self._event_dispatcher->EventDispatcher()
A:redis.asyncio.connection.self.retry->Retry(NoBackoff(), 0)
A:redis.asyncio.connection.self.encoder->encoder_class(encoding, encoding_errors, decode_responses)
A:redis.asyncio.connection.p->int(protocol)
A:redis.asyncio.connection.repr_args->','.join((f'{k}={v}' for (k, v) in self.repr_pieces()))
A:redis.asyncio.connection.wm->weakref.WeakMethod(callback)
A:redis.asyncio.connection.self._parser->parser_class(socket_read_size=self._socket_read_size)
A:redis.asyncio.connection.callback->ref()
A:redis.asyncio.connection.task->callback(self)
A:redis.asyncio.connection.command->command.encode().encode()
A:redis.asyncio.connection.host_error->self._host_error()
A:redis.asyncio.connection.buff->SYM_EMPTY.join((buff, SYM_DOLLAR, str(arg_length).encode(), SYM_CRLF, arg, SYM_CRLF))
A:redis.asyncio.connection.arg_length->len(arg)
A:redis.asyncio.connection.chunklen->len(chunk)
A:redis.asyncio.connection.self.port->int(port)
A:redis.asyncio.connection.sock->writer.transport.get_extra_info('socket')
A:redis.asyncio.connection.kwargs->super()._connection_arguments()
A:redis.asyncio.connection.kwargs['ssl']->self.ssl_context.get()
A:redis.asyncio.connection.context->ssl.create_default_context()
A:redis.asyncio.connection.value->unquote(value_list[0])
A:redis.asyncio.connection.parser->URL_QUERY_ARGUMENT_PARSERS.get(name)
A:redis.asyncio.connection.kwargs[name]->parser(value)
A:redis.asyncio.connection.kwargs['username']->unquote(parsed.username)
A:redis.asyncio.connection.kwargs['password']->unquote(parsed.password)
A:redis.asyncio.connection.kwargs['path']->unquote(parsed.path)
A:redis.asyncio.connection.kwargs['host']->unquote(parsed.hostname)
A:redis.asyncio.connection.kwargs['port']->int(parsed.port)
A:redis.asyncio.connection.kwargs['db']->int(unquote(parsed.path).replace('/', ''))
A:redis.asyncio.connection._CP->TypeVar('_CP', bound='ConnectionPool')
A:redis.asyncio.connection.url_options->parse_url(url)
A:redis.asyncio.connection.self.encoder_class->self.connection_kwargs.get('encoder_class', Encoder)
A:redis.asyncio.connection.self._lock->asyncio.Lock()
A:redis.asyncio.connection.self._in_use_connections->weakref.WeakSet()
A:redis.asyncio.connection.connection->super().get_available_connection()
A:redis.asyncio.connection.exc->next((r for r in resp if isinstance(r, BaseException)), None)
A:redis.asyncio.connection.self._condition->asyncio.Condition()
redis.asyncio.BlockingConnectionPool(self,max_connections:int=50,timeout:Optional[int]=20,connection_class:Type[AbstractConnection]=Connection,queue_class:Type[asyncio.Queue]=asyncio.LifoQueue,**connection_kwargs)
redis.asyncio.BlockingConnectionPool.get_connection(self,command_name=None,*keys,**options)
redis.asyncio.BlockingConnectionPool.release(self,connection:AbstractConnection)
redis.asyncio.Connection(self,*,host:str='localhost',port:Union[str,int]=6379,socket_keepalive:bool=False,socket_keepalive_options:Optional[Mapping[int,Union[int,bytes]]]=None,socket_type:int=0,**kwargs)
redis.asyncio.Connection._connect(self)
redis.asyncio.Connection._connection_arguments(self)->Mapping
redis.asyncio.Connection._host_error(self)->str
redis.asyncio.Connection.repr_pieces(self)
redis.asyncio.ConnectionPool(self,connection_class:Type[AbstractConnection]=Connection,max_connections:Optional[int]=None,**connection_kwargs)
redis.asyncio.ConnectionPool.__repr__(self)
redis.asyncio.ConnectionPool._mock(self,error:RedisError)
redis.asyncio.ConnectionPool.aclose(self)->None
redis.asyncio.ConnectionPool.can_get_connection(self)->bool
redis.asyncio.ConnectionPool.disconnect(self,inuse_connections:bool=True)
redis.asyncio.ConnectionPool.ensure_connection(self,connection:AbstractConnection)
redis.asyncio.ConnectionPool.from_url(cls:Type[_CP],url:str,**kwargs)->_CP
redis.asyncio.ConnectionPool.get_available_connection(self)
redis.asyncio.ConnectionPool.get_connection(self,command_name=None,*keys,**options)
redis.asyncio.ConnectionPool.get_encoder(self)
redis.asyncio.ConnectionPool.make_connection(self)
redis.asyncio.ConnectionPool.re_auth_callback(self,token:TokenInterface)
redis.asyncio.ConnectionPool.release(self,connection:AbstractConnection)
redis.asyncio.ConnectionPool.reset(self)
redis.asyncio.ConnectionPool.set_retry(self,retry:'Retry')->None
redis.asyncio.SSLConnection(self,ssl_keyfile:Optional[str]=None,ssl_certfile:Optional[str]=None,ssl_cert_reqs:Union[str,ssl.VerifyMode]='required',ssl_ca_certs:Optional[str]=None,ssl_ca_data:Optional[str]=None,ssl_check_hostname:bool=True,ssl_min_version:Optional[TLSVersion]=None,ssl_ciphers:Optional[str]=None,**kwargs)
redis.asyncio.SSLConnection._connection_arguments(self)->Mapping
redis.asyncio.SSLConnection.ca_certs(self)
redis.asyncio.SSLConnection.ca_data(self)
redis.asyncio.SSLConnection.cert_reqs(self)
redis.asyncio.SSLConnection.certfile(self)
redis.asyncio.SSLConnection.check_hostname(self)
redis.asyncio.SSLConnection.keyfile(self)
redis.asyncio.SSLConnection.min_version(self)
redis.asyncio.UnixDomainSocketConnection(self,*,path:str='',**kwargs)
redis.asyncio.UnixDomainSocketConnection._connect(self)
redis.asyncio.UnixDomainSocketConnection._host_error(self)->str
redis.asyncio.UnixDomainSocketConnection.repr_pieces(self)->Iterable[Tuple[str, Union[str, int]]]
redis.asyncio.connection.AbstractConnection(self,*,db:Union[str,int]=0,password:Optional[str]=None,socket_timeout:Optional[float]=None,socket_connect_timeout:Optional[float]=None,retry_on_timeout:bool=False,retry_on_error:Union[list,_Sentinel]=SENTINEL,encoding:str='utf-8',encoding_errors:str='strict',decode_responses:bool=False,parser_class:Type[BaseParser]=DefaultParser,socket_read_size:int=65536,health_check_interval:float=0,client_name:Optional[str]=None,lib_name:Optional[str]='redis-py',lib_version:Optional[str]=get_lib_version(),username:Optional[str]=None,retry:Optional[Retry]=None,redis_connect_func:Optional[ConnectCallbackT]=None,encoder_class:Type[Encoder]=Encoder,credential_provider:Optional[CredentialProvider]=None,protocol:Optional[int]=2,event_dispatcher:Optional[EventDispatcher]=None)
redis.asyncio.connection.AbstractConnection.__del__(self,_warnings:Any=warnings)
redis.asyncio.connection.AbstractConnection.__init__(self,*,db:Union[str,int]=0,password:Optional[str]=None,socket_timeout:Optional[float]=None,socket_connect_timeout:Optional[float]=None,retry_on_timeout:bool=False,retry_on_error:Union[list,_Sentinel]=SENTINEL,encoding:str='utf-8',encoding_errors:str='strict',decode_responses:bool=False,parser_class:Type[BaseParser]=DefaultParser,socket_read_size:int=65536,health_check_interval:float=0,client_name:Optional[str]=None,lib_name:Optional[str]='redis-py',lib_version:Optional[str]=get_lib_version(),username:Optional[str]=None,retry:Optional[Retry]=None,redis_connect_func:Optional[ConnectCallbackT]=None,encoder_class:Type[Encoder]=Encoder,credential_provider:Optional[CredentialProvider]=None,protocol:Optional[int]=2,event_dispatcher:Optional[EventDispatcher]=None)
redis.asyncio.connection.AbstractConnection.__repr__(self)
redis.asyncio.connection.AbstractConnection._close(self)
redis.asyncio.connection.AbstractConnection._connect(self)
redis.asyncio.connection.AbstractConnection._error_message(self,exception:BaseException)->str
redis.asyncio.connection.AbstractConnection._host_error(self)->str
redis.asyncio.connection.AbstractConnection._ping_failed(self,error)
redis.asyncio.connection.AbstractConnection._send_packed_command(self,command:Iterable[bytes])->None
redis.asyncio.connection.AbstractConnection._send_ping(self)
redis.asyncio.connection.AbstractConnection._socket_is_empty(self)
redis.asyncio.connection.AbstractConnection.can_read_destructive(self)
redis.asyncio.connection.AbstractConnection.check_health(self)
redis.asyncio.connection.AbstractConnection.connect(self)
redis.asyncio.connection.AbstractConnection.connect_check_health(self,check_health:bool=True)
redis.asyncio.connection.AbstractConnection.deregister_connect_callback(self,callback)
redis.asyncio.connection.AbstractConnection.disconnect(self,nowait:bool=False)->None
redis.asyncio.connection.AbstractConnection.get_protocol(self)
redis.asyncio.connection.AbstractConnection.is_connected(self)
redis.asyncio.connection.AbstractConnection.on_connect(self)->None
redis.asyncio.connection.AbstractConnection.on_connect_check_health(self,check_health:bool=True)->None
redis.asyncio.connection.AbstractConnection.pack_command(self,*args:EncodableT)->List[bytes]
redis.asyncio.connection.AbstractConnection.pack_commands(self,commands:Iterable[Iterable[EncodableT]])->List[bytes]
redis.asyncio.connection.AbstractConnection.process_invalidation_messages(self)
redis.asyncio.connection.AbstractConnection.re_auth(self)
redis.asyncio.connection.AbstractConnection.read_response(self,disable_decoding:bool=False,timeout:Optional[float]=None,*,disconnect_on_error:bool=True,push_request:Optional[bool]=False)
redis.asyncio.connection.AbstractConnection.register_connect_callback(self,callback)
redis.asyncio.connection.AbstractConnection.repr_pieces(self)
redis.asyncio.connection.AbstractConnection.send_command(self,*args:Any,**kwargs:Any)->None
redis.asyncio.connection.AbstractConnection.send_packed_command(self,command:Union[bytes,str,Iterable[bytes]],check_health:bool=True)->None
redis.asyncio.connection.AbstractConnection.set_parser(self,parser_class:Type[BaseParser])->None
redis.asyncio.connection.AbstractConnection.set_re_auth_token(self,token:TokenInterface)
redis.asyncio.connection.AsyncConnectCallbackProtocol(self,connection:'AbstractConnection')
redis.asyncio.connection.AsyncConnectCallbackProtocol.__call__(self,connection:'AbstractConnection')
redis.asyncio.connection.BlockingConnectionPool(self,max_connections:int=50,timeout:Optional[int]=20,connection_class:Type[AbstractConnection]=Connection,queue_class:Type[asyncio.Queue]=asyncio.LifoQueue,**connection_kwargs)
redis.asyncio.connection.BlockingConnectionPool.__init__(self,max_connections:int=50,timeout:Optional[int]=20,connection_class:Type[AbstractConnection]=Connection,queue_class:Type[asyncio.Queue]=asyncio.LifoQueue,**connection_kwargs)
redis.asyncio.connection.BlockingConnectionPool.get_connection(self,command_name=None,*keys,**options)
redis.asyncio.connection.BlockingConnectionPool.release(self,connection:AbstractConnection)
redis.asyncio.connection.ConnectCallbackProtocol(self,connection:'AbstractConnection')
redis.asyncio.connection.ConnectCallbackProtocol.__call__(self,connection:'AbstractConnection')
redis.asyncio.connection.ConnectKwargs(TypedDict,total=False)
redis.asyncio.connection.Connection(self,*,host:str='localhost',port:Union[str,int]=6379,socket_keepalive:bool=False,socket_keepalive_options:Optional[Mapping[int,Union[int,bytes]]]=None,socket_type:int=0,**kwargs)
redis.asyncio.connection.Connection.__init__(self,*,host:str='localhost',port:Union[str,int]=6379,socket_keepalive:bool=False,socket_keepalive_options:Optional[Mapping[int,Union[int,bytes]]]=None,socket_type:int=0,**kwargs)
redis.asyncio.connection.Connection._connect(self)
redis.asyncio.connection.Connection._connection_arguments(self)->Mapping
redis.asyncio.connection.Connection._host_error(self)->str
redis.asyncio.connection.Connection.repr_pieces(self)
redis.asyncio.connection.ConnectionPool(self,connection_class:Type[AbstractConnection]=Connection,max_connections:Optional[int]=None,**connection_kwargs)
redis.asyncio.connection.ConnectionPool.__init__(self,connection_class:Type[AbstractConnection]=Connection,max_connections:Optional[int]=None,**connection_kwargs)
redis.asyncio.connection.ConnectionPool.__repr__(self)
redis.asyncio.connection.ConnectionPool._mock(self,error:RedisError)
redis.asyncio.connection.ConnectionPool.aclose(self)->None
redis.asyncio.connection.ConnectionPool.can_get_connection(self)->bool
redis.asyncio.connection.ConnectionPool.disconnect(self,inuse_connections:bool=True)
redis.asyncio.connection.ConnectionPool.ensure_connection(self,connection:AbstractConnection)
redis.asyncio.connection.ConnectionPool.from_url(cls:Type[_CP],url:str,**kwargs)->_CP
redis.asyncio.connection.ConnectionPool.get_available_connection(self)
redis.asyncio.connection.ConnectionPool.get_connection(self,command_name=None,*keys,**options)
redis.asyncio.connection.ConnectionPool.get_encoder(self)
redis.asyncio.connection.ConnectionPool.make_connection(self)
redis.asyncio.connection.ConnectionPool.re_auth_callback(self,token:TokenInterface)
redis.asyncio.connection.ConnectionPool.release(self,connection:AbstractConnection)
redis.asyncio.connection.ConnectionPool.reset(self)
redis.asyncio.connection.ConnectionPool.set_retry(self,retry:'Retry')->None
redis.asyncio.connection.RedisSSLContext(self,keyfile:Optional[str]=None,certfile:Optional[str]=None,cert_reqs:Optional[Union[str,ssl.VerifyMode]]=None,ca_certs:Optional[str]=None,ca_data:Optional[str]=None,check_hostname:bool=False,min_version:Optional[TLSVersion]=None,ciphers:Optional[str]=None)
redis.asyncio.connection.RedisSSLContext.__init__(self,keyfile:Optional[str]=None,certfile:Optional[str]=None,cert_reqs:Optional[Union[str,ssl.VerifyMode]]=None,ca_certs:Optional[str]=None,ca_data:Optional[str]=None,check_hostname:bool=False,min_version:Optional[TLSVersion]=None,ciphers:Optional[str]=None)
redis.asyncio.connection.RedisSSLContext.get(self)->SSLContext
redis.asyncio.connection.SSLConnection(self,ssl_keyfile:Optional[str]=None,ssl_certfile:Optional[str]=None,ssl_cert_reqs:Union[str,ssl.VerifyMode]='required',ssl_ca_certs:Optional[str]=None,ssl_ca_data:Optional[str]=None,ssl_check_hostname:bool=True,ssl_min_version:Optional[TLSVersion]=None,ssl_ciphers:Optional[str]=None,**kwargs)
redis.asyncio.connection.SSLConnection.__init__(self,ssl_keyfile:Optional[str]=None,ssl_certfile:Optional[str]=None,ssl_cert_reqs:Union[str,ssl.VerifyMode]='required',ssl_ca_certs:Optional[str]=None,ssl_ca_data:Optional[str]=None,ssl_check_hostname:bool=True,ssl_min_version:Optional[TLSVersion]=None,ssl_ciphers:Optional[str]=None,**kwargs)
redis.asyncio.connection.SSLConnection._connection_arguments(self)->Mapping
redis.asyncio.connection.SSLConnection.ca_certs(self)
redis.asyncio.connection.SSLConnection.ca_data(self)
redis.asyncio.connection.SSLConnection.cert_reqs(self)
redis.asyncio.connection.SSLConnection.certfile(self)
redis.asyncio.connection.SSLConnection.check_hostname(self)
redis.asyncio.connection.SSLConnection.keyfile(self)
redis.asyncio.connection.SSLConnection.min_version(self)
redis.asyncio.connection.UnixDomainSocketConnection(self,*,path:str='',**kwargs)
redis.asyncio.connection.UnixDomainSocketConnection.__init__(self,*,path:str='',**kwargs)
redis.asyncio.connection.UnixDomainSocketConnection._connect(self)
redis.asyncio.connection.UnixDomainSocketConnection._host_error(self)->str
redis.asyncio.connection.UnixDomainSocketConnection.repr_pieces(self)->Iterable[Tuple[str, Union[str, int]]]
redis.asyncio.connection._Sentinel(enum.Enum)
redis.asyncio.connection.parse_url(url:str)->ConnectKwargs
redis.asyncio.connection.to_bool(value)->Optional[bool]


----------------------------------------/dataset/nuaa/anaconda3/envs/redis6.1.1/lib/python3.9/site-packages/redis/_parsers/resp3.py----------------------------------------
A:redis._parsers.resp3.logger->getLogger('push_response')
A:redis._parsers.resp3.result->self._read_response(disable_decoding=disable_decoding, push_request=push_request)
A:redis._parsers.resp3.raw->self._buffer.readline()
A:redis._parsers.resp3.response->self.encoder.decode(response)
A:redis._parsers.resp3.error->self.parse_error(response)
A:redis._parsers.resp3.key->self._read_response(disable_decoding=disable_decoding)
A:redis._parsers.resp3.resp_dict[key]->self._read_response(disable_decoding=disable_decoding, push_request=push_request)
redis._parsers._AsyncRESP3Parser(self,socket_read_size)
redis._parsers._AsyncRESP3Parser._read_response(self,disable_decoding:bool=False,push_request:bool=False)->Union[EncodableT, ResponseError, None]
redis._parsers._AsyncRESP3Parser.handle_pubsub_push_response(self,response)
redis._parsers._AsyncRESP3Parser.handle_push_response(self,response,disable_decoding,push_request)
redis._parsers._AsyncRESP3Parser.read_response(self,disable_decoding:bool=False,push_request:bool=False)
redis._parsers._AsyncRESP3Parser.set_invalidation_push_handler(self,invalidation_push_handler_func)
redis._parsers._AsyncRESP3Parser.set_pubsub_push_handler(self,pubsub_push_handler_func)
redis._parsers._RESP3Parser(self,socket_read_size)
redis._parsers._RESP3Parser._read_response(self,disable_decoding=False,push_request=False)
redis._parsers._RESP3Parser.handle_pubsub_push_response(self,response)
redis._parsers._RESP3Parser.handle_push_response(self,response,disable_decoding,push_request)
redis._parsers._RESP3Parser.read_response(self,disable_decoding=False,push_request=False)
redis._parsers._RESP3Parser.set_invalidation_push_handler(self,invalidation_push_handler_func)
redis._parsers._RESP3Parser.set_pubsub_push_handler(self,pubsub_push_handler_func)
redis._parsers.resp3._AsyncRESP3Parser(self,socket_read_size)
redis._parsers.resp3._AsyncRESP3Parser.__init__(self,socket_read_size)
redis._parsers.resp3._AsyncRESP3Parser._read_response(self,disable_decoding:bool=False,push_request:bool=False)->Union[EncodableT, ResponseError, None]
redis._parsers.resp3._AsyncRESP3Parser.handle_pubsub_push_response(self,response)
redis._parsers.resp3._AsyncRESP3Parser.handle_push_response(self,response,disable_decoding,push_request)
redis._parsers.resp3._AsyncRESP3Parser.read_response(self,disable_decoding:bool=False,push_request:bool=False)
redis._parsers.resp3._AsyncRESP3Parser.set_invalidation_push_handler(self,invalidation_push_handler_func)
redis._parsers.resp3._AsyncRESP3Parser.set_pubsub_push_handler(self,pubsub_push_handler_func)
redis._parsers.resp3._RESP3Parser(self,socket_read_size)
redis._parsers.resp3._RESP3Parser.__init__(self,socket_read_size)
redis._parsers.resp3._RESP3Parser._read_response(self,disable_decoding=False,push_request=False)
redis._parsers.resp3._RESP3Parser.handle_pubsub_push_response(self,response)
redis._parsers.resp3._RESP3Parser.handle_push_response(self,response,disable_decoding,push_request)
redis._parsers.resp3._RESP3Parser.read_response(self,disable_decoding=False,push_request=False)
redis._parsers.resp3._RESP3Parser.set_invalidation_push_handler(self,invalidation_push_handler_func)
redis._parsers.resp3._RESP3Parser.set_pubsub_push_handler(self,pubsub_push_handler_func)


----------------------------------------/dataset/nuaa/anaconda3/envs/redis6.1.1/lib/python3.9/site-packages/redis/_parsers/__init__.py----------------------------------------


----------------------------------------/dataset/nuaa/anaconda3/envs/redis6.1.1/lib/python3.9/site-packages/redis/_parsers/socket.py----------------------------------------
A:redis._parsers.socket.NONBLOCKING_EXCEPTIONS->tuple(NONBLOCKING_EXCEPTION_ERROR_NUMBERS.keys())
A:redis._parsers.socket.SENTINEL->object()
A:redis._parsers.socket.self._buffer->io.BytesIO()
A:redis._parsers.socket.pos->self._buffer.tell()
A:redis._parsers.socket.end->self._buffer.seek(0, SEEK_END)
A:redis._parsers.socket.current_pos->buf.tell()
A:redis._parsers.socket.data->buf.readline()
A:redis._parsers.socket.data_length->len(data)
A:redis._parsers.socket.allowed->NONBLOCKING_EXCEPTION_ERROR_NUMBERS.get(ex.__class__, -1)
A:redis._parsers.socket.unread->self.unread_bytes()
A:redis._parsers.socket.view->self._buffer.getbuffer()
redis._parsers.socket.SocketBuffer(self,socket:socket.socket,socket_read_size:int,socket_timeout:float)
redis._parsers.socket.SocketBuffer.__init__(self,socket:socket.socket,socket_read_size:int,socket_timeout:float)
redis._parsers.socket.SocketBuffer._read_from_socket(self,length:Optional[int]=None,timeout:Union[float,object]=SENTINEL,raise_on_timeout:Optional[bool]=True)->bool
redis._parsers.socket.SocketBuffer.can_read(self,timeout:float)->bool
redis._parsers.socket.SocketBuffer.close(self)->None
redis._parsers.socket.SocketBuffer.get_pos(self)->int
redis._parsers.socket.SocketBuffer.purge(self)->None
redis._parsers.socket.SocketBuffer.read(self,length:int)->bytes
redis._parsers.socket.SocketBuffer.readline(self)->bytes
redis._parsers.socket.SocketBuffer.rewind(self,pos:int)->None
redis._parsers.socket.SocketBuffer.unread_bytes(self)->int


----------------------------------------/dataset/nuaa/anaconda3/envs/redis6.1.1/lib/python3.9/site-packages/redis/_parsers/helpers.py----------------------------------------
A:redis._parsers.helpers.response->response.splitlines().splitlines()
A:redis._parsers.helpers.response[field]->int(response[field])
A:redis._parsers.helpers.(k, v)->item.rsplit('=', 1)
A:redis._parsers.helpers.sub_dict[k]->get_value(v)
A:redis._parsers.helpers.(key, value)->info.split('=')
A:redis._parsers.helpers.info[key]->get_value(value)
A:redis._parsers.helpers.stats->pairs_to_dict(response, decode_keys=True, decode_string_values=True)
A:redis._parsers.helpers.stats[key]->pairs_to_dict(value, decode_keys=True, decode_string_values=True)
A:redis._parsers.helpers.result->pairs_to_dict_typed(item, SENTINEL_STATE_TYPES)
A:redis._parsers.helpers.flags->set(result['flags'].split(','))
A:redis._parsers.helpers.value->type_info[key](value)
A:redis._parsers.helpers.state->parse_sentinel_state(map(str_if_bytes, item))
A:redis._parsers.helpers.keys->map(str_if_bytes, keys)
A:redis._parsers.helpers.values->map(str_if_bytes, values)
A:redis._parsers.helpers.it->iter(r)
A:redis._parsers.helpers.score_cast_func->options.get('score_cast_func', float)
A:redis._parsers.helpers.response[1]->parse_stream_list(response[1])
A:redis._parsers.helpers.data->bool_ok(response)
A:redis._parsers.helpers.first->bool_ok(response).get('first-entry')
A:redis._parsers.helpers.no_values->options.get('no_values', False)
A:redis._parsers.helpers.result['command']->space.join(item[4])
A:redis._parsers.helpers.line_items->line.split(' ')
A:redis._parsers.helpers.(slots, migrations)->_parse_slots(line_items[8:])
A:redis._parsers.helpers.(slot_id, dst_node_id)->s_range[1:-1].split('->-', 1)
A:redis._parsers.helpers.(slot_id, src_node_id)->s_range[1:-1].split('-<-', 1)
A:redis._parsers.helpers.cmd_name->str_if_bytes(command[0])
A:redis._parsers.helpers.cmd_dict['arity']->int(command[1])
A:redis._parsers.helpers.data['flags']->list(map(str_if_bytes, data['flags']))
A:redis._parsers.helpers.data['passwords']->list(map(str_if_bytes, data['passwords']))
A:redis._parsers.helpers.data['commands']->str_if_bytes(data['commands'])
A:redis._parsers.helpers.data['keys']->list(str_if_bytes(data['keys']).split(' '))
A:redis._parsers.helpers.data['channels']->list(str_if_bytes(data['channels']).split(' '))
A:redis._parsers.helpers.log_data->pairs_to_dict(log, True, True)
A:redis._parsers.helpers.client_info->pairs_to_dict(log, True, True).get('client-info', '')
A:redis._parsers.helpers.log_data['client-info']->parse_client_info(client_info)
A:redis._parsers.helpers.log_data['age-seconds']->float(log_data['age-seconds'])
A:redis._parsers.helpers.client_info[int_key]->int(client_info[int_key])
redis._parsers.helpers._parse_node_line(line)
redis._parsers.helpers._parse_slots(slot_ranges)
redis._parsers.helpers.bool_ok(response,**options)
redis._parsers.helpers.float_or_none(response)
redis._parsers.helpers.pairs_to_dict(response,decode_keys=False,decode_string_values=False)
redis._parsers.helpers.pairs_to_dict_typed(response,type_info)
redis._parsers.helpers.pairs_to_dict_with_str_keys(response)
redis._parsers.helpers.parse_acl_getuser(response,**options)
redis._parsers.helpers.parse_acl_log(response,**options)
redis._parsers.helpers.parse_client_info(value)
redis._parsers.helpers.parse_client_kill(response,**options)
redis._parsers.helpers.parse_client_list(response,**options)
redis._parsers.helpers.parse_cluster_info(response,**options)
redis._parsers.helpers.parse_cluster_nodes(response,**options)
redis._parsers.helpers.parse_command(response,**options)
redis._parsers.helpers.parse_command_resp3(response,**options)
redis._parsers.helpers.parse_config_get(response,**options)
redis._parsers.helpers.parse_debug_object(response)
redis._parsers.helpers.parse_geosearch_generic(response,**options)
redis._parsers.helpers.parse_hscan(response,**options)
redis._parsers.helpers.parse_info(response)
redis._parsers.helpers.parse_list_of_dicts(response)
redis._parsers.helpers.parse_memory_stats(response,**kwargs)
redis._parsers.helpers.parse_pubsub_numsub(response,**options)
redis._parsers.helpers.parse_scan(response,**options)
redis._parsers.helpers.parse_sentinel_get_master(response)
redis._parsers.helpers.parse_sentinel_master(response)
redis._parsers.helpers.parse_sentinel_masters(response)
redis._parsers.helpers.parse_sentinel_masters_resp3(response)
redis._parsers.helpers.parse_sentinel_slaves_and_sentinels(response)
redis._parsers.helpers.parse_sentinel_slaves_and_sentinels_resp3(response)
redis._parsers.helpers.parse_sentinel_state(item)
redis._parsers.helpers.parse_sentinel_state_resp3(response)
redis._parsers.helpers.parse_set_result(response,**options)
redis._parsers.helpers.parse_slowlog_get(response,**options)
redis._parsers.helpers.parse_stralgo(response,**options)
redis._parsers.helpers.parse_stream_list(response)
redis._parsers.helpers.parse_xautoclaim(response,**options)
redis._parsers.helpers.parse_xclaim(response,**options)
redis._parsers.helpers.parse_xinfo_stream(response,**options)
redis._parsers.helpers.parse_xpending(response,**options)
redis._parsers.helpers.parse_xpending_range(response)
redis._parsers.helpers.parse_xread(response)
redis._parsers.helpers.parse_xread_resp3(response)
redis._parsers.helpers.parse_zadd(response,**options)
redis._parsers.helpers.parse_zmscore(response,**options)
redis._parsers.helpers.parse_zscan(response,**options)
redis._parsers.helpers.sort_return_tuples(response,**options)
redis._parsers.helpers.string_keys_to_dict(key_string,callback)
redis._parsers.helpers.timestamp_to_datetime(response)
redis._parsers.helpers.zset_score_pairs(response,**options)


----------------------------------------/dataset/nuaa/anaconda3/envs/redis6.1.1/lib/python3.9/site-packages/redis/_parsers/resp2.py----------------------------------------
A:redis._parsers.resp2.result->self._read_response(disable_decoding=disable_decoding)
A:redis._parsers.resp2.raw->self._buffer.readline()
A:redis._parsers.resp2.response->self.encoder.decode(response)
A:redis._parsers.resp2.error->self.parse_error(response)
redis._parsers._AsyncRESP2Parser(_AsyncRESPBase)
redis._parsers._AsyncRESP2Parser._read_response(self,disable_decoding:bool=False)->Union[EncodableT, ResponseError, None]
redis._parsers._AsyncRESP2Parser.read_response(self,disable_decoding:bool=False)
redis._parsers._RESP2Parser(_RESPBase)
redis._parsers._RESP2Parser._read_response(self,disable_decoding=False)
redis._parsers._RESP2Parser.read_response(self,disable_decoding=False)
redis._parsers.resp2._AsyncRESP2Parser(_AsyncRESPBase)
redis._parsers.resp2._AsyncRESP2Parser._read_response(self,disable_decoding:bool=False)->Union[EncodableT, ResponseError, None]
redis._parsers.resp2._AsyncRESP2Parser.read_response(self,disable_decoding:bool=False)
redis._parsers.resp2._RESP2Parser(_RESPBase)
redis._parsers.resp2._RESP2Parser._read_response(self,disable_decoding=False)
redis._parsers.resp2._RESP2Parser.read_response(self,disable_decoding=False)


----------------------------------------/dataset/nuaa/anaconda3/envs/redis6.1.1/lib/python3.9/site-packages/redis/_parsers/commands.py----------------------------------------
A:redis._parsers.commands.command->self.parse_subcommand(subcmd)
A:redis._parsers.commands.pubsub_type->args[1].upper()
A:redis._parsers.commands.keys->self._get_pubsub_keys(*args)
A:redis._parsers.commands.cmd_name->args[0].lower()
A:redis._parsers.commands.cmd_dict['arity']->int(command[1])
A:redis._parsers.commands.commands->r.command()
A:redis._parsers.commands.commands[cmd.lower()]->r.command().pop(cmd)
A:redis._parsers.commands.cmd_name_split->args[0].lower().split()
A:redis._parsers.commands.keys_pos->list(range(command['first_key_pos'], last_key_pos + 1, command['step_count']))
A:redis._parsers.commands.message->e.__str__()
redis._parsers.AsyncCommandsParser(self)
redis._parsers.AsyncCommandsParser._get_moveable_keys(self,*args:Any)->Optional[Tuple[str, ...]]
redis._parsers.AsyncCommandsParser.get_keys(self,*args:Any)->Optional[Tuple[str, ...]]
redis._parsers.AsyncCommandsParser.initialize(self,node:Optional['ClusterNode']=None)->None
redis._parsers.CommandsParser(self,redis_connection)
redis._parsers.CommandsParser._get_moveable_keys(self,redis_conn,*args)
redis._parsers.CommandsParser.get_keys(self,redis_conn,*args)
redis._parsers.CommandsParser.initialize(self,r)
redis._parsers.commands.AbstractCommandsParser
redis._parsers.commands.AbstractCommandsParser._get_pubsub_keys(self,*args)
redis._parsers.commands.AbstractCommandsParser.parse_subcommand(self,command,**options)
redis._parsers.commands.AsyncCommandsParser(self)
redis._parsers.commands.AsyncCommandsParser.__init__(self)
redis._parsers.commands.AsyncCommandsParser._get_moveable_keys(self,*args:Any)->Optional[Tuple[str, ...]]
redis._parsers.commands.AsyncCommandsParser.get_keys(self,*args:Any)->Optional[Tuple[str, ...]]
redis._parsers.commands.AsyncCommandsParser.initialize(self,node:Optional['ClusterNode']=None)->None
redis._parsers.commands.CommandsParser(self,redis_connection)
redis._parsers.commands.CommandsParser.__init__(self,redis_connection)
redis._parsers.commands.CommandsParser._get_moveable_keys(self,redis_conn,*args)
redis._parsers.commands.CommandsParser.get_keys(self,redis_conn,*args)
redis._parsers.commands.CommandsParser.initialize(self,r)


----------------------------------------/dataset/nuaa/anaconda3/envs/redis6.1.1/lib/python3.9/site-packages/redis/_parsers/encoders.py----------------------------------------
A:redis._parsers.encoders.value->value.decode(self.encoding, self.encoding_errors).decode(self.encoding, self.encoding_errors)
redis._parsers.Encoder(self,encoding,encoding_errors,decode_responses)
redis._parsers.Encoder.decode(self,value,force=False)
redis._parsers.Encoder.encode(self,value)
redis._parsers.encoders.Encoder(self,encoding,encoding_errors,decode_responses)
redis._parsers.encoders.Encoder.__init__(self,encoding,encoding_errors,decode_responses)
redis._parsers.encoders.Encoder.decode(self,value,force=False)
redis._parsers.encoders.Encoder.encode(self,value)


----------------------------------------/dataset/nuaa/anaconda3/envs/redis6.1.1/lib/python3.9/site-packages/redis/_parsers/base.py----------------------------------------
A:redis._parsers.base.exception_class->exception_class.get(response, ResponseError).get(response, ResponseError)
A:redis._parsers.base.self._buffer->SocketBuffer(self._sock, self.socket_read_size, connection.socket_timeout)
A:redis._parsers.base.found->self._buffer.find(b'\r\n', self._pos)
redis._parsers.BaseParser(ABC)
redis._parsers.BaseParser.on_connect(self,connection)
redis._parsers.BaseParser.on_disconnect(self)
redis._parsers.BaseParser.parse_error(cls,response)
redis._parsers._AsyncRESPBase(self,socket_read_size:int)
redis._parsers._AsyncRESPBase._clear(self)
redis._parsers._AsyncRESPBase._read(self,length:int)->bytes
redis._parsers._AsyncRESPBase._readline(self)->bytes
redis._parsers._AsyncRESPBase.can_read_destructive(self)->bool
redis._parsers._AsyncRESPBase.on_connect(self,connection)
redis._parsers._AsyncRESPBase.on_disconnect(self)
redis._parsers.base.AsyncBaseParser(self,socket_read_size:int)
redis._parsers.base.AsyncBaseParser.__init__(self,socket_read_size:int)
redis._parsers.base.AsyncBaseParser.can_read_destructive(self)->bool
redis._parsers.base.AsyncBaseParser.read_response(self,disable_decoding:bool=False)->Union[EncodableT, ResponseError, None, List[EncodableT]]
redis._parsers.base.BaseParser(ABC)
redis._parsers.base.BaseParser.on_connect(self,connection)
redis._parsers.base.BaseParser.on_disconnect(self)
redis._parsers.base.BaseParser.parse_error(cls,response)
redis._parsers.base._AsyncRESPBase(self,socket_read_size:int)
redis._parsers.base._AsyncRESPBase.__init__(self,socket_read_size:int)
redis._parsers.base._AsyncRESPBase._clear(self)
redis._parsers.base._AsyncRESPBase._read(self,length:int)->bytes
redis._parsers.base._AsyncRESPBase._readline(self)->bytes
redis._parsers.base._AsyncRESPBase.can_read_destructive(self)->bool
redis._parsers.base._AsyncRESPBase.on_connect(self,connection)
redis._parsers.base._AsyncRESPBase.on_disconnect(self)
redis._parsers.base._RESPBase(self,socket_read_size)
redis._parsers.base._RESPBase.__del__(self)
redis._parsers.base._RESPBase.__init__(self,socket_read_size)
redis._parsers.base._RESPBase.can_read(self,timeout)
redis._parsers.base._RESPBase.on_connect(self,connection)
redis._parsers.base._RESPBase.on_disconnect(self)


----------------------------------------/dataset/nuaa/anaconda3/envs/redis6.1.1/lib/python3.9/site-packages/redis/_parsers/hiredis.py----------------------------------------
A:redis._parsers.hiredis.NOT_ENOUGH_DATA->object()
A:redis._parsers.hiredis.self._buffer->bytearray(socket_read_size)
A:redis._parsers.hiredis.self._reader->hiredis.Reader(**kwargs)
A:redis._parsers.hiredis.self._next_response->self._reader.gets()
A:redis._parsers.hiredis.bufflen->self._sock.recv_into(self._buffer)
A:redis._parsers.hiredis.allowed->socket.NONBLOCKING_EXCEPTION_ERROR_NUMBERS.get(ex.__class__, -1)
A:redis._parsers.hiredis.response->self._reader.gets()
redis._parsers._AsyncHiredisParser(self,socket_read_size:int)
redis._parsers._AsyncHiredisParser.can_read_destructive(self)
redis._parsers._AsyncHiredisParser.on_connect(self,connection)
redis._parsers._AsyncHiredisParser.on_disconnect(self)
redis._parsers._AsyncHiredisParser.read_from_socket(self)
redis._parsers._AsyncHiredisParser.read_response(self,disable_decoding:bool=False)->Union[EncodableT, List[EncodableT]]
redis._parsers._HiredisParser(self,socket_read_size)
redis._parsers._HiredisParser.__del__(self)
redis._parsers._HiredisParser.can_read(self,timeout)
redis._parsers._HiredisParser.on_connect(self,connection,**kwargs)
redis._parsers._HiredisParser.on_disconnect(self)
redis._parsers._HiredisParser.read_from_socket(self,timeout=SENTINEL,raise_on_timeout=True)
redis._parsers._HiredisParser.read_response(self,disable_decoding=False)
redis._parsers.hiredis._AsyncHiredisParser(self,socket_read_size:int)
redis._parsers.hiredis._AsyncHiredisParser.__init__(self,socket_read_size:int)
redis._parsers.hiredis._AsyncHiredisParser.can_read_destructive(self)
redis._parsers.hiredis._AsyncHiredisParser.on_connect(self,connection)
redis._parsers.hiredis._AsyncHiredisParser.on_disconnect(self)
redis._parsers.hiredis._AsyncHiredisParser.read_from_socket(self)
redis._parsers.hiredis._AsyncHiredisParser.read_response(self,disable_decoding:bool=False)->Union[EncodableT, List[EncodableT]]
redis._parsers.hiredis._HiredisParser(self,socket_read_size)
redis._parsers.hiredis._HiredisParser.__del__(self)
redis._parsers.hiredis._HiredisParser.__init__(self,socket_read_size)
redis._parsers.hiredis._HiredisParser.can_read(self,timeout)
redis._parsers.hiredis._HiredisParser.on_connect(self,connection,**kwargs)
redis._parsers.hiredis._HiredisParser.on_disconnect(self)
redis._parsers.hiredis._HiredisParser.read_from_socket(self,timeout=SENTINEL,raise_on_timeout=True)
redis._parsers.hiredis._HiredisParser.read_response(self,disable_decoding=False)
redis._parsers.hiredis._HiredisReaderArgs(TypedDict,total=False)


----------------------------------------/dataset/nuaa/anaconda3/envs/redis6.1.1/lib/python3.9/site-packages/redis/auth/token_manager.py----------------------------------------
A:redis.auth.token_manager.logger->logging.getLogger(__name__)
A:redis.auth.token_manager.loop->asyncio.get_running_loop()
A:redis.auth.token_manager.thread->threading.Thread(target=_start_event_loop_in_thread, args=(loop,), daemon=True)
A:redis.auth.token_manager.init_event->asyncio.Event()
A:redis.auth.token_manager.self._init_timer->asyncio.get_running_loop().call_later(initial_delay_in_ms / 1000, wrapped)
A:redis.auth.token_manager.wrapped->_async_to_sync_wrapper(loop, self._renew_token_async)
A:redis.auth.token_manager.token->self._idp.request_token(force_refresh)
A:redis.auth.token_manager.delay_for_lower_refresh->self._delay_for_lower_refresh(expire_date)
A:redis.auth.token_manager.delay_for_ratio_refresh->self._delay_for_ratio_refresh(expire_date, issue_date)
A:redis.auth.token_manager.delay->self._calculate_renewal_delay(token_res.get_token().get_expires_at_ms(), token_res.get_token().get_received_at_ms())
A:redis.auth.token_manager.token_res->self.acquire_token(force_refresh=True)
A:redis.auth.token_manager.self._next_timer->asyncio.get_running_loop().call_later(delay, self._renew_token)
redis.auth.token_manager.CredentialsListener(self)
redis.auth.token_manager.CredentialsListener.__init__(self)
redis.auth.token_manager.CredentialsListener.on_error(self)->Union[Callable[[Exception], None], Awaitable]
redis.auth.token_manager.CredentialsListener.on_error(self,callback:Union[Callable[[Exception],None],Awaitable])->None
redis.auth.token_manager.CredentialsListener.on_next(self)->Union[Callable[[Any], None], Awaitable]
redis.auth.token_manager.CredentialsListener.on_next(self,callback:Union[Callable[[Any],None],Awaitable])->None
redis.auth.token_manager.RetryPolicy(self,max_attempts:int,delay_in_ms:float)
redis.auth.token_manager.RetryPolicy.__init__(self,max_attempts:int,delay_in_ms:float)
redis.auth.token_manager.RetryPolicy.get_delay_in_ms(self)->float
redis.auth.token_manager.RetryPolicy.get_max_attempts(self)->int
redis.auth.token_manager.TokenManager(self,identity_provider:IdentityProviderInterface,config:TokenManagerConfig)
redis.auth.token_manager.TokenManager.__del__(self)
redis.auth.token_manager.TokenManager.__init__(self,identity_provider:IdentityProviderInterface,config:TokenManagerConfig)
redis.auth.token_manager.TokenManager._calculate_renewal_delay(self,expire_date:float,issue_date:float)->float
redis.auth.token_manager.TokenManager._delay_for_lower_refresh(self,expire_date:float)
redis.auth.token_manager.TokenManager._delay_for_ratio_refresh(self,expire_date:float,issue_date:float)
redis.auth.token_manager.TokenManager._renew_token(self,skip_initial:bool=False,init_event:asyncio.Event=None)
redis.auth.token_manager.TokenManager._renew_token_async(self,skip_initial:bool=False,init_event:asyncio.Event=None)
redis.auth.token_manager.TokenManager.acquire_token(self,force_refresh=False)->TokenResponse
redis.auth.token_manager.TokenManager.acquire_token_async(self,force_refresh=False)->TokenResponse
redis.auth.token_manager.TokenManager.start(self,listener:CredentialsListener,skip_initial:bool=False)->Callable[[], None]
redis.auth.token_manager.TokenManager.start_async(self,listener:CredentialsListener,block_for_initial:bool=False,initial_delay_in_ms:float=0,skip_initial:bool=False)->Callable[[], None]
redis.auth.token_manager.TokenManager.stop(self)
redis.auth.token_manager.TokenManagerConfig(self,expiration_refresh_ratio:float,lower_refresh_bound_millis:int,token_request_execution_timeout_in_ms:int,retry_policy:RetryPolicy)
redis.auth.token_manager.TokenManagerConfig.__init__(self,expiration_refresh_ratio:float,lower_refresh_bound_millis:int,token_request_execution_timeout_in_ms:int,retry_policy:RetryPolicy)
redis.auth.token_manager.TokenManagerConfig.get_expiration_refresh_ratio(self)->float
redis.auth.token_manager.TokenManagerConfig.get_lower_refresh_bound_millis(self)->int
redis.auth.token_manager.TokenManagerConfig.get_retry_policy(self)->RetryPolicy
redis.auth.token_manager.TokenManagerConfig.get_token_request_execution_timeout_in_ms(self)->int
redis.auth.token_manager._async_to_sync_wrapper(loop,coro_func,*args,**kwargs)
redis.auth.token_manager._start_event_loop_in_thread(event_loop:asyncio.AbstractEventLoop)


----------------------------------------/dataset/nuaa/anaconda3/envs/redis6.1.1/lib/python3.9/site-packages/redis/auth/__init__.py----------------------------------------


----------------------------------------/dataset/nuaa/anaconda3/envs/redis6.1.1/lib/python3.9/site-packages/redis/auth/err.py----------------------------------------
redis.auth.err.InvalidTokenSchemaErr(self,missing_fields:Iterable[str]=[])
redis.auth.err.InvalidTokenSchemaErr.__init__(self,missing_fields:Iterable[str]=[])
redis.auth.err.RequestTokenErr(self,*args)
redis.auth.err.RequestTokenErr.__init__(self,*args)
redis.auth.err.TokenRenewalErr(self,*args)
redis.auth.err.TokenRenewalErr.__init__(self,*args)


----------------------------------------/dataset/nuaa/anaconda3/envs/redis6.1.1/lib/python3.9/site-packages/redis/auth/idp.py----------------------------------------
redis.auth.idp.IdentityProviderConfigInterface(ABC)
redis.auth.idp.IdentityProviderConfigInterface.get_provider(self)->IdentityProviderInterface
redis.auth.idp.IdentityProviderInterface(ABC)
redis.auth.idp.IdentityProviderInterface.request_token(self,force_refresh=False)->TokenInterface


----------------------------------------/dataset/nuaa/anaconda3/envs/redis6.1.1/lib/python3.9/site-packages/redis/auth/token.py----------------------------------------
A:redis.auth.token.self._decoded->jwt.decode(self._value, options={'verify_signature': False}, algorithms=[jwt.get_unverified_header(self._value).get('alg')])
redis.auth.token.JWToken(self,token:str)
redis.auth.token.JWToken.__init__(self,token:str)
redis.auth.token.JWToken._validate_token(self)
redis.auth.token.JWToken.get_expires_at_ms(self)->float
redis.auth.token.JWToken.get_received_at_ms(self)->float
redis.auth.token.JWToken.get_value(self)->str
redis.auth.token.JWToken.is_expired(self)->bool
redis.auth.token.JWToken.try_get(self,key:str)->str
redis.auth.token.JWToken.ttl(self)->float
redis.auth.token.SimpleToken(self,value:str,expires_at_ms:float,received_at_ms:float,claims:dict)
redis.auth.token.SimpleToken.__init__(self,value:str,expires_at_ms:float,received_at_ms:float,claims:dict)
redis.auth.token.SimpleToken.get_expires_at_ms(self)->float
redis.auth.token.SimpleToken.get_received_at_ms(self)->float
redis.auth.token.SimpleToken.get_value(self)->str
redis.auth.token.SimpleToken.is_expired(self)->bool
redis.auth.token.SimpleToken.try_get(self,key:str)->str
redis.auth.token.SimpleToken.ttl(self)->float
redis.auth.token.TokenInterface(ABC)
redis.auth.token.TokenInterface.get_expires_at_ms(self)->float
redis.auth.token.TokenInterface.get_received_at_ms(self)->float
redis.auth.token.TokenInterface.get_value(self)->str
redis.auth.token.TokenInterface.is_expired(self)->bool
redis.auth.token.TokenInterface.try_get(self,key:str)->str
redis.auth.token.TokenInterface.ttl(self)->float
redis.auth.token.TokenResponse(self,token:TokenInterface)
redis.auth.token.TokenResponse.__init__(self,token:TokenInterface)
redis.auth.token.TokenResponse.get_token(self)->TokenInterface
redis.auth.token.TokenResponse.get_ttl_ms(self)->float


----------------------------------------/dataset/nuaa/anaconda3/envs/redis6.1.1/lib/python3.9/site-packages/redis/commands/__init__.py----------------------------------------


----------------------------------------/dataset/nuaa/anaconda3/envs/redis6.1.1/lib/python3.9/site-packages/redis/commands/helpers.py----------------------------------------
A:redis.commands.helpers.keys->list(keys)
A:redis.commands.helpers.item_str->nativestr(item)
A:redis.commands.helpers.res[response[i]]->float(response[i + 1])
A:redis.commands.helpers.newobj->copy.copy(obj)
redis.commands.helpers.decode_dict_keys(obj)
redis.commands.helpers.delist(x)
redis.commands.helpers.get_protocol_version(client)
redis.commands.helpers.list_or_args(keys:KeysT,args:Tuple[KeyT,...])->List[KeyT]
redis.commands.helpers.nativestr(x)
redis.commands.helpers.parse_list_to_dict(response)
redis.commands.helpers.parse_to_list(response)
redis.commands.helpers.random_string(length=10)
redis.commands.list_or_args(keys:KeysT,args:Tuple[KeyT,...])->List[KeyT]


----------------------------------------/dataset/nuaa/anaconda3/envs/redis6.1.1/lib/python3.9/site-packages/redis/commands/core.py----------------------------------------
A:redis.commands.core.b->int(bits)
A:redis.commands.core.encoder->registered_client.get_encoder()
A:redis.commands.core.passwords->list_or_args(passwords, [])
A:redis.commands.core.password->registered_client.get_encoder().encode(password)
A:redis.commands.core.hashed_passwords->list_or_args(hashed_passwords, [])
A:redis.commands.core.hashed_password->registered_client.get_encoder().encode(hashed_password)
A:redis.commands.core.category->registered_client.get_encoder().encode(category)
A:redis.commands.core.cmd->registered_client.get_encoder().encode(cmd)
A:redis.commands.core.key->registered_client.get_encoder().encode(key)
A:redis.commands.core.channel->registered_client.get_encoder().encode(channel)
A:redis.commands.core.keys->list_or_args(keys, None)
A:redis.commands.core.decode_responses->self.get_connection_kwargs().get('decode_responses', False)
A:redis.commands.core.overflow->overflow.upper().upper()
A:redis.commands.core.time->int(time.total_seconds())
A:redis.commands.core.exp_option->list()
A:redis.commands.core.when->int(when.timestamp() * 1000)
A:redis.commands.core.value->self.get(name)
A:redis.commands.core.args->list_or_args(keys, args)
A:redis.commands.core.time_ms->int(time_ms.total_seconds() * 1000)
A:redis.commands.core.supported_algos_str->', '.join(supported_algo)
A:redis.commands.core.(cursor, data)->self.zscan(name, cursor=cursor, match=match, count=count, score_cast_func=score_cast_func)
A:redis.commands.core.(keys, values)->zip(*streams.items())
A:redis.commands.core.seconds->int(seconds.total_seconds())
A:redis.commands.core.milliseconds->int(milliseconds.total_seconds() * 1000)
A:redis.commands.core.unix_time_seconds->int(unix_time_seconds.timestamp())
A:redis.commands.core.unix_time_milliseconds->int(unix_time_milliseconds.timestamp() * 1000)
A:redis.commands.core.script->registered_client.get_encoder().encode(script)
A:redis.commands.core.self.sha->hashlib.sha1(script).hexdigest()
A:redis.commands.core.pieces->list(args)
redis.commands.AsyncCoreCommands(AsyncACLCommands,AsyncClusterCommands,AsyncDataAccessCommands,AsyncManagementCommands,AsyncModuleCommands,AsyncPubSubCommands,AsyncScriptCommands,AsyncFunctionCommands)
redis.commands.CoreCommands(ACLCommands,ClusterCommands,DataAccessCommands,ManagementCommands,ModuleCommands,PubSubCommands,ScriptCommands,FunctionCommands)
redis.commands.core.ACLCommands(CommandsProtocol)
redis.commands.core.ACLCommands.acl_cat(self,category:Optional[str]=None,**kwargs)->ResponseT
redis.commands.core.ACLCommands.acl_deluser(self,*username:str,**kwargs)->ResponseT
redis.commands.core.ACLCommands.acl_dryrun(self,username,*args,**kwargs)
redis.commands.core.ACLCommands.acl_genpass(self,bits:Optional[int]=None,**kwargs)->ResponseT
redis.commands.core.ACLCommands.acl_getuser(self,username:str,**kwargs)->ResponseT
redis.commands.core.ACLCommands.acl_help(self,**kwargs)->ResponseT
redis.commands.core.ACLCommands.acl_list(self,**kwargs)->ResponseT
redis.commands.core.ACLCommands.acl_load(self,**kwargs)->ResponseT
redis.commands.core.ACLCommands.acl_log(self,count:Optional[int]=None,**kwargs)->ResponseT
redis.commands.core.ACLCommands.acl_log_reset(self,**kwargs)->ResponseT
redis.commands.core.ACLCommands.acl_save(self,**kwargs)->ResponseT
redis.commands.core.ACLCommands.acl_setuser(self,username:str,enabled:bool=False,nopass:bool=False,passwords:Optional[Union[str,Iterable[str]]]=None,hashed_passwords:Optional[Union[str,Iterable[str]]]=None,categories:Optional[Iterable[str]]=None,commands:Optional[Iterable[str]]=None,keys:Optional[Iterable[KeyT]]=None,channels:Optional[Iterable[ChannelT]]=None,selectors:Optional[Iterable[Tuple[str,KeyT]]]=None,reset:bool=False,reset_keys:bool=False,reset_channels:bool=False,reset_passwords:bool=False,**kwargs)->ResponseT
redis.commands.core.ACLCommands.acl_users(self,**kwargs)->ResponseT
redis.commands.core.ACLCommands.acl_whoami(self,**kwargs)->ResponseT
redis.commands.core.AsyncBasicKeyCommands(BasicKeyCommands)
redis.commands.core.AsyncBasicKeyCommands.__contains__(self,name:KeyT)
redis.commands.core.AsyncBasicKeyCommands.__delitem__(self,name:KeyT)
redis.commands.core.AsyncBasicKeyCommands.__getitem__(self,name:KeyT)
redis.commands.core.AsyncBasicKeyCommands.__setitem__(self,name:KeyT,value:EncodableT)
redis.commands.core.AsyncBasicKeyCommands.unwatch(self)->None
redis.commands.core.AsyncBasicKeyCommands.watch(self,*names:KeyT)->None
redis.commands.core.AsyncCoreCommands(AsyncACLCommands,AsyncClusterCommands,AsyncDataAccessCommands,AsyncManagementCommands,AsyncModuleCommands,AsyncPubSubCommands,AsyncScriptCommands,AsyncFunctionCommands)
redis.commands.core.AsyncDataAccessCommands(AsyncBasicKeyCommands,AsyncHyperlogCommands,AsyncHashCommands,AsyncGeoCommands,AsyncListCommands,AsyncScanCommands,AsyncSetCommands,AsyncStreamCommands,AsyncSortedSetCommands)
redis.commands.core.AsyncManagementCommands(ManagementCommands)
redis.commands.core.AsyncManagementCommands.command_info(self,**kwargs)->None
redis.commands.core.AsyncManagementCommands.debug_segfault(self,**kwargs)->None
redis.commands.core.AsyncManagementCommands.memory_doctor(self,**kwargs)->None
redis.commands.core.AsyncManagementCommands.memory_help(self,**kwargs)->None
redis.commands.core.AsyncManagementCommands.shutdown(self,save:bool=False,nosave:bool=False,now:bool=False,force:bool=False,abort:bool=False,**kwargs)->None
redis.commands.core.AsyncModuleCommands(ModuleCommands)
redis.commands.core.AsyncModuleCommands.command_info(self)->None
redis.commands.core.AsyncScanCommands(ScanCommands)
redis.commands.core.AsyncScanCommands.hscan_iter(self,name:str,match:Union[PatternT,None]=None,count:Optional[int]=None,no_values:Union[bool,None]=None)->AsyncIterator
redis.commands.core.AsyncScanCommands.scan_iter(self,match:Union[PatternT,None]=None,count:Optional[int]=None,_type:Optional[str]=None,**kwargs)->AsyncIterator
redis.commands.core.AsyncScanCommands.sscan_iter(self,name:KeyT,match:Union[PatternT,None]=None,count:Optional[int]=None)->AsyncIterator
redis.commands.core.AsyncScanCommands.zscan_iter(self,name:KeyT,match:Union[PatternT,None]=None,count:Optional[int]=None,score_cast_func:Union[type,Callable]=float)->AsyncIterator
redis.commands.core.AsyncScript(self,registered_client:'redis.asyncio.client.Redis',script:ScriptTextT)
redis.commands.core.AsyncScript.__init__(self,registered_client:'redis.asyncio.client.Redis',script:ScriptTextT)
redis.commands.core.AsyncScriptCommands(ScriptCommands)
redis.commands.core.AsyncScriptCommands.register_script(self:'redis.asyncio.client.Redis',script:ScriptTextT)->AsyncScript
redis.commands.core.AsyncScriptCommands.script_debug(self,*args)->None
redis.commands.core.BasicKeyCommands(CommandsProtocol)
redis.commands.core.BasicKeyCommands.__delitem__(self,name:KeyT)
redis.commands.core.BasicKeyCommands.__getitem__(self,name:KeyT)
redis.commands.core.BasicKeyCommands.__setitem__(self,name:KeyT,value:EncodableT)
redis.commands.core.BasicKeyCommands.append(self,key:KeyT,value:EncodableT)->ResponseT
redis.commands.core.BasicKeyCommands.bitcount(self,key:KeyT,start:Optional[int]=None,end:Optional[int]=None,mode:Optional[str]=None)->ResponseT
redis.commands.core.BasicKeyCommands.bitfield(self:Union['redis.client.Redis','redis.asyncio.client.Redis'],key:KeyT,default_overflow:Optional[str]=None)->BitFieldOperation
redis.commands.core.BasicKeyCommands.bitfield_ro(self:Union['redis.client.Redis','redis.asyncio.client.Redis'],key:KeyT,encoding:str,offset:BitfieldOffsetT,items:Optional[list]=None)->ResponseT
redis.commands.core.BasicKeyCommands.bitop(self,operation:str,dest:KeyT,*keys:KeyT)->ResponseT
redis.commands.core.BasicKeyCommands.bitpos(self,key:KeyT,bit:int,start:Optional[int]=None,end:Optional[int]=None,mode:Optional[str]=None)->ResponseT
redis.commands.core.BasicKeyCommands.blmove(self,first_list:str,second_list:str,timeout:int,src:str='LEFT',dest:str='RIGHT')->ResponseT
redis.commands.core.BasicKeyCommands.copy(self,source:str,destination:str,destination_db:Optional[str]=None,replace:bool=False)->ResponseT
redis.commands.core.BasicKeyCommands.decrby(self,name:KeyT,amount:int=1)->ResponseT
redis.commands.core.BasicKeyCommands.delete(self,*names:KeyT)->ResponseT
redis.commands.core.BasicKeyCommands.dump(self,name:KeyT)->ResponseT
redis.commands.core.BasicKeyCommands.exists(self,*names:KeyT)->ResponseT
redis.commands.core.BasicKeyCommands.expire(self,name:KeyT,time:ExpiryT,nx:bool=False,xx:bool=False,gt:bool=False,lt:bool=False)->ResponseT
redis.commands.core.BasicKeyCommands.expireat(self,name:KeyT,when:AbsExpiryT,nx:bool=False,xx:bool=False,gt:bool=False,lt:bool=False)->ResponseT
redis.commands.core.BasicKeyCommands.expiretime(self,key:str)->int
redis.commands.core.BasicKeyCommands.get(self,name:KeyT)->ResponseT
redis.commands.core.BasicKeyCommands.getbit(self,name:KeyT,offset:int)->ResponseT
redis.commands.core.BasicKeyCommands.getdel(self,name:KeyT)->ResponseT
redis.commands.core.BasicKeyCommands.getex(self,name:KeyT,ex:Optional[ExpiryT]=None,px:Optional[ExpiryT]=None,exat:Optional[AbsExpiryT]=None,pxat:Optional[AbsExpiryT]=None,persist:bool=False)->ResponseT
redis.commands.core.BasicKeyCommands.getrange(self,key:KeyT,start:int,end:int)->ResponseT
redis.commands.core.BasicKeyCommands.getset(self,name:KeyT,value:EncodableT)->ResponseT
redis.commands.core.BasicKeyCommands.hrandfield(self,key:str,count:Optional[int]=None,withvalues:bool=False)->ResponseT
redis.commands.core.BasicKeyCommands.incrby(self,name:KeyT,amount:int=1)->ResponseT
redis.commands.core.BasicKeyCommands.incrbyfloat(self,name:KeyT,amount:float=1.0)->ResponseT
redis.commands.core.BasicKeyCommands.keys(self,pattern:PatternT='*',**kwargs)->ResponseT
redis.commands.core.BasicKeyCommands.lcs(self,key1:str,key2:str,len:Optional[bool]=False,idx:Optional[bool]=False,minmatchlen:Optional[int]=0,withmatchlen:Optional[bool]=False)->Union[str, int, list]
redis.commands.core.BasicKeyCommands.lmove(self,first_list:str,second_list:str,src:str='LEFT',dest:str='RIGHT')->ResponseT
redis.commands.core.BasicKeyCommands.mget(self,keys:KeysT,*args:EncodableT)->ResponseT
redis.commands.core.BasicKeyCommands.move(self,name:KeyT,db:int)->ResponseT
redis.commands.core.BasicKeyCommands.mset(self,mapping:Mapping[AnyKeyT,EncodableT])->ResponseT
redis.commands.core.BasicKeyCommands.msetnx(self,mapping:Mapping[AnyKeyT,EncodableT])->ResponseT
redis.commands.core.BasicKeyCommands.persist(self,name:KeyT)->ResponseT
redis.commands.core.BasicKeyCommands.pexpire(self,name:KeyT,time:ExpiryT,nx:bool=False,xx:bool=False,gt:bool=False,lt:bool=False)->ResponseT
redis.commands.core.BasicKeyCommands.pexpireat(self,name:KeyT,when:AbsExpiryT,nx:bool=False,xx:bool=False,gt:bool=False,lt:bool=False)->ResponseT
redis.commands.core.BasicKeyCommands.pexpiretime(self,key:str)->int
redis.commands.core.BasicKeyCommands.psetex(self,name:KeyT,time_ms:ExpiryT,value:EncodableT)
redis.commands.core.BasicKeyCommands.pttl(self,name:KeyT)->ResponseT
redis.commands.core.BasicKeyCommands.randomkey(self,**kwargs)->ResponseT
redis.commands.core.BasicKeyCommands.rename(self,src:KeyT,dst:KeyT)->ResponseT
redis.commands.core.BasicKeyCommands.renamenx(self,src:KeyT,dst:KeyT)
redis.commands.core.BasicKeyCommands.restore(self,name:KeyT,ttl:float,value:EncodableT,replace:bool=False,absttl:bool=False,idletime:Optional[int]=None,frequency:Optional[int]=None)->ResponseT
redis.commands.core.BasicKeyCommands.set(self,name:KeyT,value:EncodableT,ex:Optional[ExpiryT]=None,px:Optional[ExpiryT]=None,nx:bool=False,xx:bool=False,keepttl:bool=False,get:bool=False,exat:Optional[AbsExpiryT]=None,pxat:Optional[AbsExpiryT]=None)->ResponseT
redis.commands.core.BasicKeyCommands.setbit(self,name:KeyT,offset:int,value:int)->ResponseT
redis.commands.core.BasicKeyCommands.setex(self,name:KeyT,time:ExpiryT,value:EncodableT)->ResponseT
redis.commands.core.BasicKeyCommands.setnx(self,name:KeyT,value:EncodableT)->ResponseT
redis.commands.core.BasicKeyCommands.setrange(self,name:KeyT,offset:int,value:EncodableT)->ResponseT
redis.commands.core.BasicKeyCommands.stralgo(self,algo:Literal['LCS'],value1:KeyT,value2:KeyT,specific_argument:Union[Literal['strings'],Literal['keys']]='strings',len:bool=False,idx:bool=False,minmatchlen:Optional[int]=None,withmatchlen:bool=False,**kwargs)->ResponseT
redis.commands.core.BasicKeyCommands.strlen(self,name:KeyT)->ResponseT
redis.commands.core.BasicKeyCommands.substr(self,name:KeyT,start:int,end:int=-1)->ResponseT
redis.commands.core.BasicKeyCommands.touch(self,*args:KeyT)->ResponseT
redis.commands.core.BasicKeyCommands.ttl(self,name:KeyT)->ResponseT
redis.commands.core.BasicKeyCommands.type(self,name:KeyT)->ResponseT
redis.commands.core.BasicKeyCommands.unlink(self,*names:KeyT)->ResponseT
redis.commands.core.BasicKeyCommands.unwatch(self)->None
redis.commands.core.BasicKeyCommands.watch(self,*names:KeyT)->None
redis.commands.core.BitFieldOperation(self,client:Union['redis.client.Redis','redis.asyncio.client.Redis'],key:str,default_overflow:Optional[str]=None)
redis.commands.core.BitFieldOperation.__init__(self,client:Union['redis.client.Redis','redis.asyncio.client.Redis'],key:str,default_overflow:Optional[str]=None)
redis.commands.core.BitFieldOperation.command(self)
redis.commands.core.BitFieldOperation.execute(self)->ResponseT
redis.commands.core.BitFieldOperation.get(self,fmt:str,offset:BitfieldOffsetT)
redis.commands.core.BitFieldOperation.incrby(self,fmt:str,offset:BitfieldOffsetT,increment:int,overflow:Optional[str]=None)
redis.commands.core.BitFieldOperation.overflow(self,overflow:str)
redis.commands.core.BitFieldOperation.reset(self)
redis.commands.core.BitFieldOperation.set(self,fmt:str,offset:BitfieldOffsetT,value:int)
redis.commands.core.ClusterCommands(CommandsProtocol)
redis.commands.core.ClusterCommands.cluster(self,cluster_arg,*args,**kwargs)->ResponseT
redis.commands.core.ClusterCommands.readonly(self,**kwargs)->ResponseT
redis.commands.core.ClusterCommands.readwrite(self,**kwargs)->ResponseT
redis.commands.core.CoreCommands(ACLCommands,ClusterCommands,DataAccessCommands,ManagementCommands,ModuleCommands,PubSubCommands,ScriptCommands,FunctionCommands)
redis.commands.core.DataAccessCommands(BasicKeyCommands,HyperlogCommands,HashCommands,GeoCommands,ListCommands,ScanCommands,SetCommands,StreamCommands,SortedSetCommands)
redis.commands.core.FunctionCommands
redis.commands.core.FunctionCommands._fcall(self,command:str,function,numkeys:int,*keys_and_args:Any)->Union[Awaitable[str], str]
redis.commands.core.FunctionCommands.fcall(self,function,numkeys:int,*keys_and_args:Any)->Union[Awaitable[str], str]
redis.commands.core.FunctionCommands.fcall_ro(self,function,numkeys:int,*keys_and_args:Any)->Union[Awaitable[str], str]
redis.commands.core.FunctionCommands.function_delete(self,library:str)->Union[Awaitable[str], str]
redis.commands.core.FunctionCommands.function_dump(self)->Union[Awaitable[str], str]
redis.commands.core.FunctionCommands.function_flush(self,mode:str='SYNC')->Union[Awaitable[str], str]
redis.commands.core.FunctionCommands.function_kill(self)->Union[Awaitable[str], str]
redis.commands.core.FunctionCommands.function_list(self,library:Optional[str]='*',withcode:Optional[bool]=False)->Union[Awaitable[List], List]
redis.commands.core.FunctionCommands.function_load(self,code:str,replace:Optional[bool]=False)->Union[Awaitable[str], str]
redis.commands.core.FunctionCommands.function_restore(self,payload:str,policy:Optional[str]='APPEND')->Union[Awaitable[str], str]
redis.commands.core.FunctionCommands.function_stats(self)->Union[Awaitable[List], List]
redis.commands.core.GeoCommands(CommandsProtocol)
redis.commands.core.GeoCommands._georadiusgeneric(self,command:str,*args:EncodableT,**kwargs:Union[EncodableT,None])->ResponseT
redis.commands.core.GeoCommands._geosearchgeneric(self,command:str,*args:EncodableT,**kwargs:Union[EncodableT,None])->ResponseT
redis.commands.core.GeoCommands.geoadd(self,name:KeyT,values:Sequence[EncodableT],nx:bool=False,xx:bool=False,ch:bool=False)->ResponseT
redis.commands.core.GeoCommands.geodist(self,name:KeyT,place1:FieldT,place2:FieldT,unit:Optional[str]=None)->ResponseT
redis.commands.core.GeoCommands.geohash(self,name:KeyT,*values:FieldT)->ResponseT
redis.commands.core.GeoCommands.geopos(self,name:KeyT,*values:FieldT)->ResponseT
redis.commands.core.GeoCommands.georadius(self,name:KeyT,longitude:float,latitude:float,radius:float,unit:Optional[str]=None,withdist:bool=False,withcoord:bool=False,withhash:bool=False,count:Optional[int]=None,sort:Optional[str]=None,store:Optional[KeyT]=None,store_dist:Optional[KeyT]=None,any:bool=False)->ResponseT
redis.commands.core.GeoCommands.georadiusbymember(self,name:KeyT,member:FieldT,radius:float,unit:Optional[str]=None,withdist:bool=False,withcoord:bool=False,withhash:bool=False,count:Optional[int]=None,sort:Optional[str]=None,store:Union[KeyT,None]=None,store_dist:Union[KeyT,None]=None,any:bool=False)->ResponseT
redis.commands.core.GeoCommands.geosearch(self,name:KeyT,member:Union[FieldT,None]=None,longitude:Union[float,None]=None,latitude:Union[float,None]=None,unit:str='m',radius:Union[float,None]=None,width:Union[float,None]=None,height:Union[float,None]=None,sort:Optional[str]=None,count:Optional[int]=None,any:bool=False,withcoord:bool=False,withdist:bool=False,withhash:bool=False)->ResponseT
redis.commands.core.GeoCommands.geosearchstore(self,dest:KeyT,name:KeyT,member:Optional[FieldT]=None,longitude:Optional[float]=None,latitude:Optional[float]=None,unit:str='m',radius:Optional[float]=None,width:Optional[float]=None,height:Optional[float]=None,sort:Optional[str]=None,count:Optional[int]=None,any:bool=False,storedist:bool=False)->ResponseT
redis.commands.core.HashCommands(CommandsProtocol)
redis.commands.core.HashCommands.hdel(self,name:str,*keys:str)->Union[Awaitable[int], int]
redis.commands.core.HashCommands.hexists(self,name:str,key:str)->Union[Awaitable[bool], bool]
redis.commands.core.HashCommands.hexpire(self,name:KeyT,seconds:ExpiryT,*fields:str,nx:bool=False,xx:bool=False,gt:bool=False,lt:bool=False)->ResponseT
redis.commands.core.HashCommands.hexpireat(self,name:KeyT,unix_time_seconds:AbsExpiryT,*fields:str,nx:bool=False,xx:bool=False,gt:bool=False,lt:bool=False)->ResponseT
redis.commands.core.HashCommands.hexpiretime(self,key:KeyT,*fields:str)->ResponseT
redis.commands.core.HashCommands.hget(self,name:str,key:str)->Union[Awaitable[Optional[str]], Optional[str]]
redis.commands.core.HashCommands.hgetall(self,name:str)->Union[Awaitable[dict], dict]
redis.commands.core.HashCommands.hgetdel(self,name:str,*keys:str)->Union[Awaitable[Optional[List[Union[str, bytes]]]], Optional[List[Union[str, bytes]]]]
redis.commands.core.HashCommands.hgetex(self,name:KeyT,*keys:str,ex:Optional[ExpiryT]=None,px:Optional[ExpiryT]=None,exat:Optional[AbsExpiryT]=None,pxat:Optional[AbsExpiryT]=None,persist:bool=False)->Union[Awaitable[Optional[List[Union[str, bytes]]]], Optional[List[Union[str, bytes]]]]
redis.commands.core.HashCommands.hincrby(self,name:str,key:str,amount:int=1)->Union[Awaitable[int], int]
redis.commands.core.HashCommands.hincrbyfloat(self,name:str,key:str,amount:float=1.0)->Union[Awaitable[float], float]
redis.commands.core.HashCommands.hkeys(self,name:str)->Union[Awaitable[List], List]
redis.commands.core.HashCommands.hlen(self,name:str)->Union[Awaitable[int], int]
redis.commands.core.HashCommands.hmget(self,name:str,keys:List,*args:List)->Union[Awaitable[List], List]
redis.commands.core.HashCommands.hmset(self,name:str,mapping:dict)->Union[Awaitable[str], str]
redis.commands.core.HashCommands.hpersist(self,name:KeyT,*fields:str)->ResponseT
redis.commands.core.HashCommands.hpexpire(self,name:KeyT,milliseconds:ExpiryT,*fields:str,nx:bool=False,xx:bool=False,gt:bool=False,lt:bool=False)->ResponseT
redis.commands.core.HashCommands.hpexpireat(self,name:KeyT,unix_time_milliseconds:AbsExpiryT,*fields:str,nx:bool=False,xx:bool=False,gt:bool=False,lt:bool=False)->ResponseT
redis.commands.core.HashCommands.hpexpiretime(self,key:KeyT,*fields:str)->ResponseT
redis.commands.core.HashCommands.hpttl(self,key:KeyT,*fields:str)->ResponseT
redis.commands.core.HashCommands.hset(self,name:str,key:Optional[str]=None,value:Optional[str]=None,mapping:Optional[dict]=None,items:Optional[list]=None)->Union[Awaitable[int], int]
redis.commands.core.HashCommands.hsetex(self,name:str,key:Optional[str]=None,value:Optional[str]=None,mapping:Optional[dict]=None,items:Optional[list]=None,ex:Optional[ExpiryT]=None,px:Optional[ExpiryT]=None,exat:Optional[AbsExpiryT]=None,pxat:Optional[AbsExpiryT]=None,data_persist_option:Optional[HashDataPersistOptions]=None,keepttl:bool=False)->Union[Awaitable[int], int]
redis.commands.core.HashCommands.hsetnx(self,name:str,key:str,value:str)->Union[Awaitable[bool], bool]
redis.commands.core.HashCommands.hstrlen(self,name:str,key:str)->Union[Awaitable[int], int]
redis.commands.core.HashCommands.httl(self,key:KeyT,*fields:str)->ResponseT
redis.commands.core.HashCommands.hvals(self,name:str)->Union[Awaitable[List], List]
redis.commands.core.HashDataPersistOptions(Enum)
redis.commands.core.HyperlogCommands(CommandsProtocol)
redis.commands.core.HyperlogCommands.pfadd(self,name:KeyT,*values:FieldT)->ResponseT
redis.commands.core.HyperlogCommands.pfcount(self,*sources:KeyT)->ResponseT
redis.commands.core.HyperlogCommands.pfmerge(self,dest:KeyT,*sources:KeyT)->ResponseT
redis.commands.core.ListCommands(CommandsProtocol)
redis.commands.core.ListCommands.blmpop(self,timeout:float,numkeys:int,*args:List[str],direction:str,count:Optional[int]=1)->Optional[list]
redis.commands.core.ListCommands.blpop(self,keys:List,timeout:Optional[Number]=0)->Union[Awaitable[list], list]
redis.commands.core.ListCommands.brpop(self,keys:List,timeout:Optional[Number]=0)->Union[Awaitable[list], list]
redis.commands.core.ListCommands.brpoplpush(self,src:str,dst:str,timeout:Optional[Number]=0)->Union[Awaitable[Optional[str]], Optional[str]]
redis.commands.core.ListCommands.lindex(self,name:str,index:int)->Union[Awaitable[Optional[str]], Optional[str]]
redis.commands.core.ListCommands.linsert(self,name:str,where:str,refvalue:str,value:str)->Union[Awaitable[int], int]
redis.commands.core.ListCommands.llen(self,name:str)->Union[Awaitable[int], int]
redis.commands.core.ListCommands.lmpop(self,num_keys:int,*args:List[str],direction:str,count:Optional[int]=1)->Union[Awaitable[list], list]
redis.commands.core.ListCommands.lpop(self,name:str,count:Optional[int]=None)->Union[Awaitable[Union[str, List, None]], Union[str, List, None]]
redis.commands.core.ListCommands.lpos(self,name:str,value:str,rank:Optional[int]=None,count:Optional[int]=None,maxlen:Optional[int]=None)->Union[str, List, None]
redis.commands.core.ListCommands.lpush(self,name:str,*values:FieldT)->Union[Awaitable[int], int]
redis.commands.core.ListCommands.lpushx(self,name:str,*values:FieldT)->Union[Awaitable[int], int]
redis.commands.core.ListCommands.lrange(self,name:str,start:int,end:int)->Union[Awaitable[list], list]
redis.commands.core.ListCommands.lrem(self,name:str,count:int,value:str)->Union[Awaitable[int], int]
redis.commands.core.ListCommands.lset(self,name:str,index:int,value:str)->Union[Awaitable[str], str]
redis.commands.core.ListCommands.ltrim(self,name:str,start:int,end:int)->Union[Awaitable[str], str]
redis.commands.core.ListCommands.rpop(self,name:str,count:Optional[int]=None)->Union[Awaitable[Union[str, List, None]], Union[str, List, None]]
redis.commands.core.ListCommands.rpoplpush(self,src:str,dst:str)->Union[Awaitable[str], str]
redis.commands.core.ListCommands.rpush(self,name:str,*values:FieldT)->Union[Awaitable[int], int]
redis.commands.core.ListCommands.rpushx(self,name:str,*values:str)->Union[Awaitable[int], int]
redis.commands.core.ListCommands.sort(self,name:str,start:Optional[int]=None,num:Optional[int]=None,by:Optional[str]=None,get:Optional[List[str]]=None,desc:bool=False,alpha:bool=False,store:Optional[str]=None,groups:Optional[bool]=False)->Union[List, int]
redis.commands.core.ListCommands.sort_ro(self,key:str,start:Optional[int]=None,num:Optional[int]=None,by:Optional[str]=None,get:Optional[List[str]]=None,desc:bool=False,alpha:bool=False)->list
redis.commands.core.ManagementCommands(CommandsProtocol)
redis.commands.core.ManagementCommands.auth(self,password:str,username:Optional[str]=None,**kwargs)
redis.commands.core.ManagementCommands.bgrewriteaof(self,**kwargs)
redis.commands.core.ManagementCommands.bgsave(self,schedule:bool=True,**kwargs)->ResponseT
redis.commands.core.ManagementCommands.client_getname(self,**kwargs)->ResponseT
redis.commands.core.ManagementCommands.client_getredir(self,**kwargs)->ResponseT
redis.commands.core.ManagementCommands.client_id(self,**kwargs)->ResponseT
redis.commands.core.ManagementCommands.client_info(self,**kwargs)->ResponseT
redis.commands.core.ManagementCommands.client_kill(self,address:str,**kwargs)->ResponseT
redis.commands.core.ManagementCommands.client_kill_filter(self,_id:Optional[str]=None,_type:Optional[str]=None,addr:Optional[str]=None,skipme:Optional[bool]=None,laddr:Optional[bool]=None,user:Optional[str]=None,maxage:Optional[int]=None,**kwargs)->ResponseT
redis.commands.core.ManagementCommands.client_list(self,_type:Optional[str]=None,client_id:List[EncodableT]=[],**kwargs)->ResponseT
redis.commands.core.ManagementCommands.client_no_evict(self,mode:str)->Union[Awaitable[str], str]
redis.commands.core.ManagementCommands.client_no_touch(self,mode:str)->Union[Awaitable[str], str]
redis.commands.core.ManagementCommands.client_pause(self,timeout:int,all:bool=True,**kwargs)->ResponseT
redis.commands.core.ManagementCommands.client_reply(self,reply:Union[Literal['ON'],Literal['OFF'],Literal['SKIP']],**kwargs)->ResponseT
redis.commands.core.ManagementCommands.client_setinfo(self,attr:str,value:str,**kwargs)->ResponseT
redis.commands.core.ManagementCommands.client_setname(self,name:str,**kwargs)->ResponseT
redis.commands.core.ManagementCommands.client_tracking(self,on:bool=True,clientid:Optional[int]=None,prefix:Sequence[KeyT]=[],bcast:bool=False,optin:bool=False,optout:bool=False,noloop:bool=False,**kwargs)->ResponseT
redis.commands.core.ManagementCommands.client_tracking_off(self,clientid:Optional[int]=None,prefix:Sequence[KeyT]=[],bcast:bool=False,optin:bool=False,optout:bool=False,noloop:bool=False)->ResponseT
redis.commands.core.ManagementCommands.client_tracking_on(self,clientid:Optional[int]=None,prefix:Sequence[KeyT]=[],bcast:bool=False,optin:bool=False,optout:bool=False,noloop:bool=False)->ResponseT
redis.commands.core.ManagementCommands.client_trackinginfo(self,**kwargs)->ResponseT
redis.commands.core.ManagementCommands.client_unblock(self,client_id:int,error:bool=False,**kwargs)->ResponseT
redis.commands.core.ManagementCommands.client_unpause(self,**kwargs)->ResponseT
redis.commands.core.ManagementCommands.command(self,**kwargs)
redis.commands.core.ManagementCommands.command_count(self,**kwargs)->ResponseT
redis.commands.core.ManagementCommands.command_docs(self,*args)
redis.commands.core.ManagementCommands.command_getkeysandflags(self,*args:List[str])->List[Union[str, List[str]]]
redis.commands.core.ManagementCommands.command_info(self,**kwargs)->None
redis.commands.core.ManagementCommands.command_list(self,module:Optional[str]=None,category:Optional[str]=None,pattern:Optional[str]=None)->ResponseT
redis.commands.core.ManagementCommands.config_get(self,pattern:PatternT='*',*args:List[PatternT],**kwargs)->ResponseT
redis.commands.core.ManagementCommands.config_resetstat(self,**kwargs)->ResponseT
redis.commands.core.ManagementCommands.config_rewrite(self,**kwargs)->ResponseT
redis.commands.core.ManagementCommands.config_set(self,name:KeyT,value:EncodableT,*args:List[Union[KeyT,EncodableT]],**kwargs)->ResponseT
redis.commands.core.ManagementCommands.dbsize(self,**kwargs)->ResponseT
redis.commands.core.ManagementCommands.debug_object(self,key:KeyT,**kwargs)->ResponseT
redis.commands.core.ManagementCommands.debug_segfault(self,**kwargs)->None
redis.commands.core.ManagementCommands.echo(self,value:EncodableT,**kwargs)->ResponseT
redis.commands.core.ManagementCommands.failover(self)
redis.commands.core.ManagementCommands.flushall(self,asynchronous:bool=False,**kwargs)->ResponseT
redis.commands.core.ManagementCommands.flushdb(self,asynchronous:bool=False,**kwargs)->ResponseT
redis.commands.core.ManagementCommands.hello(self)
redis.commands.core.ManagementCommands.info(self,section:Optional[str]=None,*args:List[str],**kwargs)->ResponseT
redis.commands.core.ManagementCommands.lastsave(self,**kwargs)->ResponseT
redis.commands.core.ManagementCommands.latency_doctor(self)
redis.commands.core.ManagementCommands.latency_graph(self)
redis.commands.core.ManagementCommands.latency_histogram(self,*args)
redis.commands.core.ManagementCommands.latency_history(self,event:str)->ResponseT
redis.commands.core.ManagementCommands.latency_latest(self)->ResponseT
redis.commands.core.ManagementCommands.latency_reset(self,*events:str)->ResponseT
redis.commands.core.ManagementCommands.lolwut(self,*version_numbers:Union[str,float],**kwargs)->ResponseT
redis.commands.core.ManagementCommands.memory_doctor(self,**kwargs)->None
redis.commands.core.ManagementCommands.memory_help(self,**kwargs)->None
redis.commands.core.ManagementCommands.memory_malloc_stats(self,**kwargs)->ResponseT
redis.commands.core.ManagementCommands.memory_purge(self,**kwargs)->ResponseT
redis.commands.core.ManagementCommands.memory_stats(self,**kwargs)->ResponseT
redis.commands.core.ManagementCommands.memory_usage(self,key:KeyT,samples:Optional[int]=None,**kwargs)->ResponseT
redis.commands.core.ManagementCommands.migrate(self,host:str,port:int,keys:KeysT,destination_db:int,timeout:int,copy:bool=False,replace:bool=False,auth:Optional[str]=None,**kwargs)->ResponseT
redis.commands.core.ManagementCommands.object(self,infotype:str,key:KeyT,**kwargs)->ResponseT
redis.commands.core.ManagementCommands.ping(self,**kwargs)->ResponseT
redis.commands.core.ManagementCommands.psync(self,replicationid:str,offset:int)
redis.commands.core.ManagementCommands.quit(self,**kwargs)->ResponseT
redis.commands.core.ManagementCommands.replicaof(self,*args,**kwargs)->ResponseT
redis.commands.core.ManagementCommands.reset(self)->ResponseT
redis.commands.core.ManagementCommands.role(self)->ResponseT
redis.commands.core.ManagementCommands.save(self,**kwargs)->ResponseT
redis.commands.core.ManagementCommands.select(self,index:int,**kwargs)->ResponseT
redis.commands.core.ManagementCommands.shutdown(self,save:bool=False,nosave:bool=False,now:bool=False,force:bool=False,abort:bool=False,**kwargs)->None
redis.commands.core.ManagementCommands.slaveof(self,host:Optional[str]=None,port:Optional[int]=None,**kwargs)->ResponseT
redis.commands.core.ManagementCommands.slowlog_get(self,num:Optional[int]=None,**kwargs)->ResponseT
redis.commands.core.ManagementCommands.slowlog_len(self,**kwargs)->ResponseT
redis.commands.core.ManagementCommands.slowlog_reset(self,**kwargs)->ResponseT
redis.commands.core.ManagementCommands.swapdb(self,first:int,second:int,**kwargs)->ResponseT
redis.commands.core.ManagementCommands.sync(self)->ResponseT
redis.commands.core.ManagementCommands.time(self,**kwargs)->ResponseT
redis.commands.core.ManagementCommands.wait(self,num_replicas:int,timeout:int,**kwargs)->ResponseT
redis.commands.core.ManagementCommands.waitaof(self,num_local:int,num_replicas:int,timeout:int,**kwargs)->ResponseT
redis.commands.core.ModuleCommands(CommandsProtocol)
redis.commands.core.ModuleCommands.command(self)->ResponseT
redis.commands.core.ModuleCommands.command_count(self)->ResponseT
redis.commands.core.ModuleCommands.command_getkeys(self,*args)->ResponseT
redis.commands.core.ModuleCommands.command_info(self)->None
redis.commands.core.ModuleCommands.module_list(self)->ResponseT
redis.commands.core.ModuleCommands.module_load(self,path,*args)->ResponseT
redis.commands.core.ModuleCommands.module_loadex(self,path:str,options:Optional[List[str]]=None,args:Optional[List[str]]=None)->ResponseT
redis.commands.core.ModuleCommands.module_unload(self,name)->ResponseT
redis.commands.core.PubSubCommands(CommandsProtocol)
redis.commands.core.PubSubCommands.publish(self,channel:ChannelT,message:EncodableT,**kwargs)->ResponseT
redis.commands.core.PubSubCommands.pubsub_channels(self,pattern:PatternT='*',**kwargs)->ResponseT
redis.commands.core.PubSubCommands.pubsub_numpat(self,**kwargs)->ResponseT
redis.commands.core.PubSubCommands.pubsub_numsub(self,*args:ChannelT,**kwargs)->ResponseT
redis.commands.core.PubSubCommands.pubsub_shardchannels(self,pattern:PatternT='*',**kwargs)->ResponseT
redis.commands.core.PubSubCommands.pubsub_shardnumsub(self,*args:ChannelT,**kwargs)->ResponseT
redis.commands.core.PubSubCommands.spublish(self,shard_channel:ChannelT,message:EncodableT)->ResponseT
redis.commands.core.ScanCommands(CommandsProtocol)
redis.commands.core.ScanCommands.hscan(self,name:KeyT,cursor:int=0,match:Union[PatternT,None]=None,count:Optional[int]=None,no_values:Union[bool,None]=None)->ResponseT
redis.commands.core.ScanCommands.hscan_iter(self,name:str,match:Union[PatternT,None]=None,count:Optional[int]=None,no_values:Union[bool,None]=None)->Iterator
redis.commands.core.ScanCommands.scan(self,cursor:int=0,match:Union[PatternT,None]=None,count:Optional[int]=None,_type:Optional[str]=None,**kwargs)->ResponseT
redis.commands.core.ScanCommands.scan_iter(self,match:Union[PatternT,None]=None,count:Optional[int]=None,_type:Optional[str]=None,**kwargs)->Iterator
redis.commands.core.ScanCommands.sscan(self,name:KeyT,cursor:int=0,match:Union[PatternT,None]=None,count:Optional[int]=None)->ResponseT
redis.commands.core.ScanCommands.sscan_iter(self,name:KeyT,match:Union[PatternT,None]=None,count:Optional[int]=None)->Iterator
redis.commands.core.ScanCommands.zscan(self,name:KeyT,cursor:int=0,match:Union[PatternT,None]=None,count:Optional[int]=None,score_cast_func:Union[type,Callable]=float)->ResponseT
redis.commands.core.ScanCommands.zscan_iter(self,name:KeyT,match:Union[PatternT,None]=None,count:Optional[int]=None,score_cast_func:Union[type,Callable]=float)->Iterator
redis.commands.core.Script(self,registered_client:'redis.client.Redis',script:ScriptTextT)
redis.commands.core.Script.__init__(self,registered_client:'redis.client.Redis',script:ScriptTextT)
redis.commands.core.Script.get_encoder(self)
redis.commands.core.ScriptCommands(CommandsProtocol)
redis.commands.core.ScriptCommands._eval(self,command:str,script:str,numkeys:int,*keys_and_args:str)->Union[Awaitable[str], str]
redis.commands.core.ScriptCommands._evalsha(self,command:str,sha:str,numkeys:int,*keys_and_args:list)->Union[Awaitable[str], str]
redis.commands.core.ScriptCommands.eval(self,script:str,numkeys:int,*keys_and_args:str)->Union[Awaitable[str], str]
redis.commands.core.ScriptCommands.eval_ro(self,script:str,numkeys:int,*keys_and_args:str)->Union[Awaitable[str], str]
redis.commands.core.ScriptCommands.evalsha(self,sha:str,numkeys:int,*keys_and_args:str)->Union[Awaitable[str], str]
redis.commands.core.ScriptCommands.evalsha_ro(self,sha:str,numkeys:int,*keys_and_args:str)->Union[Awaitable[str], str]
redis.commands.core.ScriptCommands.register_script(self:'redis.client.Redis',script:ScriptTextT)->Script
redis.commands.core.ScriptCommands.script_debug(self,*args)->None
redis.commands.core.ScriptCommands.script_exists(self,*args:str)->ResponseT
redis.commands.core.ScriptCommands.script_flush(self,sync_type:Union[Literal['SYNC'],Literal['ASYNC']]=None)->ResponseT
redis.commands.core.ScriptCommands.script_kill(self)->ResponseT
redis.commands.core.ScriptCommands.script_load(self,script:ScriptTextT)->ResponseT
redis.commands.core.SetCommands(CommandsProtocol)
redis.commands.core.SetCommands.sadd(self,name:str,*values:FieldT)->Union[Awaitable[int], int]
redis.commands.core.SetCommands.scard(self,name:str)->Union[Awaitable[int], int]
redis.commands.core.SetCommands.sdiff(self,keys:List,*args:List)->Union[Awaitable[list], list]
redis.commands.core.SetCommands.sdiffstore(self,dest:str,keys:List,*args:List)->Union[Awaitable[int], int]
redis.commands.core.SetCommands.sinter(self,keys:List,*args:List)->Union[Awaitable[list], list]
redis.commands.core.SetCommands.sintercard(self,numkeys:int,keys:List[str],limit:int=0)->Union[Awaitable[int], int]
redis.commands.core.SetCommands.sinterstore(self,dest:str,keys:List,*args:List)->Union[Awaitable[int], int]
redis.commands.core.SetCommands.sismember(self,name:str,value:str)->Union[Awaitable[Union[Literal[0], Literal[1]]], Union[Literal[0], Literal[1]]]
redis.commands.core.SetCommands.smembers(self,name:str)->Union[Awaitable[Set], Set]
redis.commands.core.SetCommands.smismember(self,name:str,values:List,*args:List)->Union[Awaitable[List[Union[Literal[0], Literal[1]]]], List[Union[Literal[0], Literal[1]]]]
redis.commands.core.SetCommands.smove(self,src:str,dst:str,value:str)->Union[Awaitable[bool], bool]
redis.commands.core.SetCommands.spop(self,name:str,count:Optional[int]=None)->Union[str, List, None]
redis.commands.core.SetCommands.srandmember(self,name:str,number:Optional[int]=None)->Union[str, List, None]
redis.commands.core.SetCommands.srem(self,name:str,*values:FieldT)->Union[Awaitable[int], int]
redis.commands.core.SetCommands.sunion(self,keys:List,*args:List)->Union[Awaitable[List], List]
redis.commands.core.SetCommands.sunionstore(self,dest:str,keys:List,*args:List)->Union[Awaitable[int], int]
redis.commands.core.SortedSetCommands(CommandsProtocol)
redis.commands.core.SortedSetCommands._zaggregate(self,command:str,dest:Union[KeyT,None],keys:Union[Sequence[KeyT],Mapping[AnyKeyT,float]],aggregate:Optional[str]=None,**options)->ResponseT
redis.commands.core.SortedSetCommands._zrange(self,command,dest:Union[KeyT,None],name:KeyT,start:int,end:int,desc:bool=False,byscore:bool=False,bylex:bool=False,withscores:bool=False,score_cast_func:Union[type,Callable,None]=float,offset:Optional[int]=None,num:Optional[int]=None)->ResponseT
redis.commands.core.SortedSetCommands.bzmpop(self,timeout:float,numkeys:int,keys:List[str],min:Optional[bool]=False,max:Optional[bool]=False,count:Optional[int]=1)->Optional[list]
redis.commands.core.SortedSetCommands.bzpopmax(self,keys:KeysT,timeout:TimeoutSecT=0)->ResponseT
redis.commands.core.SortedSetCommands.bzpopmin(self,keys:KeysT,timeout:TimeoutSecT=0)->ResponseT
redis.commands.core.SortedSetCommands.zadd(self,name:KeyT,mapping:Mapping[AnyKeyT,EncodableT],nx:bool=False,xx:bool=False,ch:bool=False,incr:bool=False,gt:bool=False,lt:bool=False)->ResponseT
redis.commands.core.SortedSetCommands.zcard(self,name:KeyT)->ResponseT
redis.commands.core.SortedSetCommands.zcount(self,name:KeyT,min:ZScoreBoundT,max:ZScoreBoundT)->ResponseT
redis.commands.core.SortedSetCommands.zdiff(self,keys:KeysT,withscores:bool=False)->ResponseT
redis.commands.core.SortedSetCommands.zdiffstore(self,dest:KeyT,keys:KeysT)->ResponseT
redis.commands.core.SortedSetCommands.zincrby(self,name:KeyT,amount:float,value:EncodableT)->ResponseT
redis.commands.core.SortedSetCommands.zinter(self,keys:KeysT,aggregate:Optional[str]=None,withscores:bool=False)->ResponseT
redis.commands.core.SortedSetCommands.zintercard(self,numkeys:int,keys:List[str],limit:int=0)->Union[Awaitable[int], int]
redis.commands.core.SortedSetCommands.zinterstore(self,dest:KeyT,keys:Union[Sequence[KeyT],Mapping[AnyKeyT,float]],aggregate:Optional[str]=None)->ResponseT
redis.commands.core.SortedSetCommands.zlexcount(self,name,min,max)
redis.commands.core.SortedSetCommands.zmpop(self,num_keys:int,keys:List[str],min:Optional[bool]=False,max:Optional[bool]=False,count:Optional[int]=1)->Union[Awaitable[list], list]
redis.commands.core.SortedSetCommands.zmscore(self,key:KeyT,members:List[str])->ResponseT
redis.commands.core.SortedSetCommands.zpopmax(self,name:KeyT,count:Optional[int]=None)->ResponseT
redis.commands.core.SortedSetCommands.zpopmin(self,name:KeyT,count:Optional[int]=None)->ResponseT
redis.commands.core.SortedSetCommands.zrandmember(self,key:KeyT,count:Optional[int]=None,withscores:bool=False)->ResponseT
redis.commands.core.SortedSetCommands.zrange(self,name:KeyT,start:int,end:int,desc:bool=False,withscores:bool=False,score_cast_func:Union[type,Callable]=float,byscore:bool=False,bylex:bool=False,offset:Optional[int]=None,num:Optional[int]=None)->ResponseT
redis.commands.core.SortedSetCommands.zrangebylex(self,name:KeyT,min:EncodableT,max:EncodableT,start:Optional[int]=None,num:Optional[int]=None)->ResponseT
redis.commands.core.SortedSetCommands.zrangebyscore(self,name:KeyT,min:ZScoreBoundT,max:ZScoreBoundT,start:Optional[int]=None,num:Optional[int]=None,withscores:bool=False,score_cast_func:Union[type,Callable]=float)->ResponseT
redis.commands.core.SortedSetCommands.zrangestore(self,dest:KeyT,name:KeyT,start:int,end:int,byscore:bool=False,bylex:bool=False,desc:bool=False,offset:Optional[int]=None,num:Optional[int]=None)->ResponseT
redis.commands.core.SortedSetCommands.zrank(self,name:KeyT,value:EncodableT,withscore:bool=False)->ResponseT
redis.commands.core.SortedSetCommands.zrem(self,name:KeyT,*values:FieldT)->ResponseT
redis.commands.core.SortedSetCommands.zremrangebylex(self,name:KeyT,min:EncodableT,max:EncodableT)->ResponseT
redis.commands.core.SortedSetCommands.zremrangebyrank(self,name:KeyT,min:int,max:int)->ResponseT
redis.commands.core.SortedSetCommands.zremrangebyscore(self,name:KeyT,min:ZScoreBoundT,max:ZScoreBoundT)->ResponseT
redis.commands.core.SortedSetCommands.zrevrange(self,name:KeyT,start:int,end:int,withscores:bool=False,score_cast_func:Union[type,Callable]=float)->ResponseT
redis.commands.core.SortedSetCommands.zrevrangebylex(self,name:KeyT,max:EncodableT,min:EncodableT,start:Optional[int]=None,num:Optional[int]=None)->ResponseT
redis.commands.core.SortedSetCommands.zrevrangebyscore(self,name:KeyT,max:ZScoreBoundT,min:ZScoreBoundT,start:Optional[int]=None,num:Optional[int]=None,withscores:bool=False,score_cast_func:Union[type,Callable]=float)
redis.commands.core.SortedSetCommands.zrevrank(self,name:KeyT,value:EncodableT,withscore:bool=False)->ResponseT
redis.commands.core.SortedSetCommands.zscore(self,name:KeyT,value:EncodableT)->ResponseT
redis.commands.core.SortedSetCommands.zunion(self,keys:Union[Sequence[KeyT],Mapping[AnyKeyT,float]],aggregate:Optional[str]=None,withscores:bool=False)->ResponseT
redis.commands.core.SortedSetCommands.zunionstore(self,dest:KeyT,keys:Union[Sequence[KeyT],Mapping[AnyKeyT,float]],aggregate:Optional[str]=None)->ResponseT
redis.commands.core.StreamCommands(CommandsProtocol)
redis.commands.core.StreamCommands.xack(self,name:KeyT,groupname:GroupT,*ids:StreamIdT)->ResponseT
redis.commands.core.StreamCommands.xadd(self,name:KeyT,fields:Dict[FieldT,EncodableT],id:StreamIdT='*',maxlen:Optional[int]=None,approximate:bool=True,nomkstream:bool=False,minid:Union[StreamIdT,None]=None,limit:Optional[int]=None)->ResponseT
redis.commands.core.StreamCommands.xautoclaim(self,name:KeyT,groupname:GroupT,consumername:ConsumerT,min_idle_time:int,start_id:StreamIdT='0-0',count:Optional[int]=None,justid:bool=False)->ResponseT
redis.commands.core.StreamCommands.xclaim(self,name:KeyT,groupname:GroupT,consumername:ConsumerT,min_idle_time:int,message_ids:Union[List[StreamIdT],Tuple[StreamIdT]],idle:Optional[int]=None,time:Optional[int]=None,retrycount:Optional[int]=None,force:bool=False,justid:bool=False)->ResponseT
redis.commands.core.StreamCommands.xdel(self,name:KeyT,*ids:StreamIdT)->ResponseT
redis.commands.core.StreamCommands.xgroup_create(self,name:KeyT,groupname:GroupT,id:StreamIdT='$',mkstream:bool=False,entries_read:Optional[int]=None)->ResponseT
redis.commands.core.StreamCommands.xgroup_createconsumer(self,name:KeyT,groupname:GroupT,consumername:ConsumerT)->ResponseT
redis.commands.core.StreamCommands.xgroup_delconsumer(self,name:KeyT,groupname:GroupT,consumername:ConsumerT)->ResponseT
redis.commands.core.StreamCommands.xgroup_destroy(self,name:KeyT,groupname:GroupT)->ResponseT
redis.commands.core.StreamCommands.xgroup_setid(self,name:KeyT,groupname:GroupT,id:StreamIdT,entries_read:Optional[int]=None)->ResponseT
redis.commands.core.StreamCommands.xinfo_consumers(self,name:KeyT,groupname:GroupT)->ResponseT
redis.commands.core.StreamCommands.xinfo_groups(self,name:KeyT)->ResponseT
redis.commands.core.StreamCommands.xinfo_stream(self,name:KeyT,full:bool=False)->ResponseT
redis.commands.core.StreamCommands.xlen(self,name:KeyT)->ResponseT
redis.commands.core.StreamCommands.xpending(self,name:KeyT,groupname:GroupT)->ResponseT
redis.commands.core.StreamCommands.xpending_range(self,name:KeyT,groupname:GroupT,min:StreamIdT,max:StreamIdT,count:int,consumername:Union[ConsumerT,None]=None,idle:Optional[int]=None)->ResponseT
redis.commands.core.StreamCommands.xrange(self,name:KeyT,min:StreamIdT='-',max:StreamIdT='+',count:Optional[int]=None)->ResponseT
redis.commands.core.StreamCommands.xread(self,streams:Dict[KeyT,StreamIdT],count:Optional[int]=None,block:Optional[int]=None)->ResponseT
redis.commands.core.StreamCommands.xreadgroup(self,groupname:str,consumername:str,streams:Dict[KeyT,StreamIdT],count:Optional[int]=None,block:Optional[int]=None,noack:bool=False)->ResponseT
redis.commands.core.StreamCommands.xrevrange(self,name:KeyT,max:StreamIdT='+',min:StreamIdT='-',count:Optional[int]=None)->ResponseT
redis.commands.core.StreamCommands.xtrim(self,name:KeyT,maxlen:Optional[int]=None,approximate:bool=True,minid:Union[StreamIdT,None]=None,limit:Optional[int]=None)->ResponseT


----------------------------------------/dataset/nuaa/anaconda3/envs/redis6.1.1/lib/python3.9/site-packages/redis/commands/redismodules.py----------------------------------------
A:redis.commands.redismodules.jj->JSON(client=self, encoder=encoder, decoder=decoder)
A:redis.commands.redismodules.s->AsyncSearch(client=self, index_name=index_name)
A:redis.commands.redismodules.bf->BFBloom(client=self)
A:redis.commands.redismodules.cf->CFBloom(client=self)
A:redis.commands.redismodules.cms->CMSBloom(client=self)
A:redis.commands.redismodules.topk->TOPKBloom(client=self)
A:redis.commands.redismodules.tdigest->TDigestBloom(client=self)
A:redis.commands.redismodules.vset->VectorSet(client=self)
redis.commands.AsyncRedisModuleCommands(RedisModuleCommands)
redis.commands.AsyncRedisModuleCommands.ft(self,index_name='idx')->AsyncSearch
redis.commands.RedisModuleCommands
redis.commands.RedisModuleCommands.bf(self)->BFBloom
redis.commands.RedisModuleCommands.cf(self)->CFBloom
redis.commands.RedisModuleCommands.cms(self)->CMSBloom
redis.commands.RedisModuleCommands.ft(self,index_name='idx')->Search
redis.commands.RedisModuleCommands.json(self,encoder=JSONEncoder(),decoder=JSONDecoder())->JSON
redis.commands.RedisModuleCommands.tdigest(self)->TDigestBloom
redis.commands.RedisModuleCommands.topk(self)->TOPKBloom
redis.commands.RedisModuleCommands.ts(self)->TimeSeries
redis.commands.RedisModuleCommands.vset(self)->VectorSet
redis.commands.redismodules.AsyncRedisModuleCommands(RedisModuleCommands)
redis.commands.redismodules.AsyncRedisModuleCommands.ft(self,index_name='idx')->AsyncSearch
redis.commands.redismodules.RedisModuleCommands
redis.commands.redismodules.RedisModuleCommands.bf(self)->BFBloom
redis.commands.redismodules.RedisModuleCommands.cf(self)->CFBloom
redis.commands.redismodules.RedisModuleCommands.cms(self)->CMSBloom
redis.commands.redismodules.RedisModuleCommands.ft(self,index_name='idx')->Search
redis.commands.redismodules.RedisModuleCommands.json(self,encoder=JSONEncoder(),decoder=JSONDecoder())->JSON
redis.commands.redismodules.RedisModuleCommands.tdigest(self)->TDigestBloom
redis.commands.redismodules.RedisModuleCommands.topk(self)->TOPKBloom
redis.commands.redismodules.RedisModuleCommands.ts(self)->TimeSeries
redis.commands.redismodules.RedisModuleCommands.vset(self)->VectorSet


----------------------------------------/dataset/nuaa/anaconda3/envs/redis6.1.1/lib/python3.9/site-packages/redis/commands/cluster.py----------------------------------------
A:redis.commands.cluster.READ_COMMANDS->frozenset(['BITCOUNT', 'BITPOS', 'EVAL_RO', 'EVALSHA_RO', 'EXISTS', 'GEODIST', 'GEOHASH', 'GEOPOS', 'GEORADIUS', 'GEORADIUSBYMEMBER', 'GET', 'GETBIT', 'GETRANGE', 'HEXISTS', 'HGET', 'HGETALL', 'HKEYS', 'HLEN', 'HMGET', 'HSTRLEN', 'HVALS', 'KEYS', 'LINDEX', 'LLEN', 'LRANGE', 'MGET', 'PTTL', 'RANDOMKEY', 'SCARD', 'SDIFF', 'SINTER', 'SISMEMBER', 'SMEMBERS', 'SRANDMEMBER', 'STRLEN', 'SUNION', 'TTL', 'ZCARD', 'ZCOUNT', 'ZRANGE', 'ZSCORE'])
A:redis.commands.cluster.slot->key_slot(self.encoder.encode(pair[0]))
A:redis.commands.cluster.pipe->self.pipeline()
A:redis.commands.cluster.keys->list_or_args(keys, args)
A:redis.commands.cluster.slots_to_keys->self._partition_keys_by_slot(keys)
A:redis.commands.cluster.res->self._execute_pipeline_by_slot('MGET', slots_to_keys)
A:redis.commands.cluster.slots_to_pairs->self._partition_pairs_by_slot(mapping)
A:redis.commands.cluster.target_nodes->kwargs.pop('target_nodes', None)
A:redis.commands.cluster.(cursors, data)->self.scan(match=match, count=count, _type=_type, **kwargs)
A:redis.commands.cluster.(cur, data)->self.scan(cursor=cursor, match=match, count=count, _type=_type, target_nodes=nodes[name], **kwargs)
redis.commands.AsyncRedisClusterCommands(AsyncClusterMultiKeyCommands,AsyncClusterManagementCommands,AsyncACLCommands,AsyncClusterDataAccessCommands,AsyncScriptCommands,AsyncFunctionCommands,AsyncModuleCommands,AsyncRedisModuleCommands)
redis.commands.RedisClusterCommands(ClusterMultiKeyCommands,ClusterManagementCommands,ACLCommands,PubSubCommands,ClusterDataAccessCommands,ScriptCommands,FunctionCommands,ModuleCommands,RedisModuleCommands)
redis.commands.cluster.AsyncClusterDataAccessCommands(ClusterDataAccessCommands,AsyncDataAccessCommands)
redis.commands.cluster.AsyncClusterDataAccessCommands.scan_iter(self,match:Optional[PatternT]=None,count:Optional[int]=None,_type:Optional[str]=None,**kwargs)->AsyncIterator
redis.commands.cluster.AsyncClusterManagementCommands(ClusterManagementCommands,AsyncManagementCommands)
redis.commands.cluster.AsyncClusterManagementCommands.cluster_delslots(self,*slots:EncodableT)->List[bool]
redis.commands.cluster.AsyncClusterMultiKeyCommands(ClusterMultiKeyCommands)
redis.commands.cluster.AsyncClusterMultiKeyCommands._execute_pipeline_by_slot(self,command:str,slots_to_args:Mapping[int,Iterable[EncodableT]])->List[Any]
redis.commands.cluster.AsyncClusterMultiKeyCommands._split_command_across_slots(self,command:str,*keys:KeyT)->int
redis.commands.cluster.AsyncClusterMultiKeyCommands.mget_nonatomic(self,keys:KeysT,*args:KeyT)->List[Optional[Any]]
redis.commands.cluster.AsyncClusterMultiKeyCommands.mset_nonatomic(self,mapping:Mapping[AnyKeyT,EncodableT])->List[bool]
redis.commands.cluster.AsyncRedisClusterCommands(AsyncClusterMultiKeyCommands,AsyncClusterManagementCommands,AsyncACLCommands,AsyncClusterDataAccessCommands,AsyncScriptCommands,AsyncFunctionCommands,AsyncModuleCommands,AsyncRedisModuleCommands)
redis.commands.cluster.ClusterDataAccessCommands(DataAccessCommands)
redis.commands.cluster.ClusterDataAccessCommands.scan_iter(self,match:Optional[PatternT]=None,count:Optional[int]=None,_type:Optional[str]=None,**kwargs)->Iterator
redis.commands.cluster.ClusterDataAccessCommands.stralgo(self,algo:Literal['LCS'],value1:KeyT,value2:KeyT,specific_argument:Union[Literal['strings'],Literal['keys']]='strings',len:bool=False,idx:bool=False,minmatchlen:Optional[int]=None,withmatchlen:bool=False,**kwargs)->ResponseT
redis.commands.cluster.ClusterManagementCommands(ManagementCommands)
redis.commands.cluster.ClusterManagementCommands.cluster_addslots(self,target_node:'TargetNodesT',*slots:EncodableT)->ResponseT
redis.commands.cluster.ClusterManagementCommands.cluster_addslotsrange(self,target_node:'TargetNodesT',*slots:EncodableT)->ResponseT
redis.commands.cluster.ClusterManagementCommands.cluster_bumpepoch(self,target_nodes:Optional['TargetNodesT']=None)->None
redis.commands.cluster.ClusterManagementCommands.cluster_count_failure_report(self,node_id:str)->ResponseT
redis.commands.cluster.ClusterManagementCommands.cluster_countkeysinslot(self,slot_id:int)->ResponseT
redis.commands.cluster.ClusterManagementCommands.cluster_delslots(self,*slots:EncodableT)->List[bool]
redis.commands.cluster.ClusterManagementCommands.cluster_delslotsrange(self,*slots:EncodableT)->ResponseT
redis.commands.cluster.ClusterManagementCommands.cluster_failover(self,target_node:'TargetNodesT',option:Optional[str]=None)->ResponseT
redis.commands.cluster.ClusterManagementCommands.cluster_flushslots(self,target_nodes:Optional['TargetNodesT']=None)->None
redis.commands.cluster.ClusterManagementCommands.cluster_get_keys_in_slot(self,slot:int,num_keys:int)->ResponseT
redis.commands.cluster.ClusterManagementCommands.cluster_info(self,target_nodes:Optional['TargetNodesT']=None)->ResponseT
redis.commands.cluster.ClusterManagementCommands.cluster_keyslot(self,key:str)->ResponseT
redis.commands.cluster.ClusterManagementCommands.cluster_links(self,target_node:'TargetNodesT')->ResponseT
redis.commands.cluster.ClusterManagementCommands.cluster_meet(self,host:str,port:int,target_nodes:Optional['TargetNodesT']=None)->ResponseT
redis.commands.cluster.ClusterManagementCommands.cluster_myid(self,target_node:'TargetNodesT')->ResponseT
redis.commands.cluster.ClusterManagementCommands.cluster_myshardid(self,target_nodes=None)
redis.commands.cluster.ClusterManagementCommands.cluster_nodes(self)->ResponseT
redis.commands.cluster.ClusterManagementCommands.cluster_replicas(self,node_id:str,target_nodes:Optional['TargetNodesT']=None)->ResponseT
redis.commands.cluster.ClusterManagementCommands.cluster_replicate(self,target_nodes:'TargetNodesT',node_id:str)->ResponseT
redis.commands.cluster.ClusterManagementCommands.cluster_reset(self,soft:bool=True,target_nodes:Optional['TargetNodesT']=None)->ResponseT
redis.commands.cluster.ClusterManagementCommands.cluster_save_config(self,target_nodes:Optional['TargetNodesT']=None)->ResponseT
redis.commands.cluster.ClusterManagementCommands.cluster_set_config_epoch(self,epoch:int,target_nodes:Optional['TargetNodesT']=None)->ResponseT
redis.commands.cluster.ClusterManagementCommands.cluster_setslot(self,target_node:'TargetNodesT',node_id:str,slot_id:int,state:str)->ResponseT
redis.commands.cluster.ClusterManagementCommands.cluster_setslot_stable(self,slot_id:int)->ResponseT
redis.commands.cluster.ClusterManagementCommands.cluster_shards(self,target_nodes=None)
redis.commands.cluster.ClusterManagementCommands.cluster_slots(self,target_nodes:Optional['TargetNodesT']=None)->ResponseT
redis.commands.cluster.ClusterManagementCommands.readonly(self,target_nodes:Optional['TargetNodesT']=None)->ResponseT
redis.commands.cluster.ClusterManagementCommands.readwrite(self,target_nodes:Optional['TargetNodesT']=None)->ResponseT
redis.commands.cluster.ClusterManagementCommands.replicaof(self,*args,**kwargs)->NoReturn
redis.commands.cluster.ClusterManagementCommands.slaveof(self,*args,**kwargs)->NoReturn
redis.commands.cluster.ClusterManagementCommands.swapdb(self,*args,**kwargs)->NoReturn
redis.commands.cluster.ClusterMultiKeyCommands(ClusterCommandsProtocol)
redis.commands.cluster.ClusterMultiKeyCommands._execute_pipeline_by_slot(self,command:str,slots_to_args:Mapping[int,Iterable[EncodableT]])->List[Any]
redis.commands.cluster.ClusterMultiKeyCommands._partition_keys_by_slot(self,keys:Iterable[KeyT])->Dict[int, List[KeyT]]
redis.commands.cluster.ClusterMultiKeyCommands._partition_pairs_by_slot(self,mapping:Mapping[AnyKeyT,EncodableT])->Dict[int, List[EncodableT]]
redis.commands.cluster.ClusterMultiKeyCommands._reorder_keys_by_command(self,keys:Iterable[KeyT],slots_to_args:Mapping[int,Iterable[EncodableT]],responses:Iterable[Any])->List[Any]
redis.commands.cluster.ClusterMultiKeyCommands._split_command_across_slots(self,command:str,*keys:KeyT)->int
redis.commands.cluster.ClusterMultiKeyCommands.delete(self,*keys:KeyT)->ResponseT
redis.commands.cluster.ClusterMultiKeyCommands.exists(self,*keys:KeyT)->ResponseT
redis.commands.cluster.ClusterMultiKeyCommands.mget_nonatomic(self,keys:KeysT,*args:KeyT)->List[Optional[Any]]
redis.commands.cluster.ClusterMultiKeyCommands.mset_nonatomic(self,mapping:Mapping[AnyKeyT,EncodableT])->List[bool]
redis.commands.cluster.ClusterMultiKeyCommands.touch(self,*keys:KeyT)->ResponseT
redis.commands.cluster.ClusterMultiKeyCommands.unlink(self,*keys:KeyT)->ResponseT
redis.commands.cluster.RedisClusterCommands(ClusterMultiKeyCommands,ClusterManagementCommands,ACLCommands,PubSubCommands,ClusterDataAccessCommands,ScriptCommands,FunctionCommands,ModuleCommands,RedisModuleCommands)


----------------------------------------/dataset/nuaa/anaconda3/envs/redis6.1.1/lib/python3.9/site-packages/redis/commands/sentinel.py----------------------------------------
redis.commands.AsyncSentinelCommands(SentinelCommands)
redis.commands.AsyncSentinelCommands.sentinel(self,*args)->None
redis.commands.SentinelCommands
redis.commands.SentinelCommands.sentinel(self,*args)
redis.commands.SentinelCommands.sentinel_ckquorum(self,new_master_name)
redis.commands.SentinelCommands.sentinel_failover(self,new_master_name)
redis.commands.SentinelCommands.sentinel_flushconfig(self)
redis.commands.SentinelCommands.sentinel_get_master_addr_by_name(self,service_name)
redis.commands.SentinelCommands.sentinel_master(self,service_name)
redis.commands.SentinelCommands.sentinel_masters(self)
redis.commands.SentinelCommands.sentinel_monitor(self,name,ip,port,quorum)
redis.commands.SentinelCommands.sentinel_remove(self,name)
redis.commands.SentinelCommands.sentinel_reset(self,pattern)
redis.commands.SentinelCommands.sentinel_sentinels(self,service_name)
redis.commands.SentinelCommands.sentinel_set(self,name,option,value)
redis.commands.SentinelCommands.sentinel_slaves(self,service_name)
redis.commands.sentinel.AsyncSentinelCommands(SentinelCommands)
redis.commands.sentinel.AsyncSentinelCommands.sentinel(self,*args)->None
redis.commands.sentinel.SentinelCommands
redis.commands.sentinel.SentinelCommands.sentinel(self,*args)
redis.commands.sentinel.SentinelCommands.sentinel_ckquorum(self,new_master_name)
redis.commands.sentinel.SentinelCommands.sentinel_failover(self,new_master_name)
redis.commands.sentinel.SentinelCommands.sentinel_flushconfig(self)
redis.commands.sentinel.SentinelCommands.sentinel_get_master_addr_by_name(self,service_name)
redis.commands.sentinel.SentinelCommands.sentinel_master(self,service_name)
redis.commands.sentinel.SentinelCommands.sentinel_masters(self)
redis.commands.sentinel.SentinelCommands.sentinel_monitor(self,name,ip,port,quorum)
redis.commands.sentinel.SentinelCommands.sentinel_remove(self,name)
redis.commands.sentinel.SentinelCommands.sentinel_reset(self,pattern)
redis.commands.sentinel.SentinelCommands.sentinel_sentinels(self,service_name)
redis.commands.sentinel.SentinelCommands.sentinel_set(self,name,option,value)
redis.commands.sentinel.SentinelCommands.sentinel_slaves(self,service_name)


----------------------------------------/dataset/nuaa/anaconda3/envs/redis6.1.1/lib/python3.9/site-packages/redis/commands/json/__init__.py----------------------------------------
A:redis.commands.json.__init__.x->self.__decoder__.decode(obj)
A:redis.commands.json.__init__.p->Pipeline(connection_pool=self.client.connection_pool, response_callbacks=self._MODULE_CALLBACKS, transaction=transaction, shard_hint=shard_hint)
redis.commands.json.__init__.ClusterPipeline(JSONCommands,redis.cluster.ClusterPipeline)
redis.commands.json.__init__.JSON(self,client,version=None,decoder=JSONDecoder(),encoder=JSONEncoder())
redis.commands.json.__init__.JSON.__init__(self,client,version=None,decoder=JSONDecoder(),encoder=JSONEncoder())
redis.commands.json.__init__.JSON._decode(self,obj)
redis.commands.json.__init__.JSON._encode(self,obj)
redis.commands.json.__init__.JSON.pipeline(self,transaction=True,shard_hint=None)
redis.commands.json.__init__.Pipeline(JSONCommands,redis.client.Pipeline)


----------------------------------------/dataset/nuaa/anaconda3/envs/redis6.1.1/lib/python3.9/site-packages/redis/commands/json/_util.py----------------------------------------


----------------------------------------/dataset/nuaa/anaconda3/envs/redis6.1.1/lib/python3.9/site-packages/redis/commands/json/decoders.py----------------------------------------
A:redis.commands.json.decoders.b[index]->d(item)
A:redis.commands.json.decoders.newobj->copy.copy(obj)
A:redis.commands.json.decoders.match->re.findall(intreg, obj)
redis.commands.json.bulk_of_jsons(d)
redis.commands.json.decode_list(b)
redis.commands.json.decoders.bulk_of_jsons(d)
redis.commands.json.decoders.decode_dict_keys(obj)
redis.commands.json.decoders.decode_list(b)
redis.commands.json.decoders.unstring(obj)


----------------------------------------/dataset/nuaa/anaconda3/envs/redis6.1.1/lib/python3.9/site-packages/redis/commands/json/commands.py----------------------------------------
A:redis.commands.json.commands.obj->decode_dict_keys(obj)
A:redis.commands.json.commands.file_content->loads(fp.read())
A:redis.commands.json.commands.file_path->os.path.join(root, file)
redis.commands.json.JSONCommands
redis.commands.json.JSONCommands.arrappend(self,name:str,path:Optional[str]=Path.root_path(),*args:List[JsonType])->List[Optional[int]]
redis.commands.json.JSONCommands.arrindex(self,name:str,path:str,scalar:int,start:Optional[int]=None,stop:Optional[int]=None)->List[Optional[int]]
redis.commands.json.JSONCommands.arrinsert(self,name:str,path:str,index:int,*args:List[JsonType])->List[Optional[int]]
redis.commands.json.JSONCommands.arrlen(self,name:str,path:Optional[str]=Path.root_path())->List[Optional[int]]
redis.commands.json.JSONCommands.arrpop(self,name:str,path:Optional[str]=Path.root_path(),index:Optional[int]=-1)->List[Optional[str]]
redis.commands.json.JSONCommands.arrtrim(self,name:str,path:str,start:int,stop:int)->List[Optional[int]]
redis.commands.json.JSONCommands.clear(self,name:str,path:Optional[str]=Path.root_path())->int
redis.commands.json.JSONCommands.debug(self,subcommand:str,key:Optional[str]=None,path:Optional[str]=Path.root_path())->Union[int, List[str]]
redis.commands.json.JSONCommands.delete(self,key:str,path:Optional[str]=Path.root_path())->int
redis.commands.json.JSONCommands.get(self,name:str,*args,no_escape:Optional[bool]=False)->Optional[List[JsonType]]
redis.commands.json.JSONCommands.jsonget(self,*args,**kwargs)
redis.commands.json.JSONCommands.jsonmget(self,*args,**kwargs)
redis.commands.json.JSONCommands.jsonset(self,*args,**kwargs)
redis.commands.json.JSONCommands.merge(self,name:str,path:str,obj:JsonType,decode_keys:Optional[bool]=False)->Optional[str]
redis.commands.json.JSONCommands.mget(self,keys:List[str],path:str)->List[JsonType]
redis.commands.json.JSONCommands.mset(self,triplets:List[Tuple[str,str,JsonType]])->Optional[str]
redis.commands.json.JSONCommands.numincrby(self,name:str,path:str,number:int)->str
redis.commands.json.JSONCommands.nummultby(self,name:str,path:str,number:int)->str
redis.commands.json.JSONCommands.objkeys(self,name:str,path:Optional[str]=Path.root_path())->List[Optional[List[str]]]
redis.commands.json.JSONCommands.objlen(self,name:str,path:Optional[str]=Path.root_path())->List[Optional[int]]
redis.commands.json.JSONCommands.resp(self,name:str,path:Optional[str]=Path.root_path())->List
redis.commands.json.JSONCommands.set(self,name:str,path:str,obj:JsonType,nx:Optional[bool]=False,xx:Optional[bool]=False,decode_keys:Optional[bool]=False)->Optional[str]
redis.commands.json.JSONCommands.set_file(self,name:str,path:str,file_name:str,nx:Optional[bool]=False,xx:Optional[bool]=False,decode_keys:Optional[bool]=False)->Optional[str]
redis.commands.json.JSONCommands.set_path(self,json_path:str,root_folder:str,nx:Optional[bool]=False,xx:Optional[bool]=False,decode_keys:Optional[bool]=False)->Dict[str, bool]
redis.commands.json.JSONCommands.strappend(self,name:str,value:str,path:Optional[str]=Path.root_path())->Union[int, List[Optional[int]]]
redis.commands.json.JSONCommands.strlen(self,name:str,path:Optional[str]=None)->List[Optional[int]]
redis.commands.json.JSONCommands.toggle(self,name:str,path:Optional[str]=Path.root_path())->Union[bool, List[Optional[int]]]
redis.commands.json.JSONCommands.type(self,name:str,path:Optional[str]=Path.root_path())->List[str]
redis.commands.json.commands.JSONCommands
redis.commands.json.commands.JSONCommands.arrappend(self,name:str,path:Optional[str]=Path.root_path(),*args:List[JsonType])->List[Optional[int]]
redis.commands.json.commands.JSONCommands.arrindex(self,name:str,path:str,scalar:int,start:Optional[int]=None,stop:Optional[int]=None)->List[Optional[int]]
redis.commands.json.commands.JSONCommands.arrinsert(self,name:str,path:str,index:int,*args:List[JsonType])->List[Optional[int]]
redis.commands.json.commands.JSONCommands.arrlen(self,name:str,path:Optional[str]=Path.root_path())->List[Optional[int]]
redis.commands.json.commands.JSONCommands.arrpop(self,name:str,path:Optional[str]=Path.root_path(),index:Optional[int]=-1)->List[Optional[str]]
redis.commands.json.commands.JSONCommands.arrtrim(self,name:str,path:str,start:int,stop:int)->List[Optional[int]]
redis.commands.json.commands.JSONCommands.clear(self,name:str,path:Optional[str]=Path.root_path())->int
redis.commands.json.commands.JSONCommands.debug(self,subcommand:str,key:Optional[str]=None,path:Optional[str]=Path.root_path())->Union[int, List[str]]
redis.commands.json.commands.JSONCommands.delete(self,key:str,path:Optional[str]=Path.root_path())->int
redis.commands.json.commands.JSONCommands.get(self,name:str,*args,no_escape:Optional[bool]=False)->Optional[List[JsonType]]
redis.commands.json.commands.JSONCommands.jsonget(self,*args,**kwargs)
redis.commands.json.commands.JSONCommands.jsonmget(self,*args,**kwargs)
redis.commands.json.commands.JSONCommands.jsonset(self,*args,**kwargs)
redis.commands.json.commands.JSONCommands.merge(self,name:str,path:str,obj:JsonType,decode_keys:Optional[bool]=False)->Optional[str]
redis.commands.json.commands.JSONCommands.mget(self,keys:List[str],path:str)->List[JsonType]
redis.commands.json.commands.JSONCommands.mset(self,triplets:List[Tuple[str,str,JsonType]])->Optional[str]
redis.commands.json.commands.JSONCommands.numincrby(self,name:str,path:str,number:int)->str
redis.commands.json.commands.JSONCommands.nummultby(self,name:str,path:str,number:int)->str
redis.commands.json.commands.JSONCommands.objkeys(self,name:str,path:Optional[str]=Path.root_path())->List[Optional[List[str]]]
redis.commands.json.commands.JSONCommands.objlen(self,name:str,path:Optional[str]=Path.root_path())->List[Optional[int]]
redis.commands.json.commands.JSONCommands.resp(self,name:str,path:Optional[str]=Path.root_path())->List
redis.commands.json.commands.JSONCommands.set(self,name:str,path:str,obj:JsonType,nx:Optional[bool]=False,xx:Optional[bool]=False,decode_keys:Optional[bool]=False)->Optional[str]
redis.commands.json.commands.JSONCommands.set_file(self,name:str,path:str,file_name:str,nx:Optional[bool]=False,xx:Optional[bool]=False,decode_keys:Optional[bool]=False)->Optional[str]
redis.commands.json.commands.JSONCommands.set_path(self,json_path:str,root_folder:str,nx:Optional[bool]=False,xx:Optional[bool]=False,decode_keys:Optional[bool]=False)->Dict[str, bool]
redis.commands.json.commands.JSONCommands.strappend(self,name:str,value:str,path:Optional[str]=Path.root_path())->Union[int, List[Optional[int]]]
redis.commands.json.commands.JSONCommands.strlen(self,name:str,path:Optional[str]=None)->List[Optional[int]]
redis.commands.json.commands.JSONCommands.toggle(self,name:str,path:Optional[str]=Path.root_path())->Union[bool, List[Optional[int]]]
redis.commands.json.commands.JSONCommands.type(self,name:str,path:Optional[str]=Path.root_path())->List[str]


----------------------------------------/dataset/nuaa/anaconda3/envs/redis6.1.1/lib/python3.9/site-packages/redis/commands/json/path.py----------------------------------------
redis.commands.json.path.Path(self,path)
redis.commands.json.path.Path.__init__(self,path)
redis.commands.json.path.Path.__repr__(self)
redis.commands.json.path.Path.root_path()


----------------------------------------/dataset/nuaa/anaconda3/envs/redis6.1.1/lib/python3.9/site-packages/redis/commands/search/profile_information.py----------------------------------------
redis.commands.search.profile_information.ProfileInformation(self,info:Any)
redis.commands.search.profile_information.ProfileInformation.__init__(self,info:Any)
redis.commands.search.profile_information.ProfileInformation.info(self)->Any


----------------------------------------/dataset/nuaa/anaconda3/envs/redis6.1.1/lib/python3.9/site-packages/redis/commands/search/__init__.py----------------------------------------
A:redis.commands.search.__init__.self._pipeline->client.pipeline(transaction=False, shard_hint=None)
A:redis.commands.search.__init__.p->AsyncPipeline(connection_pool=self.client.connection_pool, response_callbacks=self._MODULE_CALLBACKS, transaction=transaction, shard_hint=shard_hint)
redis.commands.search.__init__.AsyncPipeline(AsyncSearchCommands,AsyncioPipeline,Pipeline)
redis.commands.search.__init__.AsyncSearch(Search,AsyncSearchCommands)
redis.commands.search.__init__.AsyncSearch.BatchIndexer(Search.BatchIndexer)
redis.commands.search.__init__.AsyncSearch.BatchIndexer.add_document(self,doc_id,nosave=False,score=1.0,payload=None,replace=False,partial=False,no_create=False,**fields)
redis.commands.search.__init__.AsyncSearch.BatchIndexer.commit(self)
redis.commands.search.__init__.AsyncSearch.pipeline(self,transaction=True,shard_hint=None)
redis.commands.search.__init__.Pipeline(SearchCommands,redis.client.Pipeline)
redis.commands.search.__init__.Search(self,client,index_name='idx')
redis.commands.search.__init__.Search.BatchIndexer(self,client,chunk_size=1000)
redis.commands.search.__init__.Search.BatchIndexer.__del__(self)
redis.commands.search.__init__.Search.BatchIndexer.__init__(self,client,chunk_size=1000)
redis.commands.search.__init__.Search.BatchIndexer.add_document(self,doc_id,nosave=False,score=1.0,payload=None,replace=False,partial=False,no_create=False,**fields)
redis.commands.search.__init__.Search.BatchIndexer.add_document_hash(self,doc_id,score=1.0,replace=False)
redis.commands.search.__init__.Search.BatchIndexer.commit(self)
redis.commands.search.__init__.Search.__init__(self,client,index_name='idx')
redis.commands.search.__init__.Search.pipeline(self,transaction=True,shard_hint=None)


----------------------------------------/dataset/nuaa/anaconda3/envs/redis6.1.1/lib/python3.9/site-packages/redis/commands/search/querystring.py----------------------------------------
A:redis.commands.search.querystring.self.v->str(v)
A:redis.commands.search.querystring.curvals->kvparams.setdefault(k, [])
A:redis.commands.search.querystring.s->BaseNode(f'@{key}:({self.JOINSTR.join((v.to_string() for v in vals))})')
A:redis.commands.search.querystring.with_parens->self._should_use_paren(with_parens)
A:redis.commands.search.querystring.self.s->str(s)
A:redis.commands.search.querystring.ret->super().to_string(with_parens=False)
redis.commands.search.querystring.BaseNode(self,s)
redis.commands.search.querystring.BaseNode.__init__(self,s)
redis.commands.search.querystring.BaseNode.to_string(self,with_parens=None)
redis.commands.search.querystring.DisjunctNode(IntersectNode)
redis.commands.search.querystring.DisjunctNode.to_string(self,with_parens=None)
redis.commands.search.querystring.DistjunctUnion(DisjunctNode)
redis.commands.search.querystring.GeoValue(self,lon,lat,radius,unit='km')
redis.commands.search.querystring.GeoValue.__init__(self,lon,lat,radius,unit='km')
redis.commands.search.querystring.GeoValue.to_string(self)
redis.commands.search.querystring.IntersectNode(Node)
redis.commands.search.querystring.Node(self,*children,**kwparams)
redis.commands.search.querystring.Node.JOINSTR(self)
redis.commands.search.querystring.Node.__init__(self,*children,**kwparams)
redis.commands.search.querystring.Node.__str__(self)
redis.commands.search.querystring.Node._should_use_paren(self,optval)
redis.commands.search.querystring.Node.join_fields(self,key,vals)
redis.commands.search.querystring.Node.to_node(cls,obj)
redis.commands.search.querystring.Node.to_string(self,with_parens=None)
redis.commands.search.querystring.OptionalNode(IntersectNode)
redis.commands.search.querystring.OptionalNode.to_string(self,with_parens=None)
redis.commands.search.querystring.RangeValue(self,a,b,inclusive_min=False,inclusive_max=False)
redis.commands.search.querystring.RangeValue.__init__(self,a,b,inclusive_min=False,inclusive_max=False)
redis.commands.search.querystring.RangeValue.to_string(self)
redis.commands.search.querystring.ScalarValue(self,v)
redis.commands.search.querystring.ScalarValue.__init__(self,v)
redis.commands.search.querystring.ScalarValue.to_string(self)
redis.commands.search.querystring.TagValue(self,*tags)
redis.commands.search.querystring.TagValue.__init__(self,*tags)
redis.commands.search.querystring.TagValue.to_string(self)
redis.commands.search.querystring.UnionNode(Node)
redis.commands.search.querystring.Value
redis.commands.search.querystring.Value.__str__(self)
redis.commands.search.querystring.Value.combinable(self)
redis.commands.search.querystring.Value.make_value(v)
redis.commands.search.querystring.Value.to_string(self)
redis.commands.search.querystring.between(a,b,inclusive_min=True,inclusive_max=True)
redis.commands.search.querystring.disjunct(*args,**kwargs)
redis.commands.search.querystring.disjunct_union(*args,**kwargs)
redis.commands.search.querystring.equal(n)
redis.commands.search.querystring.ge(n)
redis.commands.search.querystring.geo(lat,lon,radius,unit='km')
redis.commands.search.querystring.gt(n)
redis.commands.search.querystring.intersect(*args,**kwargs)
redis.commands.search.querystring.le(n)
redis.commands.search.querystring.lt(n)
redis.commands.search.querystring.querystring(*args,**kwargs)
redis.commands.search.querystring.tags(*t)
redis.commands.search.querystring.union(*args,**kwargs)


----------------------------------------/dataset/nuaa/anaconda3/envs/redis6.1.1/lib/python3.9/site-packages/redis/commands/search/_util.py----------------------------------------
redis.commands.search._util.to_string(s,encoding:str='utf-8')


----------------------------------------/dataset/nuaa/anaconda3/envs/redis6.1.1/lib/python3.9/site-packages/redis/commands/search/result.py----------------------------------------
A:redis.commands.search.result.id->to_string(res[i])
A:redis.commands.search.result.keys->map(to_string, res[i + fields_offset][::2])
A:redis.commands.search.result.fields[key]->to_string(value, encoding=encoding)
redis.commands.search.result.Result(self,res,hascontent,duration=0,has_payload=False,with_scores=False,field_encodings:Optional[dict]=None)
redis.commands.search.result.Result.__init__(self,res,hascontent,duration=0,has_payload=False,with_scores=False,field_encodings:Optional[dict]=None)
redis.commands.search.result.Result.__repr__(self)->str


----------------------------------------/dataset/nuaa/anaconda3/envs/redis6.1.1/lib/python3.9/site-packages/redis/commands/search/suggestion.py----------------------------------------
A:redis.commands.search.suggestion.self.string->to_string(string)
A:redis.commands.search.suggestion.self.payload->to_string(payload)
redis.commands.search.suggestion.Suggestion(self,string:str,score:float=1.0,payload:Optional[str]=None)
redis.commands.search.suggestion.Suggestion.__init__(self,string:str,score:float=1.0,payload:Optional[str]=None)
redis.commands.search.suggestion.Suggestion.__repr__(self)->str
redis.commands.search.suggestion.SuggestionParser(self,with_scores:bool,with_payloads:bool,ret)
redis.commands.search.suggestion.SuggestionParser.__init__(self,with_scores:bool,with_payloads:bool,ret)
redis.commands.search.suggestion.SuggestionParser.__iter__(self)


----------------------------------------/dataset/nuaa/anaconda3/envs/redis6.1.1/lib/python3.9/site-packages/redis/commands/search/query.py----------------------------------------
A:redis.commands.search.query.fields->self._mk_field_list(fields)
A:redis.commands.search.query.self._sortby->SortbyField(field, asc)
redis.commands.search.query.Filter(self,keyword:str,field:str,*args:List[str])
redis.commands.search.query.Filter.__init__(self,keyword:str,field:str,*args:List[str])
redis.commands.search.query.GeoFilter(self,field:str,lon:float,lat:float,radius:float,unit:str=KILOMETERS)
redis.commands.search.query.GeoFilter.__init__(self,field:str,lon:float,lat:float,radius:float,unit:str=KILOMETERS)
redis.commands.search.query.NumericFilter(self,field:str,minval:Union[int,str],maxval:Union[int,str],minExclusive:bool=False,maxExclusive:bool=False)
redis.commands.search.query.NumericFilter.__init__(self,field:str,minval:Union[int,str],maxval:Union[int,str],minExclusive:bool=False,maxExclusive:bool=False)
redis.commands.search.query.Query(self,query_string:str)
redis.commands.search.query.Query.__init__(self,query_string:str)
redis.commands.search.query.Query._get_args_tags(self)->List[str]
redis.commands.search.query.Query._mk_field_list(self,fields:List[str])->List
redis.commands.search.query.Query.add_filter(self,flt:'Filter')->'Query'
redis.commands.search.query.Query.dialect(self,dialect:int)->'Query'
redis.commands.search.query.Query.expander(self,expander:str)->'Query'
redis.commands.search.query.Query.get_args(self)->List[str]
redis.commands.search.query.Query.highlight(self,fields:Optional[List[str]]=None,tags:Optional[List[str]]=None)->None
redis.commands.search.query.Query.in_order(self)->'Query'
redis.commands.search.query.Query.language(self,language:str)->'Query'
redis.commands.search.query.Query.limit_fields(self,*fields:List[str])->'Query'
redis.commands.search.query.Query.limit_ids(self,*ids)->'Query'
redis.commands.search.query.Query.no_content(self)->'Query'
redis.commands.search.query.Query.no_stopwords(self)->'Query'
redis.commands.search.query.Query.paging(self,offset:int,num:int)->'Query'
redis.commands.search.query.Query.query_string(self)->str
redis.commands.search.query.Query.return_field(self,field:str,as_field:Optional[str]=None,decode_field:Optional[bool]=True,encoding:Optional[str]='utf8')->'Query'
redis.commands.search.query.Query.return_fields(self,*fields)->'Query'
redis.commands.search.query.Query.scorer(self,scorer:str)->'Query'
redis.commands.search.query.Query.slop(self,slop:int)->'Query'
redis.commands.search.query.Query.sort_by(self,field:str,asc:bool=True)->'Query'
redis.commands.search.query.Query.summarize(self,fields:Optional[List]=None,context_len:Optional[int]=None,num_frags:Optional[int]=None,sep:Optional[str]=None)->'Query'
redis.commands.search.query.Query.timeout(self,timeout:float)->'Query'
redis.commands.search.query.Query.verbatim(self)->'Query'
redis.commands.search.query.Query.with_payloads(self)->'Query'
redis.commands.search.query.Query.with_scores(self)->'Query'
redis.commands.search.query.SortbyField(self,field:str,asc=True)
redis.commands.search.query.SortbyField.__init__(self,field:str,asc=True)


----------------------------------------/dataset/nuaa/anaconda3/envs/redis6.1.1/lib/python3.9/site-packages/redis/commands/search/dialect.py----------------------------------------


----------------------------------------/dataset/nuaa/anaconda3/envs/redis6.1.1/lib/python3.9/site-packages/redis/commands/search/field.py----------------------------------------
A:redis.commands.search.field.self.args_suffix->list()
A:redis.commands.search.field.sort->kwargs.get('sortable', False)
A:redis.commands.search.field.noindex->kwargs.get('no_index', False)
redis.commands.search.field.Field(self,name:str,args:List[str]=None,sortable:bool=False,no_index:bool=False,index_missing:bool=False,index_empty:bool=False,as_name:str=None)
redis.commands.search.field.Field.__init__(self,name:str,args:List[str]=None,sortable:bool=False,no_index:bool=False,index_missing:bool=False,index_empty:bool=False,as_name:str=None)
redis.commands.search.field.Field.append_arg(self,value)
redis.commands.search.field.Field.redis_args(self)
redis.commands.search.field.GeoField(self,name:str,**kwargs)
redis.commands.search.field.GeoField.__init__(self,name:str,**kwargs)
redis.commands.search.field.GeoShapeField(self,name:str,coord_system=None,**kwargs)
redis.commands.search.field.GeoShapeField.__init__(self,name:str,coord_system=None,**kwargs)
redis.commands.search.field.NumericField(self,name:str,**kwargs)
redis.commands.search.field.NumericField.__init__(self,name:str,**kwargs)
redis.commands.search.field.TagField(self,name:str,separator:str=',',case_sensitive:bool=False,withsuffixtrie:bool=False,**kwargs)
redis.commands.search.field.TagField.__init__(self,name:str,separator:str=',',case_sensitive:bool=False,withsuffixtrie:bool=False,**kwargs)
redis.commands.search.field.TextField(self,name:str,weight:float=1.0,no_stem:bool=False,phonetic_matcher:str=None,withsuffixtrie:bool=False,**kwargs)
redis.commands.search.field.TextField.__init__(self,name:str,weight:float=1.0,no_stem:bool=False,phonetic_matcher:str=None,withsuffixtrie:bool=False,**kwargs)
redis.commands.search.field.VectorField(self,name:str,algorithm:str,attributes:dict,**kwargs)
redis.commands.search.field.VectorField.__init__(self,name:str,algorithm:str,attributes:dict,**kwargs)


----------------------------------------/dataset/nuaa/anaconda3/envs/redis6.1.1/lib/python3.9/site-packages/redis/commands/search/aggregation.py----------------------------------------
A:redis.commands.search.aggregation.FIELDNAME->object()
A:redis.commands.search.aggregation._limit->Limit(offset, num)
A:redis.commands.search.aggregation.max->kwargs.get('max', 0)
redis.commands.search.aggregation.AggregateRequest(self,query:str='*')
redis.commands.search.aggregation.AggregateRequest.__init__(self,query:str='*')
redis.commands.search.aggregation.AggregateRequest.add_scores(self)->'AggregateRequest'
redis.commands.search.aggregation.AggregateRequest.apply(self,**kwexpr)->'AggregateRequest'
redis.commands.search.aggregation.AggregateRequest.build_args(self)->List[str]
redis.commands.search.aggregation.AggregateRequest.cursor(self,count:int=0,max_idle:float=0.0)->'AggregateRequest'
redis.commands.search.aggregation.AggregateRequest.dialect(self,dialect:int)->'AggregateRequest'
redis.commands.search.aggregation.AggregateRequest.filter(self,expressions:Union[str,List[str]])->'AggregateRequest'
redis.commands.search.aggregation.AggregateRequest.group_by(self,fields:List[str],*reducers:Union[Reducer,List[Reducer]])->'AggregateRequest'
redis.commands.search.aggregation.AggregateRequest.limit(self,offset:int,num:int)->'AggregateRequest'
redis.commands.search.aggregation.AggregateRequest.load(self,*fields:List[str])->'AggregateRequest'
redis.commands.search.aggregation.AggregateRequest.scorer(self,scorer:str)->'AggregateRequest'
redis.commands.search.aggregation.AggregateRequest.sort_by(self,*fields:List[str],**kwargs)->'AggregateRequest'
redis.commands.search.aggregation.AggregateRequest.verbatim(self)->'AggregateRequest'
redis.commands.search.aggregation.AggregateRequest.with_schema(self)->'AggregateRequest'
redis.commands.search.aggregation.AggregateResult(self,rows,cursor:Cursor,schema)
redis.commands.search.aggregation.AggregateResult.__init__(self,rows,cursor:Cursor,schema)
redis.commands.search.aggregation.AggregateResult.__repr__(self)->(str, str)
redis.commands.search.aggregation.Asc(SortDirection)
redis.commands.search.aggregation.Cursor(self,cid:int)
redis.commands.search.aggregation.Cursor.__init__(self,cid:int)
redis.commands.search.aggregation.Cursor.build_args(self)
redis.commands.search.aggregation.Desc(SortDirection)
redis.commands.search.aggregation.Limit(self,offset:int=0,count:int=0)
redis.commands.search.aggregation.Limit.__init__(self,offset:int=0,count:int=0)
redis.commands.search.aggregation.Limit.build_args(self)
redis.commands.search.aggregation.Reducer(self,*args:List[str])
redis.commands.search.aggregation.Reducer.__init__(self,*args:List[str])
redis.commands.search.aggregation.Reducer.alias(self,alias:str)->'Reducer'
redis.commands.search.aggregation.Reducer.args(self)->List[str]
redis.commands.search.aggregation.SortDirection(self,field:str)
redis.commands.search.aggregation.SortDirection.__init__(self,field:str)


----------------------------------------/dataset/nuaa/anaconda3/envs/redis6.1.1/lib/python3.9/site-packages/redis/commands/search/commands.py----------------------------------------
A:redis.commands.search.commands.it->map(to_string, res)
A:redis.commands.search.commands.result->Result(res[0], not query._no_content, duration=kwargs['duration'], has_payload=query._with_payloads, with_scores=query._with_scores)
A:redis.commands.search.commands.fields->self.client.hgetall(id)
A:redis.commands.search.commands.res->self.execute_command(SYNDUMP_CMD, self.index_name)
A:redis.commands.search.commands.query->Query(query)
A:redis.commands.search.commands.(args, query)->self._mk_query_args(query, query_params=query_params)
A:redis.commands.search.commands.st->time.monotonic()
A:redis.commands.search.commands.(args, query_text)->self._mk_query_args(query, query_params=query_params)
A:redis.commands.search.commands.has_cursor->bool(query._cursor)
A:redis.commands.search.commands.raw->self.execute_command(*cmd)
A:redis.commands.search.commands.cursor->Cursor(raw[1])
A:redis.commands.search.commands.pipe->self.pipeline(transaction=False)
A:redis.commands.search.commands.parser->SuggestionParser(with_scores, with_payloads, ret)
redis.commands.search.AsyncSearchCommands(SearchCommands)
redis.commands.search.AsyncSearchCommands.aggregate(self,query:Union[str,Query],query_params:Dict[str,Union[str,int,float]]=None)
redis.commands.search.AsyncSearchCommands.config_get(self,option:str)->str
redis.commands.search.AsyncSearchCommands.config_set(self,option:str,value:str)->bool
redis.commands.search.AsyncSearchCommands.info(self)
redis.commands.search.AsyncSearchCommands.load_document(self,id)
redis.commands.search.AsyncSearchCommands.search(self,query:Union[str,Query],query_params:Dict[str,Union[str,int,float]]=None)
redis.commands.search.AsyncSearchCommands.spellcheck(self,query,distance=None,include=None,exclude=None)
redis.commands.search.AsyncSearchCommands.sugadd(self,key,*suggestions,**kwargs)
redis.commands.search.AsyncSearchCommands.sugget(self,key:str,prefix:str,fuzzy:bool=False,num:int=10,with_scores:bool=False,with_payloads:bool=False)->List[SuggestionParser]
redis.commands.search.SearchCommands
redis.commands.search.SearchCommands._add_document(self,doc_id,conn=None,nosave=False,score=1.0,payload=None,replace=False,partial=False,language=None,no_create=False,**fields)
redis.commands.search.SearchCommands._add_document_hash(self,doc_id,conn=None,score=1.0,language=None,replace=False)
redis.commands.search.SearchCommands._get_aggregate_result(self,raw:List,query:Union[str,Query,AggregateRequest],has_cursor:bool)
redis.commands.search.SearchCommands._mk_query_args(self,query,query_params:Union[Dict[str,Union[str,int,float,bytes]],None])
redis.commands.search.SearchCommands._parse_aggregate(self,res,**kwargs)
redis.commands.search.SearchCommands._parse_config_get(self,res,**kwargs)
redis.commands.search.SearchCommands._parse_info(self,res,**kwargs)
redis.commands.search.SearchCommands._parse_profile(self,res,**kwargs)
redis.commands.search.SearchCommands._parse_results(self,cmd,res,**kwargs)
redis.commands.search.SearchCommands._parse_search(self,res,**kwargs)
redis.commands.search.SearchCommands._parse_spellcheck(self,res,**kwargs)
redis.commands.search.SearchCommands._parse_syndump(self,res,**kwargs)
redis.commands.search.SearchCommands.add_document(self,doc_id:str,nosave:bool=False,score:float=1.0,payload:bool=None,replace:bool=False,partial:bool=False,language:Optional[str]=None,no_create:str=False,**fields:List[str])
redis.commands.search.SearchCommands.add_document_hash(self,doc_id,score=1.0,language=None,replace=False)
redis.commands.search.SearchCommands.aggregate(self,query:Union[str,Query],query_params:Dict[str,Union[str,int,float]]=None)
redis.commands.search.SearchCommands.aliasadd(self,alias:str)
redis.commands.search.SearchCommands.aliasdel(self,alias:str)
redis.commands.search.SearchCommands.aliasupdate(self,alias:str)
redis.commands.search.SearchCommands.alter_schema_add(self,fields:List[str])
redis.commands.search.SearchCommands.batch_indexer(self,chunk_size=100)
redis.commands.search.SearchCommands.config_get(self,option:str)->str
redis.commands.search.SearchCommands.config_set(self,option:str,value:str)->bool
redis.commands.search.SearchCommands.create_index(self,fields:List[Field],no_term_offsets:bool=False,no_field_flags:bool=False,stopwords:Optional[List[str]]=None,definition:Optional[IndexDefinition]=None,max_text_fields=False,temporary=None,no_highlight:bool=False,no_term_frequencies:bool=False,skip_initial_scan:bool=False)
redis.commands.search.SearchCommands.delete_document(self,doc_id,conn=None,delete_actual_document=False)
redis.commands.search.SearchCommands.dict_add(self,name:str,*terms:List[str])
redis.commands.search.SearchCommands.dict_del(self,name:str,*terms:List[str])
redis.commands.search.SearchCommands.dict_dump(self,name:str)
redis.commands.search.SearchCommands.dropindex(self,delete_documents:bool=False)
redis.commands.search.SearchCommands.explain(self,query:Union[str,Query],query_params:Dict[str,Union[str,int,float]]=None)
redis.commands.search.SearchCommands.explain_cli(self,query:Union[str,Query])
redis.commands.search.SearchCommands.get(self,*ids)
redis.commands.search.SearchCommands.get_params_args(self,query_params:Union[Dict[str,Union[str,int,float,bytes]],None])
redis.commands.search.SearchCommands.info(self)
redis.commands.search.SearchCommands.load_document(self,id)
redis.commands.search.SearchCommands.profile(self,query:Union[Query,AggregateRequest],limited:bool=False,query_params:Optional[Dict[str,Union[str,int,float]]]=None)
redis.commands.search.SearchCommands.search(self,query:Union[str,Query],query_params:Union[Dict[str,Union[str,int,float,bytes]],None]=None)
redis.commands.search.SearchCommands.spellcheck(self,query,distance=None,include=None,exclude=None)
redis.commands.search.SearchCommands.sugadd(self,key,*suggestions,**kwargs)
redis.commands.search.SearchCommands.sugdel(self,key:str,string:str)->int
redis.commands.search.SearchCommands.sugget(self,key:str,prefix:str,fuzzy:bool=False,num:int=10,with_scores:bool=False,with_payloads:bool=False)->List[SuggestionParser]
redis.commands.search.SearchCommands.suglen(self,key:str)->int
redis.commands.search.SearchCommands.syndump(self)
redis.commands.search.SearchCommands.synupdate(self,groupid:str,skipinitial:bool=False,*terms:List[str])
redis.commands.search.SearchCommands.tagvals(self,tagfield:str)
redis.commands.search.commands.AsyncSearchCommands(SearchCommands)
redis.commands.search.commands.AsyncSearchCommands.aggregate(self,query:Union[str,Query],query_params:Dict[str,Union[str,int,float]]=None)
redis.commands.search.commands.AsyncSearchCommands.config_get(self,option:str)->str
redis.commands.search.commands.AsyncSearchCommands.config_set(self,option:str,value:str)->bool
redis.commands.search.commands.AsyncSearchCommands.info(self)
redis.commands.search.commands.AsyncSearchCommands.load_document(self,id)
redis.commands.search.commands.AsyncSearchCommands.search(self,query:Union[str,Query],query_params:Dict[str,Union[str,int,float]]=None)
redis.commands.search.commands.AsyncSearchCommands.spellcheck(self,query,distance=None,include=None,exclude=None)
redis.commands.search.commands.AsyncSearchCommands.sugadd(self,key,*suggestions,**kwargs)
redis.commands.search.commands.AsyncSearchCommands.sugget(self,key:str,prefix:str,fuzzy:bool=False,num:int=10,with_scores:bool=False,with_payloads:bool=False)->List[SuggestionParser]
redis.commands.search.commands.SearchCommands
redis.commands.search.commands.SearchCommands._add_document(self,doc_id,conn=None,nosave=False,score=1.0,payload=None,replace=False,partial=False,language=None,no_create=False,**fields)
redis.commands.search.commands.SearchCommands._add_document_hash(self,doc_id,conn=None,score=1.0,language=None,replace=False)
redis.commands.search.commands.SearchCommands._get_aggregate_result(self,raw:List,query:Union[str,Query,AggregateRequest],has_cursor:bool)
redis.commands.search.commands.SearchCommands._mk_query_args(self,query,query_params:Union[Dict[str,Union[str,int,float,bytes]],None])
redis.commands.search.commands.SearchCommands._parse_aggregate(self,res,**kwargs)
redis.commands.search.commands.SearchCommands._parse_config_get(self,res,**kwargs)
redis.commands.search.commands.SearchCommands._parse_info(self,res,**kwargs)
redis.commands.search.commands.SearchCommands._parse_profile(self,res,**kwargs)
redis.commands.search.commands.SearchCommands._parse_results(self,cmd,res,**kwargs)
redis.commands.search.commands.SearchCommands._parse_search(self,res,**kwargs)
redis.commands.search.commands.SearchCommands._parse_spellcheck(self,res,**kwargs)
redis.commands.search.commands.SearchCommands._parse_syndump(self,res,**kwargs)
redis.commands.search.commands.SearchCommands.add_document(self,doc_id:str,nosave:bool=False,score:float=1.0,payload:bool=None,replace:bool=False,partial:bool=False,language:Optional[str]=None,no_create:str=False,**fields:List[str])
redis.commands.search.commands.SearchCommands.add_document_hash(self,doc_id,score=1.0,language=None,replace=False)
redis.commands.search.commands.SearchCommands.aggregate(self,query:Union[str,Query],query_params:Dict[str,Union[str,int,float]]=None)
redis.commands.search.commands.SearchCommands.aliasadd(self,alias:str)
redis.commands.search.commands.SearchCommands.aliasdel(self,alias:str)
redis.commands.search.commands.SearchCommands.aliasupdate(self,alias:str)
redis.commands.search.commands.SearchCommands.alter_schema_add(self,fields:List[str])
redis.commands.search.commands.SearchCommands.batch_indexer(self,chunk_size=100)
redis.commands.search.commands.SearchCommands.config_get(self,option:str)->str
redis.commands.search.commands.SearchCommands.config_set(self,option:str,value:str)->bool
redis.commands.search.commands.SearchCommands.create_index(self,fields:List[Field],no_term_offsets:bool=False,no_field_flags:bool=False,stopwords:Optional[List[str]]=None,definition:Optional[IndexDefinition]=None,max_text_fields=False,temporary=None,no_highlight:bool=False,no_term_frequencies:bool=False,skip_initial_scan:bool=False)
redis.commands.search.commands.SearchCommands.delete_document(self,doc_id,conn=None,delete_actual_document=False)
redis.commands.search.commands.SearchCommands.dict_add(self,name:str,*terms:List[str])
redis.commands.search.commands.SearchCommands.dict_del(self,name:str,*terms:List[str])
redis.commands.search.commands.SearchCommands.dict_dump(self,name:str)
redis.commands.search.commands.SearchCommands.dropindex(self,delete_documents:bool=False)
redis.commands.search.commands.SearchCommands.explain(self,query:Union[str,Query],query_params:Dict[str,Union[str,int,float]]=None)
redis.commands.search.commands.SearchCommands.explain_cli(self,query:Union[str,Query])
redis.commands.search.commands.SearchCommands.get(self,*ids)
redis.commands.search.commands.SearchCommands.get_params_args(self,query_params:Union[Dict[str,Union[str,int,float,bytes]],None])
redis.commands.search.commands.SearchCommands.info(self)
redis.commands.search.commands.SearchCommands.load_document(self,id)
redis.commands.search.commands.SearchCommands.profile(self,query:Union[Query,AggregateRequest],limited:bool=False,query_params:Optional[Dict[str,Union[str,int,float]]]=None)
redis.commands.search.commands.SearchCommands.search(self,query:Union[str,Query],query_params:Union[Dict[str,Union[str,int,float,bytes]],None]=None)
redis.commands.search.commands.SearchCommands.spellcheck(self,query,distance=None,include=None,exclude=None)
redis.commands.search.commands.SearchCommands.sugadd(self,key,*suggestions,**kwargs)
redis.commands.search.commands.SearchCommands.sugdel(self,key:str,string:str)->int
redis.commands.search.commands.SearchCommands.sugget(self,key:str,prefix:str,fuzzy:bool=False,num:int=10,with_scores:bool=False,with_payloads:bool=False)->List[SuggestionParser]
redis.commands.search.commands.SearchCommands.suglen(self,key:str)->int
redis.commands.search.commands.SearchCommands.syndump(self)
redis.commands.search.commands.SearchCommands.synupdate(self,groupid:str,skipinitial:bool=False,*terms:List[str])
redis.commands.search.commands.SearchCommands.tagvals(self,tagfield:str)


----------------------------------------/dataset/nuaa/anaconda3/envs/redis6.1.1/lib/python3.9/site-packages/redis/commands/search/reducers.py----------------------------------------
redis.commands.search.reducers.FieldOnlyReducer(self,field:str)
redis.commands.search.reducers.FieldOnlyReducer.__init__(self,field:str)
redis.commands.search.reducers.avg(self,field:str)
redis.commands.search.reducers.avg.__init__(self,field:str)
redis.commands.search.reducers.count(self)
redis.commands.search.reducers.count.__init__(self)
redis.commands.search.reducers.count_distinct(self,field:str)
redis.commands.search.reducers.count_distinct.__init__(self,field:str)
redis.commands.search.reducers.count_distinctish(FieldOnlyReducer)
redis.commands.search.reducers.first_value(self,field:str,*byfields:Union[Asc,Desc])
redis.commands.search.reducers.first_value.__init__(self,field:str,*byfields:Union[Asc,Desc])
redis.commands.search.reducers.max(self,field:str)
redis.commands.search.reducers.max.__init__(self,field:str)
redis.commands.search.reducers.min(self,field:str)
redis.commands.search.reducers.min.__init__(self,field:str)
redis.commands.search.reducers.quantile(self,field:str,pct:float)
redis.commands.search.reducers.quantile.__init__(self,field:str,pct:float)
redis.commands.search.reducers.random_sample(self,field:str,size:int)
redis.commands.search.reducers.random_sample.__init__(self,field:str,size:int)
redis.commands.search.reducers.stddev(self,field:str)
redis.commands.search.reducers.stddev.__init__(self,field:str)
redis.commands.search.reducers.sum(self,field:str)
redis.commands.search.reducers.sum.__init__(self,field:str)
redis.commands.search.reducers.tolist(self,field:str)
redis.commands.search.reducers.tolist.__init__(self,field:str)


----------------------------------------/dataset/nuaa/anaconda3/envs/redis6.1.1/lib/python3.9/site-packages/redis/commands/search/document.py----------------------------------------
A:redis.commands.search.document.value->getattr(self, item)
redis.commands.search.document.Document(self,id,payload=None,**fields)
redis.commands.search.document.Document.__getitem__(self,item)
redis.commands.search.document.Document.__init__(self,id,payload=None,**fields)
redis.commands.search.document.Document.__repr__(self)


----------------------------------------/dataset/nuaa/anaconda3/envs/redis6.1.1/lib/python3.9/site-packages/redis/commands/search/index_definition.py----------------------------------------
redis.commands.search.index_definition.IndexDefinition(self,prefix=[],filter=None,language_field=None,language=None,score_field=None,score=1.0,payload_field=None,index_type=None)
redis.commands.search.index_definition.IndexDefinition.__init__(self,prefix=[],filter=None,language_field=None,language=None,score_field=None,score=1.0,payload_field=None,index_type=None)
redis.commands.search.index_definition.IndexDefinition._append_filter(self,filter)
redis.commands.search.index_definition.IndexDefinition._append_index_type(self,index_type)
redis.commands.search.index_definition.IndexDefinition._append_language(self,language_field,language)
redis.commands.search.index_definition.IndexDefinition._append_payload(self,payload_field)
redis.commands.search.index_definition.IndexDefinition._append_prefix(self,prefix)
redis.commands.search.index_definition.IndexDefinition._append_score(self,score_field,score)
redis.commands.search.index_definition.IndexType(Enum)


----------------------------------------/dataset/nuaa/anaconda3/envs/redis6.1.1/lib/python3.9/site-packages/redis/commands/bf/__init__.py----------------------------------------
redis.bf.__init__.AbstractBloom
redis.bf.__init__.AbstractBloom.append_bucket_size(params,bucket_size)
redis.bf.__init__.AbstractBloom.append_capacity(params,capacity)
redis.bf.__init__.AbstractBloom.append_error(params,error)
redis.bf.__init__.AbstractBloom.append_expansion(params,expansion)
redis.bf.__init__.AbstractBloom.append_items(params,items)
redis.bf.__init__.AbstractBloom.append_items_and_increments(params,items,increments)
redis.bf.__init__.AbstractBloom.append_max_iterations(params,max_iterations)
redis.bf.__init__.AbstractBloom.append_no_create(params,noCreate)
redis.bf.__init__.AbstractBloom.append_no_scale(params,noScale)
redis.bf.__init__.AbstractBloom.append_values_and_weights(params,items,weights)
redis.bf.__init__.AbstractBloom.append_weights(params,weights)
redis.bf.__init__.BFBloom(self,client,**kwargs)
redis.bf.__init__.CFBloom(self,client,**kwargs)
redis.bf.__init__.CMSBloom(self,client,**kwargs)
redis.bf.__init__.TDigestBloom(self,client,**kwargs)
redis.bf.__init__.TOPKBloom(self,client,**kwargs)
redis.commands.bf.__init__.AbstractBloom
redis.commands.bf.__init__.AbstractBloom.append_bucket_size(params,bucket_size)
redis.commands.bf.__init__.AbstractBloom.append_capacity(params,capacity)
redis.commands.bf.__init__.AbstractBloom.append_error(params,error)
redis.commands.bf.__init__.AbstractBloom.append_expansion(params,expansion)
redis.commands.bf.__init__.AbstractBloom.append_items(params,items)
redis.commands.bf.__init__.AbstractBloom.append_items_and_increments(params,items,increments)
redis.commands.bf.__init__.AbstractBloom.append_max_iterations(params,max_iterations)
redis.commands.bf.__init__.AbstractBloom.append_no_create(params,noCreate)
redis.commands.bf.__init__.AbstractBloom.append_no_scale(params,noScale)
redis.commands.bf.__init__.AbstractBloom.append_values_and_weights(params,items,weights)
redis.commands.bf.__init__.AbstractBloom.append_weights(params,weights)
redis.commands.bf.__init__.BFBloom(self,client,**kwargs)
redis.commands.bf.__init__.BFBloom.__init__(self,client,**kwargs)
redis.commands.bf.__init__.CFBloom(self,client,**kwargs)
redis.commands.bf.__init__.CFBloom.__init__(self,client,**kwargs)
redis.commands.bf.__init__.CMSBloom(self,client,**kwargs)
redis.commands.bf.__init__.CMSBloom.__init__(self,client,**kwargs)
redis.commands.bf.__init__.TDigestBloom(self,client,**kwargs)
redis.commands.bf.__init__.TDigestBloom.__init__(self,client,**kwargs)
redis.commands.bf.__init__.TOPKBloom(self,client,**kwargs)
redis.commands.bf.__init__.TOPKBloom.__init__(self,client,**kwargs)


----------------------------------------/dataset/nuaa/anaconda3/envs/redis6.1.1/lib/python3.9/site-packages/redis/commands/bf/commands.py----------------------------------------
redis.bf.BFCommands
redis.bf.BFCommands.add(self,key,item)
redis.bf.BFCommands.card(self,key)
redis.bf.BFCommands.create(self,key,errorRate,capacity,expansion=None,noScale=None)
redis.bf.BFCommands.exists(self,key,item)
redis.bf.BFCommands.info(self,key)
redis.bf.BFCommands.insert(self,key,items,capacity=None,error=None,noCreate=None,expansion=None,noScale=None)
redis.bf.BFCommands.loadchunk(self,key,iter,data)
redis.bf.BFCommands.madd(self,key,*items)
redis.bf.BFCommands.mexists(self,key,*items)
redis.bf.BFCommands.scandump(self,key,iter)
redis.bf.CFCommands
redis.bf.CFCommands.add(self,key,item)
redis.bf.CFCommands.addnx(self,key,item)
redis.bf.CFCommands.count(self,key,item)
redis.bf.CFCommands.create(self,key,capacity,expansion=None,bucket_size=None,max_iterations=None)
redis.bf.CFCommands.delete(self,key,item)
redis.bf.CFCommands.exists(self,key,item)
redis.bf.CFCommands.info(self,key)
redis.bf.CFCommands.insert(self,key,items,capacity=None,nocreate=None)
redis.bf.CFCommands.insertnx(self,key,items,capacity=None,nocreate=None)
redis.bf.CFCommands.loadchunk(self,key,iter,data)
redis.bf.CFCommands.mexists(self,key,*items)
redis.bf.CFCommands.scandump(self,key,iter)
redis.bf.CMSCommands
redis.bf.CMSCommands.incrby(self,key,items,increments)
redis.bf.CMSCommands.info(self,key)
redis.bf.CMSCommands.initbydim(self,key,width,depth)
redis.bf.CMSCommands.initbyprob(self,key,error,probability)
redis.bf.CMSCommands.merge(self,destKey,numKeys,srcKeys,weights=[])
redis.bf.CMSCommands.query(self,key,*items)
redis.bf.TDigestCommands
redis.bf.TDigestCommands.add(self,key,values)
redis.bf.TDigestCommands.byrank(self,key,rank,*ranks)
redis.bf.TDigestCommands.byrevrank(self,key,rank,*ranks)
redis.bf.TDigestCommands.cdf(self,key,value,*values)
redis.bf.TDigestCommands.create(self,key,compression=100)
redis.bf.TDigestCommands.info(self,key)
redis.bf.TDigestCommands.max(self,key)
redis.bf.TDigestCommands.merge(self,destination_key,num_keys,*keys,compression=None,override=False)
redis.bf.TDigestCommands.min(self,key)
redis.bf.TDigestCommands.quantile(self,key,quantile,*quantiles)
redis.bf.TDigestCommands.rank(self,key,value,*values)
redis.bf.TDigestCommands.reset(self,key)
redis.bf.TDigestCommands.revrank(self,key,value,*values)
redis.bf.TDigestCommands.trimmed_mean(self,key,low_cut_quantile,high_cut_quantile)
redis.bf.TOPKCommands
redis.bf.TOPKCommands.add(self,key,*items)
redis.bf.TOPKCommands.count(self,key,*items)
redis.bf.TOPKCommands.incrby(self,key,items,increments)
redis.bf.TOPKCommands.info(self,key)
redis.bf.TOPKCommands.list(self,key,withcount=False)
redis.bf.TOPKCommands.query(self,key,*items)
redis.bf.TOPKCommands.reserve(self,key,k,width,depth,decay)
redis.commands.bf.commands.BFCommands
redis.commands.bf.commands.BFCommands.add(self,key,item)
redis.commands.bf.commands.BFCommands.card(self,key)
redis.commands.bf.commands.BFCommands.create(self,key,errorRate,capacity,expansion=None,noScale=None)
redis.commands.bf.commands.BFCommands.exists(self,key,item)
redis.commands.bf.commands.BFCommands.info(self,key)
redis.commands.bf.commands.BFCommands.insert(self,key,items,capacity=None,error=None,noCreate=None,expansion=None,noScale=None)
redis.commands.bf.commands.BFCommands.loadchunk(self,key,iter,data)
redis.commands.bf.commands.BFCommands.madd(self,key,*items)
redis.commands.bf.commands.BFCommands.mexists(self,key,*items)
redis.commands.bf.commands.BFCommands.scandump(self,key,iter)
redis.commands.bf.commands.CFCommands
redis.commands.bf.commands.CFCommands.add(self,key,item)
redis.commands.bf.commands.CFCommands.addnx(self,key,item)
redis.commands.bf.commands.CFCommands.count(self,key,item)
redis.commands.bf.commands.CFCommands.create(self,key,capacity,expansion=None,bucket_size=None,max_iterations=None)
redis.commands.bf.commands.CFCommands.delete(self,key,item)
redis.commands.bf.commands.CFCommands.exists(self,key,item)
redis.commands.bf.commands.CFCommands.info(self,key)
redis.commands.bf.commands.CFCommands.insert(self,key,items,capacity=None,nocreate=None)
redis.commands.bf.commands.CFCommands.insertnx(self,key,items,capacity=None,nocreate=None)
redis.commands.bf.commands.CFCommands.loadchunk(self,key,iter,data)
redis.commands.bf.commands.CFCommands.mexists(self,key,*items)
redis.commands.bf.commands.CFCommands.scandump(self,key,iter)
redis.commands.bf.commands.CMSCommands
redis.commands.bf.commands.CMSCommands.incrby(self,key,items,increments)
redis.commands.bf.commands.CMSCommands.info(self,key)
redis.commands.bf.commands.CMSCommands.initbydim(self,key,width,depth)
redis.commands.bf.commands.CMSCommands.initbyprob(self,key,error,probability)
redis.commands.bf.commands.CMSCommands.merge(self,destKey,numKeys,srcKeys,weights=[])
redis.commands.bf.commands.CMSCommands.query(self,key,*items)
redis.commands.bf.commands.TDigestCommands
redis.commands.bf.commands.TDigestCommands.add(self,key,values)
redis.commands.bf.commands.TDigestCommands.byrank(self,key,rank,*ranks)
redis.commands.bf.commands.TDigestCommands.byrevrank(self,key,rank,*ranks)
redis.commands.bf.commands.TDigestCommands.cdf(self,key,value,*values)
redis.commands.bf.commands.TDigestCommands.create(self,key,compression=100)
redis.commands.bf.commands.TDigestCommands.info(self,key)
redis.commands.bf.commands.TDigestCommands.max(self,key)
redis.commands.bf.commands.TDigestCommands.merge(self,destination_key,num_keys,*keys,compression=None,override=False)
redis.commands.bf.commands.TDigestCommands.min(self,key)
redis.commands.bf.commands.TDigestCommands.quantile(self,key,quantile,*quantiles)
redis.commands.bf.commands.TDigestCommands.rank(self,key,value,*values)
redis.commands.bf.commands.TDigestCommands.reset(self,key)
redis.commands.bf.commands.TDigestCommands.revrank(self,key,value,*values)
redis.commands.bf.commands.TDigestCommands.trimmed_mean(self,key,low_cut_quantile,high_cut_quantile)
redis.commands.bf.commands.TOPKCommands
redis.commands.bf.commands.TOPKCommands.add(self,key,*items)
redis.commands.bf.commands.TOPKCommands.count(self,key,*items)
redis.commands.bf.commands.TOPKCommands.incrby(self,key,items,increments)
redis.commands.bf.commands.TOPKCommands.info(self,key)
redis.commands.bf.commands.TOPKCommands.list(self,key,withcount=False)
redis.commands.bf.commands.TOPKCommands.query(self,key,*items)
redis.commands.bf.commands.TOPKCommands.reserve(self,key,k,width,depth,decay)


----------------------------------------/dataset/nuaa/anaconda3/envs/redis6.1.1/lib/python3.9/site-packages/redis/commands/bf/info.py----------------------------------------
A:redis.commands.bf.info.response->dict(zip(map(nativestr, args[::2]), args[1::2]))
redis.commands.bf.BFInfo(self,args)
redis.commands.bf.BFInfo.__getitem__(self,item)
redis.commands.bf.BFInfo.get(self,item)
redis.commands.bf.CFInfo(self,args)
redis.commands.bf.CFInfo.__getitem__(self,item)
redis.commands.bf.CFInfo.get(self,item)
redis.commands.bf.CMSInfo(self,args)
redis.commands.bf.CMSInfo.__getitem__(self,item)
redis.commands.bf.TDigestInfo(self,args)
redis.commands.bf.TDigestInfo.__getitem__(self,item)
redis.commands.bf.TDigestInfo.get(self,item)
redis.commands.bf.TopKInfo(self,args)
redis.commands.bf.TopKInfo.__getitem__(self,item)
redis.commands.bf.info.BFInfo(self,args)
redis.commands.bf.info.BFInfo.__getitem__(self,item)
redis.commands.bf.info.BFInfo.__init__(self,args)
redis.commands.bf.info.BFInfo.get(self,item)
redis.commands.bf.info.CFInfo(self,args)
redis.commands.bf.info.CFInfo.__getitem__(self,item)
redis.commands.bf.info.CFInfo.__init__(self,args)
redis.commands.bf.info.CFInfo.get(self,item)
redis.commands.bf.info.CMSInfo(self,args)
redis.commands.bf.info.CMSInfo.__getitem__(self,item)
redis.commands.bf.info.CMSInfo.__init__(self,args)
redis.commands.bf.info.TDigestInfo(self,args)
redis.commands.bf.info.TDigestInfo.__getitem__(self,item)
redis.commands.bf.info.TDigestInfo.__init__(self,args)
redis.commands.bf.info.TDigestInfo.get(self,item)
redis.commands.bf.info.TopKInfo(self,args)
redis.commands.bf.info.TopKInfo.__getitem__(self,item)
redis.commands.bf.info.TopKInfo.__init__(self,args)


----------------------------------------/dataset/nuaa/anaconda3/envs/redis6.1.1/lib/python3.9/site-packages/redis/commands/vectorset/__init__.py----------------------------------------
redis.commands.vectorset.__init__.VectorSet(self,client,**kwargs)
redis.commands.vectorset.__init__.VectorSet.__init__(self,client,**kwargs)


----------------------------------------/dataset/nuaa/anaconda3/envs/redis6.1.1/lib/python3.9/site-packages/redis/commands/vectorset/utils.py----------------------------------------
A:redis.commands.vectorset.utils.result['l2']->float(response[2])
A:redis.commands.vectorset.utils.result['range']->float(response[3])
A:redis.commands.vectorset.utils.value->float(value)
redis.commands.vectorset.parse_vemb_result(response,**options)
redis.commands.vectorset.parse_vlinks_result(response,**options)
redis.commands.vectorset.parse_vsim_result(response,**options)
redis.commands.vectorset.utils.parse_vemb_result(response,**options)
redis.commands.vectorset.utils.parse_vlinks_result(response,**options)
redis.commands.vectorset.utils.parse_vsim_result(response,**options)


----------------------------------------/dataset/nuaa/anaconda3/envs/redis6.1.1/lib/python3.9/site-packages/redis/commands/vectorset/commands.py----------------------------------------
A:redis.commands.vectorset.commands.attributes_json->json.dumps(attributes)
redis.commands.vectorset.VectorSetCommands(CommandsProtocol)
redis.commands.vectorset.VectorSetCommands.vadd(self,key:KeyT,vector:Union[List[float],bytes],element:str,reduce_dim:Optional[int]=None,cas:Optional[bool]=False,quantization:Optional[QuantizationOptions]=None,ef:Optional[Number]=None,attributes:Optional[Union[dict,str]]=None,numlinks:Optional[int]=None)->Union[Awaitable[int], int]
redis.commands.vectorset.VectorSetCommands.vcard(self,key:KeyT)->Union[Awaitable[int], int]
redis.commands.vectorset.VectorSetCommands.vdim(self,key:KeyT)->Union[Awaitable[int], int]
redis.commands.vectorset.VectorSetCommands.vemb(self,key:KeyT,element:str,raw:Optional[bool]=False)->Union[Awaitable[Optional[Union[List[EncodableT], Dict[str, EncodableT]]]], Optional[Union[List[EncodableT], Dict[str, EncodableT]]]]
redis.commands.vectorset.VectorSetCommands.vgetattr(self,key:KeyT,element:str)->Union[Optional[Awaitable[dict]], Optional[dict]]
redis.commands.vectorset.VectorSetCommands.vinfo(self,key:KeyT)->Union[Awaitable[dict], dict]
redis.commands.vectorset.VectorSetCommands.vlinks(self,key:KeyT,element:str,with_scores:Optional[bool]=False)->Union[Awaitable[Optional[List[Union[List[Union[str, bytes]], Dict[Union[str, bytes], Number]]]]], Optional[List[Union[List[Union[str, bytes]], Dict[Union[str, bytes], Number]]]]]
redis.commands.vectorset.VectorSetCommands.vrandmember(self,key:KeyT,count:Optional[int]=None)->Union[Awaitable[Optional[Union[List[str], str]]], Optional[Union[List[str], str]]]
redis.commands.vectorset.VectorSetCommands.vrem(self,key:KeyT,element:str)->Union[Awaitable[int], int]
redis.commands.vectorset.VectorSetCommands.vsetattr(self,key:KeyT,element:str,attributes:Optional[Union[dict,str]]=None)->Union[Awaitable[int], int]
redis.commands.vectorset.VectorSetCommands.vsim(self,key:KeyT,input:Union[List[float],bytes,str],with_scores:Optional[bool]=False,count:Optional[int]=None,ef:Optional[Number]=None,filter:Optional[str]=None,filter_ef:Optional[str]=None,truth:Optional[bool]=False,no_thread:Optional[bool]=False)->Union[Awaitable[Optional[List[Union[List[EncodableT], Dict[EncodableT, Number]]]]], Optional[List[Union[List[EncodableT], Dict[EncodableT, Number]]]]]
redis.commands.vectorset.commands.CallbacksOptions(Enum)
redis.commands.vectorset.commands.QuantizationOptions(Enum)
redis.commands.vectorset.commands.VectorSetCommands(CommandsProtocol)
redis.commands.vectorset.commands.VectorSetCommands.vadd(self,key:KeyT,vector:Union[List[float],bytes],element:str,reduce_dim:Optional[int]=None,cas:Optional[bool]=False,quantization:Optional[QuantizationOptions]=None,ef:Optional[Number]=None,attributes:Optional[Union[dict,str]]=None,numlinks:Optional[int]=None)->Union[Awaitable[int], int]
redis.commands.vectorset.commands.VectorSetCommands.vcard(self,key:KeyT)->Union[Awaitable[int], int]
redis.commands.vectorset.commands.VectorSetCommands.vdim(self,key:KeyT)->Union[Awaitable[int], int]
redis.commands.vectorset.commands.VectorSetCommands.vemb(self,key:KeyT,element:str,raw:Optional[bool]=False)->Union[Awaitable[Optional[Union[List[EncodableT], Dict[str, EncodableT]]]], Optional[Union[List[EncodableT], Dict[str, EncodableT]]]]
redis.commands.vectorset.commands.VectorSetCommands.vgetattr(self,key:KeyT,element:str)->Union[Optional[Awaitable[dict]], Optional[dict]]
redis.commands.vectorset.commands.VectorSetCommands.vinfo(self,key:KeyT)->Union[Awaitable[dict], dict]
redis.commands.vectorset.commands.VectorSetCommands.vlinks(self,key:KeyT,element:str,with_scores:Optional[bool]=False)->Union[Awaitable[Optional[List[Union[List[Union[str, bytes]], Dict[Union[str, bytes], Number]]]]], Optional[List[Union[List[Union[str, bytes]], Dict[Union[str, bytes], Number]]]]]
redis.commands.vectorset.commands.VectorSetCommands.vrandmember(self,key:KeyT,count:Optional[int]=None)->Union[Awaitable[Optional[Union[List[str], str]]], Optional[Union[List[str], str]]]
redis.commands.vectorset.commands.VectorSetCommands.vrem(self,key:KeyT,element:str)->Union[Awaitable[int], int]
redis.commands.vectorset.commands.VectorSetCommands.vsetattr(self,key:KeyT,element:str,attributes:Optional[Union[dict,str]]=None)->Union[Awaitable[int], int]
redis.commands.vectorset.commands.VectorSetCommands.vsim(self,key:KeyT,input:Union[List[float],bytes,str],with_scores:Optional[bool]=False,count:Optional[int]=None,ef:Optional[Number]=None,filter:Optional[str]=None,filter_ef:Optional[str]=None,truth:Optional[bool]=False,no_thread:Optional[bool]=False)->Union[Awaitable[Optional[List[Union[List[EncodableT], Dict[EncodableT, Number]]]]], Optional[List[Union[List[EncodableT], Dict[EncodableT, Number]]]]]


----------------------------------------/dataset/nuaa/anaconda3/envs/redis6.1.1/lib/python3.9/site-packages/redis/commands/timeseries/__init__.py----------------------------------------
A:redis.commands.timeseries.__init__.p->Pipeline(connection_pool=self.client.connection_pool, response_callbacks=self._MODULE_CALLBACKS, transaction=transaction, shard_hint=shard_hint)
redis.commands.timeseries.__init__.ClusterPipeline(TimeSeriesCommands,redis.cluster.ClusterPipeline)
redis.commands.timeseries.__init__.Pipeline(TimeSeriesCommands,redis.client.Pipeline)
redis.commands.timeseries.__init__.TimeSeries(self,client=None,**kwargs)
redis.commands.timeseries.__init__.TimeSeries.__init__(self,client=None,**kwargs)
redis.commands.timeseries.__init__.TimeSeries.pipeline(self,transaction=True,shard_hint=None)


----------------------------------------/dataset/nuaa/anaconda3/envs/redis6.1.1/lib/python3.9/site-packages/redis/commands/timeseries/utils.py----------------------------------------
redis.commands.timeseries.parse_get(response)
redis.commands.timeseries.parse_m_get(response)
redis.commands.timeseries.parse_m_range(response)
redis.commands.timeseries.parse_range(response,**kwargs)
redis.commands.timeseries.utils.list_to_dict(aList)
redis.commands.timeseries.utils.parse_get(response)
redis.commands.timeseries.utils.parse_m_get(response)
redis.commands.timeseries.utils.parse_m_range(response)
redis.commands.timeseries.utils.parse_range(response,**kwargs)


----------------------------------------/dataset/nuaa/anaconda3/envs/redis6.1.1/lib/python3.9/site-packages/redis/commands/timeseries/commands.py----------------------------------------
A:redis.commands.timeseries.commands.params->self.__mrange_params(aggregation_type, bucket_size_msec, count, filters, from_time, to_time, with_labels, filter_by_ts, filter_by_min_value, filter_by_max_value, groupby, reduce, select_labels, align, latest, bucket_timestamp, empty)
redis.commands.timeseries.TimeSeriesCommands
redis.commands.timeseries.TimeSeriesCommands.__mrange_params(self,aggregation_type:Optional[str],bucket_size_msec:Optional[int],count:Optional[int],filters:List[str],from_time:Union[int,str],to_time:Union[int,str],with_labels:Optional[bool],filter_by_ts:Optional[List[int]],filter_by_min_value:Optional[int],filter_by_max_value:Optional[int],groupby:Optional[str],reduce:Optional[str],select_labels:Optional[List[str]],align:Optional[Union[int,str]],latest:Optional[bool],bucket_timestamp:Optional[str],empty:Optional[bool])
redis.commands.timeseries.TimeSeriesCommands.__range_params(self,key:KeyT,from_time:Union[int,str],to_time:Union[int,str],count:Optional[int],aggregation_type:Optional[str],bucket_size_msec:Optional[int],filter_by_ts:Optional[List[int]],filter_by_min_value:Optional[int],filter_by_max_value:Optional[int],align:Optional[Union[int,str]],latest:Optional[bool],bucket_timestamp:Optional[str],empty:Optional[bool])
redis.commands.timeseries.TimeSeriesCommands._append_aggregation(params:List[str],aggregation_type:Optional[str],bucket_size_msec:Optional[int])
redis.commands.timeseries.TimeSeriesCommands._append_align(params:List[str],align:Optional[Union[int,str]])
redis.commands.timeseries.TimeSeriesCommands._append_bucket_timestamp(params:List[str],bucket_timestamp:Optional[str])
redis.commands.timeseries.TimeSeriesCommands._append_chunk_size(params:List[str],chunk_size:Optional[int])
redis.commands.timeseries.TimeSeriesCommands._append_count(params:List[str],count:Optional[int])
redis.commands.timeseries.TimeSeriesCommands._append_duplicate_policy(params:List[str],duplicate_policy:Optional[str])
redis.commands.timeseries.TimeSeriesCommands._append_empty(params:List[str],empty:Optional[bool])
redis.commands.timeseries.TimeSeriesCommands._append_filer_by_ts(params:List[str],ts_list:Optional[List[int]])
redis.commands.timeseries.TimeSeriesCommands._append_filer_by_value(params:List[str],min_value:Optional[int],max_value:Optional[int])
redis.commands.timeseries.TimeSeriesCommands._append_groupby_reduce(params:List[str],groupby:Optional[str],reduce:Optional[str])
redis.commands.timeseries.TimeSeriesCommands._append_insertion_filters(params:List[str],ignore_max_time_diff:Optional[int]=None,ignore_max_val_diff:Optional[Number]=None)
redis.commands.timeseries.TimeSeriesCommands._append_labels(params:List[str],labels:Optional[List[str]])
redis.commands.timeseries.TimeSeriesCommands._append_latest(params:List[str],latest:Optional[bool])
redis.commands.timeseries.TimeSeriesCommands._append_on_duplicate(params:List[str],on_duplicate:Optional[str])
redis.commands.timeseries.TimeSeriesCommands._append_retention(params:List[str],retention:Optional[int])
redis.commands.timeseries.TimeSeriesCommands._append_timestamp(params:List[str],timestamp:Optional[int])
redis.commands.timeseries.TimeSeriesCommands._append_uncompressed(params:List[str],uncompressed:Optional[bool])
redis.commands.timeseries.TimeSeriesCommands._append_with_labels(params:List[str],with_labels:Optional[bool],select_labels:Optional[List[str]])
redis.commands.timeseries.TimeSeriesCommands.add(self,key:KeyT,timestamp:Union[int,str],value:Number,retention_msecs:Optional[int]=None,uncompressed:Optional[bool]=False,labels:Optional[Dict[str,str]]=None,chunk_size:Optional[int]=None,duplicate_policy:Optional[str]=None,ignore_max_time_diff:Optional[int]=None,ignore_max_val_diff:Optional[Number]=None,on_duplicate:Optional[str]=None)
redis.commands.timeseries.TimeSeriesCommands.alter(self,key:KeyT,retention_msecs:Optional[int]=None,labels:Optional[Dict[str,str]]=None,chunk_size:Optional[int]=None,duplicate_policy:Optional[str]=None,ignore_max_time_diff:Optional[int]=None,ignore_max_val_diff:Optional[Number]=None)
redis.commands.timeseries.TimeSeriesCommands.create(self,key:KeyT,retention_msecs:Optional[int]=None,uncompressed:Optional[bool]=False,labels:Optional[Dict[str,str]]=None,chunk_size:Optional[int]=None,duplicate_policy:Optional[str]=None,ignore_max_time_diff:Optional[int]=None,ignore_max_val_diff:Optional[Number]=None)
redis.commands.timeseries.TimeSeriesCommands.createrule(self,source_key:KeyT,dest_key:KeyT,aggregation_type:str,bucket_size_msec:int,align_timestamp:Optional[int]=None)
redis.commands.timeseries.TimeSeriesCommands.decrby(self,key:KeyT,value:Number,timestamp:Optional[Union[int,str]]=None,retention_msecs:Optional[int]=None,uncompressed:Optional[bool]=False,labels:Optional[Dict[str,str]]=None,chunk_size:Optional[int]=None,duplicate_policy:Optional[str]=None,ignore_max_time_diff:Optional[int]=None,ignore_max_val_diff:Optional[Number]=None)
redis.commands.timeseries.TimeSeriesCommands.delete(self,key:KeyT,from_time:int,to_time:int)
redis.commands.timeseries.TimeSeriesCommands.deleterule(self,source_key:KeyT,dest_key:KeyT)
redis.commands.timeseries.TimeSeriesCommands.get(self,key:KeyT,latest:Optional[bool]=False)
redis.commands.timeseries.TimeSeriesCommands.incrby(self,key:KeyT,value:Number,timestamp:Optional[Union[int,str]]=None,retention_msecs:Optional[int]=None,uncompressed:Optional[bool]=False,labels:Optional[Dict[str,str]]=None,chunk_size:Optional[int]=None,duplicate_policy:Optional[str]=None,ignore_max_time_diff:Optional[int]=None,ignore_max_val_diff:Optional[Number]=None)
redis.commands.timeseries.TimeSeriesCommands.info(self,key:KeyT)
redis.commands.timeseries.TimeSeriesCommands.madd(self,ktv_tuples:List[Tuple[KeyT,Union[int,str],Number]])
redis.commands.timeseries.TimeSeriesCommands.mget(self,filters:List[str],with_labels:Optional[bool]=False,select_labels:Optional[List[str]]=None,latest:Optional[bool]=False)
redis.commands.timeseries.TimeSeriesCommands.mrange(self,from_time:Union[int,str],to_time:Union[int,str],filters:List[str],count:Optional[int]=None,aggregation_type:Optional[str]=None,bucket_size_msec:Optional[int]=0,with_labels:Optional[bool]=False,filter_by_ts:Optional[List[int]]=None,filter_by_min_value:Optional[int]=None,filter_by_max_value:Optional[int]=None,groupby:Optional[str]=None,reduce:Optional[str]=None,select_labels:Optional[List[str]]=None,align:Optional[Union[int,str]]=None,latest:Optional[bool]=False,bucket_timestamp:Optional[str]=None,empty:Optional[bool]=False)
redis.commands.timeseries.TimeSeriesCommands.mrevrange(self,from_time:Union[int,str],to_time:Union[int,str],filters:List[str],count:Optional[int]=None,aggregation_type:Optional[str]=None,bucket_size_msec:Optional[int]=0,with_labels:Optional[bool]=False,filter_by_ts:Optional[List[int]]=None,filter_by_min_value:Optional[int]=None,filter_by_max_value:Optional[int]=None,groupby:Optional[str]=None,reduce:Optional[str]=None,select_labels:Optional[List[str]]=None,align:Optional[Union[int,str]]=None,latest:Optional[bool]=False,bucket_timestamp:Optional[str]=None,empty:Optional[bool]=False)
redis.commands.timeseries.TimeSeriesCommands.queryindex(self,filters:List[str])
redis.commands.timeseries.TimeSeriesCommands.range(self,key:KeyT,from_time:Union[int,str],to_time:Union[int,str],count:Optional[int]=None,aggregation_type:Optional[str]=None,bucket_size_msec:Optional[int]=0,filter_by_ts:Optional[List[int]]=None,filter_by_min_value:Optional[int]=None,filter_by_max_value:Optional[int]=None,align:Optional[Union[int,str]]=None,latest:Optional[bool]=False,bucket_timestamp:Optional[str]=None,empty:Optional[bool]=False)
redis.commands.timeseries.TimeSeriesCommands.revrange(self,key:KeyT,from_time:Union[int,str],to_time:Union[int,str],count:Optional[int]=None,aggregation_type:Optional[str]=None,bucket_size_msec:Optional[int]=0,filter_by_ts:Optional[List[int]]=None,filter_by_min_value:Optional[int]=None,filter_by_max_value:Optional[int]=None,align:Optional[Union[int,str]]=None,latest:Optional[bool]=False,bucket_timestamp:Optional[str]=None,empty:Optional[bool]=False)
redis.commands.timeseries.commands.TimeSeriesCommands
redis.commands.timeseries.commands.TimeSeriesCommands.__mrange_params(self,aggregation_type:Optional[str],bucket_size_msec:Optional[int],count:Optional[int],filters:List[str],from_time:Union[int,str],to_time:Union[int,str],with_labels:Optional[bool],filter_by_ts:Optional[List[int]],filter_by_min_value:Optional[int],filter_by_max_value:Optional[int],groupby:Optional[str],reduce:Optional[str],select_labels:Optional[List[str]],align:Optional[Union[int,str]],latest:Optional[bool],bucket_timestamp:Optional[str],empty:Optional[bool])
redis.commands.timeseries.commands.TimeSeriesCommands.__range_params(self,key:KeyT,from_time:Union[int,str],to_time:Union[int,str],count:Optional[int],aggregation_type:Optional[str],bucket_size_msec:Optional[int],filter_by_ts:Optional[List[int]],filter_by_min_value:Optional[int],filter_by_max_value:Optional[int],align:Optional[Union[int,str]],latest:Optional[bool],bucket_timestamp:Optional[str],empty:Optional[bool])
redis.commands.timeseries.commands.TimeSeriesCommands._append_aggregation(params:List[str],aggregation_type:Optional[str],bucket_size_msec:Optional[int])
redis.commands.timeseries.commands.TimeSeriesCommands._append_align(params:List[str],align:Optional[Union[int,str]])
redis.commands.timeseries.commands.TimeSeriesCommands._append_bucket_timestamp(params:List[str],bucket_timestamp:Optional[str])
redis.commands.timeseries.commands.TimeSeriesCommands._append_chunk_size(params:List[str],chunk_size:Optional[int])
redis.commands.timeseries.commands.TimeSeriesCommands._append_count(params:List[str],count:Optional[int])
redis.commands.timeseries.commands.TimeSeriesCommands._append_duplicate_policy(params:List[str],duplicate_policy:Optional[str])
redis.commands.timeseries.commands.TimeSeriesCommands._append_empty(params:List[str],empty:Optional[bool])
redis.commands.timeseries.commands.TimeSeriesCommands._append_filer_by_ts(params:List[str],ts_list:Optional[List[int]])
redis.commands.timeseries.commands.TimeSeriesCommands._append_filer_by_value(params:List[str],min_value:Optional[int],max_value:Optional[int])
redis.commands.timeseries.commands.TimeSeriesCommands._append_groupby_reduce(params:List[str],groupby:Optional[str],reduce:Optional[str])
redis.commands.timeseries.commands.TimeSeriesCommands._append_insertion_filters(params:List[str],ignore_max_time_diff:Optional[int]=None,ignore_max_val_diff:Optional[Number]=None)
redis.commands.timeseries.commands.TimeSeriesCommands._append_labels(params:List[str],labels:Optional[List[str]])
redis.commands.timeseries.commands.TimeSeriesCommands._append_latest(params:List[str],latest:Optional[bool])
redis.commands.timeseries.commands.TimeSeriesCommands._append_on_duplicate(params:List[str],on_duplicate:Optional[str])
redis.commands.timeseries.commands.TimeSeriesCommands._append_retention(params:List[str],retention:Optional[int])
redis.commands.timeseries.commands.TimeSeriesCommands._append_timestamp(params:List[str],timestamp:Optional[int])
redis.commands.timeseries.commands.TimeSeriesCommands._append_uncompressed(params:List[str],uncompressed:Optional[bool])
redis.commands.timeseries.commands.TimeSeriesCommands._append_with_labels(params:List[str],with_labels:Optional[bool],select_labels:Optional[List[str]])
redis.commands.timeseries.commands.TimeSeriesCommands.add(self,key:KeyT,timestamp:Union[int,str],value:Number,retention_msecs:Optional[int]=None,uncompressed:Optional[bool]=False,labels:Optional[Dict[str,str]]=None,chunk_size:Optional[int]=None,duplicate_policy:Optional[str]=None,ignore_max_time_diff:Optional[int]=None,ignore_max_val_diff:Optional[Number]=None,on_duplicate:Optional[str]=None)
redis.commands.timeseries.commands.TimeSeriesCommands.alter(self,key:KeyT,retention_msecs:Optional[int]=None,labels:Optional[Dict[str,str]]=None,chunk_size:Optional[int]=None,duplicate_policy:Optional[str]=None,ignore_max_time_diff:Optional[int]=None,ignore_max_val_diff:Optional[Number]=None)
redis.commands.timeseries.commands.TimeSeriesCommands.create(self,key:KeyT,retention_msecs:Optional[int]=None,uncompressed:Optional[bool]=False,labels:Optional[Dict[str,str]]=None,chunk_size:Optional[int]=None,duplicate_policy:Optional[str]=None,ignore_max_time_diff:Optional[int]=None,ignore_max_val_diff:Optional[Number]=None)
redis.commands.timeseries.commands.TimeSeriesCommands.createrule(self,source_key:KeyT,dest_key:KeyT,aggregation_type:str,bucket_size_msec:int,align_timestamp:Optional[int]=None)
redis.commands.timeseries.commands.TimeSeriesCommands.decrby(self,key:KeyT,value:Number,timestamp:Optional[Union[int,str]]=None,retention_msecs:Optional[int]=None,uncompressed:Optional[bool]=False,labels:Optional[Dict[str,str]]=None,chunk_size:Optional[int]=None,duplicate_policy:Optional[str]=None,ignore_max_time_diff:Optional[int]=None,ignore_max_val_diff:Optional[Number]=None)
redis.commands.timeseries.commands.TimeSeriesCommands.delete(self,key:KeyT,from_time:int,to_time:int)
redis.commands.timeseries.commands.TimeSeriesCommands.deleterule(self,source_key:KeyT,dest_key:KeyT)
redis.commands.timeseries.commands.TimeSeriesCommands.get(self,key:KeyT,latest:Optional[bool]=False)
redis.commands.timeseries.commands.TimeSeriesCommands.incrby(self,key:KeyT,value:Number,timestamp:Optional[Union[int,str]]=None,retention_msecs:Optional[int]=None,uncompressed:Optional[bool]=False,labels:Optional[Dict[str,str]]=None,chunk_size:Optional[int]=None,duplicate_policy:Optional[str]=None,ignore_max_time_diff:Optional[int]=None,ignore_max_val_diff:Optional[Number]=None)
redis.commands.timeseries.commands.TimeSeriesCommands.info(self,key:KeyT)
redis.commands.timeseries.commands.TimeSeriesCommands.madd(self,ktv_tuples:List[Tuple[KeyT,Union[int,str],Number]])
redis.commands.timeseries.commands.TimeSeriesCommands.mget(self,filters:List[str],with_labels:Optional[bool]=False,select_labels:Optional[List[str]]=None,latest:Optional[bool]=False)
redis.commands.timeseries.commands.TimeSeriesCommands.mrange(self,from_time:Union[int,str],to_time:Union[int,str],filters:List[str],count:Optional[int]=None,aggregation_type:Optional[str]=None,bucket_size_msec:Optional[int]=0,with_labels:Optional[bool]=False,filter_by_ts:Optional[List[int]]=None,filter_by_min_value:Optional[int]=None,filter_by_max_value:Optional[int]=None,groupby:Optional[str]=None,reduce:Optional[str]=None,select_labels:Optional[List[str]]=None,align:Optional[Union[int,str]]=None,latest:Optional[bool]=False,bucket_timestamp:Optional[str]=None,empty:Optional[bool]=False)
redis.commands.timeseries.commands.TimeSeriesCommands.mrevrange(self,from_time:Union[int,str],to_time:Union[int,str],filters:List[str],count:Optional[int]=None,aggregation_type:Optional[str]=None,bucket_size_msec:Optional[int]=0,with_labels:Optional[bool]=False,filter_by_ts:Optional[List[int]]=None,filter_by_min_value:Optional[int]=None,filter_by_max_value:Optional[int]=None,groupby:Optional[str]=None,reduce:Optional[str]=None,select_labels:Optional[List[str]]=None,align:Optional[Union[int,str]]=None,latest:Optional[bool]=False,bucket_timestamp:Optional[str]=None,empty:Optional[bool]=False)
redis.commands.timeseries.commands.TimeSeriesCommands.queryindex(self,filters:List[str])
redis.commands.timeseries.commands.TimeSeriesCommands.range(self,key:KeyT,from_time:Union[int,str],to_time:Union[int,str],count:Optional[int]=None,aggregation_type:Optional[str]=None,bucket_size_msec:Optional[int]=0,filter_by_ts:Optional[List[int]]=None,filter_by_min_value:Optional[int]=None,filter_by_max_value:Optional[int]=None,align:Optional[Union[int,str]]=None,latest:Optional[bool]=False,bucket_timestamp:Optional[str]=None,empty:Optional[bool]=False)
redis.commands.timeseries.commands.TimeSeriesCommands.revrange(self,key:KeyT,from_time:Union[int,str],to_time:Union[int,str],count:Optional[int]=None,aggregation_type:Optional[str]=None,bucket_size_msec:Optional[int]=0,filter_by_ts:Optional[List[int]]=None,filter_by_min_value:Optional[int]=None,filter_by_max_value:Optional[int]=None,align:Optional[Union[int,str]]=None,latest:Optional[bool]=False,bucket_timestamp:Optional[str]=None,empty:Optional[bool]=False)


----------------------------------------/dataset/nuaa/anaconda3/envs/redis6.1.1/lib/python3.9/site-packages/redis/commands/timeseries/info.py----------------------------------------
A:redis.commands.timeseries.info.response->dict(zip(map(nativestr, args[::2]), args[1::2]))
A:redis.commands.timeseries.info.self.rules->dict(zip(map(nativestr, args[::2]), args[1::2])).get('rules')
A:redis.commands.timeseries.info.self.source_key->dict(zip(map(nativestr, args[::2]), args[1::2])).get('sourceKey')
A:redis.commands.timeseries.info.self.chunk_count->dict(zip(map(nativestr, args[::2]), args[1::2])).get('chunkCount')
A:redis.commands.timeseries.info.self.memory_usage->dict(zip(map(nativestr, args[::2]), args[1::2])).get('memoryUsage')
A:redis.commands.timeseries.info.self.total_samples->dict(zip(map(nativestr, args[::2]), args[1::2])).get('totalSamples')
A:redis.commands.timeseries.info.self.labels->list_to_dict(response.get('labels'))
A:redis.commands.timeseries.info.self.retention_msecs->dict(zip(map(nativestr, args[::2]), args[1::2])).get('retentionTime')
A:redis.commands.timeseries.info.self.last_timestamp->dict(zip(map(nativestr, args[::2]), args[1::2])).get('lastTimestamp')
A:redis.commands.timeseries.info.self.first_timestamp->dict(zip(map(nativestr, args[::2]), args[1::2])).get('firstTimestamp')
A:redis.commands.timeseries.info.self.duplicate_policy->self.duplicate_policy.decode()
redis.commands.timeseries.TSInfo(self,args)
redis.commands.timeseries.TSInfo.__getitem__(self,item)
redis.commands.timeseries.TSInfo.get(self,item)
redis.commands.timeseries.info.TSInfo(self,args)
redis.commands.timeseries.info.TSInfo.__getitem__(self,item)
redis.commands.timeseries.info.TSInfo.__init__(self,args)
redis.commands.timeseries.info.TSInfo.get(self,item)

