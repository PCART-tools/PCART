
----------------------------------------/home/zhang/Packages/pydantic/pydantic2.0a4/types.py----------------------------------------
A:pydantic.types.HashableItemType->TypeVar('HashableItemType', bound=Hashable)
A:pydantic.types.AnyItemType->TypeVar('AnyItemType')
A:pydantic.types.AnyType->TypeVar('AnyType')
A:pydantic.types.field_schema->handler(core_schema)
A:pydantic.types.SecretType->TypeVar('SecretType', str, bytes)
A:pydantic.types.(metadata, remaining_annotations)->_internal._known_annotated_metadata.collect_known_metadata(annotations)
A:pydantic.types.value->value.decode().decode()
A:pydantic.types.schema->handler(source)
A:pydantic.types.json_schema->handler(schema)
A:pydantic.types.self.inner_schema->handler(str if self.field_type is SecretStr else bytes)
A:pydantic.types.card_number->self.validate_luhn_check_digit(card_number)
A:pydantic.types.self.brand->self.validate_brand(card_number)
A:pydantic.types.sum_->int(card_number[-1])
A:pydantic.types.length->len(card_number)
A:pydantic.types.digit->int(card_number[i])
A:pydantic.types.byte_string_re->re.compile('^\\s*(\\d*\\.?\\d+)\\s*(\\w+)?', re.IGNORECASE)
A:pydantic.types.str_match->re.compile('^\\s*(\\d*\\.?\\d+)\\s*(\\w+)?', re.IGNORECASE).match(str(__input_value))
A:pydantic.types.(scalar, unit)->re.compile('^\\s*(\\d*\\.?\\d+)\\s*(\\w+)?', re.IGNORECASE).match(str(__input_value)).groups()
A:pydantic.types.num->float(self)
A:pydantic.types.__getattr__->getattr_migration(__name__)
pydantic.AllowInfNan(_fields.PydanticMetadata)
pydantic.AllowInfNan.__hash__(self)->int
pydantic.Base64Encoder(EncoderProtocol)
pydantic.Base64Encoder.decode(cls,data:bytes)->bytes
pydantic.Base64Encoder.encode(cls,value:bytes)->bytes
pydantic.Base64Encoder.get_json_format(cls)->str
pydantic.ByteSize(int)
pydantic.ByteSize.__get_pydantic_core_schema__(cls,source:type[Any],handler:GetCoreSchemaHandler)->core_schema.CoreSchema
pydantic.ByteSize.human_readable(self,decimal:bool=False)->str
pydantic.ByteSize.to(self,unit:str)->float
pydantic.ByteSize.validate(cls,__input_value:Any,_:core_schema.ValidationInfo)->ByteSize
pydantic.EncodedBytes
pydantic.EncodedBytes.__get_pydantic_core_schema__(self,source:type[Any],handler:Callable[[Any],core_schema.CoreSchema])->core_schema.CoreSchema
pydantic.EncodedBytes.__get_pydantic_json_schema__(self,core_schema:core_schema.CoreSchema,handler:GetJsonSchemaHandler)->JsonSchemaValue
pydantic.EncodedBytes.__hash__(self)->int
pydantic.EncodedBytes.decode(self,data:bytes,_:core_schema.ValidationInfo)->bytes
pydantic.EncodedBytes.encode(self,value:bytes)->bytes
pydantic.EncodedStr(EncodedBytes)
pydantic.EncodedStr.__get_pydantic_core_schema__(self,source:type[Any],handler:Callable[[Any],core_schema.CoreSchema])->core_schema.CoreSchema
pydantic.EncodedStr.decode_str(self,data:bytes,_:core_schema.ValidationInfo)->str
pydantic.EncodedStr.encode_str(self,value:str)->str
pydantic.EncoderProtocol(Protocol)
pydantic.EncoderProtocol.decode(cls,data:bytes)->bytes
pydantic.EncoderProtocol.encode(cls,value:bytes)->bytes
pydantic.EncoderProtocol.get_json_format(cls)->str
pydantic.PathType
pydantic.PathType.__get_pydantic_core_schema__(self,source:Any,handler:GetCoreSchemaHandler)->core_schema.CoreSchema
pydantic.PathType.__get_pydantic_json_schema__(self,core_schema:core_schema.CoreSchema,handler:GetJsonSchemaHandler)->JsonSchemaValue
pydantic.PathType.__hash__(self)->int
pydantic.PathType.validate_directory(path:Path,_:core_schema.ValidationInfo)->Path
pydantic.PathType.validate_file(path:Path,_:core_schema.ValidationInfo)->Path
pydantic.PathType.validate_new(path:Path,_:core_schema.ValidationInfo)->Path
pydantic.PaymentCardBrand(str,Enum)
pydantic.PaymentCardBrand.__str__(self)->str
pydantic.PaymentCardNumber(self,card_number:str)
pydantic.PaymentCardNumber.__get_pydantic_core_schema__(cls,source:type[Any],handler:GetCoreSchemaHandler)->core_schema.CoreSchema
pydantic.PaymentCardNumber.masked(self)->str
pydantic.PaymentCardNumber.validate(cls,__input_value:str,_:core_schema.ValidationInfo)->PaymentCardNumber
pydantic.PaymentCardNumber.validate_brand(card_number:str)->PaymentCardBrand
pydantic.PaymentCardNumber.validate_digits(cls,card_number:str)->None
pydantic.PaymentCardNumber.validate_luhn_check_digit(cls,card_number:str)->str
pydantic.SecretBytes(SecretField[bytes])
pydantic.SecretBytes._display(self)->bytes
pydantic.SecretField(self,secret_value:SecretType)
pydantic.SecretField.__eq__(self,other:Any)->bool
pydantic.SecretField.__hash__(self)->int
pydantic.SecretField.__len__(self)->int
pydantic.SecretField.__prepare_pydantic_annotations__(cls,source:type[Any],annotations:Iterable[Any])->Iterable[Any]
pydantic.SecretField.__repr__(self)->str
pydantic.SecretField.__str__(self)->str
pydantic.SecretField._display(self)->SecretType
pydantic.SecretField.get_secret_value(self)->SecretType
pydantic.SecretStr(SecretField[str])
pydantic.SecretStr._display(self)->str
pydantic.Strict(_fields.PydanticMetadata)
pydantic.Strict.__hash__(self)->int
pydantic.UuidVersion
pydantic.UuidVersion.__get_pydantic_core_schema__(self,source:Any,handler:GetCoreSchemaHandler)->core_schema.CoreSchema
pydantic.UuidVersion.__get_pydantic_json_schema__(self,core_schema:core_schema.CoreSchema,handler:GetJsonSchemaHandler)->JsonSchemaValue
pydantic.UuidVersion.__hash__(self)->int
pydantic.UuidVersion.validate(self,value:UUID,_:core_schema.ValidationInfo)->UUID
pydantic._SecretFieldValidator
pydantic._SecretFieldValidator.__get_pydantic_core_schema__(self,source:type[Any],handler:GetCoreSchemaHandler)->core_schema.CoreSchema
pydantic._SecretFieldValidator.__get_pydantic_json_schema__(self,_core_schema:core_schema.CoreSchema,handler:GetJsonSchemaHandler)->JsonSchemaValue
pydantic._SecretFieldValidator.serialize(self,value:SecretField[SecretType],info:core_schema.SerializationInfo)->str | SecretField[SecretType]
pydantic._SecretFieldValidator.validate(self,value:SecretField[SecretType]|SecretType,_:core_schema.ValidationInfo)->Any
pydantic._secret_display(value:str|bytes)->str
pydantic.conbytes(*,min_length:int|None=None,max_length:int|None=None,strict:bool|None=None)->type[bytes]
pydantic.condate(*,strict:bool|None=None,gt:date|None=None,ge:date|None=None,lt:date|None=None,le:date|None=None)->type[date]
pydantic.condecimal(*,strict:bool|None=None,gt:int|Decimal|None=None,ge:int|Decimal|None=None,lt:int|Decimal|None=None,le:int|Decimal|None=None,multiple_of:int|Decimal|None=None,max_digits:int|None=None,decimal_places:int|None=None,allow_inf_nan:bool|None=None)->type[Decimal]
pydantic.confloat(*,strict:bool|None=None,gt:float|None=None,ge:float|None=None,lt:float|None=None,le:float|None=None,multiple_of:float|None=None,allow_inf_nan:bool|None=None)->type[float]
pydantic.confrozenset(item_type:type[HashableItemType],*,min_length:int|None=None,max_length:int|None=None)->type[frozenset[HashableItemType]]
pydantic.conint(*,strict:bool|None=None,gt:int|None=None,ge:int|None=None,lt:int|None=None,le:int|None=None,multiple_of:int|None=None)->type[int]
pydantic.conlist(item_type:type[AnyItemType],*,min_length:int|None=None,max_length:int|None=None,unique_items:bool|None=None)->type[list[AnyItemType]]
pydantic.conset(item_type:type[HashableItemType],*,min_length:int|None=None,max_length:int|None=None)->type[set[HashableItemType]]
pydantic.constr(*,strip_whitespace:bool|None=None,to_upper:bool|None=None,to_lower:bool|None=None,strict:bool|None=None,min_length:int|None=None,max_length:int|None=None,pattern:str|None=None)->type[str]
pydantic.types.AllowInfNan(_fields.PydanticMetadata)
pydantic.types.AllowInfNan.__hash__(self)->int
pydantic.types.Base64Encoder(EncoderProtocol)
pydantic.types.Base64Encoder.decode(cls,data:bytes)->bytes
pydantic.types.Base64Encoder.encode(cls,value:bytes)->bytes
pydantic.types.Base64Encoder.get_json_format(cls)->str
pydantic.types.ByteSize(int)
pydantic.types.ByteSize.__get_pydantic_core_schema__(cls,source:type[Any],handler:GetCoreSchemaHandler)->core_schema.CoreSchema
pydantic.types.ByteSize.human_readable(self,decimal:bool=False)->str
pydantic.types.ByteSize.to(self,unit:str)->float
pydantic.types.ByteSize.validate(cls,__input_value:Any,_:core_schema.ValidationInfo)->ByteSize
pydantic.types.EncodedBytes
pydantic.types.EncodedBytes.__get_pydantic_core_schema__(self,source:type[Any],handler:Callable[[Any],core_schema.CoreSchema])->core_schema.CoreSchema
pydantic.types.EncodedBytes.__get_pydantic_json_schema__(self,core_schema:core_schema.CoreSchema,handler:GetJsonSchemaHandler)->JsonSchemaValue
pydantic.types.EncodedBytes.__hash__(self)->int
pydantic.types.EncodedBytes.decode(self,data:bytes,_:core_schema.ValidationInfo)->bytes
pydantic.types.EncodedBytes.encode(self,value:bytes)->bytes
pydantic.types.EncodedStr(EncodedBytes)
pydantic.types.EncodedStr.__get_pydantic_core_schema__(self,source:type[Any],handler:Callable[[Any],core_schema.CoreSchema])->core_schema.CoreSchema
pydantic.types.EncodedStr.decode_str(self,data:bytes,_:core_schema.ValidationInfo)->str
pydantic.types.EncodedStr.encode_str(self,value:str)->str
pydantic.types.EncoderProtocol(Protocol)
pydantic.types.EncoderProtocol.decode(cls,data:bytes)->bytes
pydantic.types.EncoderProtocol.encode(cls,value:bytes)->bytes
pydantic.types.EncoderProtocol.get_json_format(cls)->str
pydantic.types.PathType
pydantic.types.PathType.__get_pydantic_core_schema__(self,source:Any,handler:GetCoreSchemaHandler)->core_schema.CoreSchema
pydantic.types.PathType.__get_pydantic_json_schema__(self,core_schema:core_schema.CoreSchema,handler:GetJsonSchemaHandler)->JsonSchemaValue
pydantic.types.PathType.__hash__(self)->int
pydantic.types.PathType.validate_directory(path:Path,_:core_schema.ValidationInfo)->Path
pydantic.types.PathType.validate_file(path:Path,_:core_schema.ValidationInfo)->Path
pydantic.types.PathType.validate_new(path:Path,_:core_schema.ValidationInfo)->Path
pydantic.types.PaymentCardBrand(str,Enum)
pydantic.types.PaymentCardBrand.__str__(self)->str
pydantic.types.PaymentCardNumber(self,card_number:str)
pydantic.types.PaymentCardNumber.__get_pydantic_core_schema__(cls,source:type[Any],handler:GetCoreSchemaHandler)->core_schema.CoreSchema
pydantic.types.PaymentCardNumber.masked(self)->str
pydantic.types.PaymentCardNumber.validate(cls,__input_value:str,_:core_schema.ValidationInfo)->PaymentCardNumber
pydantic.types.PaymentCardNumber.validate_brand(card_number:str)->PaymentCardBrand
pydantic.types.PaymentCardNumber.validate_digits(cls,card_number:str)->None
pydantic.types.PaymentCardNumber.validate_luhn_check_digit(cls,card_number:str)->str
pydantic.types.SecretBytes(SecretField[bytes])
pydantic.types.SecretBytes._display(self)->bytes
pydantic.types.SecretField(self,secret_value:SecretType)
pydantic.types.SecretField.__eq__(self,other:Any)->bool
pydantic.types.SecretField.__hash__(self)->int
pydantic.types.SecretField.__len__(self)->int
pydantic.types.SecretField.__prepare_pydantic_annotations__(cls,source:type[Any],annotations:Iterable[Any])->Iterable[Any]
pydantic.types.SecretField.__repr__(self)->str
pydantic.types.SecretField.__str__(self)->str
pydantic.types.SecretField._display(self)->SecretType
pydantic.types.SecretField.get_secret_value(self)->SecretType
pydantic.types.SecretStr(SecretField[str])
pydantic.types.SecretStr._display(self)->str
pydantic.types.Strict(_fields.PydanticMetadata)
pydantic.types.Strict.__hash__(self)->int
pydantic.types.UuidVersion
pydantic.types.UuidVersion.__get_pydantic_core_schema__(self,source:Any,handler:GetCoreSchemaHandler)->core_schema.CoreSchema
pydantic.types.UuidVersion.__get_pydantic_json_schema__(self,core_schema:core_schema.CoreSchema,handler:GetJsonSchemaHandler)->JsonSchemaValue
pydantic.types.UuidVersion.__hash__(self)->int
pydantic.types.UuidVersion.validate(self,value:UUID,_:core_schema.ValidationInfo)->UUID
pydantic.types._SecretFieldValidator
pydantic.types._SecretFieldValidator.__get_pydantic_core_schema__(self,source:type[Any],handler:GetCoreSchemaHandler)->core_schema.CoreSchema
pydantic.types._SecretFieldValidator.__get_pydantic_json_schema__(self,_core_schema:core_schema.CoreSchema,handler:GetJsonSchemaHandler)->JsonSchemaValue
pydantic.types._SecretFieldValidator.serialize(self,value:SecretField[SecretType],info:core_schema.SerializationInfo)->str | SecretField[SecretType]
pydantic.types._SecretFieldValidator.validate(self,value:SecretField[SecretType]|SecretType,_:core_schema.ValidationInfo)->Any
pydantic.types._secret_display(value:str|bytes)->str
pydantic.types.conbytes(*,min_length:int|None=None,max_length:int|None=None,strict:bool|None=None)->type[bytes]
pydantic.types.condate(*,strict:bool|None=None,gt:date|None=None,ge:date|None=None,lt:date|None=None,le:date|None=None)->type[date]
pydantic.types.condecimal(*,strict:bool|None=None,gt:int|Decimal|None=None,ge:int|Decimal|None=None,lt:int|Decimal|None=None,le:int|Decimal|None=None,multiple_of:int|Decimal|None=None,max_digits:int|None=None,decimal_places:int|None=None,allow_inf_nan:bool|None=None)->type[Decimal]
pydantic.types.confloat(*,strict:bool|None=None,gt:float|None=None,ge:float|None=None,lt:float|None=None,le:float|None=None,multiple_of:float|None=None,allow_inf_nan:bool|None=None)->type[float]
pydantic.types.confrozenset(item_type:type[HashableItemType],*,min_length:int|None=None,max_length:int|None=None)->type[frozenset[HashableItemType]]
pydantic.types.conint(*,strict:bool|None=None,gt:int|None=None,ge:int|None=None,lt:int|None=None,le:int|None=None,multiple_of:int|None=None)->type[int]
pydantic.types.conlist(item_type:type[AnyItemType],*,min_length:int|None=None,max_length:int|None=None,unique_items:bool|None=None)->type[list[AnyItemType]]
pydantic.types.conset(item_type:type[HashableItemType],*,min_length:int|None=None,max_length:int|None=None)->type[set[HashableItemType]]
pydantic.types.constr(*,strip_whitespace:bool|None=None,to_upper:bool|None=None,to_lower:bool|None=None,strict:bool|None=None,min_length:int|None=None,max_length:int|None=None,pattern:str|None=None)->type[str]


----------------------------------------/home/zhang/Packages/pydantic/pydantic2.0a4/color.py----------------------------------------
A:pydantic.color.self._rgba->parse_str(value)
A:pydantic.color.rgb->cast(Tuple[int, int, int], self.as_rgb_tuple())
A:pydantic.color.as_hex->''.join((as_hex[c] for c in range(0, len(as_hex), 2)))
A:pydantic.color.(h, s, li)->self.as_hsl_tuple(alpha=False)
A:pydantic.color.(h, s, li, a)->self.as_hsl_tuple(alpha=True)
A:pydantic.color.(h, l, s)->rgb_to_hls(self._rgba.r, self._rgba.g, self._rgba.b)
A:pydantic.color.value_lower->value.lower()
A:pydantic.color.m->re.fullmatch(r_hex_long, value_lower)
A:pydantic.color.(*rgb, a)->re.fullmatch(r_hex_long, value_lower).groups()
A:pydantic.color.color->float(value)
A:pydantic.color.alpha->float(value)
A:pydantic.color.h_value->float(h)
A:pydantic.color.(r, g, b)->hls_to_rgb(h_value, l_value, s_value)
pydantic.color.Color(self,value:ColorType)
pydantic.color.Color.__eq__(self,other:Any)->bool
pydantic.color.Color.__get_pydantic_core_schema__(cls,source:Type[Any],handler:Callable[[Any],CoreSchema])->core_schema.CoreSchema
pydantic.color.Color.__get_pydantic_json_schema__(cls,core_schema:core_schema.CoreSchema,handler:GetJsonSchemaHandler)->JsonSchemaValue
pydantic.color.Color.__hash__(self)->int
pydantic.color.Color.__repr_args__(self)->'_repr.ReprArgs'
pydantic.color.Color.__str__(self)->str
pydantic.color.Color._alpha_float(self)->float
pydantic.color.Color._validate(cls,__input_value:Any,_:Any)->'Color'
pydantic.color.Color.as_hex(self)->str
pydantic.color.Color.as_hsl(self)->str
pydantic.color.Color.as_hsl_tuple(self,*,alpha:Optional[bool]=None)->HslColorTuple
pydantic.color.Color.as_named(self,*,fallback:bool=False)->str
pydantic.color.Color.as_rgb(self)->str
pydantic.color.Color.as_rgb_tuple(self,*,alpha:Optional[bool]=None)->ColorTuple
pydantic.color.Color.original(self)->ColorType
pydantic.color.RGBA(self,r:float,g:float,b:float,alpha:Optional[float])
pydantic.color.RGBA.__getitem__(self,item:Any)->Any
pydantic.color.float_to_255(c:float)->int
pydantic.color.ints_to_rgba(r:Union[int,str],g:Union[int,str],b:Union[int,str],alpha:Optional[float]=None)->RGBA
pydantic.color.parse_color_value(value:Union[int,str],max_val:int=255)->float
pydantic.color.parse_float_alpha(value:Union[None,str,float,int])->Optional[float]
pydantic.color.parse_hsl(h:str,h_units:str,sat:str,light:str,alpha:Optional[float]=None)->RGBA
pydantic.color.parse_str(value:str)->RGBA
pydantic.color.parse_tuple(value:Tuple[Any,...])->RGBA


----------------------------------------/home/zhang/Packages/pydantic/pydantic2.0a4/dataclasses.py----------------------------------------
A:pydantic.dataclasses._T->TypeVar('_T')
A:pydantic.dataclasses.kwargs->dict(kw_only=kw_only)
A:pydantic.dataclasses.config_wrapper->_internal._config.ConfigWrapper(config)
A:pydantic.dataclasses.decorators->_internal._decorators.DecoratorInfos.build(cls)
A:pydantic.dataclasses.cls->dataclasses.dataclass(cls, init=init, repr=repr, eq=eq, order=order, unsafe_hash=unsafe_hash, frozen=frozen, **kwargs)
A:pydantic.dataclasses.__getattr__->getattr_migration(__name__)
pydantic.dataclasses.dataclass(_cls:type[_T]|None=None,*,init:Literal[False]=False,repr:bool=True,eq:bool=True,order:bool=False,unsafe_hash:bool=False,frozen:bool=False,config:ConfigDict|type[object]|None=None,validate_on_init:bool|None=None,kw_only:bool=False)->Callable[[type[_T]], type[PydanticDataclass]] | type[PydanticDataclass]


----------------------------------------/home/zhang/Packages/pydantic/pydantic2.0a4/class_validators.py----------------------------------------
A:pydantic.class_validators.__getattr__->getattr_migration(__name__)


----------------------------------------/home/zhang/Packages/pydantic/pydantic2.0a4/validators.py----------------------------------------
A:pydantic.validators.__getattr__->getattr_migration(__name__)


----------------------------------------/home/zhang/Packages/pydantic/pydantic2.0a4/utils.py----------------------------------------
A:pydantic.utils.__getattr__->getattr_migration(__name__)


----------------------------------------/home/zhang/Packages/pydantic/pydantic2.0a4/decorator.py----------------------------------------
A:pydantic.decorator.__getattr__->getattr_migration(__name__)


----------------------------------------/home/zhang/Packages/pydantic/pydantic2.0a4/parse.py----------------------------------------
A:pydantic.parse.__getattr__->getattr_migration(__name__)


----------------------------------------/home/zhang/Packages/pydantic/pydantic2.0a4/env_settings.py----------------------------------------
A:pydantic.env_settings.__getattr__->getattr_migration(__name__)


----------------------------------------/home/zhang/Packages/pydantic/pydantic2.0a4/tools.py----------------------------------------
A:pydantic.tools.__getattr__->getattr_migration(__name__)


----------------------------------------/home/zhang/Packages/pydantic/pydantic2.0a4/annotated_arguments.py----------------------------------------
A:pydantic.annotated_arguments.schema->handler(source_type)
A:pydantic.annotated_arguments.info_arg->inspect_validator(self.func, 'wrap')
A:pydantic.annotated_arguments.schema['serialization']->pydantic_core.core_schema.wrap_serializer_function_ser_schema(function=self.func, info_arg=inspect_annotated_serializer(self.func, 'wrap'), json_return_type=self.json_return_type, when_used=self.when_used)
pydantic.annotated_arguments.AfterValidator
pydantic.annotated_arguments.AfterValidator.__get_pydantic_core_schema__(self,source_type:Any,handler:GetCoreSchemaHandler)->core_schema.CoreSchema
pydantic.annotated_arguments.BeforeValidator
pydantic.annotated_arguments.BeforeValidator.__get_pydantic_core_schema__(self,source_type:Any,handler:GetCoreSchemaHandler)->core_schema.CoreSchema
pydantic.annotated_arguments.PlainSerializer
pydantic.annotated_arguments.PlainSerializer.__get_pydantic_core_schema__(self,source_type:Any,handler:GetCoreSchemaHandler)->core_schema.CoreSchema
pydantic.annotated_arguments.PlainValidator
pydantic.annotated_arguments.PlainValidator.__get_pydantic_core_schema__(self,source_type:Any,handler:GetCoreSchemaHandler)->core_schema.CoreSchema
pydantic.annotated_arguments.WrapSerializer
pydantic.annotated_arguments.WrapSerializer.__get_pydantic_core_schema__(self,source_type:Any,handler:GetCoreSchemaHandler)->core_schema.CoreSchema
pydantic.annotated_arguments.WrapValidator
pydantic.annotated_arguments.WrapValidator.__get_pydantic_core_schema__(self,source_type:Any,handler:GetCoreSchemaHandler)->core_schema.CoreSchema


----------------------------------------/home/zhang/Packages/pydantic/pydantic2.0a4/datetime_parse.py----------------------------------------
A:pydantic.datetime_parse.__getattr__->getattr_migration(__name__)


----------------------------------------/home/zhang/Packages/pydantic/pydantic2.0a4/_migration.py----------------------------------------
pydantic._migration.getattr_migration(module:str)->Callable[[str], Any]
pydantic.getattr_migration(module:str)->Callable[[str], Any]


----------------------------------------/home/zhang/Packages/pydantic/pydantic2.0a4/errors.py----------------------------------------
A:pydantic.errors.name->re.search(".*'(.+?)'", str(name_error)).group(1)
A:pydantic.errors.__getattr__->getattr_migration(__name__)
pydantic.PydanticErrorMixin(self,message:str,*,code:PydanticErrorCodes|None)
pydantic.PydanticErrorMixin.__str__(self)->str
pydantic.PydanticImportError(self,message:str)
pydantic.PydanticInvalidForJsonSchema(self,message:str)
pydantic.PydanticSchemaGenerationError(self,message:str)
pydantic.PydanticUndefinedAnnotation(self,name:str,message:str)
pydantic.PydanticUndefinedAnnotation.from_name_error(cls,name_error:NameError)->PydanticUndefinedAnnotation
pydantic.PydanticUserError(PydanticErrorMixin,TypeError)
pydantic.errors.PydanticErrorMixin(self,message:str,*,code:PydanticErrorCodes|None)
pydantic.errors.PydanticErrorMixin.__str__(self)->str
pydantic.errors.PydanticImportError(self,message:str)
pydantic.errors.PydanticInvalidForJsonSchema(self,message:str)
pydantic.errors.PydanticSchemaGenerationError(self,message:str)
pydantic.errors.PydanticUndefinedAnnotation(self,name:str,message:str)
pydantic.errors.PydanticUndefinedAnnotation.from_name_error(cls,name_error:NameError)->PydanticUndefinedAnnotation
pydantic.errors.PydanticUserError(PydanticErrorMixin,TypeError)


----------------------------------------/home/zhang/Packages/pydantic/pydantic2.0a4/type_adapter.py----------------------------------------
A:pydantic.type_adapter.T->TypeVar('T')
A:pydantic.type_adapter.local_ns->_internal._typing_extra.parent_frame_namespace(parent_depth=parent_depth)
A:pydantic.type_adapter.global_ns->sys._getframe(max(parent_depth - 1, 1)).f_globals.copy()
A:pydantic.type_adapter.gen->_internal._generate_schema.GenerateSchema(config_wrapper, types_namespace=global_ns, typevars_map={})
A:pydantic.type_adapter.config_wrapper->_internal._config.ConfigWrapper(config)
A:pydantic.type_adapter.core_schema->flatten_schema_defs(core_schema)
A:pydantic.type_adapter.simplified_core_schema->inline_schema_defs(core_schema)
A:pydantic.type_adapter.core_config->_internal._config.ConfigWrapper(config).core_config()
A:pydantic.type_adapter.validator->SchemaValidator(simplified_core_schema, core_config)
A:pydantic.type_adapter.serializer->SchemaSerializer(simplified_core_schema, core_config)
A:pydantic.type_adapter.schema_generator_instance->schema_generator(by_alias=by_alias, ref_template=ref_template)
A:pydantic.type_adapter.definitions->schema_generator(by_alias=by_alias, ref_template=ref_template).generate_definitions(core_schemas)
pydantic.TypeAdapter(self,__type:Any,*,config:ConfigDict|None=None,_parent_depth:int=2)
pydantic.TypeAdapter.dump_json(self,__instance:T,*,indent:int|None=None,include:IncEx|None=None,exclude:IncEx|None=None,by_alias:bool=False,exclude_unset:bool=False,exclude_defaults:bool=False,exclude_none:bool=False,round_trip:bool=False,warnings:bool=True)->bytes
pydantic.TypeAdapter.dump_python(self,__instance:T,*,mode:Literal['json','python']='python',include:IncEx|None=None,exclude:IncEx|None=None,by_alias:bool=False,exclude_unset:bool=False,exclude_defaults:bool=False,exclude_none:bool=False,round_trip:bool=False,warnings:bool=True)->Any
pydantic.TypeAdapter.json_schema(self,*,by_alias:bool=True,ref_template:str=DEFAULT_REF_TEMPLATE,schema_generator:type[GenerateJsonSchema]=GenerateJsonSchema)->dict[str, Any]
pydantic.TypeAdapter.json_schemas(__types:Iterable[TypeAdapter[Any]],*,by_alias:bool=True,ref_template:str=DEFAULT_REF_TEMPLATE,title:str|None=None,description:str|None=None,schema_generator:type[GenerateJsonSchema]=GenerateJsonSchema)->dict[str, Any]
pydantic.TypeAdapter.validate_json(self,__data:str|bytes,*,strict:bool|None=None,context:dict[str,Any]|None=None)->T
pydantic.TypeAdapter.validate_python(self,__object:Any,*,strict:bool|None=None,context:dict[str,Any]|None=None)->T
pydantic.type_adapter.TypeAdapter(self,__type:Any,*,config:ConfigDict|None=None,_parent_depth:int=2)
pydantic.type_adapter.TypeAdapter.dump_json(self,__instance:T,*,indent:int|None=None,include:IncEx|None=None,exclude:IncEx|None=None,by_alias:bool=False,exclude_unset:bool=False,exclude_defaults:bool=False,exclude_none:bool=False,round_trip:bool=False,warnings:bool=True)->bytes
pydantic.type_adapter.TypeAdapter.dump_python(self,__instance:T,*,mode:Literal['json','python']='python',include:IncEx|None=None,exclude:IncEx|None=None,by_alias:bool=False,exclude_unset:bool=False,exclude_defaults:bool=False,exclude_none:bool=False,round_trip:bool=False,warnings:bool=True)->Any
pydantic.type_adapter.TypeAdapter.json_schema(self,*,by_alias:bool=True,ref_template:str=DEFAULT_REF_TEMPLATE,schema_generator:type[GenerateJsonSchema]=GenerateJsonSchema)->dict[str, Any]
pydantic.type_adapter.TypeAdapter.json_schemas(__types:Iterable[TypeAdapter[Any]],*,by_alias:bool=True,ref_template:str=DEFAULT_REF_TEMPLATE,title:str|None=None,description:str|None=None,schema_generator:type[GenerateJsonSchema]=GenerateJsonSchema)->dict[str, Any]
pydantic.type_adapter.TypeAdapter.validate_json(self,__data:str|bytes,*,strict:bool|None=None,context:dict[str,Any]|None=None)->T
pydantic.type_adapter.TypeAdapter.validate_python(self,__object:Any,*,strict:bool|None=None,context:dict[str,Any]|None=None)->T
pydantic.type_adapter._get_schema(type_:Any,config_wrapper:_config.ConfigWrapper,parent_depth:int)->CoreSchema


----------------------------------------/home/zhang/Packages/pydantic/pydantic2.0a4/error_wrappers.py----------------------------------------
A:pydantic.error_wrappers.__getattr__->getattr_migration(__name__)


----------------------------------------/home/zhang/Packages/pydantic/pydantic2.0a4/main.py----------------------------------------
A:pydantic.main.Model->typing.TypeVar('Model', bound='BaseModel')
A:pydantic.main.(base_field_names, class_vars, base_private_attributes)->_collect_bases_data(bases)
A:pydantic.main.config_wrapper->_internal._config.ConfigWrapper.for_model(bases, namespace, kwargs)
A:pydantic.main.private_attributes->_internal._model_construction.inspect_namespace(namespace, config_wrapper.ignored_types, class_vars, base_field_names)
A:pydantic.main.cls.__pydantic_decorators__->_internal._decorators.DecoratorInfos.build(cls)
A:pydantic.main.parameters->getattr(cls, '__parameters__', ())
A:pydantic.main.parent_parameters->getattr(cls, '__pydantic_generic_metadata__', {}).get('parameters', ())
A:pydantic.main.parameters_str->', '.join([str(x) for x in combined_parameters])
A:pydantic.main.set_name->getattr(obj, '__set_name__', None)
A:pydantic.main.cls.__pydantic_parent_namespace__->_internal._typing_extra.parent_frame_namespace()
A:pydantic.main.parent_namespace->getattr(cls, '__pydantic_parent_namespace__', None)
A:pydantic.main.types_namespace->_internal._typing_extra.get_cls_types_namespace(cls, types_namespace)
A:pydantic.main.__pydantic_decorators__->_internal._decorators.DecoratorInfos()
A:pydantic.main.__pydantic_validator__->_internal._model_construction.MockValidator('Pydantic models should inherit from BaseModel, BaseModel cannot be instantiated directly', code='base-model-instantiated')
A:pydantic.main.model_config->ConfigDict()
A:pydantic.main.attr->getattr(self.__class__, name, None)
A:pydantic.main.m->type(self).__new__(cls)
A:pydantic.main.fields_values[name]->field.get_default(call_default_factory=True)
A:pydantic.main._fields_set->set(values.keys())
A:pydantic.main.cls->type(self)
A:pydantic.main.value->getattr(self, name, Undefined)
A:pydantic.main.cached->_internal._generics.get_cached_generic_type_late(cls, typevar_values, origin, args)
A:pydantic.main.args->tuple((_generics.replace_types(arg, typevars_map) for arg in parent_args))
A:pydantic.main.model_name->origin.model_parametrized_name(args)
A:pydantic.main.params->tuple({param: None for param in _generics.iter_contained_typevars(typevars_map.values())})
A:pydantic.main.submodel->_internal._generics.create_generic_submodel(model_name, origin, args, params)
A:pydantic.main.params_component->', '.join(param_names)
A:pydantic.main.obj->deprecated.parse.load_file(path, proto=proto, content_type=content_type, encoding=encoding, allow_pickle=allow_pickle)
A:pydantic.main.values->dict(_deprecated_copy_internals._iter(self, to_dict=False, by_alias=False, include=include, exclude=exclude, exclude_unset=False), **update or {})
A:pydantic.main.extra->self.__pydantic_extra__.copy()
A:pydantic.main.extra[k]->dict(_deprecated_copy_internals._iter(self, to_dict=False, by_alias=False, include=include, exclude=exclude, exclude_unset=False), **update or {}).pop(k)
A:pydantic.main.fields_set->set(self.__pydantic_fields_set__)
A:pydantic.main.f_def->cast('tuple[str, Any]', f_def)
A:pydantic.main.resolved_bases->resolve_bases(__base__)
A:pydantic.main.(meta, ns, kwds)->prepare_class(__model_name, resolved_bases, kwds=__cls_kwargs__)
A:pydantic.main.__getattr__->getattr_migration(__name__)
pydantic.BaseModel(__pydantic_self__,**data:Any)
pydantic.BaseModel.__class_getitem__(cls,typevar_values:type[Any]|tuple[type[Any],...])->type[BaseModel] | _forward_ref.PydanticForwardRef | _forward_ref.PydanticRecursiveRef
pydantic.BaseModel.__copy__(self:Model)->Model
pydantic.BaseModel.__deepcopy__(self:Model,memo:dict[int,Any]|None=None)->Model
pydantic.BaseModel.__eq__(self,other:Any)->bool
pydantic.BaseModel.__fields_set__(self)->set[str]
pydantic.BaseModel.__get_pydantic_core_schema__(cls,__source:type[BaseModel],__handler:Callable[[Any],CoreSchema])->CoreSchema
pydantic.BaseModel.__get_pydantic_json_schema__(cls,__core_schema:CoreSchema,__handler:GetJsonSchemaHandler)->JsonSchemaValue
pydantic.BaseModel.__getstate__(self)->dict[Any, Any]
pydantic.BaseModel.__iter__(self)->TupleGenerator
pydantic.BaseModel.__pydantic_init_subclass__(cls,**kwargs:Any)->None
pydantic.BaseModel.__repr_args__(self)->_repr.ReprArgs
pydantic.BaseModel.__setattr__(self,name:str,value:Any)->None
pydantic.BaseModel.__setstate__(self,state:dict[Any,Any])->None
pydantic.BaseModel._calculate_keys(self,*args:Any,**kwargs:Any)->Any
pydantic.BaseModel._copy_and_set_values(self,*args:Any,**kwargs:Any)->Any
pydantic.BaseModel._get_value(cls,*args:Any,**kwargs:Any)->Any
pydantic.BaseModel._iter(self,*args:Any,**kwargs:Any)->Any
pydantic.BaseModel.construct(cls:type[Model],_fields_set:set[str]|None=None,**values:Any)->Model
pydantic.BaseModel.copy(self:Model,*,include:AbstractSetIntStr|MappingIntStrAny|None=None,exclude:AbstractSetIntStr|MappingIntStrAny|None=None,update:typing.Dict[str,Any]|None=None,deep:bool=False)->Model
pydantic.BaseModel.dict(self,*,include:IncEx=None,exclude:IncEx=None,by_alias:bool=False,exclude_unset:bool=False,exclude_defaults:bool=False,exclude_none:bool=False)->typing.Dict[str, Any]
pydantic.BaseModel.from_orm(cls:type[Model],obj:Any)->Model
pydantic.BaseModel.json(self,*,include:IncEx=None,exclude:IncEx=None,by_alias:bool=False,exclude_unset:bool=False,exclude_defaults:bool=False,exclude_none:bool=False,encoder:typing.Callable[[Any],Any]|None=Undefined,models_as_dict:bool=Undefined,**dumps_kwargs:Any)->str
pydantic.BaseModel.model_computed_fields(self)->dict[str, ComputedFieldInfo]
pydantic.BaseModel.model_construct(cls:type[Model],_fields_set:set[str]|None=None,**values:Any)->Model
pydantic.BaseModel.model_copy(self:Model,*,update:dict[str,Any]|None=None,deep:bool=False)->Model
pydantic.BaseModel.model_dump(self,*,mode:typing_extensions.Literal['json','python']|str='python',include:IncEx=None,exclude:IncEx=None,by_alias:bool=False,exclude_unset:bool=False,exclude_defaults:bool=False,exclude_none:bool=False,round_trip:bool=False,warnings:bool=True)->dict[str, Any]
pydantic.BaseModel.model_dump_json(self,*,indent:int|None=None,include:IncEx=None,exclude:IncEx=None,by_alias:bool=False,exclude_unset:bool=False,exclude_defaults:bool=False,exclude_none:bool=False,round_trip:bool=False,warnings:bool=True)->str
pydantic.BaseModel.model_extra(self)->dict[str, Any] | None
pydantic.BaseModel.model_fields_set(self)->set[str]
pydantic.BaseModel.model_json_schema(cls,by_alias:bool=True,ref_template:str=DEFAULT_REF_TEMPLATE,schema_generator:type[GenerateJsonSchema]=GenerateJsonSchema)->dict[str, Any]
pydantic.BaseModel.model_modify_json_schema(cls,json_schema:JsonSchemaValue)->JsonSchemaValue
pydantic.BaseModel.model_parametrized_name(cls,params:tuple[type[Any],...])->str
pydantic.BaseModel.model_post_init(self,__context:Any)->None
pydantic.BaseModel.model_rebuild(cls,*,force:bool=False,raise_errors:bool=True,_parent_namespace_depth:int=2,_types_namespace:dict[str,Any]|None=None)->bool | None
pydantic.BaseModel.model_validate(cls:type[Model],obj:Any,*,strict:bool|None=None,context:dict[str,Any]|None=None)->Model
pydantic.BaseModel.model_validate_json(cls:type[Model],json_data:str|bytes|bytearray,*,strict:bool|None=None,context:dict[str,Any]|None=None)->Model
pydantic.BaseModel.parse_file(cls:type[Model],path:str|Path,*,content_type:str|None=None,encoding:str='utf8',proto:_deprecated_parse.Protocol|None=None,allow_pickle:bool=False)->Model
pydantic.BaseModel.parse_obj(cls:type[Model],obj:Any)->Model
pydantic.BaseModel.parse_raw(cls:type[Model],b:str|bytes,*,content_type:str|None=None,encoding:str='utf8',proto:_deprecated_parse.Protocol|None=None,allow_pickle:bool=False)->Model
pydantic.BaseModel.schema(cls,by_alias:bool=True,ref_template:str=DEFAULT_REF_TEMPLATE)->typing.Dict[str, Any]
pydantic.BaseModel.schema_json(cls,*,by_alias:bool=True,ref_template:str=DEFAULT_REF_TEMPLATE,**dumps_kwargs:Any)->str
pydantic.BaseModel.update_forward_refs(cls,**localns:Any)->None
pydantic.BaseModel.validate(cls:type[Model],value:Any)->Model
pydantic.ModelMetaclass(mcs,cls_name:str,bases:tuple[type[Any],...],namespace:dict[str,Any],__pydantic_generic_metadata__:_generics.PydanticGenericMetadata|None=None,__pydantic_reset_parent_namespace__:bool=True,**kwargs:Any)
pydantic.ModelMetaclass.__instancecheck__(self,instance:Any)->bool
pydantic.ModelMetaclass.__prepare__(cls,*args:Any,**kwargs:Any)->Mapping[str, object]
pydantic._ModelNamespaceDict(dict)
pydantic._ModelNamespaceDict.__setitem__(self,k:str,v:object)->None
pydantic._collect_bases_data(bases:tuple[type[Any],...])->tuple[set[str], set[str], dict[str, ModelPrivateAttr]]
pydantic.create_model(__model_name:str,*,__config__:ConfigDict|None=None,__base__:None=None,__module__:str=__name__,__validators__:dict[str,AnyClassMethod]|None=None,__cls_kwargs__:dict[str,Any]|None=None,**field_definitions:Any)->type[BaseModel]
pydantic.create_model(__model_name:str,*,__config__:ConfigDict|None=None,__base__:type[Model]|tuple[type[Model],...],__module__:str=__name__,__validators__:dict[str,AnyClassMethod]|None=None,__cls_kwargs__:dict[str,Any]|None=None,**field_definitions:Any)->type[Model]
pydantic.create_model(__model_name:str,*,__config__:ConfigDict|None=None,__base__:type[Model]|tuple[type[Model],...]|None=None,__module__:str=__name__,__validators__:dict[str,AnyClassMethod]|None=None,__cls_kwargs__:dict[str,Any]|None=None,__slots__:tuple[str,...]|None=None,**field_definitions:Any)->type[Model]
pydantic.main.BaseModel(__pydantic_self__,**data:Any)
pydantic.main.BaseModel.__class_getitem__(cls,typevar_values:type[Any]|tuple[type[Any],...])->type[BaseModel] | _forward_ref.PydanticForwardRef | _forward_ref.PydanticRecursiveRef
pydantic.main.BaseModel.__copy__(self:Model)->Model
pydantic.main.BaseModel.__deepcopy__(self:Model,memo:dict[int,Any]|None=None)->Model
pydantic.main.BaseModel.__eq__(self,other:Any)->bool
pydantic.main.BaseModel.__fields_set__(self)->set[str]
pydantic.main.BaseModel.__get_pydantic_core_schema__(cls,__source:type[BaseModel],__handler:Callable[[Any],CoreSchema])->CoreSchema
pydantic.main.BaseModel.__get_pydantic_json_schema__(cls,__core_schema:CoreSchema,__handler:GetJsonSchemaHandler)->JsonSchemaValue
pydantic.main.BaseModel.__getstate__(self)->dict[Any, Any]
pydantic.main.BaseModel.__iter__(self)->TupleGenerator
pydantic.main.BaseModel.__pydantic_init_subclass__(cls,**kwargs:Any)->None
pydantic.main.BaseModel.__repr_args__(self)->_repr.ReprArgs
pydantic.main.BaseModel.__setattr__(self,name:str,value:Any)->None
pydantic.main.BaseModel.__setstate__(self,state:dict[Any,Any])->None
pydantic.main.BaseModel._calculate_keys(self,*args:Any,**kwargs:Any)->Any
pydantic.main.BaseModel._copy_and_set_values(self,*args:Any,**kwargs:Any)->Any
pydantic.main.BaseModel._get_value(cls,*args:Any,**kwargs:Any)->Any
pydantic.main.BaseModel._iter(self,*args:Any,**kwargs:Any)->Any
pydantic.main.BaseModel.construct(cls:type[Model],_fields_set:set[str]|None=None,**values:Any)->Model
pydantic.main.BaseModel.copy(self:Model,*,include:AbstractSetIntStr|MappingIntStrAny|None=None,exclude:AbstractSetIntStr|MappingIntStrAny|None=None,update:typing.Dict[str,Any]|None=None,deep:bool=False)->Model
pydantic.main.BaseModel.dict(self,*,include:IncEx=None,exclude:IncEx=None,by_alias:bool=False,exclude_unset:bool=False,exclude_defaults:bool=False,exclude_none:bool=False)->typing.Dict[str, Any]
pydantic.main.BaseModel.from_orm(cls:type[Model],obj:Any)->Model
pydantic.main.BaseModel.json(self,*,include:IncEx=None,exclude:IncEx=None,by_alias:bool=False,exclude_unset:bool=False,exclude_defaults:bool=False,exclude_none:bool=False,encoder:typing.Callable[[Any],Any]|None=Undefined,models_as_dict:bool=Undefined,**dumps_kwargs:Any)->str
pydantic.main.BaseModel.model_computed_fields(self)->dict[str, ComputedFieldInfo]
pydantic.main.BaseModel.model_construct(cls:type[Model],_fields_set:set[str]|None=None,**values:Any)->Model
pydantic.main.BaseModel.model_copy(self:Model,*,update:dict[str,Any]|None=None,deep:bool=False)->Model
pydantic.main.BaseModel.model_dump(self,*,mode:typing_extensions.Literal['json','python']|str='python',include:IncEx=None,exclude:IncEx=None,by_alias:bool=False,exclude_unset:bool=False,exclude_defaults:bool=False,exclude_none:bool=False,round_trip:bool=False,warnings:bool=True)->dict[str, Any]
pydantic.main.BaseModel.model_dump_json(self,*,indent:int|None=None,include:IncEx=None,exclude:IncEx=None,by_alias:bool=False,exclude_unset:bool=False,exclude_defaults:bool=False,exclude_none:bool=False,round_trip:bool=False,warnings:bool=True)->str
pydantic.main.BaseModel.model_extra(self)->dict[str, Any] | None
pydantic.main.BaseModel.model_fields_set(self)->set[str]
pydantic.main.BaseModel.model_json_schema(cls,by_alias:bool=True,ref_template:str=DEFAULT_REF_TEMPLATE,schema_generator:type[GenerateJsonSchema]=GenerateJsonSchema)->dict[str, Any]
pydantic.main.BaseModel.model_modify_json_schema(cls,json_schema:JsonSchemaValue)->JsonSchemaValue
pydantic.main.BaseModel.model_parametrized_name(cls,params:tuple[type[Any],...])->str
pydantic.main.BaseModel.model_post_init(self,__context:Any)->None
pydantic.main.BaseModel.model_rebuild(cls,*,force:bool=False,raise_errors:bool=True,_parent_namespace_depth:int=2,_types_namespace:dict[str,Any]|None=None)->bool | None
pydantic.main.BaseModel.model_validate(cls:type[Model],obj:Any,*,strict:bool|None=None,context:dict[str,Any]|None=None)->Model
pydantic.main.BaseModel.model_validate_json(cls:type[Model],json_data:str|bytes|bytearray,*,strict:bool|None=None,context:dict[str,Any]|None=None)->Model
pydantic.main.BaseModel.parse_file(cls:type[Model],path:str|Path,*,content_type:str|None=None,encoding:str='utf8',proto:_deprecated_parse.Protocol|None=None,allow_pickle:bool=False)->Model
pydantic.main.BaseModel.parse_obj(cls:type[Model],obj:Any)->Model
pydantic.main.BaseModel.parse_raw(cls:type[Model],b:str|bytes,*,content_type:str|None=None,encoding:str='utf8',proto:_deprecated_parse.Protocol|None=None,allow_pickle:bool=False)->Model
pydantic.main.BaseModel.schema(cls,by_alias:bool=True,ref_template:str=DEFAULT_REF_TEMPLATE)->typing.Dict[str, Any]
pydantic.main.BaseModel.schema_json(cls,*,by_alias:bool=True,ref_template:str=DEFAULT_REF_TEMPLATE,**dumps_kwargs:Any)->str
pydantic.main.BaseModel.update_forward_refs(cls,**localns:Any)->None
pydantic.main.BaseModel.validate(cls:type[Model],value:Any)->Model
pydantic.main.ModelMetaclass(mcs,cls_name:str,bases:tuple[type[Any],...],namespace:dict[str,Any],__pydantic_generic_metadata__:_generics.PydanticGenericMetadata|None=None,__pydantic_reset_parent_namespace__:bool=True,**kwargs:Any)
pydantic.main.ModelMetaclass.__instancecheck__(self,instance:Any)->bool
pydantic.main.ModelMetaclass.__prepare__(cls,*args:Any,**kwargs:Any)->Mapping[str, object]
pydantic.main._ModelNamespaceDict(dict)
pydantic.main._ModelNamespaceDict.__setitem__(self,k:str,v:object)->None
pydantic.main._collect_bases_data(bases:tuple[type[Any],...])->tuple[set[str], set[str], dict[str, ModelPrivateAttr]]
pydantic.main.create_model(__model_name:str,*,__config__:ConfigDict|None=None,__base__:None=None,__module__:str=__name__,__validators__:dict[str,AnyClassMethod]|None=None,__cls_kwargs__:dict[str,Any]|None=None,**field_definitions:Any)->type[BaseModel]
pydantic.main.create_model(__model_name:str,*,__config__:ConfigDict|None=None,__base__:type[Model]|tuple[type[Model],...],__module__:str=__name__,__validators__:dict[str,AnyClassMethod]|None=None,__cls_kwargs__:dict[str,Any]|None=None,**field_definitions:Any)->type[Model]
pydantic.main.create_model(__model_name:str,*,__config__:ConfigDict|None=None,__base__:type[Model]|tuple[type[Model],...]|None=None,__module__:str=__name__,__validators__:dict[str,AnyClassMethod]|None=None,__cls_kwargs__:dict[str,Any]|None=None,__slots__:tuple[str,...]|None=None,**field_definitions:Any)->type[Model]


----------------------------------------/home/zhang/Packages/pydantic/pydantic2.0a4/typing.py----------------------------------------
A:pydantic.typing.__getattr__->getattr_migration(__name__)


----------------------------------------/home/zhang/Packages/pydantic/pydantic2.0a4/config.py----------------------------------------
A:pydantic.config.Extra->_Extra()
A:pydantic.config.__getattr__->getattr_migration(__name__)
pydantic.ConfigDict(TypedDict,total=False)
pydantic.config.ConfigDict(TypedDict,total=False)
pydantic.config.JsonSchemaExtraCallable(self,schema:dict[str,Any],model_class:type[Any])
pydantic.config._Extra
pydantic.config._Extra.__getattribute__(self,__name:str)->Any


----------------------------------------/home/zhang/Packages/pydantic/pydantic2.0a4/json_schema.py----------------------------------------
A:pydantic.json_schema.CoreRef->NewType('CoreRef', str)
A:pydantic.json_schema.DefsRef->NewType('DefsRef', str)
A:pydantic.json_schema.JsonRef->NewType('JsonRef', str)
A:pydantic.json_schema.self._schema_type_to_method->self.build_schema_type_to_method()
A:pydantic.json_schema.mapping[key]->getattr(self, method_name)
A:pydantic.json_schema.json_schema->schema_generator(by_alias=by_alias, ref_template=ref_template).generate(cls.__pydantic_core_schema__)
A:pydantic.json_schema.json_ref_counts->self.get_json_ref_counts(json_schema)
A:pydantic.json_schema.ref->item.get('$ref')
A:pydantic.json_schema.ref_json_schema->self.get_schema_from_definitions(ref)
A:pydantic.json_schema.all_json_refs->list(self.json_to_defs_refs.keys())
A:pydantic.json_schema.core_ref->CoreRef(schema['schema_ref'])
A:pydantic.json_schema.metadata_handler->_internal._core_metadata.CoreMetadataHandler(schema)
A:pydantic.json_schema.(defs_ref, ref_json_schema)->self.get_cache_defs_ref_schema(core_ref)
A:pydantic.json_schema.current_handler->GenerateJsonSchemaHandler(self, new_handler_func)
A:pydantic.json_schema.json_schema['minItems']->len(schema['items_schema'])
A:pydantic.json_schema.json_schema['items']->self.generate_inner(schema['items_schema'])
A:pydantic.json_schema.json_schema['maxItems']->len(prefix_items)
A:pydantic.json_schema.keys_pattern->keys_schema.pop('pattern', None)
A:pydantic.json_schema.default->schema['default_factory']()
A:pydantic.json_schema.encoded_default->self.encode_default(default)
A:pydantic.json_schema.inner_json_schema->self.generate_inner(schema['schema'])
A:pydantic.json_schema.generated[str(k)]->self.generate_inner(v).copy()
A:pydantic.json_schema.one_of_choices->_deduplicate_schemas(generated.values())
A:pydantic.json_schema.openapi_discriminator->self._extract_discriminator(schema, one_of_choices)
A:pydantic.json_schema.properties->choice.get('properties', {})
A:pydantic.json_schema.use_strict->schema.get('strict', False)
A:pydantic.json_schema.alias->argument.get('alias')
A:pydantic.json_schema.field_json_schema->self.handle_ref_overrides(field_json_schema)
A:pydantic.json_schema.title->config.get('title')
A:pydantic.json_schema.cls->cast('type[BaseModel]', schema['cls'])
A:pydantic.json_schema.json_schema_extra->config.get('json_schema_extra')
A:pydantic.json_schema.prefer_positional->metadata.get('pydantic_js_prefer_positional_arguments')
A:pydantic.json_schema.var_args_schema->schema.get('var_args_schema')
A:pydantic.json_schema.var_kwargs_schema->schema.get('var_kwargs_schema')
A:pydantic.json_schema.name->self.get_argument_name(argument)
A:pydantic.json_schema.argument_schema->self.generate_inner(argument['schema']).copy()
A:pydantic.json_schema.argument_schema['title']->self.get_title_from_name(name)
A:pydantic.json_schema.additional_properties_schema->self.generate_inner(var_kwargs_schema)
A:pydantic.json_schema.items_schema->self.generate_inner(var_args_schema)
A:pydantic.json_schema.(_, ref_json_schema)->self.get_cache_defs_ref_schema(core_ref)
A:pydantic.json_schema.components->re.split('([\\][,])', core_ref)
A:pydantic.json_schema.core_ref_no_id->''.join(components)
A:pydantic.json_schema.short_ref->''.join(components)
A:pydantic.json_schema.first_choice->DefsRef(self.normalize_name(short_ref))
A:pydantic.json_schema.second_choice->DefsRef(self.normalize_name(core_ref_no_id))
A:pydantic.json_schema.third_choice->DefsRef(self.normalize_name(core_ref))
A:pydantic.json_schema.new_json_ref->JsonRef(self.ref_template.format(model=new))
A:pydantic.json_schema.self.definitions[new]->self.definitions.pop(old)
A:pydantic.json_schema.self.defs_to_core_refs[new]->self.defs_to_core_refs.pop(old)
A:pydantic.json_schema.self.json_to_defs_refs[new_json_ref]->self.json_to_defs_refs.pop(old_json_ref)
A:pydantic.json_schema.maybe_defs_ref->self.core_to_defs_refs.get(core_ref)
A:pydantic.json_schema.defs_ref->self.get_defs_ref(core_ref)
A:pydantic.json_schema.json_ref->JsonRef(schema['$ref'])
A:pydantic.json_schema.referenced_json_schema->self.get_schema_from_definitions(JsonRef(json_schema['$ref']))
A:pydantic.json_schema.members->_deduplicate_schemas(members)
A:pydantic.json_schema.message->self.render_warning_message(kind, detail)
A:pydantic.json_schema.instance->schema_generator(by_alias=by_alias, ref_template=ref_template)
A:pydantic.json_schema.definitions->schema_generator(by_alias=by_alias, ref_template=ref_template).generate_definitions([x.__pydantic_core_schema__ for x in models])
A:pydantic.json_schema._JSON_SCHEMA_CACHE->_JsonSchemaCache()
A:pydantic.json_schema.cls_json_schema_cache->_JsonSchemaCache().get(cls)
A:pydantic.json_schema.cached->_JsonSchemaCache().get(cls).get((by_alias, ref_template, schema_generator))
pydantic.json_schema.GenerateJsonSchema(self,by_alias:bool=True,ref_template:str=DEFAULT_REF_TEMPLATE)
pydantic.json_schema.GenerateJsonSchema.ValidationsMapping
pydantic.json_schema.GenerateJsonSchema._common_set_schema(self,schema:core_schema.SetSchema|core_schema.FrozenSetSchema)->JsonSchemaValue
pydantic.json_schema.GenerateJsonSchema._extract_discriminator(self,schema:core_schema.TaggedUnionSchema,one_of_choices:list[_JsonDict])->str | None
pydantic.json_schema.GenerateJsonSchema._function_schema(self,schema:_core_utils.AnyFunctionSchema)->JsonSchemaValue
pydantic.json_schema.GenerateJsonSchema._named_required_fields_schema(self,named_required_fields:Sequence[tuple[str,bool,CoreSchemaOrField]])->JsonSchemaValue
pydantic.json_schema.GenerateJsonSchema._update_class_schema(self,json_schema:JsonSchemaValue,title:str|None,forbid_additional_properties:bool,cls:type[Any],json_schema_extra:dict[str,Any]|JsonSchemaExtraCallable|None)->JsonSchemaValue
pydantic.json_schema.GenerateJsonSchema.any_schema(self,schema:core_schema.AnySchema)->JsonSchemaValue
pydantic.json_schema.GenerateJsonSchema.arguments_schema(self,schema:core_schema.ArgumentsSchema)->JsonSchemaValue
pydantic.json_schema.GenerateJsonSchema.bool_schema(self,schema:core_schema.BoolSchema)->JsonSchemaValue
pydantic.json_schema.GenerateJsonSchema.build_schema_type_to_method(self)->dict[CoreSchemaOrFieldType, Callable[[CoreSchemaOrField], JsonSchemaValue]]
pydantic.json_schema.GenerateJsonSchema.bytes_schema(self,schema:core_schema.BytesSchema)->JsonSchemaValue
pydantic.json_schema.GenerateJsonSchema.call_schema(self,schema:core_schema.CallSchema)->JsonSchemaValue
pydantic.json_schema.GenerateJsonSchema.callable_schema(self,schema:core_schema.CallableSchema)->JsonSchemaValue
pydantic.json_schema.GenerateJsonSchema.chain_schema(self,schema:core_schema.ChainSchema)->JsonSchemaValue
pydantic.json_schema.GenerateJsonSchema.change_defs_ref(self,old:DefsRef,new:DefsRef,json_schema:JsonSchemaValue)->JsonSchemaValue
pydantic.json_schema.GenerateJsonSchema.custom_error_schema(self,schema:core_schema.CustomErrorSchema)->JsonSchemaValue
pydantic.json_schema.GenerateJsonSchema.dataclass_args_schema(self,schema:core_schema.DataclassArgsSchema)->JsonSchemaValue
pydantic.json_schema.GenerateJsonSchema.dataclass_field_schema(self,schema:core_schema.DataclassField)->JsonSchemaValue
pydantic.json_schema.GenerateJsonSchema.dataclass_schema(self,schema:core_schema.DataclassSchema)->JsonSchemaValue
pydantic.json_schema.GenerateJsonSchema.date_schema(self,schema:core_schema.DateSchema)->JsonSchemaValue
pydantic.json_schema.GenerateJsonSchema.datetime_schema(self,schema:core_schema.DatetimeSchema)->JsonSchemaValue
pydantic.json_schema.GenerateJsonSchema.default_schema(self,schema:core_schema.WithDefaultSchema)->JsonSchemaValue
pydantic.json_schema.GenerateJsonSchema.definition_ref_schema(self,schema:core_schema.DefinitionReferenceSchema)->JsonSchemaValue
pydantic.json_schema.GenerateJsonSchema.definitions_schema(self,schema:core_schema.DefinitionsSchema)->JsonSchemaValue
pydantic.json_schema.GenerateJsonSchema.dict_schema(self,schema:core_schema.DictSchema)->JsonSchemaValue
pydantic.json_schema.GenerateJsonSchema.emit_warning(self,kind:JsonSchemaWarningKind,detail:str)->None
pydantic.json_schema.GenerateJsonSchema.encode_default(self,dft:Any)->Any
pydantic.json_schema.GenerateJsonSchema.field_title_should_be_set(self,schema:CoreSchemaOrField)->bool
pydantic.json_schema.GenerateJsonSchema.float_schema(self,schema:core_schema.FloatSchema)->JsonSchemaValue
pydantic.json_schema.GenerateJsonSchema.frozenset_schema(self,schema:core_schema.FrozenSetSchema)->JsonSchemaValue
pydantic.json_schema.GenerateJsonSchema.function_after_schema(self,schema:core_schema.AfterValidatorFunctionSchema)->JsonSchemaValue
pydantic.json_schema.GenerateJsonSchema.function_before_schema(self,schema:core_schema.BeforeValidatorFunctionSchema)->JsonSchemaValue
pydantic.json_schema.GenerateJsonSchema.function_plain_schema(self,schema:core_schema.PlainValidatorFunctionSchema)->JsonSchemaValue
pydantic.json_schema.GenerateJsonSchema.function_wrap_schema(self,schema:core_schema.WrapValidatorFunctionSchema)->JsonSchemaValue
pydantic.json_schema.GenerateJsonSchema.generate(self,schema:CoreSchema)->JsonSchemaValue
pydantic.json_schema.GenerateJsonSchema.generate_definitions(self,schemas:list[CoreSchema])->dict[DefsRef, JsonSchemaValue]
pydantic.json_schema.GenerateJsonSchema.generate_inner(self,schema:_core_metadata.CoreSchemaOrField)->JsonSchemaValue
pydantic.json_schema.GenerateJsonSchema.generator_schema(self,schema:core_schema.GeneratorSchema)->JsonSchemaValue
pydantic.json_schema.GenerateJsonSchema.get_argument_name(self,argument:core_schema.ArgumentsParameter)->str
pydantic.json_schema.GenerateJsonSchema.get_cache_defs_ref_schema(self,core_ref:CoreRef)->tuple[DefsRef, JsonSchemaValue]
pydantic.json_schema.GenerateJsonSchema.get_defs_ref(self,core_ref:CoreRef)->DefsRef
pydantic.json_schema.GenerateJsonSchema.get_flattened_anyof(self,schemas:list[JsonSchemaValue])->JsonSchemaValue
pydantic.json_schema.GenerateJsonSchema.get_json_ref_counts(self,json_schema:JsonSchemaValue)->dict[JsonRef, int]
pydantic.json_schema.GenerateJsonSchema.get_schema_from_definitions(self,json_ref:JsonRef)->JsonSchemaValue | None
pydantic.json_schema.GenerateJsonSchema.get_title_from_name(self,name:str)->str
pydantic.json_schema.GenerateJsonSchema.handle_invalid_for_json_schema(self,schema:CoreSchemaOrField,error_info:str)->JsonSchemaValue
pydantic.json_schema.GenerateJsonSchema.handle_ref_overrides(self,json_schema:JsonSchemaValue)->JsonSchemaValue
pydantic.json_schema.GenerateJsonSchema.int_schema(self,schema:core_schema.IntSchema)->JsonSchemaValue
pydantic.json_schema.GenerateJsonSchema.is_instance_schema(self,schema:core_schema.IsInstanceSchema)->JsonSchemaValue
pydantic.json_schema.GenerateJsonSchema.is_subclass_schema(self,schema:core_schema.IsSubclassSchema)->JsonSchemaValue
pydantic.json_schema.GenerateJsonSchema.json_schema(self,schema:core_schema.JsonSchema)->JsonSchemaValue
pydantic.json_schema.GenerateJsonSchema.kw_arguments_schema(self,arguments:list[core_schema.ArgumentsParameter],var_kwargs_schema:CoreSchema|None)->JsonSchemaValue
pydantic.json_schema.GenerateJsonSchema.lax_or_strict_schema(self,schema:core_schema.LaxOrStrictSchema)->JsonSchemaValue
pydantic.json_schema.GenerateJsonSchema.list_schema(self,schema:core_schema.ListSchema)->JsonSchemaValue
pydantic.json_schema.GenerateJsonSchema.literal_schema(self,schema:core_schema.LiteralSchema)->JsonSchemaValue
pydantic.json_schema.GenerateJsonSchema.model_field_schema(self,schema:core_schema.ModelField)->JsonSchemaValue
pydantic.json_schema.GenerateJsonSchema.model_fields_schema(self,schema:core_schema.ModelFieldsSchema)->JsonSchemaValue
pydantic.json_schema.GenerateJsonSchema.model_schema(self,schema:core_schema.ModelSchema)->JsonSchemaValue
pydantic.json_schema.GenerateJsonSchema.multi_host_url_schema(self,schema:core_schema.MultiHostUrlSchema)->JsonSchemaValue
pydantic.json_schema.GenerateJsonSchema.none_schema(self,schema:core_schema.NoneSchema)->JsonSchemaValue
pydantic.json_schema.GenerateJsonSchema.normalize_name(self,name:str)->str
pydantic.json_schema.GenerateJsonSchema.nullable_schema(self,schema:core_schema.NullableSchema)->JsonSchemaValue
pydantic.json_schema.GenerateJsonSchema.p_arguments_schema(self,arguments:list[core_schema.ArgumentsParameter],var_args_schema:CoreSchema|None)->JsonSchemaValue
pydantic.json_schema.GenerateJsonSchema.render_warning_message(self,kind:JsonSchemaWarningKind,detail:str)->str | None
pydantic.json_schema.GenerateJsonSchema.resolve_collisions(self,json_schema:JsonSchemaValue)->JsonSchemaValue
pydantic.json_schema.GenerateJsonSchema.set_schema(self,schema:core_schema.SetSchema)->JsonSchemaValue
pydantic.json_schema.GenerateJsonSchema.str_schema(self,schema:core_schema.StringSchema)->JsonSchemaValue
pydantic.json_schema.GenerateJsonSchema.tagged_union_schema(self,schema:core_schema.TaggedUnionSchema)->JsonSchemaValue
pydantic.json_schema.GenerateJsonSchema.time_schema(self,schema:core_schema.TimeSchema)->JsonSchemaValue
pydantic.json_schema.GenerateJsonSchema.timedelta_schema(self,schema:core_schema.TimedeltaSchema)->JsonSchemaValue
pydantic.json_schema.GenerateJsonSchema.tuple_positional_schema(self,schema:core_schema.TuplePositionalSchema)->JsonSchemaValue
pydantic.json_schema.GenerateJsonSchema.tuple_variable_schema(self,schema:core_schema.TupleVariableSchema)->JsonSchemaValue
pydantic.json_schema.GenerateJsonSchema.typed_dict_field_schema(self,schema:core_schema.TypedDictField)->JsonSchemaValue
pydantic.json_schema.GenerateJsonSchema.typed_dict_schema(self,schema:core_schema.TypedDictSchema)->JsonSchemaValue
pydantic.json_schema.GenerateJsonSchema.union_schema(self,schema:core_schema.UnionSchema)->JsonSchemaValue
pydantic.json_schema.GenerateJsonSchema.update_with_validations(self,json_schema:JsonSchemaValue,core_schema:CoreSchema,mapping:dict[str,str])->None
pydantic.json_schema.GenerateJsonSchema.url_schema(self,schema:core_schema.UrlSchema)->JsonSchemaValue
pydantic.json_schema.PydanticJsonSchemaWarning(UserWarning)
pydantic.json_schema._deduplicate_schemas(schemas:Iterable[_JsonDict])->list[_JsonDict]
pydantic.json_schema._make_json_hashable(value:_Json)->_HashableJson
pydantic.json_schema.model_json_schema(cls:type[BaseModel]|type[PydanticDataclass],by_alias:bool=True,ref_template:str=DEFAULT_REF_TEMPLATE,schema_generator:type[GenerateJsonSchema]=GenerateJsonSchema)->dict[str, Any]
pydantic.json_schema.models_json_schema(models:Sequence[type[BaseModel]|type[PydanticDataclass]],*,by_alias:bool=True,title:str|None=None,description:str|None=None,ref_template:str=DEFAULT_REF_TEMPLATE,schema_generator:type[GenerateJsonSchema]=GenerateJsonSchema)->dict[str, Any]
pydantic.json_schema.update_json_schema(schema:JsonSchemaValue,updates:dict[str,Any])->JsonSchemaValue


----------------------------------------/home/zhang/Packages/pydantic/pydantic2.0a4/validate_call.py----------------------------------------
A:pydantic.validate_call.AnyCallableT->TypeVar('AnyCallableT', bound=Callable[..., Any])
pydantic.validate_call(*,config:ConfigDict|None=None,validate_return:bool=False)->Callable[[AnyCallableT], AnyCallableT]
pydantic.validate_call(__func:AnyCallableT)->AnyCallableT
pydantic.validate_call(__func:AnyCallableT|None=None,*,config:ConfigDict|None=None,validate_return:bool=False)->AnyCallableT | Callable[[AnyCallableT], AnyCallableT]
pydantic.validate_call.validate_call(*,config:ConfigDict|None=None,validate_return:bool=False)->Callable[[AnyCallableT], AnyCallableT]
pydantic.validate_call.validate_call(__func:AnyCallableT)->AnyCallableT
pydantic.validate_call.validate_call(__func:AnyCallableT|None=None,*,config:ConfigDict|None=None,validate_return:bool=False)->AnyCallableT | Callable[[AnyCallableT], AnyCallableT]


----------------------------------------/home/zhang/Packages/pydantic/pydantic2.0a4/networks.py----------------------------------------
A:pydantic.networks.field_schema->handler(core_schema)
A:pydantic.networks.(name, email)->validate_email(__input_value)
A:pydantic.networks.pretty_email_regex->re.compile(' *([\\w ]*?) *<(.+?)> *')
A:pydantic.networks.m->re.compile(' *([\\w ]*?) *<(.+?)> *').fullmatch(value)
A:pydantic.networks.(name, value)->re.compile(' *([\\w ]*?) *<(.+?)> *').fullmatch(value).groups()
A:pydantic.networks.email->value.strip()
A:pydantic.networks.parts->email_validator.validate_email(email, check_deliverability=False)
A:pydantic.networks.__getattr__->getattr_migration(__name__)
pydantic.IPvAnyAddress(cls,value:Any)
pydantic.IPvAnyAddress.__get_pydantic_core_schema__(cls,source:type[Any])->core_schema.CoreSchema
pydantic.IPvAnyAddress.__get_pydantic_json_schema__(cls,core_schema:core_schema.CoreSchema,handler:GetJsonSchemaHandler)->JsonSchemaValue
pydantic.IPvAnyAddress._validate(cls,__input_value:Any,_:core_schema.ValidationInfo)->IPv4Address | IPv6Address
pydantic.IPvAnyInterface(cls,value:NetworkType)
pydantic.IPvAnyInterface.__get_pydantic_core_schema__(cls,source:type[Any])->core_schema.CoreSchema
pydantic.IPvAnyInterface.__get_pydantic_json_schema__(cls,core_schema:core_schema.CoreSchema,handler:GetJsonSchemaHandler)->JsonSchemaValue
pydantic.IPvAnyInterface._validate(cls,__input_value:NetworkType,_:core_schema.ValidationInfo)->IPv4Interface | IPv6Interface
pydantic.IPvAnyNetwork(cls,value:NetworkType)
pydantic.IPvAnyNetwork.__get_pydantic_core_schema__(cls,source:type[Any])->core_schema.CoreSchema
pydantic.IPvAnyNetwork.__get_pydantic_json_schema__(cls,core_schema:core_schema.CoreSchema,handler:GetJsonSchemaHandler)->JsonSchemaValue
pydantic.IPvAnyNetwork._validate(cls,__input_value:NetworkType,_:core_schema.ValidationInfo)->IPv4Network | IPv6Network
pydantic.NameEmail(self,name:str,email:str)
pydantic.NameEmail.__eq__(self,other:Any)->bool
pydantic.NameEmail.__get_pydantic_core_schema__(cls,source:type[Any])->core_schema.CoreSchema
pydantic.NameEmail.__get_pydantic_json_schema__(cls,core_schema:core_schema.CoreSchema,handler:GetJsonSchemaHandler)->JsonSchemaValue
pydantic.NameEmail.__str__(self)->str
pydantic.NameEmail._validate(cls,__input_value:NameEmail|str,_:core_schema.ValidationInfo)->NameEmail
pydantic.UrlConstraints(_fields.PydanticMetadata)
pydantic.UrlConstraints.__hash__(self)->int
pydantic.import_email_validator()->None
pydantic.networks.IPvAnyAddress(cls,value:Any)
pydantic.networks.IPvAnyAddress.__get_pydantic_core_schema__(cls,source:type[Any])->core_schema.CoreSchema
pydantic.networks.IPvAnyAddress.__get_pydantic_json_schema__(cls,core_schema:core_schema.CoreSchema,handler:GetJsonSchemaHandler)->JsonSchemaValue
pydantic.networks.IPvAnyAddress._validate(cls,__input_value:Any,_:core_schema.ValidationInfo)->IPv4Address | IPv6Address
pydantic.networks.IPvAnyInterface(cls,value:NetworkType)
pydantic.networks.IPvAnyInterface.__get_pydantic_core_schema__(cls,source:type[Any])->core_schema.CoreSchema
pydantic.networks.IPvAnyInterface.__get_pydantic_json_schema__(cls,core_schema:core_schema.CoreSchema,handler:GetJsonSchemaHandler)->JsonSchemaValue
pydantic.networks.IPvAnyInterface._validate(cls,__input_value:NetworkType,_:core_schema.ValidationInfo)->IPv4Interface | IPv6Interface
pydantic.networks.IPvAnyNetwork(cls,value:NetworkType)
pydantic.networks.IPvAnyNetwork.__get_pydantic_core_schema__(cls,source:type[Any])->core_schema.CoreSchema
pydantic.networks.IPvAnyNetwork.__get_pydantic_json_schema__(cls,core_schema:core_schema.CoreSchema,handler:GetJsonSchemaHandler)->JsonSchemaValue
pydantic.networks.IPvAnyNetwork._validate(cls,__input_value:NetworkType,_:core_schema.ValidationInfo)->IPv4Network | IPv6Network
pydantic.networks.NameEmail(self,name:str,email:str)
pydantic.networks.NameEmail.__eq__(self,other:Any)->bool
pydantic.networks.NameEmail.__get_pydantic_core_schema__(cls,source:type[Any])->core_schema.CoreSchema
pydantic.networks.NameEmail.__get_pydantic_json_schema__(cls,core_schema:core_schema.CoreSchema,handler:GetJsonSchemaHandler)->JsonSchemaValue
pydantic.networks.NameEmail.__str__(self)->str
pydantic.networks.NameEmail._validate(cls,__input_value:NameEmail|str,_:core_schema.ValidationInfo)->NameEmail
pydantic.networks.UrlConstraints(_fields.PydanticMetadata)
pydantic.networks.UrlConstraints.__hash__(self)->int
pydantic.networks.import_email_validator()->None
pydantic.networks.validate_email(value:str)->tuple[str, str]
pydantic.validate_email(value:str)->tuple[str, str]


----------------------------------------/home/zhang/Packages/pydantic/pydantic2.0a4/generics.py----------------------------------------
A:pydantic.generics.__getattr__->getattr_migration(__name__)


----------------------------------------/home/zhang/Packages/pydantic/pydantic2.0a4/schema.py----------------------------------------
A:pydantic.schema.__getattr__->getattr_migration(__name__)


----------------------------------------/home/zhang/Packages/pydantic/pydantic2.0a4/version.py----------------------------------------
pydantic.version.version_info()->str


----------------------------------------/home/zhang/Packages/pydantic/pydantic2.0a4/json.py----------------------------------------
A:pydantic.json.__getattr__->getattr_migration(__name__)


----------------------------------------/home/zhang/Packages/pydantic/pydantic2.0a4/annotated.py----------------------------------------


----------------------------------------/home/zhang/Packages/pydantic/pydantic2.0a4/alias_generators.py----------------------------------------
A:pydantic.alias_generators.camel->to_pascal(snake)
A:pydantic.alias_generators.snake->re.sub('([a-z0-9])([A-Z])', lambda m: f'{m.group(1)}_{m.group(2)}', snake)
pydantic.alias_generators.to_camel(snake:str)->str
pydantic.alias_generators.to_pascal(snake:str)->str
pydantic.alias_generators.to_snake(camel:str)->str


----------------------------------------/home/zhang/Packages/pydantic/pydantic2.0a4/__init__.py----------------------------------------
A:pydantic.__init__.__getattr__->getattr_migration(__name__)


----------------------------------------/home/zhang/Packages/pydantic/pydantic2.0a4/mypy.py----------------------------------------
A:pydantic.m.MYPY_VERSION_TUPLE->parse_mypy_version(mypy_version)
A:pydantic.m.self.plugin_config->PydanticPluginConfig(options)
A:pydantic.m.self._plugin_data->self.plugin_config.to_data()
A:pydantic.m.sym->SymbolTableNode(MDEF, func)
A:pydantic.m.transformer->PydanticModelTransformer(ctx, self.plugin_config)
A:pydantic.m.args->getattr(ret_type, 'args', None)
A:pydantic.m.ret_type.args->tuple((default_any_type for _ in args))
A:pydantic.m.toml_config->parse_toml(options.config_file)
A:pydantic.m.config->ModelConfigData()
A:pydantic.m.setting->ConfigParser().getboolean(CONFIGFILE_KEY, key, fallback=False)
A:pydantic.m.plugin_config->ConfigParser()
A:pydantic.m.pydantic_metadata->model_type.type.metadata.get(METADATA_KEY)
A:pydantic.m.from_attributes->model_type.type.metadata.get(METADATA_KEY).get('config', {}).get('from_attributes')
A:pydantic.m.fields->self.collect_fields(config)
A:pydantic.m.config_data->self.get_config_update(name, expr)
A:pydantic.m.maybe_field->self.collect_field_from_stmt(stmt, model_config)
A:pydantic.m.all_fields->self.collect_fields(config).copy()
A:pydantic.m.field->PydanticModelField.deserialize(info, data)
A:pydantic.m.is_required->self.get_is_required(cls, stmt, lhs)
A:pydantic.m.(alias, has_dynamic_alias)->self.get_alias_info(stmt)
A:pydantic.m.force_all_optional->bool(config.has_alias_generator and (not config.populate_by_name))
A:pydantic.m.init_arguments->self.get_field_arguments(fields, typed=typed, force_all_optional=force_all_optional, use_alias=use_alias)
A:pydantic.m.var->PydanticModelField.deserialize(info, data).to_var(info, use_alias=False)
A:pydantic.m.set_str->ctx.api.named_type(f'{BUILTINS_NAME}.set', [ctx.api.named_type(f'{BUILTINS_NAME}.str')])
A:pydantic.m.optional_set_str->UnionType([set_str, NoneType()])
A:pydantic.m.fields_set_argument->Argument(Var('_fields_set', optional_set_str), optional_set_str, None, ARG_OPT)
A:pydantic.m.construct_arguments->self.get_field_arguments(fields, typed=True, force_all_optional=False, use_alias=False)
A:pydantic.m.obj_type->ctx.api.named_type(f'{BUILTINS_NAME}.object')
A:pydantic.m.self_type->TypeVarDef(self_tvar_name, tvar_fullname, -1, [], obj_type)
A:pydantic.m.self_tvar_expr->TypeVarExpr(self_tvar_name, tvar_fullname, [], obj_type)
A:pydantic.m.ctx.cls.info.names[self_tvar_name]->SymbolTableNode(MDEF, self_tvar_expr)
A:pydantic.m.sym_node->info.names.get(field.name)
A:pydantic.m.var_str->repr(var)
A:pydantic.m.info.names[get_name(var)]->SymbolTableNode(MDEF, var)
A:pydantic.m.value_type->get_proper_type(cls.info[lhs.name].type)
A:pydantic.m.type_annotation->AnyType(TypeOfAny.explicit)
A:pydantic.m.ERROR_ORM->ErrorCode('pydantic-orm', 'Invalid from_attributes call', 'Pydantic')
A:pydantic.m.ERROR_CONFIG->ErrorCode('pydantic-config', 'Invalid config value', 'Pydantic')
A:pydantic.m.ERROR_ALIAS->ErrorCode('pydantic-alias', 'Dynamic alias disallowed', 'Pydantic')
A:pydantic.m.ERROR_UNEXPECTED->ErrorCode('pydantic-unexpected', 'Unexpected behavior', 'Pydantic')
A:pydantic.m.ERROR_UNTYPED->ErrorCode('pydantic-field', 'Untyped field disallowed', 'Pydantic')
A:pydantic.m.ERROR_FIELD_DEFAULTS->ErrorCode('pydantic-field', 'Invalid Field defaults', 'Pydantic')
A:pydantic.m.function_type->ctx.api.named_type(f'{BUILTINS_NAME}.function')
A:pydantic.m.signature->CallableType(arg_types, arg_kinds, arg_names, return_type, function_type)
A:pydantic.m.func->FuncDef(name, args, Block([PassStmt()]))
A:pydantic.m.func.type->set_callable_name(signature, func)
A:pydantic.m.r_name->get_unique_redefinition_name(name, info.names)
A:pydantic.m.v->Var(name, func.type)
A:pydantic.m.dec->Decorator(func, [NameExpr('classmethod')], v)
pydantic.m.ModelConfigData(self,forbid_extra:bool|None=None,frozen:bool|None=None,from_attributes:bool|None=None,populate_by_name:bool|None=None,has_alias_generator:bool|None=None)
pydantic.m.ModelConfigData.set_values_dict(self)->dict[str, Any]
pydantic.m.ModelConfigData.setdefault(self,key:str,value:Any)->None
pydantic.m.ModelConfigData.update(self,config:ModelConfigData|None)->None
pydantic.m.PydanticModelField(self,name:str,is_required:bool,alias:str|None,has_dynamic_alias:bool,line:int,column:int)
pydantic.m.PydanticModelField.deserialize(cls,info:TypeInfo,data:JsonDict)->PydanticModelField
pydantic.m.PydanticModelField.serialize(self)->JsonDict
pydantic.m.PydanticModelField.to_argument(self,info:TypeInfo,typed:bool,force_optional:bool,use_alias:bool)->Argument
pydantic.m.PydanticModelField.to_var(self,info:TypeInfo,use_alias:bool)->Var
pydantic.m.PydanticModelTransformer(self,ctx:ClassDefContext,plugin_config:PydanticPluginConfig)
pydantic.m.PydanticModelTransformer.add_initializer(self,fields:list[PydanticModelField],config:ModelConfigData)->None
pydantic.m.PydanticModelTransformer.add_model_construct_method(self,fields:list[PydanticModelField])->None
pydantic.m.PydanticModelTransformer.adjust_validator_signatures(self)->None
pydantic.m.PydanticModelTransformer.collect_config(self)->ModelConfigData
pydantic.m.PydanticModelTransformer.collect_field_from_stmt(self,stmt:Statement,model_config:ModelConfigData)->PydanticModelField | None
pydantic.m.PydanticModelTransformer.collect_fields(self,model_config:ModelConfigData)->list[PydanticModelField]
pydantic.m.PydanticModelTransformer.get_alias_info(stmt:AssignmentStmt)->tuple[str | None, bool]
pydantic.m.PydanticModelTransformer.get_config_update(self,name:str,arg:Expression)->ModelConfigData | None
pydantic.m.PydanticModelTransformer.get_field_arguments(self,fields:list[PydanticModelField],typed:bool,force_all_optional:bool,use_alias:bool)->list[Argument]
pydantic.m.PydanticModelTransformer.get_is_required(cls:ClassDef,stmt:AssignmentStmt,lhs:NameExpr)->bool
pydantic.m.PydanticModelTransformer.is_dynamic_alias_present(fields:list[PydanticModelField],has_alias_generator:bool)->bool
pydantic.m.PydanticModelTransformer.set_frozen(self,fields:list[PydanticModelField],frozen:bool)->None
pydantic.m.PydanticModelTransformer.should_init_forbid_extra(self,fields:list[PydanticModelField],config:ModelConfigData)->bool
pydantic.m.PydanticModelTransformer.transform(self)->None
pydantic.m.PydanticPlugin(self,options:Options)
pydantic.m.PydanticPlugin._pydantic_field_callback(self,ctx:FunctionContext)->Type
pydantic.m.PydanticPlugin._pydantic_model_class_maker_callback(self,ctx:ClassDefContext)->None
pydantic.m.PydanticPlugin._pydantic_model_metaclass_marker_callback(self,ctx:ClassDefContext)->None
pydantic.m.PydanticPlugin.get_base_class_hook(self,fullname:str)->Callable[[ClassDefContext], None] | None
pydantic.m.PydanticPlugin.get_class_decorator_hook(self,fullname:str)->Callable[[ClassDefContext], None] | None
pydantic.m.PydanticPlugin.get_function_hook(self,fullname:str)->Callable[[FunctionContext], Type] | None
pydantic.m.PydanticPlugin.get_metaclass_hook(self,fullname:str)->Callable[[ClassDefContext], None] | None
pydantic.m.PydanticPlugin.get_method_hook(self,fullname:str)->Callable[[MethodContext], Type] | None
pydantic.m.PydanticPlugin.report_config_data(self,ctx:ReportConfigContext)->dict[str, Any]
pydantic.m.PydanticPluginConfig(self,options:Options)
pydantic.m.PydanticPluginConfig.to_data(self)->dict[str, Any]
pydantic.m.add_method(ctx:ClassDefContext,name:str,args:list[Argument],return_type:Type,self_type:Type|None=None,tvar_def:TypeVarDef|None=None,is_classmethod:bool=False,is_new:bool=False)->None
pydantic.m.error_default_and_default_factory_specified(api:CheckerPluginInterface,context:Context)->None
pydantic.m.error_from_attributes(model_name:str,api:CheckerPluginInterface,context:Context)->None
pydantic.m.error_invalid_config_value(name:str,api:SemanticAnalyzerPluginInterface,context:Context)->None
pydantic.m.error_required_dynamic_aliases(api:SemanticAnalyzerPluginInterface,context:Context)->None
pydantic.m.error_unexpected_behavior(detail:str,api:CheckerPluginInterface|SemanticAnalyzerPluginInterface,context:Context)->None
pydantic.m.error_untyped_fields(api:SemanticAnalyzerPluginInterface,context:Context)->None
pydantic.m.from_attributes_callback(ctx:MethodContext)->Type
pydantic.m.get_fullname(x:FuncBase|SymbolNode)->str
pydantic.m.get_name(x:FuncBase|SymbolNode)->str
pydantic.m.parse_mypy_version(version:str)->tuple[int, ...]
pydantic.m.parse_toml(config_file:str)->dict[str, Any] | None
pydantic.m.plugin(version:str)->type[Plugin]


----------------------------------------/home/zhang/Packages/pydantic/pydantic2.0a4/decorators.py----------------------------------------
A:pydantic.decorators._V1ValidatorType->TypeVar('_V1ValidatorType', V1Validator, _PartialClsOrStaticMethod)
A:pydantic.decorators._V2BeforeAfterOrPlainValidatorType->TypeVar('_V2BeforeAfterOrPlainValidatorType', V2Validator, _PartialClsOrStaticMethod)
A:pydantic.decorators._V2WrapValidatorType->TypeVar('_V2WrapValidatorType', V2WrapValidator, _PartialClsOrStaticMethod)
A:pydantic.decorators._V1RootValidatorFunctionType->TypeVar('_V1RootValidatorFunctionType', _decorators_v1.V1RootValidatorFunction, _V1RootValidatorClsMethod, _PartialClsOrStaticMethod)
A:pydantic.decorators.fields->tuple((__field, *fields))
A:pydantic.decorators.f->_internal._decorators.ensure_classmethod_based_on_signature(f)
A:pydantic.decorators.validator_wrapper_info->_internal._decorators.ValidatorDecoratorInfo(fields=fields, mode=mode, each_item=each_item, always=always, check_fields=check_fields)
A:pydantic.decorators.dec_info->_internal._decorators.ModelValidatorDecoratorInfo(mode=mode)
A:pydantic.decorators.wrap->partial(_decorators_v1.make_v1_generic_root_validator, pre=pre)
A:pydantic.decorators.res->_internal._decorators.ensure_classmethod_based_on_signature(f)
A:pydantic.decorators._PlainSerializeMethodType->TypeVar('_PlainSerializeMethodType', bound=_PlainSerializationFunction)
A:pydantic.decorators._WrapSerializeMethodType->TypeVar('_WrapSerializeMethodType', bound=_WrapSerializationFunction)
A:pydantic.decorators.ModelType->TypeVar('ModelType')
pydantic.decorators.ModelAfterValidator(self:ModelType,__info:_core_schema.ValidationInfo)
pydantic.decorators.ModelAfterValidatorWithoutInfo(self:ModelType)
pydantic.decorators.ModelBeforeValidator(self,cls:Any,__value:Any,__info:_core_schema.ValidationInfo)
pydantic.decorators.ModelBeforeValidatorWithoutInfo(self,cls:Any,__value:Any)
pydantic.decorators.ModelWrapValidator(self,cls:type[ModelType],__value:Any,__handler:Callable[[Any],ModelType],__info:_core_schema.ValidationInfo)
pydantic.decorators.ModelWrapValidatorWithoutInfo(self,cls:type[ModelType],__value:Any,__handler:Callable[[Any],ModelType])
pydantic.decorators.field_serializer(*fields:str,mode:Literal['plain','wrap']='plain',json_return_type:_core_schema.JsonReturnTypes|None=None,when_used:Literal['always','unless-none','json','json-unless-none']='always',check_fields:bool|None=None)->Callable[[Any], Any]
pydantic.decorators.field_serializer(__field:str,*fields:str,json_return_type:_core_schema.JsonReturnTypes|None=...,when_used:Literal['always','unless-none','json','json-unless-none']=...,check_fields:bool|None=...)->Callable[[_PlainSerializeMethodType], _PlainSerializeMethodType]
pydantic.decorators.field_serializer(__field:str,*fields:str,mode:Literal['plain'],json_return_type:_core_schema.JsonReturnTypes|None=...,when_used:Literal['always','unless-none','json','json-unless-none']=...,check_fields:bool|None=...)->Callable[[_PlainSerializeMethodType], _PlainSerializeMethodType]
pydantic.decorators.field_serializer(__field:str,*fields:str,mode:Literal['wrap'],json_return_type:_core_schema.JsonReturnTypes|None=...,when_used:Literal['always','unless-none','json','json-unless-none']=...,check_fields:bool|None=...)->Callable[[_WrapSerializeMethodType], _WrapSerializeMethodType]
pydantic.decorators.field_validator(__field:str,*fields:str,mode:FieldValidatorModes='after',check_fields:bool|None=None)->Callable[[Any], Any]
pydantic.decorators.field_validator(__field:str,*fields:str,mode:Literal['before','after','plain']=...,check_fields:bool|None=...)->Callable[[_V2BeforeAfterOrPlainValidatorType], _V2BeforeAfterOrPlainValidatorType]
pydantic.decorators.field_validator(__field:str,*fields:str,mode:Literal['wrap'],check_fields:bool|None=...)->Callable[[_V2WrapValidatorType], _V2WrapValidatorType]
pydantic.decorators.model_serializer(__f:Callable[...,Any]|None=None,*,mode:Literal['plain','wrap']='plain',json_return_type:_core_schema.JsonReturnTypes|None=None)->Callable[[Any], _decorators.PydanticDescriptorProxy[Any]] | _decorators.PydanticDescriptorProxy[Any]
pydantic.decorators.model_validator(*,mode:Literal['after'])->Callable[[AnyModeAfterValidator], _decorators.PydanticDescriptorProxy[_decorators.ModelValidatorDecoratorInfo]]
pydantic.decorators.model_validator(*,mode:Literal['before'])->Callable[[AnyModeBeforeValidator], _decorators.PydanticDescriptorProxy[_decorators.ModelValidatorDecoratorInfo]]
pydantic.decorators.model_validator(*,mode:Literal['wrap','before','after'])->Any
pydantic.decorators.model_validator(*,mode:Literal['wrap'])->Callable[[AnyModelWrapValidator], _decorators.PydanticDescriptorProxy[_decorators.ModelValidatorDecoratorInfo]]
pydantic.decorators.root_validator(*,pre:Literal[False],skip_on_failure:Literal[True],allow_reuse:bool=...)->Callable[[_V1RootValidatorFunctionType], _V1RootValidatorFunctionType]
pydantic.decorators.root_validator(*,pre:Literal[True],allow_reuse:bool=...)->Callable[[_V1RootValidatorFunctionType], _V1RootValidatorFunctionType]
pydantic.decorators.root_validator(*,pre:bool=False,skip_on_failure:bool=False,allow_reuse:bool=False)->Any
pydantic.decorators.root_validator(*,skip_on_failure:Literal[True],allow_reuse:bool=...)->Callable[[_V1RootValidatorFunctionType], _V1RootValidatorFunctionType]
pydantic.decorators.validator(__field:str,*fields:str,pre:bool=False,each_item:bool=False,always:bool=False,check_fields:bool|None=None,allow_reuse:bool=False)->Callable[[_V1ValidatorType], _V1ValidatorType]
pydantic.field_serializer(*fields:str,mode:Literal['plain','wrap']='plain',json_return_type:_core_schema.JsonReturnTypes|None=None,when_used:Literal['always','unless-none','json','json-unless-none']='always',check_fields:bool|None=None)->Callable[[Any], Any]
pydantic.field_serializer(__field:str,*fields:str,json_return_type:_core_schema.JsonReturnTypes|None=...,when_used:Literal['always','unless-none','json','json-unless-none']=...,check_fields:bool|None=...)->Callable[[_PlainSerializeMethodType], _PlainSerializeMethodType]
pydantic.field_serializer(__field:str,*fields:str,mode:Literal['plain'],json_return_type:_core_schema.JsonReturnTypes|None=...,when_used:Literal['always','unless-none','json','json-unless-none']=...,check_fields:bool|None=...)->Callable[[_PlainSerializeMethodType], _PlainSerializeMethodType]
pydantic.field_serializer(__field:str,*fields:str,mode:Literal['wrap'],json_return_type:_core_schema.JsonReturnTypes|None=...,when_used:Literal['always','unless-none','json','json-unless-none']=...,check_fields:bool|None=...)->Callable[[_WrapSerializeMethodType], _WrapSerializeMethodType]
pydantic.field_validator(__field:str,*fields:str,mode:FieldValidatorModes='after',check_fields:bool|None=None)->Callable[[Any], Any]
pydantic.field_validator(__field:str,*fields:str,mode:Literal['before','after','plain']=...,check_fields:bool|None=...)->Callable[[_V2BeforeAfterOrPlainValidatorType], _V2BeforeAfterOrPlainValidatorType]
pydantic.field_validator(__field:str,*fields:str,mode:Literal['wrap'],check_fields:bool|None=...)->Callable[[_V2WrapValidatorType], _V2WrapValidatorType]
pydantic.model_serializer(__f:Callable[...,Any]|None=None,*,mode:Literal['plain','wrap']='plain',json_return_type:_core_schema.JsonReturnTypes|None=None)->Callable[[Any], _decorators.PydanticDescriptorProxy[Any]] | _decorators.PydanticDescriptorProxy[Any]
pydantic.model_validator(*,mode:Literal['after'])->Callable[[AnyModeAfterValidator], _decorators.PydanticDescriptorProxy[_decorators.ModelValidatorDecoratorInfo]]
pydantic.model_validator(*,mode:Literal['before'])->Callable[[AnyModeBeforeValidator], _decorators.PydanticDescriptorProxy[_decorators.ModelValidatorDecoratorInfo]]
pydantic.model_validator(*,mode:Literal['wrap','before','after'])->Any
pydantic.model_validator(*,mode:Literal['wrap'])->Callable[[AnyModelWrapValidator], _decorators.PydanticDescriptorProxy[_decorators.ModelValidatorDecoratorInfo]]
pydantic.root_validator(*,pre:Literal[False],skip_on_failure:Literal[True],allow_reuse:bool=...)->Callable[[_V1RootValidatorFunctionType], _V1RootValidatorFunctionType]
pydantic.root_validator(*,pre:Literal[True],allow_reuse:bool=...)->Callable[[_V1RootValidatorFunctionType], _V1RootValidatorFunctionType]
pydantic.root_validator(*,pre:bool=False,skip_on_failure:bool=False,allow_reuse:bool=False)->Any
pydantic.root_validator(*,skip_on_failure:Literal[True],allow_reuse:bool=...)->Callable[[_V1RootValidatorFunctionType], _V1RootValidatorFunctionType]
pydantic.validator(__field:str,*fields:str,pre:bool=False,each_item:bool=False,always:bool=False,check_fields:bool|None=None,allow_reuse:bool=False)->Callable[[_V1ValidatorType], _V1ValidatorType]


----------------------------------------/home/zhang/Packages/pydantic/pydantic2.0a4/fields.py----------------------------------------
A:pydantic.fields.(self.annotation, annotation_metadata)->self._extract_metadata(kwargs.get('annotation'))
A:pydantic.fields.default->kwargs.pop('default', Undefined)
A:pydantic.fields.self.default_factory->kwargs.get('default_factory')
A:pydantic.fields.self.alias->kwargs.get('alias')
A:pydantic.fields.self.title->kwargs.get('title')
A:pydantic.fields.self.validation_alias->kwargs.get('validation_alias', None)
A:pydantic.fields.self.serialization_alias->kwargs.get('serialization_alias', None)
A:pydantic.fields.self.description->kwargs.get('description')
A:pydantic.fields.self.examples->kwargs.get('examples')
A:pydantic.fields.self.exclude->kwargs.get('exclude')
A:pydantic.fields.self.include->kwargs.get('include')
A:pydantic.fields.self.discriminator->kwargs.get('discriminator')
A:pydantic.fields.self.repr->kwargs.get('repr', True)
A:pydantic.fields.self.json_schema_extra->kwargs.get('json_schema_extra')
A:pydantic.fields.self.validate_default->kwargs.get('validate_default', None)
A:pydantic.fields.self.frozen->kwargs.get('frozen', None)
A:pydantic.fields.self.final->kwargs.get('final', None)
A:pydantic.fields.self.init_var->kwargs.get('init_var', None)
A:pydantic.fields.self.kw_only->kwargs.get('kw_only', None)
A:pydantic.fields.(first_arg, *extra_args)->typing_extensions.get_args(annotation)
A:pydantic.fields.field_info->cls._find_field_info_arg(extra_args)
A:pydantic.fields.new_field_info->copy(field_info)
A:pydantic.fields.(default.annotation, annotation_metadata)->cls._extract_metadata(annotation)
A:pydantic.fields.pydantic_field->cls._from_dataclass_field(default)
A:pydantic.fields.(pydantic_field.annotation, annotation_metadata)->cls._extract_metadata(annotation)
A:pydantic.fields.pydantic_field.kw_only->getattr(default, 'kw_only', None)
A:pydantic.fields.field->Field(default=default, default_factory=default_factory, repr=dc_field.repr, **dc_field.metadata)
A:pydantic.fields.(field.annotation, annotation_metadata)->cls._extract_metadata(dc_field.type)
A:pydantic.fields.annotation->_internal._typing_extra.eval_type_lenient(self.annotation, types_namespace, None)
A:pydantic.fields.self.annotation->replace_types(annotation, typevars_map)
A:pydantic.fields.value->getattr(self, s)
A:pydantic.fields.self.choices->list(args)
A:pydantic.fields.converted_validation_alias->validation_alias.convert_to_aliases()
A:pydantic.fields.set_name->getattr(self.default, '__set_name__')
A:pydantic.fields.PropertyT->typing.TypeVar('PropertyT')
A:pydantic.fields.description->inspect.cleandoc(f.__doc__)
A:pydantic.fields.f->_internal._decorators.ensure_property(f)
A:pydantic.fields.dec_info->ComputedFieldInfo(f, json_return_type, alias, title, description, repr)
pydantic.AliasChoices(self,*args:str|AliasPath)
pydantic.AliasChoices.convert_to_aliases(self)->list[list[str | int]]
pydantic.AliasPath(self,first_arg:str,*args:str|int)
pydantic.AliasPath.convert_to_aliases(self)->list[str | int]
pydantic.Field(default:Any=Undefined,*,default_factory:typing.Callable[[],Any]|None=None,alias:str|None=None,alias_priority:int|None=None,validation_alias:str|AliasPath|AliasChoices|None=None,serialization_alias:str|None=None,title:str|None=None,description:str|None=None,examples:list[Any]|None=None,exclude:typing.AbstractSet[int|str]|typing.Mapping[int|str,Any]|Any=None,include:typing.AbstractSet[int|str]|typing.Mapping[int|str,Any]|Any=None,gt:float|None=None,ge:float|None=None,lt:float|None=None,le:float|None=None,multiple_of:float|None=None,allow_inf_nan:bool|None=None,max_digits:int|None=None,decimal_places:int|None=None,min_items:int|None=None,max_items:int|None=None,min_length:int|None=None,max_length:int|None=None,frozen:bool=False,pattern:str|None=None,discriminator:str|None=None,repr:bool=True,strict:bool|None=None,json_schema_extra:dict[str,Any]|None=None,validate_default:bool|None=None,const:bool|None=None,unique_items:bool|None=None,allow_mutation:bool=True,regex:str|None=None,**extra:Any)->Any
pydantic.FieldInfo(self,**kwargs:Any)
pydantic.FieldInfo.__repr_args__(self)->ReprArgs
pydantic.FieldInfo._collect_metadata(cls,kwargs:dict[str,Any])->list[Any]
pydantic.FieldInfo._extract_metadata(cls,annotation:type[Any]|None)->tuple[type[Any] | None, list[Any]]
pydantic.FieldInfo._find_field_info_arg(args:Any)->FieldInfo | None
pydantic.FieldInfo._from_dataclass_field(cls,dc_field:DataclassField[Any])->FieldInfo
pydantic.FieldInfo.apply_typevars_map(self,typevars_map:dict[Any,Any]|None,types_namespace:dict[str,Any]|None)->None
pydantic.FieldInfo.from_annotated_attribute(cls,annotation:type[Any],default:Any)->FieldInfo
pydantic.FieldInfo.from_annotation(cls,annotation:type[Any]|_forward_ref.PydanticForwardRef)->FieldInfo
pydantic.FieldInfo.from_field(cls,default:Any=Undefined,**kwargs:Any)->FieldInfo
pydantic.FieldInfo.get_default(self,*,call_default_factory:bool=False)->Any
pydantic.FieldInfo.is_required(self)->bool
pydantic.FieldInfo.rebuild_annotation(self)->Any
pydantic.PrivateAttr(default:Any=Undefined,*,default_factory:typing.Callable[[],Any]|None=None)->Any
pydantic.computed_field(*,json_return_type:_core_schema.JsonReturnTypes|None=None,alias:str|None=None,title:str|None=None,description:str|None=None,repr:bool=True)->typing.Callable[[PropertyT], PropertyT]
pydantic.computed_field(__f:PropertyT|None=None,*,alias:str|None=None,title:str|None=None,description:str|None=None,repr:bool=True,json_return_type:_core_schema.JsonReturnTypes|None=None)->PropertyT | typing.Callable[[PropertyT], PropertyT]
pydantic.computed_field(__func:PropertyT)->PropertyT
pydantic.fields.AliasChoices(self,*args:str|AliasPath)
pydantic.fields.AliasChoices.convert_to_aliases(self)->list[list[str | int]]
pydantic.fields.AliasPath(self,first_arg:str,*args:str|int)
pydantic.fields.AliasPath.convert_to_aliases(self)->list[str | int]
pydantic.fields.ComputedFieldInfo
pydantic.fields.Field(default:Any=Undefined,*,default_factory:typing.Callable[[],Any]|None=None,alias:str|None=None,alias_priority:int|None=None,validation_alias:str|AliasPath|AliasChoices|None=None,serialization_alias:str|None=None,title:str|None=None,description:str|None=None,examples:list[Any]|None=None,exclude:typing.AbstractSet[int|str]|typing.Mapping[int|str,Any]|Any=None,include:typing.AbstractSet[int|str]|typing.Mapping[int|str,Any]|Any=None,gt:float|None=None,ge:float|None=None,lt:float|None=None,le:float|None=None,multiple_of:float|None=None,allow_inf_nan:bool|None=None,max_digits:int|None=None,decimal_places:int|None=None,min_items:int|None=None,max_items:int|None=None,min_length:int|None=None,max_length:int|None=None,frozen:bool=False,pattern:str|None=None,discriminator:str|None=None,repr:bool=True,strict:bool|None=None,json_schema_extra:dict[str,Any]|None=None,validate_default:bool|None=None,const:bool|None=None,unique_items:bool|None=None,allow_mutation:bool=True,regex:str|None=None,**extra:Any)->Any
pydantic.fields.FieldInfo(self,**kwargs:Any)
pydantic.fields.FieldInfo.__repr_args__(self)->ReprArgs
pydantic.fields.FieldInfo._collect_metadata(cls,kwargs:dict[str,Any])->list[Any]
pydantic.fields.FieldInfo._extract_metadata(cls,annotation:type[Any]|None)->tuple[type[Any] | None, list[Any]]
pydantic.fields.FieldInfo._find_field_info_arg(args:Any)->FieldInfo | None
pydantic.fields.FieldInfo._from_dataclass_field(cls,dc_field:DataclassField[Any])->FieldInfo
pydantic.fields.FieldInfo.apply_typevars_map(self,typevars_map:dict[Any,Any]|None,types_namespace:dict[str,Any]|None)->None
pydantic.fields.FieldInfo.from_annotated_attribute(cls,annotation:type[Any],default:Any)->FieldInfo
pydantic.fields.FieldInfo.from_annotation(cls,annotation:type[Any]|_forward_ref.PydanticForwardRef)->FieldInfo
pydantic.fields.FieldInfo.from_field(cls,default:Any=Undefined,**kwargs:Any)->FieldInfo
pydantic.fields.FieldInfo.get_default(self,*,call_default_factory:bool=False)->Any
pydantic.fields.FieldInfo.is_required(self)->bool
pydantic.fields.FieldInfo.rebuild_annotation(self)->Any
pydantic.fields.ModelPrivateAttr(self,default:Any=Undefined,*,default_factory:typing.Callable[[],Any]|None=None)
pydantic.fields.ModelPrivateAttr.__eq__(self,other:Any)->bool
pydantic.fields.ModelPrivateAttr.__set_name__(self,cls:type[Any],name:str)->None
pydantic.fields.ModelPrivateAttr.get_default(self)->Any
pydantic.fields.PrivateAttr(default:Any=Undefined,*,default_factory:typing.Callable[[],Any]|None=None)->Any
pydantic.fields.computed_field(*,json_return_type:_core_schema.JsonReturnTypes|None=None,alias:str|None=None,title:str|None=None,description:str|None=None,repr:bool=True)->typing.Callable[[PropertyT], PropertyT]
pydantic.fields.computed_field(__f:PropertyT|None=None,*,alias:str|None=None,title:str|None=None,description:str|None=None,repr:bool=True,json_return_type:_core_schema.JsonReturnTypes|None=None)->PropertyT | typing.Callable[[PropertyT], PropertyT]
pydantic.fields.computed_field(__func:PropertyT)->PropertyT


----------------------------------------/home/zhang/Packages/pydantic/pydantic2.0a4/deprecated/decorator.py----------------------------------------
A:pydantic.deprecated.decorator.AnyCallableT->TypeVar('AnyCallableT', bound=AnyCallable)
A:pydantic.deprecated.decorator.vd->ValidatedFunction(_func, config)
A:pydantic.deprecated.decorator.type_hints->_internal._typing_extra.get_type_hints(function, include_extras=True)
A:pydantic.deprecated.decorator.values->self.build_values(args, kwargs)
A:pydantic.deprecated.decorator.m->self.init_model_instance(*args, **kwargs)
A:pydantic.deprecated.decorator.arg_iter->enumerate(args)
A:pydantic.deprecated.decorator.(i, a)->next(arg_iter)
A:pydantic.deprecated.decorator.arg_name->self.arg_mapping.get(i)
A:pydantic.deprecated.decorator.var_kwargs->d.pop(self.v_kwargs_name, {})
A:pydantic.deprecated.decorator.pos_args->len(self.arg_mapping)
A:pydantic.deprecated.decorator.config_wrapper->_internal._config.ConfigWrapper(config)
A:pydantic.deprecated.decorator.keys->', '.join(map(repr, v))
A:pydantic.deprecated.decorator.self.model->create_model(to_pascal(self.raw_function.__name__), __base__=DecoratorBaseModel, **fields)
pydantic.deprecated.decorator.ValidatedFunction(self,function:'AnyCallable',config:'ConfigType')
pydantic.deprecated.decorator.ValidatedFunction.build_values(self,args:Tuple[Any,...],kwargs:Dict[str,Any])->Dict[str, Any]
pydantic.deprecated.decorator.ValidatedFunction.call(self,*args:Any,**kwargs:Any)->Any
pydantic.deprecated.decorator.ValidatedFunction.create_model(self,fields:Dict[str,Any],takes_args:bool,takes_kwargs:bool,config:'ConfigType')->None
pydantic.deprecated.decorator.ValidatedFunction.execute(self,m:BaseModel)->Any
pydantic.deprecated.decorator.ValidatedFunction.init_model_instance(self,*args:Any,**kwargs:Any)->BaseModel
pydantic.deprecated.decorator.validate_arguments(func:'AnyCallableT')->'AnyCallableT'
pydantic.deprecated.decorator.validate_arguments(func:None=None,*,config:'ConfigType'=None)->Callable[['AnyCallableT'], 'AnyCallableT']
pydantic.deprecated.decorator.validate_arguments(func:Optional['AnyCallableT']=None,*,config:'ConfigType'=None)->Any


----------------------------------------/home/zhang/Packages/pydantic/pydantic2.0a4/deprecated/parse.py----------------------------------------
A:pydantic.deprecated.parse.b->Path(path).read_bytes()
A:pydantic.deprecated.parse.path->Path(path)
pydantic.deprecated.parse.Protocol(str,Enum)
pydantic.deprecated.parse.load_file(path:str|Path,*,content_type:str|None=None,encoding:str='utf8',proto:Protocol|None=None,allow_pickle:bool=False,json_loads:Callable[[str],Any]=json.loads)->Any
pydantic.deprecated.parse.load_str_bytes(b:str|bytes,*,content_type:str|None=None,encoding:str='utf8',proto:Protocol|None=None,allow_pickle:bool=False,json_loads:Callable[[str],Any]=json.loads)->Any


----------------------------------------/home/zhang/Packages/pydantic/pydantic2.0a4/deprecated/tools.py----------------------------------------
A:pydantic.deprecated.tools.T->TypeVar('T')
A:pydantic.deprecated.tools.res->TypeAdapter(type_).json_schema(by_alias=by_alias, schema_generator=schema_generator, ref_template=ref_template)
A:pydantic.deprecated.tools.res['title']->title(type_)
pydantic.deprecated.tools.parse_obj_as(type_:type[T],obj:Any,type_name:NameFactory|None=None)->T
pydantic.deprecated.tools.schema_json_of(type_:Any,*,title:NameFactory|None=None,by_alias:bool=True,ref_template:str=DEFAULT_REF_TEMPLATE,schema_generator:type[GenerateJsonSchema]=GenerateJsonSchema,**dumps_kwargs:Any)->str
pydantic.deprecated.tools.schema_of(type_:Any,*,title:NameFactory|None=None,by_alias:bool=True,ref_template:str=DEFAULT_REF_TEMPLATE,schema_generator:type[GenerateJsonSchema]=GenerateJsonSchema)->dict[str, Any]
pydantic.parse_obj_as(type_:type[T],obj:Any,type_name:NameFactory|None=None)->T
pydantic.schema_json_of(type_:Any,*,title:NameFactory|None=None,by_alias:bool=True,ref_template:str=DEFAULT_REF_TEMPLATE,schema_generator:type[GenerateJsonSchema]=GenerateJsonSchema,**dumps_kwargs:Any)->str
pydantic.schema_of(type_:Any,*,title:NameFactory|None=None,by_alias:bool=True,ref_template:str=DEFAULT_REF_TEMPLATE,schema_generator:type[GenerateJsonSchema]=GenerateJsonSchema)->dict[str, Any]


----------------------------------------/home/zhang/Packages/pydantic/pydantic2.0a4/deprecated/config.py----------------------------------------
pydantic.BaseConfig(metaclass=_ConfigMetaclass)
pydantic.BaseConfig.__getattr__(self,item:str)->Any
pydantic.BaseConfig.__init_subclass__(cls,**kwargs:Any)->None
pydantic.deprecated.config.BaseConfig(metaclass=_ConfigMetaclass)
pydantic.deprecated.config.BaseConfig.__getattr__(self,item:str)->Any
pydantic.deprecated.config.BaseConfig.__init_subclass__(cls,**kwargs:Any)->None
pydantic.deprecated.config._ConfigMetaclass(type)
pydantic.deprecated.config._ConfigMetaclass.__getattr__(self,item:str)->Any


----------------------------------------/home/zhang/Packages/pydantic/pydantic2.0a4/deprecated/json.py----------------------------------------
A:pydantic.deprecated.json.(minutes, seconds)->divmod(td.seconds, 60)
A:pydantic.deprecated.json.(hours, minutes)->divmod(minutes, 60)
pydantic.deprecated.json.custom_pydantic_encoder(type_encoders:Dict[Any,Callable[[Type[Any]],Any]],obj:Any)->Any
pydantic.deprecated.json.decimal_encoder(dec_value:Decimal)->Union[int, float]
pydantic.deprecated.json.isoformat(o:Union[datetime.date,datetime.time])->str
pydantic.deprecated.json.pydantic_encoder(obj:Any)->Any
pydantic.deprecated.json.timedelta_isoformat(td:datetime.timedelta)->str


----------------------------------------/home/zhang/Packages/pydantic/pydantic2.0a4/deprecated/copy_internals.py----------------------------------------
A:pydantic.deprecated.copy_internals.Model->typing.TypeVar('Model', bound='BaseModel')
A:pydantic.deprecated.copy_internals.exclude->_internal._utils.ValueItems.merge({k: v.exclude for (k, v) in self.model_fields.items() if v.exclude is not None}, exclude)
A:pydantic.deprecated.copy_internals.include->_internal._utils.ValueItems.merge({k: v.include for (k, v) in self.model_fields.items()}, include, intersect=True)
A:pydantic.deprecated.copy_internals.allowed_keys->_calculate_keys(self, include=include, exclude=exclude, exclude_unset=exclude_unset)
A:pydantic.deprecated.copy_internals.items->self.__dict__.items()
A:pydantic.deprecated.copy_internals.v->_get_value(type(self), v, to_dict=to_dict, by_alias=by_alias, include=value_include and value_include.for_element(field_key), exclude=value_exclude and value_exclude.for_element(field_key), exclude_unset=exclude_unset, exclude_defaults=exclude_defaults, exclude_none=exclude_none)
A:pydantic.deprecated.copy_internals.values->deepcopy(values)
A:pydantic.deprecated.copy_internals.m->cls.__new__(cls)
A:pydantic.deprecated.copy_internals.value->deepcopy(value)
A:pydantic.deprecated.copy_internals.keys->set(self.__dict__.keys())
pydantic.deprecated.copy_internals._calculate_keys(self:BaseModel,include:MappingIntStrAny|None,exclude:MappingIntStrAny|None,exclude_unset:bool,update:typing.Dict[str,Any]|None=None)->typing.AbstractSet[str] | None
pydantic.deprecated.copy_internals._copy_and_set_values(self:Model,values:dict[str,Any],fields_set:set[str],extra:dict[str,Any]|None=None,*,deep:bool)->Model
pydantic.deprecated.copy_internals._get_value(cls:type[BaseModel],v:Any,to_dict:bool,by_alias:bool,include:AbstractSetIntStr|MappingIntStrAny|None,exclude:AbstractSetIntStr|MappingIntStrAny|None,exclude_unset:bool,exclude_defaults:bool,exclude_none:bool)->Any
pydantic.deprecated.copy_internals._iter(self:BaseModel,to_dict:bool=False,by_alias:bool=False,include:AbstractSetIntStr|MappingIntStrAny|None=None,exclude:AbstractSetIntStr|MappingIntStrAny|None=None,exclude_unset:bool=False,exclude_defaults:bool=False,exclude_none:bool=False)->TupleGenerator


----------------------------------------/home/zhang/Packages/pydantic/pydantic2.0a4/deprecated/__init__.py----------------------------------------


----------------------------------------/home/zhang/Packages/pydantic/pydantic2.0a4/_internal/_utils.py----------------------------------------
A:pydantic._internal._utils.KeyType->TypeVar('KeyType')
A:pydantic._internal._utils.updated_mapping->mapping.copy()
A:pydantic._internal._utils.updated_mapping[k]->deep_update(updated_mapping[k], v)
A:pydantic._internal._utils.T->TypeVar('T')
A:pydantic._internal._utils.v_name->name_factory(v)
A:pydantic._internal._utils.items->dict.fromkeys(items, ...)
A:pydantic._internal._utils.item->self._items.get(e)
A:pydantic._internal._utils.all_items->self._coerce_value(v)
A:pydantic._internal._utils.normalized_items[normalized_i]->self.merge(v, normalized_items.get(normalized_i))
A:pydantic._internal._utils.normalized_item->normalized_items.setdefault(i, {})
A:pydantic._internal._utils.normalized_items[i]->self.merge(all_items, normalized_item)
A:pydantic._internal._utils.override->cls._coerce_value(override)
A:pydantic._internal._utils.base->cls._coerce_value(base)
A:pydantic._internal._utils.merged_item->cls.merge(base.get(k), override.get(k), intersect=intersect)
A:pydantic._internal._utils.class_name->getattr(items, '__class__', '???')
A:pydantic._internal._utils.Obj->TypeVar('Obj')
A:pydantic._internal._utils._EMPTY->object()
pydantic._internal._utils.ValueItems(self,value:Any,items:AbstractSetIntStr|MappingIntStrAny)
pydantic._internal._utils.ValueItems.__repr_args__(self)->_repr.ReprArgs
pydantic._internal._utils.ValueItems._coerce_items(items:AbstractSetIntStr|MappingIntStrAny)->MappingIntStrAny
pydantic._internal._utils.ValueItems._coerce_value(cls,value:Any)->Any
pydantic._internal._utils.ValueItems._normalize_indexes(self,items:MappingIntStrAny,v_length:int)->dict[int | str, Any]
pydantic._internal._utils.ValueItems.for_element(self,e:int|str)->AbstractSetIntStr | MappingIntStrAny | None
pydantic._internal._utils.ValueItems.is_excluded(self,item:Any)->bool
pydantic._internal._utils.ValueItems.is_included(self,item:Any)->bool
pydantic._internal._utils.ValueItems.is_true(v:Any)->bool
pydantic._internal._utils.ValueItems.merge(cls,base:Any,override:Any,intersect:bool=False)->Any
pydantic._internal._utils.all_identical(left:typing.Iterable[Any],right:typing.Iterable[Any])->bool
pydantic._internal._utils.almost_equal_floats(value_1:float,value_2:float,*,delta:float=1e-08)->bool
pydantic._internal._utils.deep_update(mapping:dict[KeyType,Any],*updating_mappings:dict[KeyType,Any])->dict[KeyType, Any]
pydantic._internal._utils.dict_not_none(__pos:dict[str,Any]|None=None,**kwargs:Any)->dict[str, Any]
pydantic._internal._utils.is_basemodel(cls:Any)->TypeGuard[type[BaseModel]]
pydantic._internal._utils.is_valid_identifier(identifier:str)->bool
pydantic._internal._utils.lenient_isinstance(o:Any,class_or_tuple:type[Any]|tuple[type[Any],...]|None)->bool
pydantic._internal._utils.lenient_issubclass(cls:Any,class_or_tuple:Any)->bool
pydantic._internal._utils.sequence_like(v:Any)->bool
pydantic._internal._utils.smart_deepcopy(obj:Obj)->Obj
pydantic._internal._utils.unique_list(input_list:list[T]|tuple[T,...],*,name_factory:typing.Callable[[T],str]=str)->list[T]
pydantic._internal._utils.update_not_none(mapping:dict[Any,Any],**update:Any)->None


----------------------------------------/home/zhang/Packages/pydantic/pydantic2.0a4/_internal/_config.py----------------------------------------
A:pydantic._internal._config.self.config_dict->cast(ConfigDict, config)
A:pydantic._internal._config.config_new->ConfigDict()
A:pydantic._internal._config.config->getattr(base, 'model_config', None)
A:pydantic._internal._config.config_class_from_namespace->namespace.get('Config')
A:pydantic._internal._config.config_dict_from_namespace->namespace.get('model_config')
A:pydantic._internal._config.config_new[k]->kwargs.pop(k)
A:pydantic._internal._config.extra->self.config_dict.get('extra')
A:pydantic._internal._config.core_config->pydantic_core.core_schema.CoreConfig(**core_schema.dict_not_none(title=self.config_dict.get('title') or (obj and obj.__name__), extra_fields_behavior=extra, allow_inf_nan=self.config_dict.get('allow_inf_nan'), populate_by_name=self.config_dict.get('populate_by_name'), str_strip_whitespace=self.config_dict.get('str_strip_whitespace'), str_to_lower=self.config_dict.get('str_to_lower'), str_to_upper=self.config_dict.get('str_to_upper'), strict=self.config_dict.get('strict'), ser_json_timedelta=self.config_dict.get('ser_json_timedelta'), ser_json_bytes=self.config_dict.get('ser_json_bytes'), from_attributes=self.config_dict.get('from_attributes'), loc_by_alias=self.config_dict.get('loc_by_alias'), revalidate_instances=self.config_dict.get('revalidate_instances'), validate_default=self.config_dict.get('validate_default'), str_max_length=self.config_dict.get('str_max_length'), str_min_length=self.config_dict.get('str_min_length')))
A:pydantic._internal._config.c->', '.join((f'{k}={v!r}' for (k, v) in self.config_dict.items()))
A:pydantic._internal._config.config_defaults->ConfigDict(title=None, str_to_lower=False, str_to_upper=False, str_strip_whitespace=False, str_min_length=0, str_max_length=None, extra=None, frozen=False, populate_by_name=False, use_enum_values=False, validate_assignment=False, arbitrary_types_allowed=False, undefined_types_warning=True, from_attributes=False, loc_by_alias=True, alias_generator=None, ignored_types=(), allow_inf_nan=True, json_schema_extra=None, strict=False, revalidate_instances='never', ser_json_timedelta='iso8601', ser_json_bytes='utf8', validate_default=False, validate_return=False)
A:pydantic._internal._config.config_dict->cast(ConfigDict, config)
A:pydantic._internal._config.config_keys->set(ConfigDict.__annotations__.keys())
A:pydantic._internal._config.message->'\n'.join(['Valid config keys have changed in V2:'] + renamed_bullets + removed_bullets)
pydantic._internal._config.ConfigWrapper(self,config:ConfigDict|dict[str,Any]|type[Any]|None,*,check:bool=True)
pydantic._internal._config.ConfigWrapper.__repr__(self)
pydantic._internal._config.ConfigWrapper.core_config(self,obj:Any=None)->core_schema.CoreConfig
pydantic._internal._config.ConfigWrapper.for_model(cls,bases:tuple[type[Any],...],namespace:dict[str,Any],kwargs:dict[str,Any])->Self
pydantic._internal._config.check_deprecated(config_dict:ConfigDict)->None
pydantic._internal._config.prepare_config(config:ConfigDict|dict[str,Any]|type[Any]|None)->ConfigDict


----------------------------------------/home/zhang/Packages/pydantic/pydantic2.0a4/_internal/_repr.py----------------------------------------
A:pydantic._internal._repr.__slots__->tuple()
A:pydantic._internal._repr.attrs_names->self.__dict__.keys()
A:pydantic._internal._repr.args->', '.join(map(display_as_type, typing_extensions.get_args(obj)))
pydantic._internal._repr.PlainRepr(str)
pydantic._internal._repr.PlainRepr.__repr__(self)->str
pydantic._internal._repr.Representation
pydantic._internal._repr.Representation.__pretty__(self,fmt:typing.Callable[[Any],Any],**kwargs:Any)->typing.Generator[Any, None, None]
pydantic._internal._repr.Representation.__repr__(self)->str
pydantic._internal._repr.Representation.__repr_args__(self)->ReprArgs
pydantic._internal._repr.Representation.__repr_name__(self)->str
pydantic._internal._repr.Representation.__repr_str__(self,join_str:str)->str
pydantic._internal._repr.Representation.__rich_repr__(self)->RichReprResult
pydantic._internal._repr.Representation.__str__(self)->str
pydantic._internal._repr.display_as_type(obj:Any)->str


----------------------------------------/home/zhang/Packages/pydantic/pydantic2.0a4/_internal/_model_construction.py----------------------------------------
A:pydantic._internal._model_construction.default->private_attr.get_default()
A:pydantic._internal._model_construction.raw_annotations->namespace.get('__annotations__', {})
A:pydantic._internal._model_construction.private_attributes[var_name]->PrivateAttr(default=value)
A:pydantic._internal._model_construction.private_attributes[ann_name]->PrivateAttr()
A:pydantic._internal._model_construction.typevars_map->get_model_typevars_map(cls)
A:pydantic._internal._model_construction.(fields, class_vars)->collect_model_fields(cls, bases, types_namespace, typevars_map=typevars_map)
A:pydantic._internal._model_construction.gen_schema->GenerateSchema(config_wrapper, types_namespace, typevars_map)
A:pydantic._internal._model_construction.schema->flatten_schema_defs(schema)
A:pydantic._internal._model_construction.cls.__pydantic_validator__->SchemaValidator(simplified_core_schema, core_config)
A:pydantic._internal._model_construction.core_config->config_wrapper.core_config(cls)
A:pydantic._internal._model_construction.simplified_core_schema->inline_schema_defs(schema)
A:pydantic._internal._model_construction.cls.__pydantic_serializer__->SchemaSerializer(simplified_core_schema, core_config)
A:pydantic._internal._model_construction.cls.__signature__->ClassAttribute('__signature__', generate_model_signature(cls.__init__, cls.model_fields, config_wrapper))
A:pydantic._internal._model_construction.present_params->signature(init).parameters.values()
A:pydantic._internal._model_construction.param->param.replace(annotation=Any).replace(annotation=Any)
A:pydantic._internal._model_construction.merged_params[param_name]->Parameter(param_name, Parameter.KEYWORD_ONLY, annotation=field.rebuild_annotation(), **kwargs)
A:pydantic._internal._model_construction.merged_params[var_kw_name]->var_kw.replace(name=var_kw_name)
A:pydantic._internal._model_construction.alias_generator->config.get('alias_generator')
A:pydantic._internal._model_construction.alias->alias_generator(name)
pydantic._internal._model_construction.MockValidator(self,error_message:str,*,code:PydanticErrorCodes)
pydantic._internal._model_construction.MockValidator.__getattr__(self,item:str)->None
pydantic._internal._model_construction.apply_alias_generator(config:ConfigDict,fields:dict[str,FieldInfo])->None
pydantic._internal._model_construction.complete_model_class(cls:type[BaseModel],cls_name:str,config_wrapper:ConfigWrapper,*,raise_errors:bool=True,types_namespace:dict[str,Any]|None)->bool
pydantic._internal._model_construction.generate_model_signature(init:Callable[...,None],fields:dict[str,FieldInfo],config_wrapper:ConfigWrapper)->Signature
pydantic._internal._model_construction.init_private_attributes(self:BaseModel,__context:Any)->None
pydantic._internal._model_construction.inspect_namespace(namespace:dict[str,Any],ignored_types:tuple[type[Any],...],base_class_vars:set[str],base_class_fields:set[str])->dict[str, ModelPrivateAttr]
pydantic._internal._model_construction.model_extra_getattr(self:BaseModel,item:str)->Any
pydantic._internal._model_construction.set_model_fields(cls:type[BaseModel],bases:tuple[type[Any],...],types_namespace:dict[str,Any])->None
pydantic._internal._model_construction.single_underscore(name:str)->bool


----------------------------------------/home/zhang/Packages/pydantic/pydantic2.0a4/_internal/_validators.py----------------------------------------
A:pydantic._internal._validators.v_dict->validator(__input_value)
A:pydantic._internal._validators.value_type->type(__input_value)
A:pydantic._internal._validators.v_list->validator(__input_value)
A:pydantic._internal._validators.(module_path, class_name)->dotted_path.strip(' ').rsplit('.', 1)
A:pydantic._internal._validators.module->import_module(module_path)
A:pydantic._internal._validators.PatternType->typing.TypeVar('PatternType', str, bytes)
pydantic._internal._validators._import_string_logic(dotted_path:str)->Any
pydantic._internal._validators.compile_pattern(pattern:PatternType)->typing.Pattern[PatternType]
pydantic._internal._validators.construct_counter(__input_value:typing.Mapping[Any,Any])->typing.Counter[Any]
pydantic._internal._validators.deque_any_validator(__input_value:Any,validator:core_schema.ValidatorFunctionWrapHandler)->deque[Any]
pydantic._internal._validators.deque_typed_validator(__input_value:Any,validator:core_schema.ValidatorFunctionWrapHandler)->deque[Any]
pydantic._internal._validators.import_string(value:Any)->Any
pydantic._internal._validators.ip_v4_address_validator(__input_value:Any)->IPv4Address
pydantic._internal._validators.ip_v4_interface_validator(__input_value:Any)->IPv4Interface
pydantic._internal._validators.ip_v4_network_validator(__input_value:Any)->IPv4Network
pydantic._internal._validators.ip_v6_address_validator(__input_value:Any)->IPv6Address
pydantic._internal._validators.ip_v6_interface_validator(__input_value:Any)->IPv6Interface
pydantic._internal._validators.ip_v6_network_validator(__input_value:Any)->IPv6Network
pydantic._internal._validators.mapping_validator(__input_value:typing.Mapping[Any,Any],validator:core_schema.ValidatorFunctionWrapHandler)->typing.Mapping[Any, Any]
pydantic._internal._validators.ordered_dict_any_validator(__input_value:Any,validator:core_schema.ValidatorFunctionWrapHandler)->OrderedDict[Any, Any]
pydantic._internal._validators.ordered_dict_typed_validator(__input_value:list[Any])->OrderedDict[Any, Any]
pydantic._internal._validators.pattern_bytes_validator(__input_value:Any)->Any
pydantic._internal._validators.pattern_either_validator(__input_value:Any)->typing.Pattern[Any]
pydantic._internal._validators.pattern_str_validator(__input_value:Any)->typing.Pattern[str]
pydantic._internal._validators.sequence_validator(__input_value:typing.Sequence[Any],validator:core_schema.ValidatorFunctionWrapHandler)->typing.Sequence[Any]
pydantic._internal._validators.uuid_validator(__input_value:str|bytes)->UUID


----------------------------------------/home/zhang/Packages/pydantic/pydantic2.0a4/_internal/_decorators_v1.py----------------------------------------
A:pydantic._internal._decorators_v1.sig->signature(validator)
A:pydantic._internal._decorators_v1.val1->cast(V1ValidatorWithValues, validator)
A:pydantic._internal._decorators_v1.val2->cast(V1OnlyValueValidator, validator)
A:pydantic._internal._decorators_v1.values->validator(values)
A:pydantic._internal._decorators_v1.fields->set(model_dict.keys())
A:pydantic._internal._decorators_v1.model_dict_new->validator(model_dict)
A:pydantic._internal._decorators_v1.model_extra[k]->validator(model_dict).pop(k)
pydantic._internal._decorators_v1.V1OnlyValueValidator(self,__value:Any)
pydantic._internal._decorators_v1.V1RootValidatorFunction(self,__values:RootValidatorValues)
pydantic._internal._decorators_v1.V1ValidatorWithKwargs(self,__value:Any,**kwargs:Any)
pydantic._internal._decorators_v1.V1ValidatorWithValues(self,__value:Any,values:dict[str,Any])
pydantic._internal._decorators_v1.V1ValidatorWithValuesAndKwargs(self,__value:Any,values:dict[str,Any],**kwargs:Any)
pydantic._internal._decorators_v1.V1ValidatorWithValuesKwOnly(self,__value:Any,*,values:dict[str,Any])
pydantic._internal._decorators_v1.V2CoreAfterRootValidator(self,__fields_tuple:RootValidatorFieldsTuple,__info:core_schema.ValidationInfo)
pydantic._internal._decorators_v1.V2CoreBeforeRootValidator(self,__values:RootValidatorValues,__info:core_schema.ValidationInfo)
pydantic._internal._decorators_v1.can_be_keyword(param:Parameter)->bool
pydantic._internal._decorators_v1.make_generic_v1_field_validator(validator:V1Validator)->core_schema.FieldValidatorFunction
pydantic._internal._decorators_v1.make_v1_generic_root_validator(validator:V1RootValidatorFunction,pre:bool)->V2CoreBeforeRootValidator | V2CoreAfterRootValidator


----------------------------------------/home/zhang/Packages/pydantic/pydantic2.0a4/_internal/_schema_generation_shared.py----------------------------------------
A:pydantic._internal._schema_generation_shared.self.original_schema->self.handler(__core_schema)
A:pydantic._internal._schema_generation_shared.original_schema->self.resolve_ref_schema(self.original_schema)
A:pydantic._internal._schema_generation_shared.wrapped_handler->UnpackedRefJsonSchemaHandler(handler)
A:pydantic._internal._schema_generation_shared.json_schema->self.generate_json_schema.get_schema_from_definitions(ref)
pydantic._internal._schema_generation_shared.CallbackGetCoreSchemaHandler(self,handler:Callable[[Any],core_schema.CoreSchema])
pydantic._internal._schema_generation_shared.GenerateJsonSchemaHandler(self,generate_json_schema:GenerateJsonSchema,handler_override:HandlerOverride|None)
pydantic._internal._schema_generation_shared.GenerateJsonSchemaHandler.resolve_ref_schema(self,__maybe_ref_json_schema:JsonSchemaValue)->JsonSchemaValue
pydantic._internal._schema_generation_shared.GetCoreSchemaHandler(self,__source_type:Any)
pydantic._internal._schema_generation_shared.GetJsonSchemaHandler(self,__core_schema:CoreSchemaOrField)
pydantic._internal._schema_generation_shared.GetJsonSchemaHandler.resolve_ref_schema(self,__maybe_ref_json_schema:JsonSchemaValue)->JsonSchemaValue
pydantic._internal._schema_generation_shared.UnpackedRefJsonSchemaHandler(self,handler:GetJsonSchemaHandler)
pydantic._internal._schema_generation_shared.UnpackedRefJsonSchemaHandler.resolve_ref_schema(self,__maybe_ref_json_schema:JsonSchemaValue)->JsonSchemaValue
pydantic._internal._schema_generation_shared.UnpackedRefJsonSchemaHandler.update_schema(self,schema:JsonSchemaValue)->JsonSchemaValue
pydantic._internal._schema_generation_shared.wrap_json_schema_fn_for_model_or_custom_type_with_ref_unpacking(fn:GetJsonSchemaFunction)->GetJsonSchemaFunction


----------------------------------------/home/zhang/Packages/pydantic/pydantic2.0a4/_internal/_serializers.py----------------------------------------
A:pydantic._internal._serializers.v->__serialize(item, index)
pydantic._internal._serializers.pattern_serializer(input_value:Pattern[Any],info:SerializationInfo)->str | Pattern[Any]
pydantic._internal._serializers.serialize_deque(__value:Any,__serialize:SerializerFunctionWrapHandler,__info:SerializationInfo)->list[Any] | deque[Any]


----------------------------------------/home/zhang/Packages/pydantic/pydantic2.0a4/_internal/_decorators.py----------------------------------------
A:pydantic._internal._decorators.ReturnType->TypeVar('ReturnType')
A:pydantic._internal._decorators.f->partial(self._call_wrapped_attr, name=attr)
A:pydantic._internal._decorators.self.wrapped->getattr(self.wrapped, name)(func)
A:pydantic._internal._decorators.DecoratorInfoType->TypeVar('DecoratorInfoType', bound=DecoratorInfo)
A:pydantic._internal._decorators.func->shim(func)
A:pydantic._internal._decorators.res->DecoratorInfos()
A:pydantic._internal._decorators.existing->cast(Union[DecoratorInfos, None], getattr(base, '__pydantic_decorators__', None))
A:pydantic._internal._decorators.res.validator[var_name]->Decorator.build(model_dc, cls_var_name=var_name, shim=var_value.shim, info=info)
A:pydantic._internal._decorators.res.field_validator[var_name]->Decorator.build(model_dc, cls_var_name=var_name, shim=var_value.shim, info=info)
A:pydantic._internal._decorators.res.root_validator[var_name]->Decorator.build(model_dc, cls_var_name=var_name, shim=var_value.shim, info=info)
A:pydantic._internal._decorators.res.field_serializer[var_name]->Decorator.build(model_dc, cls_var_name=var_name, shim=var_value.shim, info=info)
A:pydantic._internal._decorators.res.model_validator[var_name]->Decorator.build(model_dc, cls_var_name=var_name, shim=var_value.shim, info=info)
A:pydantic._internal._decorators.res.model_serializer[var_name]->Decorator.build(model_dc, cls_var_name=var_name, shim=var_value.shim, info=info)
A:pydantic._internal._decorators.res.computed_fields[var_name]->Decorator.build(model_dc, cls_var_name=var_name, shim=None, info=info)
A:pydantic._internal._decorators.sig->signature(unwrap_wrapped_function(function))
A:pydantic._internal._decorators.n_positional->count_positional_params(sig)
A:pydantic._internal._decorators.first->next(iter(sig.parameters.values()), None)
A:pydantic._internal._decorators.info_arg->_serializer_info_arg(mode, count_positional_params(sig))
pydantic._internal._decorators.Decorator(Generic[DecoratorInfoType])
pydantic._internal._decorators.Decorator.bind_to_cls(self,cls:Any)->Decorator[DecoratorInfoType]
pydantic._internal._decorators.Decorator.build(cls_:Any,*,cls_var_name:str,shim:Callable[[Any],Any]|None,info:DecoratorInfoType)->Decorator[DecoratorInfoType]
pydantic._internal._decorators.DecoratorInfos
pydantic._internal._decorators.DecoratorInfos.build(model_dc:type[Any])->DecoratorInfos
pydantic._internal._decorators.FieldSerializerDecoratorInfo
pydantic._internal._decorators.FieldValidatorDecoratorInfo
pydantic._internal._decorators.ModelSerializerDecoratorInfo
pydantic._internal._decorators.ModelValidatorDecoratorInfo
pydantic._internal._decorators.PydanticDescriptorProxy(Generic[ReturnType])
pydantic._internal._decorators.PydanticDescriptorProxy.__get__(self,obj:object|None,obj_type:type[object]|None=None)->PydanticDescriptorProxy[ReturnType]
pydantic._internal._decorators.PydanticDescriptorProxy.__getattr__(self,__name:str)->Any
pydantic._internal._decorators.PydanticDescriptorProxy.__post_init__(self)
pydantic._internal._decorators.PydanticDescriptorProxy.__set_name__(self,instance:Any,name:str)->None
pydantic._internal._decorators.PydanticDescriptorProxy._call_wrapped_attr(self,func:Callable[[Any],None],*,name:str)->PydanticDescriptorProxy[ReturnType]
pydantic._internal._decorators.RootValidatorDecoratorInfo
pydantic._internal._decorators.ValidatorDecoratorInfo
pydantic._internal._decorators._is_classmethod_from_sig(function:AnyDecoratorCallable)->bool
pydantic._internal._decorators._serializer_info_arg(mode:Literal['plain','wrap'],n_positional:int)->bool | None
pydantic._internal._decorators.can_be_positional(param:Parameter)->bool
pydantic._internal._decorators.count_positional_params(sig:Signature)->int
pydantic._internal._decorators.ensure_classmethod_based_on_signature(function:AnyDecoratorCallable)->Any
pydantic._internal._decorators.ensure_property(f:Any)->Any
pydantic._internal._decorators.inspect_annotated_serializer(serializer:Callable[...,Any],mode:Literal['plain','wrap'])->bool
pydantic._internal._decorators.inspect_field_serializer(serializer:Callable[...,Any],mode:Literal['plain','wrap'])->tuple[bool, bool]
pydantic._internal._decorators.inspect_model_serializer(serializer:Callable[...,Any],mode:Literal['plain','wrap'])->bool
pydantic._internal._decorators.inspect_validator(validator:Callable[...,Any],mode:FieldValidatorModes)->bool
pydantic._internal._decorators.is_instance_method_from_sig(function:AnyDecoratorCallable)->bool
pydantic._internal._decorators.unwrap_wrapped_function(func:Any,*,unwrap_class_static_method:bool=True)->Any


----------------------------------------/home/zhang/Packages/pydantic/pydantic2.0a4/_internal/_core_utils.py----------------------------------------
A:pydantic._internal._core_utils.generic_metadata->getattr(type_, '__pydantic_generic_metadata__', None)
A:pydantic._internal._core_utils.module_name->getattr(origin, '__module__', '<No __module__>')
A:pydantic._internal._core_utils.qualname->getattr(origin, '__qualname__', f'<No __qualname__: {origin}>')
A:pydantic._internal._core_utils.top_ref->walk_core_schema(schema, inline_refs).get('ref', None)
A:pydantic._internal._core_utils.valid_definitions->dict()
A:pydantic._internal._core_utils.metadata->definition.get('metadata')
A:pydantic._internal._core_utils.valid_refs->collect_definitions(schema).keys()
A:pydantic._internal._core_utils.new_schema->walk_core_schema(schema, inline_refs).copy()
A:pydantic._internal._core_utils.refs->set()
A:pydantic._internal._core_utils.expected_missing_refs->allowed_missing_refs.difference(refs)
A:pydantic._internal._core_utils.T->TypeVar('T')
A:pydantic._internal._core_utils.self._schema_type_to_method->self._build_schema_type_to_method()
A:pydantic._internal._core_utils.mapping[key]->getattr(self, method_name, self._handle_other_schemas)
A:pydantic._internal._core_utils.schema->walk_core_schema(schema, inline_refs)
A:pydantic._internal._core_utils.schema['serialization']->self._handle_ser_schemas(ser_schema.copy(), f)
A:pydantic._internal._core_utils.schema['schema']->self.walk(schema['schema'], f)
A:pydantic._internal._core_utils.ser_schema['schema']->self.walk(schema, f)
A:pydantic._internal._core_utils.updated_definition->self.walk(definition, f)
A:pydantic._internal._core_utils.new_inner_schema->self.walk(schema['schema'], f)
A:pydantic._internal._core_utils.schema['items_schema']->self.walk(schema['items_schema'], f)
A:pydantic._internal._core_utils.schema['extra_schema']->self.walk(schema['extra_schema'], f)
A:pydantic._internal._core_utils.schema['keys_schema']->self.walk(schema['keys_schema'], f)
A:pydantic._internal._core_utils.schema['values_schema']->self.walk(schema['values_schema'], f)
A:pydantic._internal._core_utils.schema['lax_schema']->self.walk(schema['lax_schema'], f)
A:pydantic._internal._core_utils.schema['strict_schema']->self.walk(schema['strict_schema'], f)
A:pydantic._internal._core_utils.schema['extra_validator']->self.walk(schema['extra_validator'], f)
A:pydantic._internal._core_utils.replaced_field->field.copy()
A:pydantic._internal._core_utils.replaced_field['schema']->self.walk(field['schema'], f)
A:pydantic._internal._core_utils.replaced_param->param.copy()
A:pydantic._internal._core_utils.replaced_param['schema']->self.walk(param['schema'], f)
A:pydantic._internal._core_utils.schema['var_args_schema']->self.walk(schema['var_args_schema'], f)
A:pydantic._internal._core_utils.schema['var_kwargs_schema']->self.walk(schema['var_kwargs_schema'], f)
A:pydantic._internal._core_utils.schema['arguments_schema']->self.walk(schema['arguments_schema'], f)
A:pydantic._internal._core_utils.schema['return_schema']->self.walk(schema['return_schema'], f)
A:pydantic._internal._core_utils.definitions->list(defs)
A:pydantic._internal._core_utils.ref->get_ref(s)
A:pydantic._internal._core_utils.all_defs[ref]->recurse(definition, collect_refs).copy()
A:pydantic._internal._core_utils.s['schema']->recurse(s['schema'], flatten_refs)
A:pydantic._internal._core_utils.s->recurse(new, inline_refs)
A:pydantic._internal._core_utils.new->all_defs.pop(ref)
pydantic._internal._core_utils._WalkCoreSchema(self)
pydantic._internal._core_utils._WalkCoreSchema._build_schema_type_to_method(self)->dict[core_schema.CoreSchemaType, Recurse]
pydantic._internal._core_utils._WalkCoreSchema._handle_other_schemas(self,schema:core_schema.CoreSchema,f:Walk)->core_schema.CoreSchema
pydantic._internal._core_utils._WalkCoreSchema._handle_ser_schemas(self,ser_schema:core_schema.SerSchema,f:Walk)->core_schema.SerSchema
pydantic._internal._core_utils._WalkCoreSchema._walk(self,schema:core_schema.CoreSchema,f:Walk)->core_schema.CoreSchema
pydantic._internal._core_utils._WalkCoreSchema.handle_arguments_schema(self,schema:core_schema.ArgumentsSchema,f:Walk)->core_schema.CoreSchema
pydantic._internal._core_utils._WalkCoreSchema.handle_call_schema(self,schema:core_schema.CallSchema,f:Walk)->core_schema.CoreSchema
pydantic._internal._core_utils._WalkCoreSchema.handle_chain_schema(self,schema:core_schema.ChainSchema,f:Walk)->core_schema.CoreSchema
pydantic._internal._core_utils._WalkCoreSchema.handle_dataclass_args_schema(self,schema:core_schema.DataclassArgsSchema,f:Walk)->core_schema.CoreSchema
pydantic._internal._core_utils._WalkCoreSchema.handle_definitions_schema(self,schema:core_schema.DefinitionsSchema,f:Walk)->core_schema.CoreSchema
pydantic._internal._core_utils._WalkCoreSchema.handle_dict_schema(self,schema:core_schema.DictSchema,f:Walk)->core_schema.CoreSchema
pydantic._internal._core_utils._WalkCoreSchema.handle_frozenset_schema(self,schema:core_schema.FrozenSetSchema,f:Walk)->core_schema.CoreSchema
pydantic._internal._core_utils._WalkCoreSchema.handle_function_schema(self,schema:AnyFunctionSchema,f:Walk)->core_schema.CoreSchema
pydantic._internal._core_utils._WalkCoreSchema.handle_generator_schema(self,schema:core_schema.GeneratorSchema,f:Walk)->core_schema.CoreSchema
pydantic._internal._core_utils._WalkCoreSchema.handle_lax_or_strict_schema(self,schema:core_schema.LaxOrStrictSchema,f:Walk)->core_schema.CoreSchema
pydantic._internal._core_utils._WalkCoreSchema.handle_list_schema(self,schema:core_schema.ListSchema,f:Walk)->core_schema.CoreSchema
pydantic._internal._core_utils._WalkCoreSchema.handle_model_fields_schema(self,schema:core_schema.ModelFieldsSchema,f:Walk)->core_schema.CoreSchema
pydantic._internal._core_utils._WalkCoreSchema.handle_set_schema(self,schema:core_schema.SetSchema,f:Walk)->core_schema.CoreSchema
pydantic._internal._core_utils._WalkCoreSchema.handle_tagged_union_schema(self,schema:core_schema.TaggedUnionSchema,f:Walk)->core_schema.CoreSchema
pydantic._internal._core_utils._WalkCoreSchema.handle_tuple_positional_schema(self,schema:core_schema.TupleVariableSchema|core_schema.TuplePositionalSchema,f:Walk)->core_schema.CoreSchema
pydantic._internal._core_utils._WalkCoreSchema.handle_tuple_variable_schema(self,schema:core_schema.TupleVariableSchema|core_schema.TuplePositionalSchema,f:Walk)->core_schema.CoreSchema
pydantic._internal._core_utils._WalkCoreSchema.handle_typed_dict_schema(self,schema:core_schema.TypedDictSchema,f:Walk)->core_schema.CoreSchema
pydantic._internal._core_utils._WalkCoreSchema.handle_union_schema(self,schema:core_schema.UnionSchema,f:Walk)->core_schema.CoreSchema
pydantic._internal._core_utils._WalkCoreSchema.walk(self,schema:core_schema.CoreSchema,f:Walk)->core_schema.CoreSchema
pydantic._internal._core_utils._simplify_schema_references(schema:core_schema.CoreSchema,inline:bool)->core_schema.CoreSchema
pydantic._internal._core_utils.collect_definitions(schema:core_schema.CoreSchema)->dict[str, core_schema.CoreSchema]
pydantic._internal._core_utils.collect_invalid_schemas(schema:core_schema.CoreSchema)->list[core_schema.CoreSchema]
pydantic._internal._core_utils.consolidate_refs(schema:core_schema.CoreSchema)->core_schema.CoreSchema
pydantic._internal._core_utils.define_expected_missing_refs(schema:core_schema.CoreSchema,allowed_missing_refs:set[str])->core_schema.CoreSchema
pydantic._internal._core_utils.flatten_schema_defs(schema:core_schema.CoreSchema)->core_schema.CoreSchema
pydantic._internal._core_utils.get_type_ref(type_:type[Any],args_override:tuple[type[Any],...]|None=None)->str
pydantic._internal._core_utils.inline_schema_defs(schema:core_schema.CoreSchema)->core_schema.CoreSchema
pydantic._internal._core_utils.is_core_schema(schema:CoreSchemaOrField)->TypeGuard[CoreSchema]
pydantic._internal._core_utils.is_core_schema_field(schema:CoreSchemaOrField)->TypeGuard[CoreSchemaField]
pydantic._internal._core_utils.is_definition_ref_schema(s:core_schema.CoreSchema)->TypeGuard[core_schema.DefinitionReferenceSchema]
pydantic._internal._core_utils.is_definitions_schema(s:core_schema.CoreSchema)->TypeGuard[core_schema.DefinitionsSchema]
pydantic._internal._core_utils.is_function_with_inner_schema(schema:CoreSchemaOrField)->TypeGuard[FunctionSchemaWithInnerSchema]
pydantic._internal._core_utils.is_list_like_schema_with_items_schema(schema:CoreSchema)->TypeGuard[core_schema.ListSchema | core_schema.TupleVariableSchema | core_schema.SetSchema | core_schema.FrozenSetSchema]
pydantic._internal._core_utils.remove_unnecessary_invalid_definitions(schema:core_schema.CoreSchema)->core_schema.CoreSchema
pydantic._internal._core_utils.walk_core_schema(schema:core_schema.CoreSchema,f:Walk)->core_schema.CoreSchema


----------------------------------------/home/zhang/Packages/pydantic/pydantic2.0a4/_internal/_fields.py----------------------------------------
A:pydantic._internal._fields.module_name->getattr(obj, '__module__', None)
A:pydantic._internal._fields.Undefined->_UndefinedType()
A:pydantic._internal._fields.type_hints->get_cls_type_hints_lenient(cls, types_namespace)
A:pydantic._internal._fields.annotations->cls.__dict__.get('__annotations__', {})
A:pydantic._internal._fields.generic_origin->getattr(cls, '__pydantic_generic_metadata__', {}).get('origin')
A:pydantic._internal._fields.default->getattr(cls, ann_name, Undefined)
A:pydantic._internal._fields.field_info->fields.FieldInfo.from_annotated_attribute(ann_type, dataclass_field)
A:pydantic._internal._fields.cls_localns->dict(vars(cls))
A:pydantic._internal._fields.ann_type->_typing_extra.eval_type_lenient(dataclass_field.type, types_namespace, cls_localns)
pydantic._internal._fields.PydanticGeneralMetadata(self,**metadata:Any)
pydantic._internal._fields.PydanticMetadata(Representation)
pydantic._internal._fields._UndefinedType
pydantic._internal._fields._UndefinedType.__copy__(self)->_UndefinedType
pydantic._internal._fields._UndefinedType.__deepcopy__(self,_:Any)->_UndefinedType
pydantic._internal._fields._UndefinedType.__reduce__(self)->str
pydantic._internal._fields._UndefinedType.__repr__(self)->str
pydantic._internal._fields._is_finalvar_with_default_val(type_:type[Any],val:Any)->bool
pydantic._internal._fields.collect_dataclass_fields(cls:type[StandardDataclass],types_namespace:dict[str,Any]|None,*,typevars_map:dict[Any,Any]|None=None)->dict[str, FieldInfo]
pydantic._internal._fields.collect_model_fields(cls:type[Any],bases:tuple[type[Any],...],types_namespace:dict[str,Any]|None,*,typevars_map:dict[Any,Any]|None=None)->tuple[dict[str, FieldInfo], set[str]]
pydantic._internal._fields.get_type_hints_infer_globalns(obj:Any,localns:dict[str,Any]|None=None,include_extras:bool=False)->dict[str, Any]


----------------------------------------/home/zhang/Packages/pydantic/pydantic2.0a4/_internal/_discriminated_union.py----------------------------------------
A:pydantic._internal._discriminated_union.old_definitions->collect_definitions(schema)
A:pydantic._internal._discriminated_union.schema->pydantic_core.core_schema.definitions_schema(schema, missing_definitions)
A:pydantic._internal._discriminated_union.new_definitions->collect_definitions(schema)
A:pydantic._internal._discriminated_union.wrapped->self._apply_to_root(schema['schema'])
A:pydantic._internal._discriminated_union.nullable_wrapper->pydantic_core.core_schema.definitions_schema(schema, missing_definitions).copy()
A:pydantic._internal._discriminated_union.definitions_wrapper->pydantic_core.core_schema.definitions_schema(schema, missing_definitions).copy()
A:pydantic._internal._discriminated_union.choice->self._choices_to_handle.pop()
A:pydantic._internal._discriminated_union.inferred_discriminator_values->self._infer_discriminator_values_for_choice(choice, source_name=None)
A:pydantic._internal._discriminated_union.subchoice_values->self._infer_discriminator_values_for_choice(subchoice, source_name=None)
A:pydantic._internal._discriminated_union.field->choice['fields'].get(self.discriminator)
A:pydantic._internal._discriminated_union.alias->choice['fields'].get(self.discriminator).get('validation_alias', self.discriminator)
A:pydantic._internal._discriminated_union.choice_values->self._infer_discriminator_values_for_inner_schema(choice, source)
pydantic._internal._discriminated_union._ApplyInferredDiscriminator(self,discriminator:str,definitions:dict[str,core_schema.CoreSchema])
pydantic._internal._discriminated_union._ApplyInferredDiscriminator._apply_to_root(self,schema:core_schema.CoreSchema)->core_schema.CoreSchema
pydantic._internal._discriminated_union._ApplyInferredDiscriminator._handle_choice(self,choice:core_schema.CoreSchema)->None
pydantic._internal._discriminated_union._ApplyInferredDiscriminator._infer_discriminator_values_for_choice(self,choice:core_schema.CoreSchema,source_name:str|None)->list[str | int]
pydantic._internal._discriminated_union._ApplyInferredDiscriminator._infer_discriminator_values_for_dataclass_choice(self,choice:core_schema.DataclassArgsSchema,source_name:str|None=None)->list[str | int]
pydantic._internal._discriminated_union._ApplyInferredDiscriminator._infer_discriminator_values_for_field(self,field:CoreSchemaField,source:str)->list[str | int]
pydantic._internal._discriminated_union._ApplyInferredDiscriminator._infer_discriminator_values_for_inner_schema(self,schema:core_schema.CoreSchema,source:str)->list[str | int]
pydantic._internal._discriminated_union._ApplyInferredDiscriminator._infer_discriminator_values_for_model_choice(self,choice:core_schema.ModelFieldsSchema,source_name:str|None=None)->list[str | int]
pydantic._internal._discriminated_union._ApplyInferredDiscriminator._infer_discriminator_values_for_typed_dict_choice(self,choice:core_schema.TypedDictSchema,source_name:str|None=None)->list[str | int]
pydantic._internal._discriminated_union._ApplyInferredDiscriminator._is_discriminator_shared(self,choice:core_schema.TaggedUnionSchema)->bool
pydantic._internal._discriminated_union._ApplyInferredDiscriminator._set_unique_choice_for_values(self,choice:core_schema.CoreSchema,values:Sequence[str|int])->None
pydantic._internal._discriminated_union._ApplyInferredDiscriminator.apply(self,schema:core_schema.CoreSchema)->core_schema.CoreSchema
pydantic._internal._discriminated_union.apply_discriminator(schema:core_schema.CoreSchema,discriminator:str,definitions:dict[str,core_schema.CoreSchema]|None=None)->core_schema.CoreSchema


----------------------------------------/home/zhang/Packages/pydantic/pydantic2.0a4/_internal/_generics.py----------------------------------------
A:pydantic._internal._generics.KT->TypeVar('KT')
A:pydantic._internal._generics.VT->TypeVar('VT')
A:pydantic._internal._generics._GENERIC_TYPES_CACHE->GenericTypesCache()
A:pydantic._internal._generics.(meta, ns, kwds)->prepare_class(model_name, bases)
A:pydantic._internal._generics.created_model->meta(model_name, bases, namespace, __pydantic_generic_metadata__={'origin': origin, 'args': args, 'parameters': params}, __pydantic_reset_parent_namespace__=False, **kwds)
A:pydantic._internal._generics.(model_module, called_globally)->_get_caller_frame_info(depth=3)
A:pydantic._internal._generics.object_by_reference->reference_module_globals.setdefault(reference_name, created_model)
A:pydantic._internal._generics.previous_caller_frame->sys._getframe(depth)
A:pydantic._internal._generics.args->get_args(v)
A:pydantic._internal._generics.origin->get_origin(cls)
A:pydantic._internal._generics.type_args->get_args(type_)
A:pydantic._internal._generics.origin_type->getattr(typing, type_._name)
A:pydantic._internal._generics.annotated->replace_types(annotated_type, type_map)
A:pydantic._internal._generics.resolved_type_args->tuple((replace_types(t, type_map) for t in parameters))
A:pydantic._internal._generics.resolved_list->list((replace_types(element, type_map) for element in type_))
A:pydantic._internal._generics.actual->len(parameters)
A:pydantic._internal._generics.expected->len(cls.__pydantic_generic_metadata__['parameters'])
A:pydantic._internal._generics.previously_seen_type_refs->set()
A:pydantic._internal._generics.token->_generic_recursion_cache.set(previously_seen_type_refs)
A:pydantic._internal._generics.type_ref->get_type_ref(origin, args_override=args)
A:pydantic._internal._generics.self_type->PydanticRecursiveRef(type_ref=type_ref)
A:pydantic._internal._generics.visited->_generic_recursion_cache.get()
A:pydantic._internal._generics.cached->GenericTypesCache().get(_late_cache_key(origin, args, typevar_values))
pydantic._internal._generics.PydanticGenericMetadata(typing_extensions.TypedDict)
pydantic._internal._generics._early_cache_key(cls:type[BaseModel],typevar_values:Any)->GenericTypesCacheKey
pydantic._internal._generics._get_caller_frame_info(depth:int=2)->tuple[str | None, bool]
pydantic._internal._generics._late_cache_key(origin:type[BaseModel],args:tuple[Any,...],typevar_values:Any)->GenericTypesCacheKey
pydantic._internal._generics._union_orderings_key(typevar_values:Any)->Any
pydantic._internal._generics.check_parameters_count(cls:type[BaseModel],parameters:tuple[Any,...])->None
pydantic._internal._generics.create_generic_submodel(model_name:str,origin:type[BaseModel],args:tuple[Any,...],params:tuple[Any,...])->type[BaseModel]
pydantic._internal._generics.generic_recursion_self_type(origin:type[BaseModel],args:tuple[Any,...])->Iterator[PydanticForwardRef | PydanticRecursiveRef | None]
pydantic._internal._generics.get_args(v:Any)->Any
pydantic._internal._generics.get_cached_generic_type_early(parent:type[BaseModel],typevar_values:Any)->type[BaseModel] | None
pydantic._internal._generics.get_cached_generic_type_late(parent:type[BaseModel],typevar_values:Any,origin:type[BaseModel],args:tuple[Any,...])->type[BaseModel] | None
pydantic._internal._generics.get_model_typevars_map(cls:type[BaseModel])->dict[TypeVarType, Any] | None
pydantic._internal._generics.get_origin(v:Any)->Any
pydantic._internal._generics.get_standard_typevars_map(cls:type[Any])->dict[TypeVarType, Any] | None
pydantic._internal._generics.iter_contained_typevars(v:Any)->Iterator[TypeVarType]
pydantic._internal._generics.recursively_defined_type_refs()->set[str]
pydantic._internal._generics.replace_types(type_:Any,type_map:Mapping[Any,Any]|None)->Any
pydantic._internal._generics.set_cached_generic_type(parent:type[BaseModel],typevar_values:tuple[Any,...],type_:type[BaseModel],origin:type[BaseModel]|None=None,args:tuple[Any,...]|None=None)->None


----------------------------------------/home/zhang/Packages/pydantic/pydantic2.0a4/_internal/_typing_extra.py----------------------------------------
A:pydantic._internal._typing_extra.NoneType->type(None)
A:pydantic._internal._typing_extra.EllipsisType->type(Ellipsis)
A:pydantic._internal._typing_extra.values->literal_values(type_)
A:pydantic._internal._typing_extra.origin->get_origin(ann_type)
A:pydantic._internal._typing_extra.test_new_type->typing.NewType('test_new_type', str)
A:pydantic._internal._typing_extra.frame->sys._getframe(parent_depth)
A:pydantic._internal._typing_extra.module_name->getattr(obj, '__module__', None)
A:pydantic._internal._typing_extra.ns->add_module_globals(cls, parent_namespace)
A:pydantic._internal._typing_extra.ann->base.__dict__.get('__annotations__', {})
A:pydantic._internal._typing_extra.localns->dict(vars(base))
A:pydantic._internal._typing_extra.hints[name]->eval_type_lenient(value, globalns, localns)
A:pydantic._internal._typing_extra.value->typing._eval_type(value, globalns, localns)
A:pydantic._internal._typing_extra.globalns->getattr(nsobj, '__globals__', {})
A:pydantic._internal._typing_extra.type_hints[name]->typing._eval_type(value, globalns, None)
A:pydantic._internal._typing_extra.res->typing.ForwardRef(arg, is_argument, is_class=is_class)
A:pydantic._internal._typing_extra.base_globals->getattr(sys.modules.get(base.__module__, None), '__dict__', {})
A:pydantic._internal._typing_extra.hints->dict(hints)
A:pydantic._internal._typing_extra.defaults->typing._get_defaults(obj)
pydantic._internal._typing_extra._check_classvar(v:type[Any]|None)->bool
pydantic._internal._typing_extra._check_finalvar(v:type[Any]|None)->bool
pydantic._internal._typing_extra.add_module_globals(obj:Any,globalns:dict[str,Any]|None=None)->dict[str, Any]
pydantic._internal._typing_extra.all_literal_values(type_:type[Any])->list[Any]
pydantic._internal._typing_extra.eval_type_lenient(value:Any,globalns:dict[str,Any]|None,localns:dict[str,Any]|None)->Any
pydantic._internal._typing_extra.get_cls_type_hints_lenient(obj:Any,globalns:dict[str,Any]|None=None)->dict[str, Any]
pydantic._internal._typing_extra.get_cls_types_namespace(cls:type[Any],parent_namespace:dict[str,Any]|None=None)->dict[str, Any]
pydantic._internal._typing_extra.get_function_type_hints(function:Callable[...,Any])->dict[str, Any]
pydantic._internal._typing_extra.is_annotated(ann_type:Any)->bool
pydantic._internal._typing_extra.is_callable_type(type_:type[Any])->bool
pydantic._internal._typing_extra.is_classvar(ann_type:type[Any])->bool
pydantic._internal._typing_extra.is_dataclass(_cls:type[Any])->TypeGuard[type[StandardDataclass]]
pydantic._internal._typing_extra.is_finalvar(ann_type:Any)->bool
pydantic._internal._typing_extra.is_literal_type(type_:type[Any])->bool
pydantic._internal._typing_extra.is_namedtuple(type_:type[Any])->bool
pydantic._internal._typing_extra.is_new_type(type_:type[Any])->bool
pydantic._internal._typing_extra.literal_values(type_:type[Any])->tuple[Any, ...]
pydantic._internal._typing_extra.parent_frame_namespace(*,parent_depth:int=2)->dict[str, Any] | None


----------------------------------------/home/zhang/Packages/pydantic/pydantic2.0a4/_internal/_core_metadata.py----------------------------------------
A:pydantic._internal._core_metadata.metadata->CoreMetadata(pydantic_js_functions=js_functions or [], pydantic_js_prefer_positional_arguments=js_prefer_positional_arguments)
A:pydantic._internal._core_metadata.schema['metadata']->CoreMetadata()
A:pydantic._internal._core_metadata.self._schema['metadata']metadata->CoreMetadata()
A:pydantic._internal._core_metadata.js_function->self.metadata.get('pydantic_js_function')
pydantic._internal._core_metadata.CoreMetadata(typing_extensions.TypedDict,total=False)
pydantic._internal._core_metadata.CoreMetadataHandler(self,schema:CoreSchemaOrField)
pydantic._internal._core_metadata.CoreMetadataHandler.get_json_schema(self,core_schema:CoreSchemaOrField,handler:GetJsonSchemaHandler)->JsonSchemaValue
pydantic._internal._core_metadata.CoreMetadataHandler.metadata(self)->CoreMetadata
pydantic._internal._core_metadata.UpdateCoreSchemaCallable(self,schema:CoreSchema,**kwargs:Any)
pydantic._internal._core_metadata.build_metadata_dict(*,js_functions:list[GetJsonSchemaFunction]|None=None,js_prefer_positional_arguments:bool|None=None,initial_metadata:Any|None=None)->Any


----------------------------------------/home/zhang/Packages/pydantic/pydantic2.0a4/_internal/_forward_ref.py----------------------------------------
A:pydantic._internal._forward_ref.model->replace_types(model, action['typevars_map'])
pydantic._internal._forward_ref.DeferredClassGetitem(TypedDict)
pydantic._internal._forward_ref.DeferredReplaceTypes(TypedDict)
pydantic._internal._forward_ref.PydanticForwardRef(self)
pydantic._internal._forward_ref.PydanticForwardRef.__getitem__(self,item:Any)->PydanticForwardRef
pydantic._internal._forward_ref.PydanticForwardRef.replace_types(self,typevars_map:Any)->PydanticForwardRef
pydantic._internal._forward_ref.PydanticForwardRef.resolve_model(self)->type[Any] | PydanticForwardRef
pydantic._internal._forward_ref.PydanticRecursiveRef(self)


----------------------------------------/home/zhang/Packages/pydantic/pydantic2.0a4/_internal/_internal_dataclass.py----------------------------------------


----------------------------------------/home/zhang/Packages/pydantic/pydantic2.0a4/_internal/_known_annotated_metadata.py----------------------------------------
A:pydantic._internal._known_annotated_metadata.(m, r)->collect_known_metadata([sub])
pydantic._internal._known_annotated_metadata.check_metadata(metadata:dict[str,Any],allowed:Iterable[str],source_type:Any)->None
pydantic._internal._known_annotated_metadata.collect_known_metadata(annotations:Iterable[Any])->tuple[dict[str, Any], list[Any]]


----------------------------------------/home/zhang/Packages/pydantic/pydantic2.0a4/_internal/_generate_schema.py----------------------------------------
A:pydantic._internal._generate_schema.FieldDecoratorInfoType->TypeVar('FieldDecoratorInfoType', bound=FieldDecoratorInfo)
A:pydantic._internal._generate_schema.fields->collect_dataclass_fields(dataclass, self.types_namespace, typevars_map=typevars_map)
A:pydantic._internal._generate_schema.schema['schema']->apply_each_item_validators(schema['schema'], each_item_validators)
A:pydantic._internal._generate_schema.inner_schema->apply_validators(args_schema, decorators.root_validator.values())
A:pydantic._internal._generate_schema.schema['items_schema']->apply_validators(inner_schema, each_item_validators)
A:pydantic._internal._generate_schema.schema['values_schema']->apply_validators(inner_schema, each_item_validators)
A:pydantic._internal._generate_schema.wrapped_handler->UnpackedRefJsonSchemaHandler(handler)
A:pydantic._internal._generate_schema.json_schema->handler(schema_or_field)
A:pydantic._internal._generate_schema.original_schema->UnpackedRefJsonSchemaHandler(handler).resolve_ref_schema(json_schema)
A:pydantic._internal._generate_schema.schema->_discriminated_union.apply_discriminator(schema, metadata.discriminator, definitions)
A:pydantic._internal._generate_schema.from_property->self._generate_schema_from_property(origin, obj)
A:pydantic._internal._generate_schema.metadata_js_function->_extract_get_pydantic_json_schema(annotation)
A:pydantic._internal._generate_schema.metadata['pydantic_js_functions']->build_metadata_dict(js_functions=[lambda _1, _2: {'type': 'string', 'format': 'regex'}]).get('pydantic_js_functions', [])
A:pydantic._internal._generate_schema.(model_ref, schema)->self._get_or_cache_recursive_ref(cls)
A:pydantic._internal._generate_schema.config_wrapper->ConfigWrapper(config, check=False)
A:pydantic._internal._generate_schema.core_config->ConfigWrapper(config, check=False).core_config()
A:pydantic._internal._generate_schema.metadata->build_metadata_dict(js_functions=[lambda _1, _2: {'type': 'string', 'format': 'regex'}])
A:pydantic._internal._generate_schema.model_schema->consolidate_refs(model_schema)
A:pydantic._internal._generate_schema.(obj, new_annotations)->self._prepare_annotations(obj, [])
A:pydantic._internal._generate_schema.get_schema->getattr(obj, '__get_pydantic_core_schema__', None)
A:pydantic._internal._generate_schema.obj->replace_types(obj, self.typevars_map)
A:pydantic._internal._generate_schema.resolved_model->replace_types(obj, self.typevars_map).resolve_model()
A:pydantic._internal._generate_schema.model_ref->get_type_ref(resolved_model)
A:pydantic._internal._generate_schema.std_schema->self._std_types_schema(obj)
A:pydantic._internal._generate_schema.origin->get_origin(obj)
A:pydantic._internal._generate_schema.common_field->self._common_field_schema(name, field_info, decorators)
A:pydantic._internal._generate_schema.this_field_validators->filter_field_decorator_info_by_field(decorators.validator.values(), name)
A:pydantic._internal._generate_schema.args->get_args(union_type)
A:pydantic._internal._generate_schema.s->pydantic_core.core_schema.nullable_schema(s)
A:pydantic._internal._generate_schema.expected->_typing_extra.all_literal_values(literal_type)
A:pydantic._internal._generate_schema.(typed_dict_ref, schema)->self._get_or_cache_recursive_ref(typed_dict_cls)
A:pydantic._internal._generate_schema.typevars_map->get_standard_typevars_map(dataclass)
A:pydantic._internal._generate_schema.annotation->replace_types(annotation, typevars_map)
A:pydantic._internal._generate_schema.field_info->fields.FieldInfo.from_annotation(annotation)
A:pydantic._internal._generate_schema.fields[field_name]->self._generate_td_field_schema(field_name, field_info, DecoratorInfos(), required=required)
A:pydantic._internal._generate_schema.arguments_schema->pydantic_core.core_schema.ArgumentsSchema(type='arguments', arguments_schema=[self._generate_parameter_schema(field_name, annotation) for (field_name, annotation) in annotations.items()], metadata=build_metadata_dict(js_prefer_positional_arguments=True))
A:pydantic._internal._generate_schema.field->fields.FieldInfo.from_annotated_attribute(annotation, default)
A:pydantic._internal._generate_schema.parameter_schema->pydantic_core.core_schema.arguments_parameter(name, schema)
A:pydantic._internal._generate_schema.parameter_schema['alias']->alias_generator(name)
A:pydantic._internal._generate_schema.params->get_args(tuple_type)
A:pydantic._internal._generate_schema.sv->pydantic_core.core_schema.tuple_variable_schema(self.generate_schema(params[0]))
A:pydantic._internal._generate_schema.(arg0, arg1)->get_args(mapping_type)
A:pydantic._internal._generate_schema.arg->get_first_arg(counter_type)
A:pydantic._internal._generate_schema.type_param->get_first_arg(type_)
A:pydantic._internal._generate_schema.item_type->get_first_arg(type_)
A:pydantic._internal._generate_schema.ser->pydantic_core.core_schema.plain_serializer_function_ser_schema(_serializers.pattern_serializer, info_arg=True, json_return_type='str')
A:pydantic._internal._generate_schema.(dataclass_ref, schema)->self._get_or_cache_recursive_ref(dataclass)
A:pydantic._internal._generate_schema.has_post_init->hasattr(dataclass, '__post_init__')
A:pydantic._internal._generate_schema.config->getattr(dataclass, '__pydantic_config__', None)
A:pydantic._internal._generate_schema.args_schema->pydantic_core.core_schema.dataclass_args_schema(dataclass.__name__, args, computed_fields=generate_computed_field(decorators.computed_fields), collect_init_only=has_post_init)
A:pydantic._internal._generate_schema.dc_schema->pydantic_core.core_schema.dataclass_schema(dataclass, inner_schema, post_init=has_post_init, ref=dataclass_ref)
A:pydantic._internal._generate_schema.sig->signature(function)
A:pydantic._internal._generate_schema.type_hints->_typing_extra.get_function_type_hints(function)
A:pydantic._internal._generate_schema.parameter_mode->mode_lookup.get(p.kind)
A:pydantic._internal._generate_schema.arg_schema->self._generate_parameter_schema(name, annotation, p.default, parameter_mode)
A:pydantic._internal._generate_schema.var_args_schema->self.generate_schema(annotation)
A:pydantic._internal._generate_schema.var_kwargs_schema->self.generate_schema(annotation)
A:pydantic._internal._generate_schema.return_hint->_typing_extra.get_function_type_hints(function).get('return')
A:pydantic._internal._generate_schema.return_schema->self.generate_schema(return_hint)
A:pydantic._internal._generate_schema.obj_ref->get_type_ref(cls)
A:pydantic._internal._generate_schema.self.recursion_cache[obj_ref]->pydantic_core.core_schema.definition_reference_schema(obj_ref)
A:pydantic._internal._generate_schema.(first_arg, *other_args)->get_args(annotated_type)
A:pydantic._internal._generate_schema.prepare->getattr(annotation, '__prepare_pydantic_annotations__', None)
A:pydantic._internal._generate_schema.res->list(prepare(source_type, tuple(annotations)))
A:pydantic._internal._generate_schema.(source_type, annotations)->self._prepare_annotations(source_type, annotations)
A:pydantic._internal._generate_schema.remaining->list(prepare(source_type, tuple(remaining)))
A:pydantic._internal._generate_schema.get_inner_schema->get_wrapped_inner_schema(get_inner_schema, annotation, self.definitions)
A:pydantic._internal._generate_schema.info_arg->inspect_validator(validator.func, validator.info.mode)
A:pydantic._internal._generate_schema.(is_field_serializer, info_arg)->inspect_field_serializer(serializer.func, serializer.info.mode)
A:pydantic._internal._generate_schema.schema['serialization']->pydantic_core.core_schema.plain_serializer_function_ser_schema(serializer.func, is_field_serializer=is_field_serializer, info_arg=info_arg, json_return_type=serializer.info.json_return_type, when_used=serializer.info.when_used)
A:pydantic._internal._generate_schema.ser_schema->pydantic_core.core_schema.plain_serializer_function_ser_schema(serializer.func, info_arg=info_arg, json_return_type=serializer.info.json_return_type)
A:pydantic._internal._generate_schema.(metadata_dict, _)->_known_annotated_metadata.collect_known_metadata([metadata])
A:pydantic._internal._generate_schema.js_modify_function->getattr(tp, '__get_pydantic_json_schema__', None)
pydantic._internal._generate_schema.GenerateSchema(self,config_wrapper:ConfigWrapper,types_namespace:dict[str,Any]|None,typevars_map:dict[Any,Any]|None=None)
pydantic._internal._generate_schema.GenerateSchema._annotated_schema(self,annotated_type:Any)->core_schema.CoreSchema
pydantic._internal._generate_schema.GenerateSchema._apply_annotations(self,get_inner_schema:GetCoreSchemaHandler,source_type:Any,annotations:typing.Iterable[Any])->CoreSchema
pydantic._internal._generate_schema.GenerateSchema._callable_schema(self,function:Callable[...,Any])->core_schema.CallSchema
pydantic._internal._generate_schema.GenerateSchema._common_field_schema(self,name:str,field_info:FieldInfo,decorators:DecoratorInfos)->_CommonField
pydantic._internal._generate_schema.GenerateSchema._counter_schema(self,counter_type:Any)->core_schema.CoreSchema
pydantic._internal._generate_schema.GenerateSchema._dataclass_schema(self,dataclass:type[StandardDataclass],origin:type[StandardDataclass]|None)->core_schema.CoreSchema
pydantic._internal._generate_schema.GenerateSchema._dict_schema(self,dict_type:Any)->core_schema.DictSchema
pydantic._internal._generate_schema.GenerateSchema._dict_subclass_schema(self,dict_subclass:Any)->core_schema.CoreSchema
pydantic._internal._generate_schema.GenerateSchema._generate_dc_field_schema(self,name:str,field_info:FieldInfo,decorators:DecoratorInfos)->core_schema.DataclassField
pydantic._internal._generate_schema.GenerateSchema._generate_md_field_schema(self,name:str,field_info:FieldInfo,decorators:DecoratorInfos,*,required:bool=True)->core_schema.ModelField
pydantic._internal._generate_schema.GenerateSchema._generate_parameter_schema(self,name:str,annotation:type[Any],default:Any=Parameter.empty,mode:Literal['positional_only','positional_or_keyword','keyword_only']|None=None)->core_schema.ArgumentsParameter
pydantic._internal._generate_schema.GenerateSchema._generate_schema(self,obj:Any)->core_schema.CoreSchema
pydantic._internal._generate_schema.GenerateSchema._generate_schema_from_prepare_annotations(self,obj:Any)->core_schema.CoreSchema | None
pydantic._internal._generate_schema.GenerateSchema._generate_schema_from_property(self,obj:Any,source:Any)->core_schema.CoreSchema | None
pydantic._internal._generate_schema.GenerateSchema._generate_td_field_schema(self,name:str,field_info:FieldInfo,decorators:DecoratorInfos,*,required:bool=True)->core_schema.TypedDictField
pydantic._internal._generate_schema.GenerateSchema._generic_collection_schema(self,parent_type:type[Any],type_:type[Any],origin:type[Any])->core_schema.CoreSchema
pydantic._internal._generate_schema.GenerateSchema._get_or_cache_recursive_ref(self,cls:type[Any])->tuple[str, core_schema.DefinitionReferenceSchema | None]
pydantic._internal._generate_schema.GenerateSchema._get_prepare_pydantic_annotations_for_known_type(self,obj:Any)->Callable[..., Any] | None
pydantic._internal._generate_schema.GenerateSchema._hashable_schema(self)->core_schema.CoreSchema
pydantic._internal._generate_schema.GenerateSchema._iterable_schema(self,type_:Any)->core_schema.GeneratorSchema
pydantic._internal._generate_schema.GenerateSchema._literal_schema(self,literal_type:Any)->core_schema.LiteralSchema
pydantic._internal._generate_schema.GenerateSchema._mapping_schema(self,mapping_type:Any)->core_schema.CoreSchema
pydantic._internal._generate_schema.GenerateSchema._namedtuple_schema(self,namedtuple_cls:Any)->core_schema.CallSchema
pydantic._internal._generate_schema.GenerateSchema._pattern_schema(self,pattern_type:Any)->core_schema.CoreSchema
pydantic._internal._generate_schema.GenerateSchema._prepare_annotations(self,source_type:Any,annotations:Iterable[Any])->tuple[Any, list[Any]]
pydantic._internal._generate_schema.GenerateSchema._sequence_schema(self,sequence_type:Any)->core_schema.CoreSchema
pydantic._internal._generate_schema.GenerateSchema._std_types_schema(self,obj:Any)->core_schema.CoreSchema | None
pydantic._internal._generate_schema.GenerateSchema._subclass_schema(self,type_:Any)->core_schema.CoreSchema
pydantic._internal._generate_schema.GenerateSchema._tuple_schema(self,tuple_type:Any)->core_schema.CoreSchema
pydantic._internal._generate_schema.GenerateSchema._type_schema(self)->core_schema.CoreSchema
pydantic._internal._generate_schema.GenerateSchema._typed_dict_schema(self,typed_dict_cls:Any,origin:Any)->core_schema.TypedDictSchema | core_schema.DefinitionReferenceSchema
pydantic._internal._generate_schema.GenerateSchema._union_schema(self,union_type:Any)->core_schema.CoreSchema
pydantic._internal._generate_schema.GenerateSchema._unsubstituted_typevar_schema(self,typevar:typing.TypeVar)->core_schema.CoreSchema
pydantic._internal._generate_schema.GenerateSchema.arbitrary_types(self)->bool
pydantic._internal._generate_schema.GenerateSchema.config_wrapper(self)->ConfigWrapper
pydantic._internal._generate_schema.GenerateSchema.generate_schema(self,obj:Any,from_dunder_get_core_schema:bool=True,from_prepare_args:bool=True)->core_schema.CoreSchema
pydantic._internal._generate_schema.GenerateSchema.model_schema(self,cls:type[BaseModel])->core_schema.CoreSchema
pydantic._internal._generate_schema._CommonField(TypedDict)
pydantic._internal._generate_schema._common_field(schema:core_schema.CoreSchema,*,validation_alias:str|list[str|int]|list[list[str|int]]|None=None,serialization_alias:str|None=None,serialization_exclude:bool|None=None,frozen:bool|None=None,metadata:Any=None)->_CommonField
pydantic._internal._generate_schema._extract_get_pydantic_json_schema(tp:Any)->GetJsonSchemaFunction | None
pydantic._internal._generate_schema._validators_require_validate_default(validators:Iterable[Decorator[ValidatorDecoratorInfo]])->bool
pydantic._internal._generate_schema.apply_each_item_validators(schema:core_schema.CoreSchema,each_item_validators:list[Decorator[ValidatorDecoratorInfo]])->core_schema.CoreSchema
pydantic._internal._generate_schema.apply_field_serializers(schema:core_schema.CoreSchema,serializers:list[Decorator[FieldSerializerDecoratorInfo]])->core_schema.CoreSchema
pydantic._internal._generate_schema.apply_model_serializers(schema:core_schema.CoreSchema,serializers:Iterable[Decorator[ModelSerializerDecoratorInfo]])->core_schema.CoreSchema
pydantic._internal._generate_schema.apply_model_validators(schema:core_schema.CoreSchema,validators:Iterable[Decorator[ModelValidatorDecoratorInfo]])->core_schema.CoreSchema
pydantic._internal._generate_schema.apply_single_annotation(schema:core_schema.CoreSchema,metadata:Any,definitions:dict[str,core_schema.CoreSchema])->core_schema.CoreSchema
pydantic._internal._generate_schema.apply_validators(schema:core_schema.CoreSchema,validators:Iterable[Decorator[RootValidatorDecoratorInfo]]|Iterable[Decorator[ValidatorDecoratorInfo]]|Iterable[Decorator[FieldValidatorDecoratorInfo]])->core_schema.CoreSchema
pydantic._internal._generate_schema.check_decorator_fields_exist(decorators:Iterable[AnyFieldDecorator],fields:Iterable[str])->None
pydantic._internal._generate_schema.check_validator_fields_against_field_name(info:FieldDecoratorInfo,field:str)->bool
pydantic._internal._generate_schema.filter_field_decorator_info_by_field(validator_functions:Iterable[Decorator[FieldDecoratorInfoType]],field:str)->list[Decorator[FieldDecoratorInfoType]]
pydantic._internal._generate_schema.generate_computed_field(d:dict[str,Decorator[ComputedFieldInfo]])->list[core_schema.ComputedField] | None
pydantic._internal._generate_schema.get_first_arg(type_:Any)->Any
pydantic._internal._generate_schema.get_wrapped_inner_schema(get_inner_schema:GetCoreSchemaHandler,annotation:Any,definitions:dict[str,core_schema.CoreSchema])->CallbackGetCoreSchemaHandler
pydantic._internal._generate_schema.modify_model_json_schema(schema_or_field:CoreSchemaOrField,handler:GetJsonSchemaHandler,*,cls:Any)->JsonSchemaValue
pydantic._internal._generate_schema.wrap_default(field_info:FieldInfo,schema:core_schema.CoreSchema)->core_schema.CoreSchema


----------------------------------------/home/zhang/Packages/pydantic/pydantic2.0a4/_internal/_std_types_schema.py----------------------------------------
A:pydantic._internal._std_types_schema.cases->list(enum_type.__members__.values())
A:pydantic._internal._std_types_schema.expected->repr(cases[0].value)
A:pydantic._internal._std_types_schema.enum_ref->get_type_ref(enum_type)
A:pydantic._internal._std_types_schema.json_schema->pydantic_core.core_schema.float_schema(allow_inf_nan=self.allow_inf_nan, multiple_of=None if self.multiple_of is None else float(self.multiple_of), le=None if self.le is None else float(self.le), ge=None if self.ge is None else float(self.ge), lt=None if self.lt is None else float(self.lt), gt=None if self.gt is None else float(self.gt))
A:pydantic._internal._std_types_schema.original_schema->handler.resolve_ref_schema(json_schema)
A:pydantic._internal._std_types_schema.metadata->build_metadata_dict(js_functions=[lambda _c, _h: {'type': 'string', 'format': 'ipv6network'}])
A:pydantic._internal._std_types_schema.to_enum_validator->pydantic_core.core_schema.general_plain_validator_function(to_enum)
A:pydantic._internal._std_types_schema.lax->pydantic_core.core_schema.union_schema([core_schema.is_instance_schema(uuid_type, json_types={'str'}), core_schema.no_info_after_validator_function(_validators.uuid_validator, core_schema.union_schema([core_schema.str_schema(), core_schema.bytes_schema()]))], custom_error_type='uuid_type', custom_error_message='Input should be a valid UUID, string, or bytes', strict=True, metadata=metadata)
A:pydantic._internal._std_types_schema.strict->pydantic_core.core_schema.custom_error_schema(core_schema.no_info_after_validator_function(self.validate, core_schema.is_instance_schema(Decimal, json_types={'int', 'float'})), custom_error_type='decimal_type', custom_error_message='Input should be a valid Decimal instance or decimal string in JSON')
A:pydantic._internal._std_types_schema.value->Decimal(str(__input_value))
A:pydantic._internal._std_types_schema.(_1, digit_tuple, exponent)->Decimal(str(__input_value)).as_tuple()
A:pydantic._internal._std_types_schema.digitsdecimals->abs(exponent)
A:pydantic._internal._std_types_schema.digits->len(digit_tuple)
A:pydantic._internal._std_types_schema.decimals->abs(exponent)
A:pydantic._internal._std_types_schema.(metadata, remaining_annotations)->_known_annotated_metadata.collect_known_metadata(annotations)
A:pydantic._internal._std_types_schema.instance_schema->pydantic_core.core_schema.is_instance_schema(path_type, json_types={'str'}, json_function=path_validator)
A:pydantic._internal._std_types_schema.inner_schema->pydantic_core.core_schema.dict_schema(schema_generator.generate_schema(keys_arg), schema_generator.generate_schema(values_arg))
A:pydantic._internal._std_types_schema.lax_schema->pydantic_core.core_schema.no_info_wrap_validator_function(_validators.deque_typed_validator, core_schema.list_schema(inner_schema, strict=False))
A:pydantic._internal._std_types_schema.(keys_arg, values_arg)->get_args(obj)
pydantic._internal._std_types_schema.DecimalValidator
pydantic._internal._std_types_schema.DecimalValidator.__get_pydantic_core_schema__(self,_source_type:Any,_handler:GetCoreSchemaHandler)->CoreSchema
pydantic._internal._std_types_schema.DecimalValidator.__get_pydantic_json_schema__(self,_schema:CoreSchema,handler:GetJsonSchemaHandler)->JsonSchemaValue
pydantic._internal._std_types_schema.DecimalValidator.__post_init__(self)->None
pydantic._internal._std_types_schema.DecimalValidator.validate(self,__input_value:int|float|str)->Decimal
pydantic._internal._std_types_schema.MetadataApplier
pydantic._internal._std_types_schema.MetadataApplier.__get_pydantic_core_schema__(self,_source_type:Any,_handler:GetCoreSchemaHandler)->CoreSchema
pydantic._internal._std_types_schema.MetadataApplier.__get_pydantic_json_schema__(self,_schema:CoreSchema,handler:GetJsonSchemaHandler)->JsonSchemaValue
pydantic._internal._std_types_schema._deque_any_schema()->core_schema.LaxOrStrictSchema
pydantic._internal._std_types_schema._deque_ser_schema(inner_schema:core_schema.CoreSchema|None=None)->core_schema.WrapSerializerFunctionSerSchema
pydantic._internal._std_types_schema._ordered_dict_any_schema()->core_schema.LaxOrStrictSchema
pydantic._internal._std_types_schema.date_schema(_schema_generator:GenerateSchema,_t:type[Any])->core_schema.DateSchema
pydantic._internal._std_types_schema.datetime_schema(_schema_generator:GenerateSchema,_t:type[Any])->core_schema.DatetimeSchema
pydantic._internal._std_types_schema.decimal_prepare_pydantic_annotations(_source:Any,annotations:Iterable[Any])->Iterable[Any]
pydantic._internal._std_types_schema.deque_schema(schema_generator:GenerateSchema,obj:Any)->core_schema.CoreSchema
pydantic._internal._std_types_schema.enum_schema(_schema_generator:GenerateSchema,enum_type:type[Enum])->core_schema.CoreSchema
pydantic._internal._std_types_schema.ip_v4_address_schema(_schema_generator:GenerateSchema,_obj:Any)->core_schema.CoreSchema
pydantic._internal._std_types_schema.ip_v4_interface_schema(_schema_generator:GenerateSchema,_obj:Any)->core_schema.CoreSchema
pydantic._internal._std_types_schema.ip_v4_network_schema(_schema_generator:GenerateSchema,_obj:Any)->core_schema.CoreSchema
pydantic._internal._std_types_schema.ip_v6_address_schema(_schema_generator:GenerateSchema,_obj:Any)->core_schema.CoreSchema
pydantic._internal._std_types_schema.ip_v6_interface_schema(_schema_generator:GenerateSchema,_obj:Any)->core_schema.CoreSchema
pydantic._internal._std_types_schema.ip_v6_network_schema(_schema_generator:GenerateSchema,_obj:Any)->core_schema.CoreSchema
pydantic._internal._std_types_schema.make_strict_ip_schema(tp:type[Any],metadata:Any)->CoreSchema
pydantic._internal._std_types_schema.multi_host_url_schema(_schema_generator:GenerateSchema,_obj:Any)->core_schema.CoreSchema
pydantic._internal._std_types_schema.ordered_dict_schema(schema_generator:GenerateSchema,obj:Any)->core_schema.CoreSchema
pydantic._internal._std_types_schema.path_schema(_schema_generator:GenerateSchema,path_type:type[PathLike])->core_schema.LaxOrStrictSchema
pydantic._internal._std_types_schema.schema_function(type:type[Any])->Callable[[StdSchemaFunction], StdSchemaFunction]
pydantic._internal._std_types_schema.time_schema(_schema_generator:GenerateSchema,_t:type[Any])->core_schema.TimeSchema
pydantic._internal._std_types_schema.timedelta_schema(_schema_generator:GenerateSchema,_t:type[Any])->core_schema.TimedeltaSchema
pydantic._internal._std_types_schema.url_schema(_schema_generator:GenerateSchema,_obj:Any)->core_schema.CoreSchema
pydantic._internal._std_types_schema.uuid_schema(_schema_generator:GenerateSchema,uuid_type:type[UUID])->core_schema.LaxOrStrictSchema


----------------------------------------/home/zhang/Packages/pydantic/pydantic2.0a4/_internal/_dataclasses.py----------------------------------------
A:pydantic._internal._dataclasses.typevars_map->get_standard_typevars_map(cls)
A:pydantic._internal._dataclasses.fields->collect_dataclass_fields(cls, types_namespace, typevars_map=typevars_map)
A:pydantic._internal._dataclasses.types_namespace->_typing_extra.get_cls_types_namespace(cls)
A:pydantic._internal._dataclasses.gen_schema->GenerateSchema(config_wrapper, types_namespace, typevars_map)
A:pydantic._internal._dataclasses.get_core_schema->getattr(cls, '__get_pydantic_core_schema__', None)
A:pydantic._internal._dataclasses.schema->flatten_schema_defs(schema)
A:pydantic._internal._dataclasses.core_config->config_wrapper.core_config(cls)
A:pydantic._internal._dataclasses.cls->typing.cast('type[PydanticDataclass]', cls)
A:pydantic._internal._dataclasses.simplified_core_schema->inline_schema_defs(schema)
A:pydantic._internal._dataclasses.cls.__pydantic_validator__validator->SchemaValidator(simplified_core_schema, core_config)
A:pydantic._internal._dataclasses.cls.__pydantic_serializer__->SchemaSerializer(simplified_core_schema, core_config)
A:pydantic._internal._dataclasses.cls.__setattr__->validated_setattr.__get__(None, cls)
pydantic._internal._dataclasses.complete_dataclass(cls:type[Any],config_wrapper:ConfigWrapper)->None
pydantic._internal._dataclasses.is_builtin_dataclass(_cls:type[Any])->TypeGuard[type[StandardDataclass]]
pydantic._internal._dataclasses.is_pydantic_dataclass(_cls:type[Any])->TypeGuard[type[PydanticDataclass]]
pydantic._internal._dataclasses.set_dataclass_fields(cls:type[StandardDataclass],types_namespace:dict[str,Any]|None=None)->None


----------------------------------------/home/zhang/Packages/pydantic/pydantic2.0a4/_internal/__init__.py----------------------------------------


----------------------------------------/home/zhang/Packages/pydantic/pydantic2.0a4/_internal/_validate_call.py----------------------------------------
A:pydantic._internal._validate_call.self.__signature__->inspect.signature(function)
A:pydantic._internal._validate_call.namespace->_typing_extra.add_module_globals(function, None)
A:pydantic._internal._validate_call.config_wrapper->ConfigWrapper(config)
A:pydantic._internal._validate_call.gen_schema->_generate_schema.GenerateSchema(config_wrapper, namespace)
A:pydantic._internal._validate_call.self.__pydantic_core_schema__schema->_generate_schema.GenerateSchema(config_wrapper, namespace).generate_schema(function)
A:pydantic._internal._validate_call.core_config->ConfigWrapper(config).core_config(self)
A:pydantic._internal._validate_call.schema->flatten_schema_defs(schema)
A:pydantic._internal._validate_call.simplified_schema->inline_schema_defs(schema)
A:pydantic._internal._validate_call.self.__pydantic_validator__->pydantic_core.SchemaValidator(simplified_schema, core_config)
A:pydantic._internal._validate_call.bound_function->self.raw_function.__get__(obj, objtype)
pydantic._internal._validate_call.CallMarker
pydantic._internal._validate_call.ValidateCallWrapper(self,function:Callable[...,Any],config:ConfigDict|None,validate_return:bool)
pydantic._internal._validate_call.ValidateCallWrapper.__get__(self,obj:Any,objtype:type[Any]|None=None)->ValidateCallWrapper
pydantic._internal._validate_call.ValidateCallWrapper.__repr__(self)->str

