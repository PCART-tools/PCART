
----------------------------------------/home/zhang/Packages/pydantic/pydantic1.0b2/types.py----------------------------------------
A:pydantic.types.namespace->dict(gt=gt, ge=ge, lt=lt, le=le, max_digits=max_digits, decimal_places=decimal_places, multiple_of=multiple_of)
A:pydantic.types.T->TypeVar('T')
A:pydantic.types.v_len->len(v)
A:pydantic.types.value->str_validator(value)
A:pydantic.types.new_cls->cast('ConstrainedInt', type.__new__(cls, name, bases, dct))
A:pydantic.types.digitsdecimals->abs(exponent)
A:pydantic.types.digits->len(digit_tuple)
A:pydantic.types.decimals->abs(exponent)
A:pydantic.types.self.brand->self._get_brand(card_number)
A:pydantic.types.sum_->int(card_number[-1])
A:pydantic.types.length->len(card_number)
A:pydantic.types.digit->int(card_number[i])
pydantic.ConstrainedBytes(bytes)
pydantic.ConstrainedBytes.__get_validators__(cls)->'CallableGenerator'
pydantic.ConstrainedDecimal(Decimal,metaclass=ConstrainedNumberMeta)
pydantic.ConstrainedDecimal.__get_validators__(cls)->'CallableGenerator'
pydantic.ConstrainedDecimal.validate(cls,value:Decimal)->Decimal
pydantic.ConstrainedFloat(float,metaclass=ConstrainedNumberMeta)
pydantic.ConstrainedFloat.__get_validators__(cls)->'CallableGenerator'
pydantic.ConstrainedInt(int,metaclass=ConstrainedNumberMeta)
pydantic.ConstrainedInt.__get_validators__(cls)->'CallableGenerator'
pydantic.ConstrainedList(list)
pydantic.ConstrainedList.__get_validators__(cls)->'CallableGenerator'
pydantic.ConstrainedList.list_length_validator(cls,v:'List[T]')->'List[T]'
pydantic.ConstrainedNumberMeta(cls,name:str,bases:Any,dct:Dict[str,Any])
pydantic.ConstrainedStr(str)
pydantic.ConstrainedStr.__get_validators__(cls)->'CallableGenerator'
pydantic.ConstrainedStr.validate(cls,value:str)->str
pydantic.DirectoryPath(Path)
pydantic.DirectoryPath.__get_validators__(cls)->'CallableGenerator'
pydantic.DirectoryPath.validate(cls,value:Path)->Path
pydantic.FilePath(Path)
pydantic.FilePath.__get_validators__(cls)->'CallableGenerator'
pydantic.FilePath.validate(cls,value:Path)->Path
pydantic.Json(metaclass=JsonMeta)
pydantic.JsonMeta(type)
pydantic.JsonMeta.__getitem__(self,t:AnyType)->Type[JsonWrapper]
pydantic.JsonWrapper
pydantic.NegativeFloat(ConstrainedFloat)
pydantic.NegativeInt(ConstrainedInt)
pydantic.PaymentCardBrand(Enum)
pydantic.PaymentCardBrand.__str__(self)->str
pydantic.PaymentCardNumber(self,card_number:str)
pydantic.PaymentCardNumber.__get_validators__(cls)->'CallableGenerator'
pydantic.PaymentCardNumber._get_brand(card_number:str)->PaymentCardBrand
pydantic.PaymentCardNumber.masked(self)->str
pydantic.PaymentCardNumber.validate_digits(cls,card_number:str)->str
pydantic.PaymentCardNumber.validate_length_for_brand(cls,card_number:'PaymentCardNumber')->'PaymentCardNumber'
pydantic.PaymentCardNumber.validate_luhn_check_digit(cls,card_number:str)->str
pydantic.PositiveFloat(ConstrainedFloat)
pydantic.PositiveInt(ConstrainedInt)
pydantic.PyObject
pydantic.PyObject.__get_validators__(cls)->'CallableGenerator'
pydantic.PyObject.validate(cls,value:Any)->Any
pydantic.SecretBytes(self,value:bytes)
pydantic.SecretBytes.__get_validators__(cls)->'CallableGenerator'
pydantic.SecretBytes.__repr__(self)->str
pydantic.SecretBytes.__str__(self)->str
pydantic.SecretBytes.display(self)->str
pydantic.SecretBytes.get_secret_value(self)->bytes
pydantic.SecretBytes.validate(cls,value:bytes)->'SecretBytes'
pydantic.SecretStr(self,value:str)
pydantic.SecretStr.__get_validators__(cls)->'CallableGenerator'
pydantic.SecretStr.__repr__(self)->str
pydantic.SecretStr.__str__(self)->str
pydantic.SecretStr.display(self)->str
pydantic.SecretStr.get_secret_value(self)->str
pydantic.SecretStr.validate(cls,value:str)->'SecretStr'
pydantic.StrictFloat(ConstrainedFloat)
pydantic.StrictInt(ConstrainedInt)
pydantic.StrictStr(ConstrainedStr)
pydantic.UUID1(UUID)
pydantic.UUID3(UUID)
pydantic.UUID4(UUID)
pydantic.UUID5(UUID)
pydantic.conbytes(*,strip_whitespace:bool=False,min_length:int=None,max_length:int=None)->Type[bytes]
pydantic.condecimal(*,gt:Decimal=None,ge:Decimal=None,lt:Decimal=None,le:Decimal=None,max_digits:int=None,decimal_places:int=None,multiple_of:Decimal=None)->Type[Decimal]
pydantic.confloat(*,strict:bool=False,gt:float=None,ge:float=None,lt:float=None,le:float=None,multiple_of:float=None)->Type[float]
pydantic.conint(*,strict:bool=False,gt:int=None,ge:int=None,lt:int=None,le:int=None,multiple_of:int=None)->Type[int]
pydantic.conlist(item_type:Type[T],*,min_items:int=None,max_items:int=None)->Type[List[T]]
pydantic.constr(*,strip_whitespace:bool=False,strict:bool=False,min_length:int=None,max_length:int=None,curtail_length:int=None,regex:str=None)->Type[str]
pydantic.types.ConstrainedBytes(bytes)
pydantic.types.ConstrainedBytes.__get_validators__(cls)->'CallableGenerator'
pydantic.types.ConstrainedDecimal(Decimal,metaclass=ConstrainedNumberMeta)
pydantic.types.ConstrainedDecimal.__get_validators__(cls)->'CallableGenerator'
pydantic.types.ConstrainedDecimal.validate(cls,value:Decimal)->Decimal
pydantic.types.ConstrainedFloat(float,metaclass=ConstrainedNumberMeta)
pydantic.types.ConstrainedFloat.__get_validators__(cls)->'CallableGenerator'
pydantic.types.ConstrainedInt(int,metaclass=ConstrainedNumberMeta)
pydantic.types.ConstrainedInt.__get_validators__(cls)->'CallableGenerator'
pydantic.types.ConstrainedList(list)
pydantic.types.ConstrainedList.__get_validators__(cls)->'CallableGenerator'
pydantic.types.ConstrainedList.list_length_validator(cls,v:'List[T]')->'List[T]'
pydantic.types.ConstrainedNumberMeta(cls,name:str,bases:Any,dct:Dict[str,Any])
pydantic.types.ConstrainedNumberMeta.__new__(cls,name:str,bases:Any,dct:Dict[str,Any])
pydantic.types.ConstrainedStr(str)
pydantic.types.ConstrainedStr.__get_validators__(cls)->'CallableGenerator'
pydantic.types.ConstrainedStr.validate(cls,value:str)->str
pydantic.types.DirectoryPath(Path)
pydantic.types.DirectoryPath.__get_validators__(cls)->'CallableGenerator'
pydantic.types.DirectoryPath.validate(cls,value:Path)->Path
pydantic.types.FilePath(Path)
pydantic.types.FilePath.__get_validators__(cls)->'CallableGenerator'
pydantic.types.FilePath.validate(cls,value:Path)->Path
pydantic.types.Json(metaclass=JsonMeta)
pydantic.types.JsonMeta(type)
pydantic.types.JsonMeta.__getitem__(self,t:AnyType)->Type[JsonWrapper]
pydantic.types.JsonWrapper
pydantic.types.NegativeFloat(ConstrainedFloat)
pydantic.types.NegativeInt(ConstrainedInt)
pydantic.types.PaymentCardBrand(Enum)
pydantic.types.PaymentCardBrand.__str__(self)->str
pydantic.types.PaymentCardNumber(self,card_number:str)
pydantic.types.PaymentCardNumber.__get_validators__(cls)->'CallableGenerator'
pydantic.types.PaymentCardNumber.__init__(self,card_number:str)
pydantic.types.PaymentCardNumber._get_brand(card_number:str)->PaymentCardBrand
pydantic.types.PaymentCardNumber.masked(self)->str
pydantic.types.PaymentCardNumber.validate_digits(cls,card_number:str)->str
pydantic.types.PaymentCardNumber.validate_length_for_brand(cls,card_number:'PaymentCardNumber')->'PaymentCardNumber'
pydantic.types.PaymentCardNumber.validate_luhn_check_digit(cls,card_number:str)->str
pydantic.types.PositiveFloat(ConstrainedFloat)
pydantic.types.PositiveInt(ConstrainedInt)
pydantic.types.PyObject
pydantic.types.PyObject.__get_validators__(cls)->'CallableGenerator'
pydantic.types.PyObject.validate(cls,value:Any)->Any
pydantic.types.SecretBytes(self,value:bytes)
pydantic.types.SecretBytes.__get_validators__(cls)->'CallableGenerator'
pydantic.types.SecretBytes.__init__(self,value:bytes)
pydantic.types.SecretBytes.__repr__(self)->str
pydantic.types.SecretBytes.__str__(self)->str
pydantic.types.SecretBytes.display(self)->str
pydantic.types.SecretBytes.get_secret_value(self)->bytes
pydantic.types.SecretBytes.validate(cls,value:bytes)->'SecretBytes'
pydantic.types.SecretStr(self,value:str)
pydantic.types.SecretStr.__get_validators__(cls)->'CallableGenerator'
pydantic.types.SecretStr.__init__(self,value:str)
pydantic.types.SecretStr.__repr__(self)->str
pydantic.types.SecretStr.__str__(self)->str
pydantic.types.SecretStr.display(self)->str
pydantic.types.SecretStr.get_secret_value(self)->str
pydantic.types.SecretStr.validate(cls,value:str)->'SecretStr'
pydantic.types.StrictFloat(ConstrainedFloat)
pydantic.types.StrictInt(ConstrainedInt)
pydantic.types.StrictStr(ConstrainedStr)
pydantic.types.UUID1(UUID)
pydantic.types.UUID3(UUID)
pydantic.types.UUID4(UUID)
pydantic.types.UUID5(UUID)
pydantic.types.conbytes(*,strip_whitespace:bool=False,min_length:int=None,max_length:int=None)->Type[bytes]
pydantic.types.condecimal(*,gt:Decimal=None,ge:Decimal=None,lt:Decimal=None,le:Decimal=None,max_digits:int=None,decimal_places:int=None,multiple_of:Decimal=None)->Type[Decimal]
pydantic.types.confloat(*,strict:bool=False,gt:float=None,ge:float=None,lt:float=None,le:float=None,multiple_of:float=None)->Type[float]
pydantic.types.conint(*,strict:bool=False,gt:int=None,ge:int=None,lt:int=None,le:int=None,multiple_of:int=None)->Type[int]
pydantic.types.conlist(item_type:Type[T],*,min_items:int=None,max_items:int=None)->Type[List[T]]
pydantic.types.constr(*,strip_whitespace:bool=False,strict:bool=False,min_length:int=None,max_length:int=None,curtail_length:int=None,regex:str=None)->Type[str]


----------------------------------------/home/zhang/Packages/pydantic/pydantic1.0b2/color.py----------------------------------------
A:pydantic.color.r_hex_short->re.compile('\\s*(?:#|0x)?([0-9a-f])([0-9a-f])([0-9a-f])([0-9a-f])?\\s*')
A:pydantic.color.r_hex_long->re.compile('\\s*(?:#|0x)?([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})?\\s*')
A:pydantic.color.r_rgb->re.compile(f'\\s*rgb\\(\\s*{_r_255}{_r_comma}{_r_255}{_r_comma}{_r_255}\\)\\s*')
A:pydantic.color.r_rgba->re.compile(f'\\s*rgba\\(\\s*{_r_255}{_r_comma}{_r_255}{_r_comma}{_r_255}{_r_comma}{_r_alpha}\\s*\\)\\s*')
A:pydantic.color.r_hsl->re.compile(f'\\s*hsl\\(\\s*{_r_h}{_r_comma}{_r_sl}{_r_comma}{_r_sl}\\s*\\)\\s*')
A:pydantic.color.r_hsla->re.compile(f'\\s*hsl\\(\\s*{_r_h}{_r_comma}{_r_sl}{_r_comma}{_r_sl}{_r_comma}{_r_alpha}\\s*\\)\\s*')
A:pydantic.color.self._rgba->parse_str(value)
A:pydantic.color.rgb->cast(Tuple[int, int, int], self.as_rgb_tuple())
A:pydantic.color.as_hex->''.join((as_hex[c] for c in range(0, len(as_hex), 2)))
A:pydantic.color.(h, s, li)->self.as_hsl_tuple(alpha=False)
A:pydantic.color.(h, s, li, a)->self.as_hsl_tuple(alpha=True)
A:pydantic.color.(h, l, s)->rgb_to_hls(self._rgba.r, self._rgba.g, self._rgba.b)
A:pydantic.color.value_lower->value.lower()
A:pydantic.color.m->re.compile(f'\\s*hsl\\(\\s*{_r_h}{_r_comma}{_r_sl}{_r_comma}{_r_sl}{_r_comma}{_r_alpha}\\s*\\)\\s*').fullmatch(value_lower)
A:pydantic.color.(*rgb, a)->re.compile(f'\\s*hsl\\(\\s*{_r_h}{_r_comma}{_r_sl}{_r_comma}{_r_sl}{_r_comma}{_r_alpha}\\s*\\)\\s*').fullmatch(value_lower).groups()
A:pydantic.color.(h, h_units, s, l_)->re.compile(f'\\s*hsl\\(\\s*{_r_h}{_r_comma}{_r_sl}{_r_comma}{_r_sl}{_r_comma}{_r_alpha}\\s*\\)\\s*').fullmatch(value_lower).groups()
A:pydantic.color.(h, h_units, s, l_, a)->re.compile(f'\\s*hsl\\(\\s*{_r_h}{_r_comma}{_r_sl}{_r_comma}{_r_sl}{_r_comma}{_r_alpha}\\s*\\)\\s*').fullmatch(value_lower).groups()
A:pydantic.color.color->float(value)
A:pydantic.color.alpha->float(value)
A:pydantic.color.h_value->float(h)
A:pydantic.color.(r, g, b)->hls_to_rgb(h_value, l_value, s_value)
pydantic.color.Color(self,value:ColorType)
pydantic.color.Color.__get_validators__(cls)->'CallableGenerator'
pydantic.color.Color.__init__(self,value:ColorType)
pydantic.color.Color.__repr__(self)->str
pydantic.color.Color.__str__(self)->str
pydantic.color.Color._alpha_float(self)->float
pydantic.color.Color.as_hex(self)->str
pydantic.color.Color.as_hsl(self)->str
pydantic.color.Color.as_hsl_tuple(self,*,alpha:Optional[bool]=None)->HslColorTuple
pydantic.color.Color.as_named(self,*,fallback:bool=False)->str
pydantic.color.Color.as_rgb(self)->str
pydantic.color.Color.as_rgb_tuple(self,*,alpha:Optional[bool]=None)->ColorTuple
pydantic.color.Color.original(self)->ColorType
pydantic.color.RGBA(self,r:float,g:float,b:float,alpha:Optional[float])
pydantic.color.RGBA.__getitem__(self,item:Any)->Any
pydantic.color.RGBA.__init__(self,r:float,g:float,b:float,alpha:Optional[float])
pydantic.color.float_to_255(c:float)->int
pydantic.color.ints_to_rgba(r:Union[int,str],g:Union[int,str],b:Union[int,str],alpha:Optional[float])->RGBA
pydantic.color.parse_color_value(value:Union[int,str],max_val:int=255)->float
pydantic.color.parse_float_alpha(value:Union[None,str,float,int])->Optional[float]
pydantic.color.parse_hsl(h:str,h_units:str,s:str,l:str,alpha:Optional[float]=None)->RGBA
pydantic.color.parse_str(value:str)->RGBA
pydantic.color.parse_tuple(value:Tuple[Any,...])->RGBA


----------------------------------------/home/zhang/Packages/pydantic/pydantic1.0b2/dataclasses.py----------------------------------------
A:pydantic.dataclasses.d->dict(self.__dict__)
A:pydantic.dataclasses.known_field->self.__pydantic_model__.__fields__.get(name, None)
A:pydantic.dataclasses.(value, error_)->self.__pydantic_model__.__fields__.get(name, None).validate(value, d, loc=name, cls=self.__class__)
A:pydantic.dataclasses.post_init_original->getattr(_cls, '__post_init_original__', None)
A:pydantic.dataclasses.post_init_post_parse->getattr(_cls, '__post_init_post_parse__', None)
A:pydantic.dataclasses.(d, _, validation_error)->validate_model(self.__pydantic_model__, self.__dict__, cls=self.__class__)
A:pydantic.dataclasses.cls->dataclasses._process_class(_cls, init, repr, eq, order, unsafe_hash, frozen)
A:pydantic.dataclasses.validators->gather_all_validators(cls)
A:pydantic.dataclasses.cls.__pydantic_model__->create_model(cls.__name__, __config__=config, __module__=_cls.__module__, __validators__=validators, **fields)
A:pydantic.dataclasses.cls.__validate__->classmethod(_validate_dataclass)
A:pydantic.dataclasses.cls.__get_validators__->classmethod(_get_validators)
pydantic.dataclasses._get_validators(cls:Type['DataclassType'])->Generator[Any, None, None]
pydantic.dataclasses._process_class(_cls:AnyType,init:bool,repr:bool,eq:bool,order:bool,unsafe_hash:bool,frozen:bool,config:Type['BaseConfig'])->'DataclassType'
pydantic.dataclasses._validate_dataclass(cls:Type['DataclassType'],v:Any)->'DataclassType'
pydantic.dataclasses.setattr_validate_assignment(self:'DataclassType',name:str,value:Any)->None


----------------------------------------/home/zhang/Packages/pydantic/pydantic1.0b2/class_validators.py----------------------------------------
A:pydantic.class_validators.f_cls->classmethod(f)
A:pydantic.class_validators.validators->self.validators.get(name, [])
A:pydantic.class_validators.unused_validators->set(chain(*[(v.func.__name__ for v in self.validators[f] if v.check_fields) for f in self.validators.keys() - self.used_validators]))
A:pydantic.class_validators.fn->', '.join(unused_validators)
A:pydantic.class_validators.validator_config->getattr(value, VALIDATOR_CONFIG_KEY, None)
A:pydantic.class_validators.sig->signature(validator)
A:pydantic.class_validators.args->list(sig.parameters.keys())
A:pydantic.class_validators.first_arg->list(sig.parameters.keys()).pop(0)
A:pydantic.class_validators.all_attributes->ChainMap(*[cls.__dict__ for cls in type_.__mro__])
pydantic.class_validators.Validator(self,func:AnyCallable,pre:bool=False,each_item:bool=False,always:bool=False,check_fields:bool=False)
pydantic.class_validators.Validator.__init__(self,func:AnyCallable,pre:bool=False,each_item:bool=False,always:bool=False,check_fields:bool=False)
pydantic.class_validators.ValidatorGroup(self,validators:'ValidatorListDict')
pydantic.class_validators.ValidatorGroup.__init__(self,validators:'ValidatorListDict')
pydantic.class_validators.ValidatorGroup.check_for_unused(self)->None
pydantic.class_validators.ValidatorGroup.get_validators(self,name:str)->Optional[Dict[str, Validator]]
pydantic.class_validators._check_validator_name(f:AnyCallable)->None
pydantic.class_validators._generic_validator_basic(validator:AnyCallable,sig:Signature,args:Set[str])->'ValidatorCallable'
pydantic.class_validators._generic_validator_cls(validator:AnyCallable,sig:Signature,args:Set[str])->'ValidatorCallable'
pydantic.class_validators.extract_root_validators(namespace:Dict[str,Any])->Tuple[List[AnyCallable], List[AnyCallable]]
pydantic.class_validators.extract_validators(namespace:Dict[str,Any])->Dict[str, List[Validator]]
pydantic.class_validators.gather_all_validators(type_:'ModelOrDc')->Dict[str, classmethod]
pydantic.class_validators.inherit_validators(base_validators:'ValidatorListDict',validators:'ValidatorListDict')->'ValidatorListDict'
pydantic.class_validators.make_generic_validator(validator:AnyCallable)->'ValidatorCallable'
pydantic.class_validators.prep_validators(v_funcs:Iterable[AnyCallable])->'ValidatorsList'
pydantic.class_validators.root_validator(_func:Optional[AnyCallable]=None,*,pre:bool=False)->Union[classmethod, Callable[[AnyCallable], classmethod]]
pydantic.class_validators.validator(*fields:str,pre:bool=False,each_item:bool=False,always:bool=False,check_fields:bool=True,whole:bool=None)->Callable[[AnyCallable], classmethod]
pydantic.root_validator(_func:Optional[AnyCallable]=None,*,pre:bool=False)->Union[classmethod, Callable[[AnyCallable], classmethod]]
pydantic.validator(*fields:str,pre:bool=False,each_item:bool=False,always:bool=False,check_fields:bool=True,whole:bool=None)->Callable[[AnyCallable], classmethod]


----------------------------------------/home/zhang/Packages/pydantic/pydantic1.0b2/validators.py----------------------------------------
A:pydantic.validators.v->v.strip().strip()
A:pydantic.validators.v_len->len(v)
A:pydantic.validators.enum_v->field.type_(v)
A:pydantic.validators.required_version->getattr(field.type_, '_required_version', None)
A:pydantic.validators.allowed_choices_set->set(permitted_choices)
A:pydantic.validators.T->TypeVar('T')
A:pydantic.validators.type_type->type(type_)
A:pydantic.validators.class_->get_class(type_)
A:pydantic.validators.supertype->_find_supertype(supertype)
pydantic.validators.IfConfig(self,validator:AnyCallable,*config_attr_names:str)
pydantic.validators.IfConfig.__init__(self,validator:AnyCallable,*config_attr_names:str)
pydantic.validators.IfConfig.check(self,config:Type['BaseConfig'])->bool
pydantic.validators._find_supertype(type_:AnyType)->Optional[AnyType]
pydantic.validators._is_new_type(type_:AnyType)->bool
pydantic.validators.any_class_validator(v:Any)->Type[T]
pydantic.validators.anystr_length_validator(v:'StrBytes',config:'BaseConfig')->'StrBytes'
pydantic.validators.anystr_strip_whitespace(v:'StrBytes')->'StrBytes'
pydantic.validators.bool_validator(v:Any)->bool
pydantic.validators.bytes_validator(v:Any)->bytes
pydantic.validators.callable_validator(v:Any)->AnyCallable
pydantic.validators.constant_validator(v:'Any',field:'ModelField')->'Any'
pydantic.validators.constr_length_validator(v:'StrBytes',field:'ModelField',config:'BaseConfig')->'StrBytes'
pydantic.validators.constr_strip_whitespace(v:'StrBytes',field:'ModelField',config:'BaseConfig')->'StrBytes'
pydantic.validators.decimal_validator(v:Any)->Decimal
pydantic.validators.dict_validator(v:Any)->Dict[Any, Any]
pydantic.validators.enum_validator(v:Any,field:'ModelField',config:'BaseConfig')->Enum
pydantic.validators.find_validators(type_:AnyType,config:Type['BaseConfig'])->Generator[AnyCallable, None, None]
pydantic.validators.float_validator(v:Any)->float
pydantic.validators.frozenset_validator(v:Any)->FrozenSet[Any]
pydantic.validators.int_validator(v:Any)->int
pydantic.validators.ip_v4_address_validator(v:Any)->IPv4Address
pydantic.validators.ip_v4_interface_validator(v:Any)->IPv4Interface
pydantic.validators.ip_v4_network_validator(v:Any)->IPv4Network
pydantic.validators.ip_v6_address_validator(v:Any)->IPv6Address
pydantic.validators.ip_v6_interface_validator(v:Any)->IPv6Interface
pydantic.validators.ip_v6_network_validator(v:Any)->IPv6Network
pydantic.validators.list_validator(v:Any)->List[Any]
pydantic.validators.make_arbitrary_type_validator(type_:Type[T])->Callable[[T], T]
pydantic.validators.make_class_validator(type_:Type[T])->Callable[[Any], Type[T]]
pydantic.validators.make_literal_validator(type_:Any)->Callable[[Any], Any]
pydantic.validators.number_multiple_validator(v:'Number',field:'ModelField')->'Number'
pydantic.validators.number_size_validator(v:'Number',field:'ModelField')->'Number'
pydantic.validators.ordered_dict_validator(v:Any)->'AnyOrderedDict'
pydantic.validators.path_exists_validator(v:Any)->Path
pydantic.validators.path_validator(v:Any)->Path
pydantic.validators.pattern_validator(v:Any)->Pattern[str]
pydantic.validators.set_validator(v:Any)->Set[Any]
pydantic.validators.str_validator(v:Any)->Optional[str]
pydantic.validators.strict_float_validator(v:Any)->float
pydantic.validators.strict_int_validator(v:Any)->int
pydantic.validators.strict_str_validator(v:Any)->str
pydantic.validators.tuple_validator(v:Any)->Tuple[Any, ...]
pydantic.validators.uuid_validator(v:Any,field:'ModelField')->UUID
pydantic.validators.validate_json(v:Any,config:'BaseConfig')->Any


----------------------------------------/home/zhang/Packages/pydantic/pydantic1.0b2/utils.py----------------------------------------
A:pydantic.utils.(module_path, class_name)->dotted_path.strip(' ').rsplit('.', 1)
A:pydantic.utils.module->import_module(module_path)
A:pydantic.utils.v->type(v).__repr__(v)
A:pydantic.utils.items->self._normalize_indexes(items, len(value))
A:pydantic.utils.item->self._items.get(e)
pydantic.utils.GetterDict(self,obj:Any)
pydantic.utils.GetterDict.__contains__(self,item:Any)->bool
pydantic.utils.GetterDict.__eq__(self,other:Any)->bool
pydantic.utils.GetterDict.__getitem__(self,key:str)->Any
pydantic.utils.GetterDict.__init__(self,obj:Any)
pydantic.utils.GetterDict.__iter__(self)->Iterator[str]
pydantic.utils.GetterDict.__len__(self)->int
pydantic.utils.GetterDict.__repr__(self)->str
pydantic.utils.GetterDict.extra_keys(self)->Set[Any]
pydantic.utils.GetterDict.get(self,key:Any,default:Any=None)->Any
pydantic.utils.GetterDict.items(self)->Iterator[Tuple[str, Any]]
pydantic.utils.GetterDict.keys(self)->List[Any]
pydantic.utils.GetterDict.values(self)->List[Any]
pydantic.utils.ValueItems(self,value:Any,items:Union['SetIntStr','DictIntStrAny'])
pydantic.utils.ValueItems.__init__(self,value:Any,items:Union['SetIntStr','DictIntStrAny'])
pydantic.utils.ValueItems.__str__(self)->str
pydantic.utils.ValueItems._normalize_indexes(self,items:Union['SetIntStr','DictIntStrAny'],v_length:int)->Union['SetIntStr', 'DictIntStrAny']
pydantic.utils.ValueItems.for_element(self,e:'IntStr')->Optional[Union['SetIntStr', 'DictIntStrAny']]
pydantic.utils.ValueItems.is_excluded(self,item:Any)->bool
pydantic.utils.ValueItems.is_included(self,item:Any)->bool
pydantic.utils.almost_equal_floats(value_1:float,value_2:float,*,delta:float=1e-08)->bool
pydantic.utils.import_string(dotted_path:str)->Any
pydantic.utils.in_ipython()->bool
pydantic.utils.lenient_issubclass(cls:Any,class_or_tuple:Union[AnyType,Tuple[AnyType,...]])->bool
pydantic.utils.sequence_like(v:AnyType)->bool
pydantic.utils.truncate(v:Union[str],*,max_len:int=80)->str
pydantic.utils.validate_field_name(bases:List[Type['BaseModel']],field_name:str)->None


----------------------------------------/home/zhang/Packages/pydantic/pydantic1.0b2/parse.py----------------------------------------
A:pydantic.parse.b->Path(path).read_bytes()
A:pydantic.parse.path->Path(path)
pydantic.Protocol(str,Enum)
pydantic.parse.Protocol(str,Enum)
pydantic.parse.load_file(path:Union[str,Path],*,content_type:str=None,encoding:str='utf8',proto:Protocol=None,allow_pickle:bool=False)->Any
pydantic.parse.load_str_bytes(b:StrBytes,*,content_type:str=None,encoding:str='utf8',proto:Protocol=None,allow_pickle:bool=False,json_loads:Callable[[str],Any]=json.loads)->Any


----------------------------------------/home/zhang/Packages/pydantic/pydantic1.0b2/env_settings.py----------------------------------------
A:pydantic.env_settings.env_val->self.__config__.json_loads(env_val)
A:pydantic.env_settings.env->field.field_info.extra.pop('env', None)
A:pydantic.env_settings.env_names->type(env_names)((n.lower() for n in env_names))
pydantic.BaseSettings(__pydantic_self__,**values:Any)
pydantic.BaseSettings.Config
pydantic.BaseSettings.Config.prepare_field(cls,field:ModelField)->None
pydantic.BaseSettings._build_environ(self)->Dict[str, Optional[str]]
pydantic.BaseSettings._build_values(self,init_kwargs:Dict[str,Any])->Dict[str, Any]
pydantic.env_settings.BaseSettings(__pydantic_self__,**values:Any)
pydantic.env_settings.BaseSettings.Config
pydantic.env_settings.BaseSettings.Config.prepare_field(cls,field:ModelField)->None
pydantic.env_settings.BaseSettings.__init__(__pydantic_self__,**values:Any)
pydantic.env_settings.BaseSettings._build_environ(self)->Dict[str, Optional[str]]
pydantic.env_settings.BaseSettings._build_values(self,init_kwargs:Dict[str,Any])->Dict[str, Any]
pydantic.env_settings.SettingsError(ValueError)


----------------------------------------/home/zhang/Packages/pydantic/pydantic1.0b2/datetime_parse.py----------------------------------------
A:pydantic.datetime_parse.date_re->re.compile('(?P<year>\\d{4})-(?P<month>\\d{1,2})-(?P<day>\\d{1,2})$')
A:pydantic.datetime_parse.time_re->re.compile('(?P<hour>\\d{1,2}):(?P<minute>\\d{1,2})(?::(?P<second>\\d{1,2})(?:\\.(?P<microsecond>\\d{1,6})\\d{0,6})?)?')
A:pydantic.datetime_parse.datetime_re->re.compile('(?P<year>\\d{4})-(?P<month>\\d{1,2})-(?P<day>\\d{1,2})[T ](?P<hour>\\d{1,2}):(?P<minute>\\d{1,2})(?::(?P<second>\\d{1,2})(?:\\.(?P<microsecond>\\d{1,6})\\d{0,6})?)?(?P<tzinfo>Z|[+-]\\d{2}(?::?\\d{2})?)?$')
A:pydantic.datetime_parse.standard_duration_re->re.compile('^(?:(?P<days>-?\\d+) (days?, )?)?((?:(?P<hours>-?\\d+):)(?=\\d+:\\d+))?(?:(?P<minutes>-?\\d+):)?(?P<seconds>-?\\d+)(?:\\.(?P<microseconds>\\d{1,6})\\d{0,6})?$')
A:pydantic.datetime_parse.iso8601_duration_re->re.compile('^(?P<sign>[-+]?)P(?:(?P<days>\\d+(.\\d+)?)D)?(?:T(?:(?P<hours>\\d+(.\\d+)?)H)?(?:(?P<minutes>\\d+(.\\d+)?)M)?(?:(?P<seconds>\\d+(.\\d+)?)S)?)?$')
A:pydantic.datetime_parse.EPOCH->datetime(1970, 1, 1)
A:pydantic.datetime_parse.MS_WATERSHED->int(20000000000.0)
A:pydantic.datetime_parse.number->get_numeric(value, 'datetime')
A:pydantic.datetime_parse.value->value.decode().decode()
A:pydantic.datetime_parse.match->re.compile('(?P<year>\\d{4})-(?P<month>\\d{1,2})-(?P<day>\\d{1,2})[T ](?P<hour>\\d{1,2}):(?P<minute>\\d{1,2})(?::(?P<second>\\d{1,2})(?:\\.(?P<microsecond>\\d{1,6})\\d{0,6})?)?(?P<tzinfo>Z|[+-]\\d{2}(?::?\\d{2})?)?$').match(value)
A:pydantic.datetime_parse.kw->re.compile('(?P<year>\\d{4})-(?P<month>\\d{1,2})-(?P<day>\\d{1,2})[T ](?P<hour>\\d{1,2}):(?P<minute>\\d{1,2})(?::(?P<second>\\d{1,2})(?:\\.(?P<microsecond>\\d{1,6})\\d{0,6})?)?(?P<tzinfo>Z|[+-]\\d{2}(?::?\\d{2})?)?$').match(value).groupdict()
A:pydantic.datetime_parse.kw['microsecond']->kw['microsecond'].ljust(6, '0').ljust(6, '0')
A:pydantic.datetime_parse.tzinfo_str->re.compile('(?P<year>\\d{4})-(?P<month>\\d{1,2})-(?P<day>\\d{1,2})[T ](?P<hour>\\d{1,2}):(?P<minute>\\d{1,2})(?::(?P<second>\\d{1,2})(?:\\.(?P<microsecond>\\d{1,6})\\d{0,6})?)?(?P<tzinfo>Z|[+-]\\d{2}(?::?\\d{2})?)?$').match(value).groupdict().pop('tzinfo')
A:pydantic.datetime_parse.tzinfo->timezone(timedelta(minutes=offset))
A:pydantic.datetime_parse.kw['microseconds']->kw['microseconds'].ljust(6, '0').ljust(6, '0')
pydantic.datetime_parse.from_unix_seconds(seconds:Union[int,float])->datetime
pydantic.datetime_parse.get_numeric(value:StrBytesIntFloat,native_expected_type:str)->Union[None, int, float]
pydantic.datetime_parse.parse_date(value:Union[date,StrBytesIntFloat])->date
pydantic.datetime_parse.parse_datetime(value:Union[datetime,StrBytesIntFloat])->datetime
pydantic.datetime_parse.parse_duration(value:StrBytesIntFloat)->timedelta
pydantic.datetime_parse.parse_time(value:Union[time,StrBytesIntFloat])->time


----------------------------------------/home/zhang/Packages/pydantic/pydantic1.0b2/errors.py----------------------------------------
A:pydantic.errors.permitted->', '.join((repr(v.value) for v in self.enum_values))
pydantic.AnyStrMaxLengthError(self,*,limit_value:int)
pydantic.AnyStrMinLengthError(self,*,limit_value:int)
pydantic.ArbitraryTypeError(self,*,expected_arbitrary_type:AnyType)
pydantic.BoolError(PydanticTypeError)
pydantic.BytesError(PydanticTypeError)
pydantic.CallableError(PydanticTypeError)
pydantic.ClassError(PydanticTypeError)
pydantic.ColorError(PydanticValueError)
pydantic.ConfigError(RuntimeError)
pydantic.DataclassTypeError(PydanticTypeError)
pydantic.DateError(PydanticValueError)
pydantic.DateTimeError(PydanticValueError)
pydantic.DecimalError(PydanticTypeError)
pydantic.DecimalIsNotFiniteError(PydanticValueError)
pydantic.DecimalMaxDigitsError(self,*,max_digits:int)
pydantic.DecimalMaxPlacesError(self,*,decimal_places:int)
pydantic.DecimalWholeDigitsError(self,*,whole_digits:int)
pydantic.DictError(PydanticTypeError)
pydantic.DurationError(PydanticValueError)
pydantic.EmailError(PydanticValueError)
pydantic.EnumError(PydanticTypeError)
pydantic.EnumError.__str__(self)->str
pydantic.ExtraError(PydanticValueError)
pydantic.FloatError(PydanticTypeError)
pydantic.FrozenSetError(PydanticTypeError)
pydantic.IPv4AddressError(PydanticValueError)
pydantic.IPv4InterfaceError(PydanticValueError)
pydantic.IPv4NetworkError(PydanticValueError)
pydantic.IPv6AddressError(PydanticValueError)
pydantic.IPv6InterfaceError(PydanticValueError)
pydantic.IPv6NetworkError(PydanticValueError)
pydantic.IPvAnyAddressError(PydanticValueError)
pydantic.IPvAnyInterfaceError(PydanticValueError)
pydantic.IPvAnyNetworkError(PydanticValueError)
pydantic.IntegerError(PydanticTypeError)
pydantic.InvalidLengthForBrand(PydanticValueError)
pydantic.JsonError(PydanticValueError)
pydantic.JsonTypeError(PydanticTypeError)
pydantic.ListError(PydanticTypeError)
pydantic.ListMaxLengthError(self,*,limit_value:int)
pydantic.ListMinLengthError(self,*,limit_value:int)
pydantic.LuhnValidationError(PydanticValueError)
pydantic.MissingError(PydanticValueError)
pydantic.NoneIsAllowedError(PydanticTypeError)
pydantic.NoneIsNotAllowedError(PydanticTypeError)
pydantic.NotDigitError(PydanticValueError)
pydantic.NumberNotGeError(_NumberBoundError)
pydantic.NumberNotGtError(_NumberBoundError)
pydantic.NumberNotLeError(_NumberBoundError)
pydantic.NumberNotLtError(_NumberBoundError)
pydantic.NumberNotMultipleError(self,*,multiple_of:Union[int,float,Decimal])
pydantic.PathError(PydanticTypeError)
pydantic.PathNotADirectoryError(_PathValueError)
pydantic.PathNotAFileError(_PathValueError)
pydantic.PathNotExistsError(_PathValueError)
pydantic.PatternError(PydanticValueError)
pydantic.PyObjectError(PydanticTypeError)
pydantic.PydanticErrorMixin(self,**ctx:Any)
pydantic.PydanticErrorMixin.__str__(self)->str
pydantic.PydanticTypeError(PydanticErrorMixin,TypeError)
pydantic.PydanticValueError(PydanticErrorMixin,ValueError)
pydantic.SequenceError(PydanticTypeError)
pydantic.SetError(PydanticTypeError)
pydantic.StrError(PydanticTypeError)
pydantic.StrRegexError(self,*,pattern:str)
pydantic.StrictBoolError(PydanticValueError)
pydantic.SubclassError(self,*,expected_class:AnyType)
pydantic.TimeError(PydanticValueError)
pydantic.TupleError(PydanticTypeError)
pydantic.TupleLengthError(self,*,actual_length:int,expected_length:int)
pydantic.UUIDError(PydanticTypeError)
pydantic.UUIDVersionError(self,*,required_version:int)
pydantic.UrlError(PydanticValueError)
pydantic.UrlExtraError(UrlError)
pydantic.UrlHostError(UrlError)
pydantic.UrlHostTldError(UrlError)
pydantic.UrlSchemeError(UrlError)
pydantic.UrlSchemePermittedError(self,allowed_schemes:Set[str])
pydantic.UrlUserInfoError(UrlError)
pydantic.WrongConstantError(PydanticValueError)
pydantic.WrongConstantError.__str__(self)->str
pydantic._NumberBoundError(self,*,limit_value:Union[int,float,Decimal])
pydantic._PathValueError(self,*,path:Path)
pydantic.errors.AnyStrMaxLengthError(self,*,limit_value:int)
pydantic.errors.AnyStrMaxLengthError.__init__(self,*,limit_value:int)
pydantic.errors.AnyStrMinLengthError(self,*,limit_value:int)
pydantic.errors.AnyStrMinLengthError.__init__(self,*,limit_value:int)
pydantic.errors.ArbitraryTypeError(self,*,expected_arbitrary_type:AnyType)
pydantic.errors.ArbitraryTypeError.__init__(self,*,expected_arbitrary_type:AnyType)
pydantic.errors.BoolError(PydanticTypeError)
pydantic.errors.BytesError(PydanticTypeError)
pydantic.errors.CallableError(PydanticTypeError)
pydantic.errors.ClassError(PydanticTypeError)
pydantic.errors.ColorError(PydanticValueError)
pydantic.errors.ConfigError(RuntimeError)
pydantic.errors.DataclassTypeError(PydanticTypeError)
pydantic.errors.DateError(PydanticValueError)
pydantic.errors.DateTimeError(PydanticValueError)
pydantic.errors.DecimalError(PydanticTypeError)
pydantic.errors.DecimalIsNotFiniteError(PydanticValueError)
pydantic.errors.DecimalMaxDigitsError(self,*,max_digits:int)
pydantic.errors.DecimalMaxDigitsError.__init__(self,*,max_digits:int)
pydantic.errors.DecimalMaxPlacesError(self,*,decimal_places:int)
pydantic.errors.DecimalMaxPlacesError.__init__(self,*,decimal_places:int)
pydantic.errors.DecimalWholeDigitsError(self,*,whole_digits:int)
pydantic.errors.DecimalWholeDigitsError.__init__(self,*,whole_digits:int)
pydantic.errors.DictError(PydanticTypeError)
pydantic.errors.DurationError(PydanticValueError)
pydantic.errors.EmailError(PydanticValueError)
pydantic.errors.EnumError(PydanticTypeError)
pydantic.errors.EnumError.__str__(self)->str
pydantic.errors.ExtraError(PydanticValueError)
pydantic.errors.FloatError(PydanticTypeError)
pydantic.errors.FrozenSetError(PydanticTypeError)
pydantic.errors.IPv4AddressError(PydanticValueError)
pydantic.errors.IPv4InterfaceError(PydanticValueError)
pydantic.errors.IPv4NetworkError(PydanticValueError)
pydantic.errors.IPv6AddressError(PydanticValueError)
pydantic.errors.IPv6InterfaceError(PydanticValueError)
pydantic.errors.IPv6NetworkError(PydanticValueError)
pydantic.errors.IPvAnyAddressError(PydanticValueError)
pydantic.errors.IPvAnyInterfaceError(PydanticValueError)
pydantic.errors.IPvAnyNetworkError(PydanticValueError)
pydantic.errors.IntegerError(PydanticTypeError)
pydantic.errors.InvalidLengthForBrand(PydanticValueError)
pydantic.errors.JsonError(PydanticValueError)
pydantic.errors.JsonTypeError(PydanticTypeError)
pydantic.errors.ListError(PydanticTypeError)
pydantic.errors.ListMaxLengthError(self,*,limit_value:int)
pydantic.errors.ListMaxLengthError.__init__(self,*,limit_value:int)
pydantic.errors.ListMinLengthError(self,*,limit_value:int)
pydantic.errors.ListMinLengthError.__init__(self,*,limit_value:int)
pydantic.errors.LuhnValidationError(PydanticValueError)
pydantic.errors.MissingError(PydanticValueError)
pydantic.errors.NoneIsAllowedError(PydanticTypeError)
pydantic.errors.NoneIsNotAllowedError(PydanticTypeError)
pydantic.errors.NotDigitError(PydanticValueError)
pydantic.errors.NumberNotGeError(_NumberBoundError)
pydantic.errors.NumberNotGtError(_NumberBoundError)
pydantic.errors.NumberNotLeError(_NumberBoundError)
pydantic.errors.NumberNotLtError(_NumberBoundError)
pydantic.errors.NumberNotMultipleError(self,*,multiple_of:Union[int,float,Decimal])
pydantic.errors.NumberNotMultipleError.__init__(self,*,multiple_of:Union[int,float,Decimal])
pydantic.errors.PathError(PydanticTypeError)
pydantic.errors.PathNotADirectoryError(_PathValueError)
pydantic.errors.PathNotAFileError(_PathValueError)
pydantic.errors.PathNotExistsError(_PathValueError)
pydantic.errors.PatternError(PydanticValueError)
pydantic.errors.PyObjectError(PydanticTypeError)
pydantic.errors.PydanticErrorMixin(self,**ctx:Any)
pydantic.errors.PydanticErrorMixin.__init__(self,**ctx:Any)
pydantic.errors.PydanticErrorMixin.__str__(self)->str
pydantic.errors.PydanticTypeError(PydanticErrorMixin,TypeError)
pydantic.errors.PydanticValueError(PydanticErrorMixin,ValueError)
pydantic.errors.SequenceError(PydanticTypeError)
pydantic.errors.SetError(PydanticTypeError)
pydantic.errors.StrError(PydanticTypeError)
pydantic.errors.StrRegexError(self,*,pattern:str)
pydantic.errors.StrRegexError.__init__(self,*,pattern:str)
pydantic.errors.StrictBoolError(PydanticValueError)
pydantic.errors.SubclassError(self,*,expected_class:AnyType)
pydantic.errors.SubclassError.__init__(self,*,expected_class:AnyType)
pydantic.errors.TimeError(PydanticValueError)
pydantic.errors.TupleError(PydanticTypeError)
pydantic.errors.TupleLengthError(self,*,actual_length:int,expected_length:int)
pydantic.errors.TupleLengthError.__init__(self,*,actual_length:int,expected_length:int)
pydantic.errors.UUIDError(PydanticTypeError)
pydantic.errors.UUIDVersionError(self,*,required_version:int)
pydantic.errors.UUIDVersionError.__init__(self,*,required_version:int)
pydantic.errors.UrlError(PydanticValueError)
pydantic.errors.UrlExtraError(UrlError)
pydantic.errors.UrlHostError(UrlError)
pydantic.errors.UrlHostTldError(UrlError)
pydantic.errors.UrlSchemeError(UrlError)
pydantic.errors.UrlSchemePermittedError(self,allowed_schemes:Set[str])
pydantic.errors.UrlSchemePermittedError.__init__(self,allowed_schemes:Set[str])
pydantic.errors.UrlUserInfoError(UrlError)
pydantic.errors.WrongConstantError(PydanticValueError)
pydantic.errors.WrongConstantError.__str__(self)->str
pydantic.errors._NumberBoundError(self,*,limit_value:Union[int,float,Decimal])
pydantic.errors._NumberBoundError.__init__(self,*,limit_value:Union[int,float,Decimal])
pydantic.errors._PathValueError(self,*,path:Path)
pydantic.errors._PathValueError.__init__(self,*,path:Path)


----------------------------------------/home/zhang/Packages/pydantic/pydantic1.0b2/error_wrappers.py----------------------------------------
A:pydantic.error_wrappers.self._error_cache->list(flatten_errors(self.raw_errors, config))
A:pydantic.error_wrappers.errors->self.errors()
A:pydantic.error_wrappers.no_errors->len(errors)
A:pydantic.error_wrappers.ctx->error.get('ctx')
A:pydantic.error_wrappers.error_loc->error.loc_tuple()
A:pydantic.error_wrappers.type_->get_exc_type(type(exc))
A:pydantic.error_wrappers.msg->str(exc)
A:pydantic.error_wrappers.r->_get_exc_type(cls)
pydantic.ValidationError(self,errors:Sequence[ErrorList],model:'ModelOrDc')
pydantic.ValidationError.__str__(self)->str
pydantic.ValidationError.errors(self)->List[Dict[str, Any]]
pydantic.ValidationError.json(self,*,indent:Union[None,int,str]=2)->str
pydantic.error_wrappers.ErrorWrapper(self,exc:Exception,loc:Union[str,'Loc'])
pydantic.error_wrappers.ErrorWrapper.__init__(self,exc:Exception,loc:Union[str,'Loc'])
pydantic.error_wrappers.ErrorWrapper.__repr__(self)->str
pydantic.error_wrappers.ErrorWrapper.loc_tuple(self)->'Loc'
pydantic.error_wrappers.ValidationError(self,errors:Sequence[ErrorList],model:'ModelOrDc')
pydantic.error_wrappers.ValidationError.__init__(self,errors:Sequence[ErrorList],model:'ModelOrDc')
pydantic.error_wrappers.ValidationError.__str__(self)->str
pydantic.error_wrappers.ValidationError.errors(self)->List[Dict[str, Any]]
pydantic.error_wrappers.ValidationError.json(self,*,indent:Union[None,int,str]=2)->str
pydantic.error_wrappers._display_error_loc(error:Dict[str,Any])->str
pydantic.error_wrappers._display_error_type_and_ctx(error:Dict[str,Any])->str
pydantic.error_wrappers._get_exc_type(cls:Type[Exception])->str
pydantic.error_wrappers.display_errors(errors:List[Dict[str,Any]])->str
pydantic.error_wrappers.error_dict(exc:Exception,config:Type['BaseConfig'],loc:'Loc')->Dict[str, Any]
pydantic.error_wrappers.flatten_errors(errors:Sequence[Any],config:Type['BaseConfig'],loc:Optional['Loc']=None)->Generator[Dict[str, Any], None, None]
pydantic.error_wrappers.get_exc_type(cls:Type[Exception])->str


----------------------------------------/home/zhang/Packages/pydantic/pydantic1.0b2/main.py----------------------------------------
A:pydantic.main.Model->TypeVar('Model', bound='BaseModel')
A:pydantic.main.alias->cls.alias_generator(name)
A:pydantic.main.config.extra->Extra(config.extra)
A:pydantic.main.config->inherit_config(namespace.get('Config'), config)
A:pydantic.main.validators->inherit_validators(extract_validators(namespace), validators)
A:pydantic.main.vg->ValidatorGroup(validators)
A:pydantic.main.extra_validators->ValidatorGroup(validators).get_validators(f.name)
A:pydantic.main.class_vars->set()
A:pydantic.main.annotations->resolve_annotations(namespace.get('__annotations__', {}), namespace.get('__module__', None))
A:pydantic.main.value->deepcopy(field.default)
A:pydantic.main.fields[ann_name]->fields.ModelField.infer(name=ann_name, value=value, annotation=ann_type, class_validators=vg.get_validators(ann_name), config=config)
A:pydantic.main.inferred->fields.ModelField.infer(name=var_name, value=value, annotation=annotations.get(var_name), class_validators=vg.get_validators(var_name), config=config)
A:pydantic.main.json_encoder->partial(custom_pydantic_encoder, config.json_encoders)
A:pydantic.main.(pre_rv_new, post_rv_new)->extract_root_validators(namespace)
A:pydantic.main.(values, fields_set, validation_error)->validate_model(cls, obj)
A:pydantic.main.known_field->self.fields.get(name, None)
A:pydantic.main.(value, error_)->self.fields.get(name, None).validate(value, self.dict(exclude={name}), loc=name)
A:pydantic.main.get_key->partial(get_key, self.fields)
A:pydantic.main.allowed_keys->self._calculate_keys(include=include, exclude=exclude, skip_defaults=False, update=update)
A:pydantic.main.encoder->cast(Callable[[Any], Any], encoder or self.__json_encoder__)
A:pydantic.main.data->self.dict(include=include, exclude=exclude, by_alias=by_alias, skip_defaults=skip_defaults)
A:pydantic.main.obj->cls._decompose_class(obj)
A:pydantic.main.exc->TypeError(f'{cls.__name__} expected dict not {type(obj).__name__}')
A:pydantic.main.m->self.__class__.construct(v, self.__fields_set__.copy())
A:pydantic.main.v->deepcopy(v)
A:pydantic.main.cached->cls.__schema_cache__.get(by_alias)
A:pydantic.main.s->model_schema(cls, by_alias=by_alias)
A:pydantic.main.value_as_dict->dict(value)
A:pydantic.main.keys->set(self.__dict__.keys())
A:pydantic.main.namespace['Config']->inherit_config(__config__, BaseConfig)
A:pydantic.main._missing->object()
A:pydantic.main.names_used->set()
A:pydantic.main.fields_set->set()
A:pydantic.main.input_data->validator(cls_, input_data)
A:pydantic.main.(v_, errors_)->field.validate(value, values, loc=field.alias, cls=cls_)
A:pydantic.main.values->validator(cls_, values)
pydantic.BaseConfig
pydantic.BaseConfig.get_field_info(cls,name:str)->Dict[str, Any]
pydantic.BaseConfig.prepare_field(cls,field:'ModelField')->None
pydantic.BaseModel(__pydantic_self__,**data:Any)
pydantic.BaseModel.__eq__(self,other:Any)->bool
pydantic.BaseModel.__get_validators__(cls)->'CallableGenerator'
pydantic.BaseModel.__getstate__(self)->'DictAny'
pydantic.BaseModel.__iter__(self)->'TupleGenerator'
pydantic.BaseModel.__repr__(self)->str
pydantic.BaseModel.__setattr__(self,name,value)
pydantic.BaseModel.__setstate__(self,state:'DictAny')->None
pydantic.BaseModel.__str__(self)->str
pydantic.BaseModel.__values__(self)->'DictStrAny'
pydantic.BaseModel._calculate_keys(self,include:Optional[Union['SetIntStr','DictIntStrAny']],exclude:Optional[Union['SetIntStr','DictIntStrAny']],skip_defaults:bool,update:Optional['DictStrAny']=None)->Optional['SetStr']
pydantic.BaseModel._decompose_class(cls:Type['Model'],obj:Any)->GetterDict
pydantic.BaseModel._get_key_factory(self,by_alias:bool)->Callable[..., str]
pydantic.BaseModel._get_value(cls,v:Any,to_dict:bool,by_alias:bool,include:Optional[Union['SetIntStr','DictIntStrAny']],exclude:Optional[Union['SetIntStr','DictIntStrAny']],skip_defaults:bool)->Any
pydantic.BaseModel._iter(self,to_dict:bool=False,by_alias:bool=False,allowed_keys:Optional['SetStr']=None,include:Union['SetIntStr','DictIntStrAny']=None,exclude:Union['SetIntStr','DictIntStrAny']=None,skip_defaults:bool=False)->'TupleGenerator'
pydantic.BaseModel.construct(cls:Type['Model'],values:'DictAny',fields_set:'SetStr')->'Model'
pydantic.BaseModel.copy(self:'Model',*,include:Union['SetIntStr','DictIntStrAny']=None,exclude:Union['SetIntStr','DictIntStrAny']=None,update:'DictStrAny'=None,deep:bool=False)->'Model'
pydantic.BaseModel.dict(self,*,include:Union['SetIntStr','DictIntStrAny']=None,exclude:Union['SetIntStr','DictIntStrAny']=None,by_alias:bool=False,skip_defaults:bool=False)->'DictStrAny'
pydantic.BaseModel.fields(self)->Dict[str, ModelField]
pydantic.BaseModel.from_orm(cls:Type['Model'],obj:Any)->'Model'
pydantic.BaseModel.json(self,*,include:Union['SetIntStr','DictIntStrAny']=None,exclude:Union['SetIntStr','DictIntStrAny']=None,by_alias:bool=False,skip_defaults:bool=False,encoder:Optional[Callable[[Any],Any]]=None,**dumps_kwargs:Any)->str
pydantic.BaseModel.parse_file(cls:Type['Model'],path:Union[str,Path],*,content_type:str=None,encoding:str='utf8',proto:Protocol=None,allow_pickle:bool=False)->'Model'
pydantic.BaseModel.parse_obj(cls:Type['Model'],obj:Any)->'Model'
pydantic.BaseModel.parse_raw(cls:Type['Model'],b:StrBytes,*,content_type:str=None,encoding:str='utf8',proto:Protocol=None,allow_pickle:bool=False)->'Model'
pydantic.BaseModel.schema(cls,by_alias:bool=True)->'DictStrAny'
pydantic.BaseModel.schema_json(cls,*,by_alias:bool=True,**dumps_kwargs:Any)->str
pydantic.BaseModel.to_string(self,pretty:bool=False)->str
pydantic.BaseModel.update_forward_refs(cls,**localns:Any)->None
pydantic.BaseModel.validate(cls:Type['Model'],value:Any)->'Model'
pydantic.Extra(str,Enum)
pydantic.ModelMetaclass(mcs,name,bases,namespace)
pydantic.create_model(model_name:str,*,__config__:Type[BaseConfig]=None,__base__:Type[BaseModel]=None,__module__:Optional[str]=None,__validators__:Dict[str,classmethod]=None,**field_definitions:Any)->Type[BaseModel]
pydantic.inherit_config(self_config:'ConfigType',parent_config:'ConfigType')->'ConfigType'
pydantic.is_valid_field(name:str)->bool
pydantic.main.BaseConfig
pydantic.main.BaseConfig.get_field_info(cls,name:str)->Dict[str, Any]
pydantic.main.BaseConfig.prepare_field(cls,field:'ModelField')->None
pydantic.main.BaseModel(__pydantic_self__,**data:Any)
pydantic.main.BaseModel.__eq__(self,other:Any)->bool
pydantic.main.BaseModel.__get_validators__(cls)->'CallableGenerator'
pydantic.main.BaseModel.__getstate__(self)->'DictAny'
pydantic.main.BaseModel.__init__(__pydantic_self__,**data:Any)
pydantic.main.BaseModel.__iter__(self)->'TupleGenerator'
pydantic.main.BaseModel.__repr__(self)->str
pydantic.main.BaseModel.__setattr__(self,name,value)
pydantic.main.BaseModel.__setstate__(self,state:'DictAny')->None
pydantic.main.BaseModel.__str__(self)->str
pydantic.main.BaseModel.__values__(self)->'DictStrAny'
pydantic.main.BaseModel._calculate_keys(self,include:Optional[Union['SetIntStr','DictIntStrAny']],exclude:Optional[Union['SetIntStr','DictIntStrAny']],skip_defaults:bool,update:Optional['DictStrAny']=None)->Optional['SetStr']
pydantic.main.BaseModel._decompose_class(cls:Type['Model'],obj:Any)->GetterDict
pydantic.main.BaseModel._get_key_factory(self,by_alias:bool)->Callable[..., str]
pydantic.main.BaseModel._get_value(cls,v:Any,to_dict:bool,by_alias:bool,include:Optional[Union['SetIntStr','DictIntStrAny']],exclude:Optional[Union['SetIntStr','DictIntStrAny']],skip_defaults:bool)->Any
pydantic.main.BaseModel._iter(self,to_dict:bool=False,by_alias:bool=False,allowed_keys:Optional['SetStr']=None,include:Union['SetIntStr','DictIntStrAny']=None,exclude:Union['SetIntStr','DictIntStrAny']=None,skip_defaults:bool=False)->'TupleGenerator'
pydantic.main.BaseModel.construct(cls:Type['Model'],values:'DictAny',fields_set:'SetStr')->'Model'
pydantic.main.BaseModel.copy(self:'Model',*,include:Union['SetIntStr','DictIntStrAny']=None,exclude:Union['SetIntStr','DictIntStrAny']=None,update:'DictStrAny'=None,deep:bool=False)->'Model'
pydantic.main.BaseModel.dict(self,*,include:Union['SetIntStr','DictIntStrAny']=None,exclude:Union['SetIntStr','DictIntStrAny']=None,by_alias:bool=False,skip_defaults:bool=False)->'DictStrAny'
pydantic.main.BaseModel.fields(self)->Dict[str, ModelField]
pydantic.main.BaseModel.from_orm(cls:Type['Model'],obj:Any)->'Model'
pydantic.main.BaseModel.json(self,*,include:Union['SetIntStr','DictIntStrAny']=None,exclude:Union['SetIntStr','DictIntStrAny']=None,by_alias:bool=False,skip_defaults:bool=False,encoder:Optional[Callable[[Any],Any]]=None,**dumps_kwargs:Any)->str
pydantic.main.BaseModel.parse_file(cls:Type['Model'],path:Union[str,Path],*,content_type:str=None,encoding:str='utf8',proto:Protocol=None,allow_pickle:bool=False)->'Model'
pydantic.main.BaseModel.parse_obj(cls:Type['Model'],obj:Any)->'Model'
pydantic.main.BaseModel.parse_raw(cls:Type['Model'],b:StrBytes,*,content_type:str=None,encoding:str='utf8',proto:Protocol=None,allow_pickle:bool=False)->'Model'
pydantic.main.BaseModel.schema(cls,by_alias:bool=True)->'DictStrAny'
pydantic.main.BaseModel.schema_json(cls,*,by_alias:bool=True,**dumps_kwargs:Any)->str
pydantic.main.BaseModel.to_string(self,pretty:bool=False)->str
pydantic.main.BaseModel.update_forward_refs(cls,**localns:Any)->None
pydantic.main.BaseModel.validate(cls:Type['Model'],value:Any)->'Model'
pydantic.main.Extra(str,Enum)
pydantic.main.ModelMetaclass(mcs,name,bases,namespace)
pydantic.main.ModelMetaclass.__new__(mcs,name,bases,namespace)
pydantic.main.create_model(model_name:str,*,__config__:Type[BaseConfig]=None,__base__:Type[BaseModel]=None,__module__:Optional[str]=None,__validators__:Dict[str,classmethod]=None,**field_definitions:Any)->Type[BaseModel]
pydantic.main.inherit_config(self_config:'ConfigType',parent_config:'ConfigType')->'ConfigType'
pydantic.main.is_valid_field(name:str)->bool
pydantic.main.prepare_config(config:Type[BaseConfig],cls_name:str)->None
pydantic.main.validate_custom_root_type(fields:Dict[str,ModelField])->None
pydantic.main.validate_model(model:Type[BaseModel],input_data:'DictStrAny',cls:'ModelOrDc'=None)->Tuple['DictStrAny', 'SetStr', Optional[ValidationError]]
pydantic.prepare_config(config:Type[BaseConfig],cls_name:str)->None
pydantic.validate_custom_root_type(fields:Dict[str,ModelField])->None
pydantic.validate_model(model:Type[BaseModel],input_data:'DictStrAny',cls:'ModelOrDc'=None)->Tuple['DictStrAny', 'SetStr', Optional[ValidationError]]


----------------------------------------/home/zhang/Packages/pydantic/pydantic1.0b2/typing.py----------------------------------------
A:pydantic.typing.v->type(v)
A:pydantic.typing.value->_eval_type(value, base_globals, None)
A:pydantic.typing.test_type->NewType('test_type', str)
A:pydantic.typing.field.type_->evaluate_forwardref(field.type_, globalns, localns or None)
A:pydantic.typing.origin->getattr(type_, '__origin__')
pydantic.typing._check_classvar(v:AnyType)->bool
pydantic.typing.display_as_type(v:AnyType)->str
pydantic.typing.get_class(type_:AnyType)->Union[None, bool, AnyType]
pydantic.typing.is_callable_type(type_:AnyType)->bool
pydantic.typing.is_classvar(ann_type:AnyType)->bool
pydantic.typing.is_new_type(type_:AnyType)->bool
pydantic.typing.new_type_supertype(type_:AnyType)->AnyType
pydantic.typing.resolve_annotations(raw_annotations:Dict[str,AnyType],module_name:Optional[str])->Dict[str, AnyType]
pydantic.typing.update_field_forward_refs(field:'ModelField',globalns:Any,localns:Any)->None


----------------------------------------/home/zhang/Packages/pydantic/pydantic1.0b2/networks.py----------------------------------------
A:pydantic.networks.url_regex->re.compile('(?:(?P<scheme>[a-z0-9]+?)://)?(?:(?P<user>[^\\s:]+)(?::(?P<password>\\S*))?@)?(?:(?P<ipv4>(?:\\d{1,3}\\.){3}\\d{1,3})|(?P<ipv6>\\[[A-F0-9]*:[A-F0-9:]+\\])|(?P<domain>[^\\s/:?#]+))?(?::(?P<port>\\d+))?(?P<path>/[^\\s?]*)?(?:\\?(?P<query>[^\\s#]+))?(?:#(?P<fragment>\\S+))?', re.IGNORECASE)
A:pydantic.networks.ascii_domain_regex->re.compile(f'(?:{_ascii_chunk}\\.)*?{_ascii_chunk}{_domain_ending}', re.IGNORECASE)
A:pydantic.networks.int_domain_regex->re.compile(f'(?:{_int_chunk}\\.)*?{_int_chunk}{_domain_ending}', re.IGNORECASE)
A:pydantic.networks.value->value.strip().strip()
A:pydantic.networks.m->re.compile('([\\w ]*?) *<(.*)> *').fullmatch(value)
A:pydantic.networks.parts->re.compile('([\\w ]*?) *<(.*)> *').fullmatch(value).groupdict()
A:pydantic.networks.(host, tld, host_type, rebuild)->cls.validate_host(parts)
A:pydantic.networks.d->re.compile(f'(?:{_int_chunk}\\.)*?{_int_chunk}{_domain_ending}', re.IGNORECASE).fullmatch(host)
A:pydantic.networks.host->host.encode('idna').decode('ascii').encode('idna').decode('ascii')
A:pydantic.networks.tld->re.compile(f'(?:{_int_chunk}\\.)*?{_int_chunk}{_domain_ending}', re.IGNORECASE).fullmatch(host).group('tld')
A:pydantic.networks.extra->' '.join((f'{n}={getattr(self, n)!r}' for n in self.__slots__ if getattr(self, n) is not None))
A:pydantic.networks.namespace->dict(strip_whitespace=strip_whitespace, min_length=min_length, max_length=max_length, tld_required=tld_required, allowed_schemes=allowed_schemes)
A:pydantic.networks.pretty_email_regex->re.compile('([\\w ]*?) *<(.*)> *')
A:pydantic.networks.(name, value)->re.compile('([\\w ]*?) *<(.*)> *').fullmatch(value).groups()
A:pydantic.networks.email->value.strip().strip().strip()
A:pydantic.networks.at_index->value.strip().strip().strip().index('@')
A:pydantic.networks.global_part->email[at_index:].lower()
pydantic.AnyHttpUrl(AnyUrl)
pydantic.AnyUrl(self,url:str,*,scheme:str,user:Optional[str]=None,password:Optional[str]=None,host:str,tld:Optional[str]=None,host_type:str='domain',port:Optional[str]=None,path:Optional[str]=None,query:Optional[str]=None,fragment:Optional[str]=None)
pydantic.AnyUrl.__get_validators__(cls)->'CallableGenerator'
pydantic.AnyUrl.__repr__(self)->str
pydantic.AnyUrl.build(cls,*,scheme:str,user:Optional[str]=None,password:Optional[str]=None,host:str,port:Optional[str]=None,path:Optional[str]=None,query:Optional[str]=None,fragment:Optional[str]=None,**kwargs:str)->str
pydantic.AnyUrl.validate(cls,value:Any,field:'ModelField',config:'BaseConfig')->'AnyUrl'
pydantic.AnyUrl.validate_host(cls,parts:Dict[str,str])->Tuple[str, Optional[str], str, bool]
pydantic.EmailStr(str)
pydantic.EmailStr.__get_validators__(cls)->'CallableGenerator'
pydantic.EmailStr.validate(cls,value:str)->str
pydantic.HttpUrl(AnyUrl)
pydantic.IPvAnyAddress(_BaseAddress)
pydantic.IPvAnyAddress.__get_validators__(cls)->'CallableGenerator'
pydantic.IPvAnyAddress.validate(cls,value:Union[str,bytes,int])->Union[IPv4Address, IPv6Address]
pydantic.IPvAnyInterface(_BaseAddress)
pydantic.IPvAnyInterface.__get_validators__(cls)->'CallableGenerator'
pydantic.IPvAnyInterface.validate(cls,value:NetworkType)->Union[IPv4Interface, IPv6Interface]
pydantic.IPvAnyNetwork(_BaseNetwork)
pydantic.IPvAnyNetwork.__get_validators__(cls)->'CallableGenerator'
pydantic.IPvAnyNetwork.validate(cls,value:NetworkType)->Union[IPv4Network, IPv6Network]
pydantic.NameEmail(self,name:str,email:str)
pydantic.NameEmail.__get_validators__(cls)->'CallableGenerator'
pydantic.NameEmail.__repr__(self)->str
pydantic.NameEmail.__str__(self)->str
pydantic.NameEmail.validate(cls,value:str)->'NameEmail'
pydantic.PostgresDsn(AnyUrl)
pydantic.RedisDsn(AnyUrl)
pydantic.networks.AnyHttpUrl(AnyUrl)
pydantic.networks.AnyUrl(self,url:str,*,scheme:str,user:Optional[str]=None,password:Optional[str]=None,host:str,tld:Optional[str]=None,host_type:str='domain',port:Optional[str]=None,path:Optional[str]=None,query:Optional[str]=None,fragment:Optional[str]=None)
pydantic.networks.AnyUrl.__get_validators__(cls)->'CallableGenerator'
pydantic.networks.AnyUrl.__init__(self,url:str,*,scheme:str,user:Optional[str]=None,password:Optional[str]=None,host:str,tld:Optional[str]=None,host_type:str='domain',port:Optional[str]=None,path:Optional[str]=None,query:Optional[str]=None,fragment:Optional[str]=None)
pydantic.networks.AnyUrl.__repr__(self)->str
pydantic.networks.AnyUrl.build(cls,*,scheme:str,user:Optional[str]=None,password:Optional[str]=None,host:str,port:Optional[str]=None,path:Optional[str]=None,query:Optional[str]=None,fragment:Optional[str]=None,**kwargs:str)->str
pydantic.networks.AnyUrl.validate(cls,value:Any,field:'ModelField',config:'BaseConfig')->'AnyUrl'
pydantic.networks.AnyUrl.validate_host(cls,parts:Dict[str,str])->Tuple[str, Optional[str], str, bool]
pydantic.networks.EmailStr(str)
pydantic.networks.EmailStr.__get_validators__(cls)->'CallableGenerator'
pydantic.networks.EmailStr.validate(cls,value:str)->str
pydantic.networks.HttpUrl(AnyUrl)
pydantic.networks.IPvAnyAddress(_BaseAddress)
pydantic.networks.IPvAnyAddress.__get_validators__(cls)->'CallableGenerator'
pydantic.networks.IPvAnyAddress.validate(cls,value:Union[str,bytes,int])->Union[IPv4Address, IPv6Address]
pydantic.networks.IPvAnyInterface(_BaseAddress)
pydantic.networks.IPvAnyInterface.__get_validators__(cls)->'CallableGenerator'
pydantic.networks.IPvAnyInterface.validate(cls,value:NetworkType)->Union[IPv4Interface, IPv6Interface]
pydantic.networks.IPvAnyNetwork(_BaseNetwork)
pydantic.networks.IPvAnyNetwork.__get_validators__(cls)->'CallableGenerator'
pydantic.networks.IPvAnyNetwork.validate(cls,value:NetworkType)->Union[IPv4Network, IPv6Network]
pydantic.networks.NameEmail(self,name:str,email:str)
pydantic.networks.NameEmail.__get_validators__(cls)->'CallableGenerator'
pydantic.networks.NameEmail.__init__(self,name:str,email:str)
pydantic.networks.NameEmail.__repr__(self)->str
pydantic.networks.NameEmail.__str__(self)->str
pydantic.networks.NameEmail.validate(cls,value:str)->'NameEmail'
pydantic.networks.PostgresDsn(AnyUrl)
pydantic.networks.RedisDsn(AnyUrl)
pydantic.networks.stricturl(*,strip_whitespace:bool=True,min_length:int=1,max_length:int=2**16,tld_required:bool=True,allowed_schemes:Optional[Set[str]]=None)->Type[AnyUrl]
pydantic.networks.validate_email(value:str)->Tuple[str, str]
pydantic.stricturl(*,strip_whitespace:bool=True,min_length:int=1,max_length:int=2**16,tld_required:bool=True,allowed_schemes:Optional[Set[str]]=None)->Type[AnyUrl]
pydantic.validate_email(value:str)->Tuple[str, str]


----------------------------------------/home/zhang/Packages/pydantic/pydantic1.0b2/generics.py----------------------------------------
A:pydantic.generics.GenericModelT->TypeVar('GenericModelT', bound='GenericModel')
A:pydantic.generics.cached->_generic_types_cache.get((cls, params))
A:pydantic.generics.type_hints->get_type_hints(cls).items()
A:pydantic.generics.model_name->cls.__concrete_name__(params)
A:pydantic.generics.validators->gather_all_validators(cls)
A:pydantic.generics.created_model->create_model(model_name=model_name, __module__=cls.__module__, __base__=cls, __config__=None, __validators__=validators, **fields)
A:pydantic.generics.params_component->', '.join(param_names)
A:pydantic.generics.concrete_type_args->tuple([typevars_map[x] for x in type_.__parameters__])
A:pydantic.generics.actual->len(parameters)
A:pydantic.generics.expected->len(cls.__parameters__)
pydantic.generics.GenericModel(cls,*args:Any,**kwargs:Any)
pydantic.generics.GenericModel.__class_getitem__(cls:Type[GenericModelT],params:Union[Type[Any],Tuple[Type[Any],...]])->Type[BaseModel]
pydantic.generics.GenericModel.__concrete_name__(cls:Type[Any],params:Tuple[Type[Any],...])->str
pydantic.generics.GenericModel.__new__(cls,*args:Any,**kwargs:Any)
pydantic.generics.check_parameters_count(cls:Type[GenericModel],parameters:Tuple[Any,...])->None
pydantic.generics.resolve_type_hint(type_:Any,typevars_map:Dict[Any,Any])->Type[Any]


----------------------------------------/home/zhang/Packages/pydantic/pydantic1.0b2/schema.py----------------------------------------
A:pydantic.schema.flat_models->get_flat_models_from_model(model)
A:pydantic.schema.model_name_map->get_model_name_map(flat_models)
A:pydantic.schema.(m_schema, m_definitions, m_nested_models)->model_process_schema(model, by_alias=by_alias, model_name_map=model_name_map, ref_prefix=ref_prefix)
A:pydantic.schema.(m_schema, m_definitions, nested_models)->model_type_schema(model, by_alias=by_alias, model_name_map=model_name_map, ref_prefix=ref_prefix, known_models=known_models)
A:pydantic.schema.field_info->cast(FieldInfo, field.field_info)
A:pydantic.schema.s->dict(title=field_info.title or field.alias.title().replace('_', ' '))
A:pydantic.schema.s['default']->encode_default(field.default)
A:pydantic.schema.validation_schema->get_field_schema_validations(field)
A:pydantic.schema.(f_schema, f_definitions, f_nested_models)->field_schema(f, by_alias=by_alias, model_name_map=model_name_map, ref_prefix=ref_prefix, known_models=known_models)
A:pydantic.schema.attr->getattr(field.field_info, attr_name, None)
A:pydantic.schema.model_name->get_long_model_name(model)
A:pydantic.schema.conflicting_model->name_model_map.pop(model_name)
A:pydantic.schema.fields->cast(Sequence[ModelField], model.__fields__.values())
A:pydantic.schema.key_field->cast(ModelField, field.key_field)
A:pydantic.schema.regex->getattr(key_field.type_, 'regex', None)
A:pydantic.schema.sub_fields->cast(List[ModelField], field.sub_fields)
A:pydantic.schema.(sf_schema, sf_definitions, sf_nested_models)->field_type_schema(sf, by_alias=by_alias, model_name_map=model_name_map, ref_prefix=ref_prefix, known_models=known_models)
A:pydantic.schema.doc->inspect.getdoc(model)
A:pydantic.schema.(sub_schema, sub_definitions, sub_nested_models)->model_process_schema(field_type, by_alias=by_alias, model_name_map=model_name_map, ref_prefix=ref_prefix, known_models=known_models)
A:pydantic.schema.field_type->type(literal_value)
A:pydantic.schema.values->literal_values(field_type)
A:pydantic.schema.field_value->getattr(field_type, field_name, None)
A:pydantic.schema.t->type(dft)
A:pydantic.schema.numeric_type->next((t for t in numeric_types if issubclass(annotation, t)))
A:pydantic.schema.constraint_func->cast(Callable[..., type], constraint_func)
pydantic.schema.SkipField(self,message:str)
pydantic.schema.SkipField.__init__(self,message:str)
pydantic.schema.encode_default(dft:Any)->Any
pydantic.schema.field_schema(field:ModelField,*,by_alias:bool=True,model_name_map:Dict[Type['BaseModel'],str],ref_prefix:Optional[str]=None,known_models:Set[Type['BaseModel']]=None)->Tuple[Dict[str, Any], Dict[str, Any], Set[str]]
pydantic.schema.field_singleton_schema(field:ModelField,*,by_alias:bool,model_name_map:Dict[Type['BaseModel'],str],schema_overrides:bool=False,ref_prefix:Optional[str]=None,known_models:Set[Type['BaseModel']])->Tuple[Dict[str, Any], Dict[str, Any], Set[str]]
pydantic.schema.field_singleton_sub_fields_schema(sub_fields:Sequence[ModelField],*,by_alias:bool,model_name_map:Dict[Type['BaseModel'],str],schema_overrides:bool=False,ref_prefix:Optional[str]=None,known_models:Set[Type['BaseModel']])->Tuple[Dict[str, Any], Dict[str, Any], Set[str]]
pydantic.schema.field_type_schema(field:ModelField,*,by_alias:bool,model_name_map:Dict[Type['BaseModel'],str],schema_overrides:bool=False,ref_prefix:Optional[str]=None,known_models:Set[Type['BaseModel']])->Tuple[Dict[str, Any], Dict[str, Any], Set[str]]
pydantic.schema.get_annotation_from_field_info(annotation:Any,field_info:FieldInfo)->Type[Any]
pydantic.schema.get_field_schema_validations(field:ModelField)->Dict[str, Any]
pydantic.schema.get_flat_models_from_field(field:ModelField,known_models:Set[Type['BaseModel']])->Set[Type['BaseModel']]
pydantic.schema.get_flat_models_from_fields(fields:Sequence[ModelField],known_models:Set[Type['BaseModel']])->Set[Type['BaseModel']]
pydantic.schema.get_flat_models_from_model(model:Type['BaseModel'],known_models:Set[Type['BaseModel']]=None)->Set[Type['BaseModel']]
pydantic.schema.get_flat_models_from_models(models:Sequence[Type['BaseModel']])->Set[Type['BaseModel']]
pydantic.schema.get_long_model_name(model:Type['BaseModel'])->str
pydantic.schema.get_model_name_map(unique_models:Set[Type['BaseModel']])->Dict[Type['BaseModel'], str]
pydantic.schema.model_process_schema(model:Type['BaseModel'],*,by_alias:bool=True,model_name_map:Dict[Type['BaseModel'],str],ref_prefix:Optional[str]=None,known_models:Set[Type['BaseModel']]=None)->Tuple[Dict[str, Any], Dict[str, Any], Set[str]]
pydantic.schema.model_schema(model:Type['BaseModel'],by_alias:bool=True,ref_prefix:Optional[str]=None)->Dict[str, Any]
pydantic.schema.model_type_schema(model:Type['BaseModel'],*,by_alias:bool,model_name_map:Dict[Type['BaseModel'],str],ref_prefix:Optional[str]=None,known_models:Set[Type['BaseModel']])->Tuple[Dict[str, Any], Dict[str, Any], Set[str]]
pydantic.schema.multivalue_literal_field_for_schema(values:Tuple[Any,...],field:ModelField)->ModelField
pydantic.schema.schema(models:Sequence[Type['BaseModel']],*,by_alias:bool=True,title:Optional[str]=None,description:Optional[str]=None,ref_prefix:Optional[str]=None)->Dict[str, Any]


----------------------------------------/home/zhang/Packages/pydantic/pydantic1.0b2/version.py----------------------------------------
A:pydantic.version.VERSION->StrictVersion('1.0b2')


----------------------------------------/home/zhang/Packages/pydantic/pydantic1.0b2/json.py----------------------------------------
A:pydantic.json.encoder->type_encoders.get(type(obj))
A:pydantic.json.(minutes, seconds)->divmod(td.seconds, 60)
A:pydantic.json.(hours, minutes)->divmod(minutes, 60)
pydantic.json.custom_pydantic_encoder(type_encoders:Dict[Any,Callable[[Type[Any]],Any]],obj:Any)->Any
pydantic.json.isoformat(o:Union[datetime.date,datetime.time])->str
pydantic.json.pydantic_encoder(obj:Any)->Any
pydantic.json.timedelta_isoformat(td:datetime.timedelta)->str


----------------------------------------/home/zhang/Packages/pydantic/pydantic1.0b2/__init__.py----------------------------------------


----------------------------------------/home/zhang/Packages/pydantic/pydantic1.0b2/fields.py----------------------------------------
A:pydantic.fields.NoneType->type(None)
A:pydantic.fields.self.alias->cast(str, self.field_info.alias)
A:pydantic.fields.self.title->kwargs.pop('title', None)
A:pydantic.fields.self.description->kwargs.pop('description', None)
A:pydantic.fields.self.const->kwargs.pop('const', None)
A:pydantic.fields.self.gt->kwargs.pop('gt', None)
A:pydantic.fields.self.ge->kwargs.pop('ge', None)
A:pydantic.fields.self.lt->kwargs.pop('lt', None)
A:pydantic.fields.self.le->kwargs.pop('le', None)
A:pydantic.fields.self.multiple_of->kwargs.pop('multiple_of', None)
A:pydantic.fields.self.min_items->kwargs.pop('min_items', None)
A:pydantic.fields.self.max_items->kwargs.pop('max_items', None)
A:pydantic.fields.self.min_length->kwargs.pop('min_length', None)
A:pydantic.fields.self.max_length->kwargs.pop('max_length', None)
A:pydantic.fields.self.regex->kwargs.pop('regex', None)
A:pydantic.fields.field_info_from_config->config.get_field_info(name)
A:pydantic.fields.field_info->FieldInfo(value, **field_info_from_config)
A:pydantic.fields.annotation->get_annotation_from_field_info(annotation, field_info)
A:pydantic.fields.schema_from_config->config.get_field_info(self.name)
A:pydantic.fields.self.field_info->cast(FieldInfo, self.field_info)
A:pydantic.fields.self.type_->type(self.default)
A:pydantic.fields.origin->getattr(self.type_, '__origin__', None)
A:pydantic.fields.get_validators->getattr(self.type_, '__get_validators__', None)
A:pydantic.fields.self.key_field->self._create_sub_type(self.type_.__args__[0], 'key_' + self.name, for_keys=True)
A:pydantic.fields.class_validators_->self.class_validators.values()
A:pydantic.fields.self.validators->prep_validators(v_funcs)
A:pydantic.fields.self.post_validators->prep_validators((v.func for v in class_validators_ if not v.each_item and (not v.pre)))
A:pydantic.fields.(v, errors)->self._apply_validators(v, values, loc, cls, self.post_validators)
A:pydantic.fields.e->errors_.TupleLengthError(actual_length=actual_length, expected_length=expected_length)
A:pydantic.fields.(r, ee)->field.validate(v_, values, loc=v_loc, cls=cls)
A:pydantic.fields.converted->iter(result)
A:pydantic.fields.v_iter->dict_validator(v)
A:pydantic.fields.(key_result, key_errors)->self.key_field.validate(k, values, loc=v_loc, cls=cls)
A:pydantic.fields.(value_result, value_errors)->self._validate_singleton(v_, values, v_loc, cls)
A:pydantic.fields.(value, error)->field.validate(v, values, loc=loc, cls=cls)
A:pydantic.fields.v->validator(cls, v, values, self, self.model_config)
pydantic.Field(default:Any,*,alias:str=None,title:str=None,description:str=None,const:bool=None,gt:float=None,ge:float=None,lt:float=None,le:float=None,multiple_of:float=None,min_items:int=None,max_items:int=None,min_length:int=None,max_length:int=None,regex:str=None,**extra:Any)->Any
pydantic.FieldInfo(self,default:Any,**kwargs:Any)
pydantic.FieldInfo.__repr__(self)->str
pydantic.Schema(default:Any,**kwargs:Any)->Any
pydantic.fields.Field(default:Any,*,alias:str=None,title:str=None,description:str=None,const:bool=None,gt:float=None,ge:float=None,lt:float=None,le:float=None,multiple_of:float=None,min_items:int=None,max_items:int=None,min_length:int=None,max_length:int=None,regex:str=None,**extra:Any)->Any
pydantic.fields.FieldInfo(self,default:Any,**kwargs:Any)
pydantic.fields.FieldInfo.__init__(self,default:Any,**kwargs:Any)
pydantic.fields.FieldInfo.__repr__(self)->str
pydantic.fields.ModelField(self,*,name:str,type_:AnyType,class_validators:Optional[Dict[str,Validator]],model_config:Type['BaseConfig'],default:Any=None,required:bool=True,alias:str=None,field_info:Optional[FieldInfo]=None)
pydantic.fields.ModelField.__init__(self,*,name:str,type_:AnyType,class_validators:Optional[Dict[str,Validator]],model_config:Type['BaseConfig'],default:Any=None,required:bool=True,alias:str=None,field_info:Optional[FieldInfo]=None)
pydantic.fields.ModelField.__repr__(self)->str
pydantic.fields.ModelField.__str__(self)->str
pydantic.fields.ModelField._apply_validators(self,v:Any,values:Dict[str,Any],loc:'LocStr',cls:Optional['ModelOrDc'],validators:'ValidatorsList')->'ValidateReturn'
pydantic.fields.ModelField._create_sub_type(self,type_:AnyType,name:str,*,for_keys:bool=False)->'ModelField'
pydantic.fields.ModelField._populate_validators(self)->None
pydantic.fields.ModelField._type_analysis(self)->None
pydantic.fields.ModelField._validate_mapping(self,v:Any,values:Dict[str,Any],loc:'LocStr',cls:Optional['ModelOrDc'])->'ValidateReturn'
pydantic.fields.ModelField._validate_sequence_like(self,v:Any,values:Dict[str,Any],loc:'LocStr',cls:Optional['ModelOrDc'])->'ValidateReturn'
pydantic.fields.ModelField._validate_singleton(self,v:Any,values:Dict[str,Any],loc:'LocStr',cls:Optional['ModelOrDc'])->'ValidateReturn'
pydantic.fields.ModelField._validate_tuple(self,v:Any,values:Dict[str,Any],loc:'LocStr',cls:Optional['ModelOrDc'])->'ValidateReturn'
pydantic.fields.ModelField.alt_alias(self)->bool
pydantic.fields.ModelField.include_in_schema(self)->bool
pydantic.fields.ModelField.infer(cls,*,name:str,value:Any,annotation:Any,class_validators:Optional[Dict[str,Validator]],config:Type['BaseConfig'])->'ModelField'
pydantic.fields.ModelField.is_complex(self)->bool
pydantic.fields.ModelField.prepare(self)->None
pydantic.fields.ModelField.set_config(self,config:Type['BaseConfig'])->None
pydantic.fields.ModelField.validate(self,v:Any,values:Dict[str,Any],*,loc:'LocStr',cls:Optional['ModelOrDc']=None)->'ValidateReturn'
pydantic.fields.Schema(default:Any,**kwargs:Any)->Any

