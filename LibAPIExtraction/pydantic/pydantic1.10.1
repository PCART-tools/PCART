
----------------------------------------/home/zhang/Packages/pydantic/pydantic1.10.1/types.py----------------------------------------
A:pydantic.types.T->TypeVar('T')
A:pydantic.types.new_cls->cast('ConstrainedInt', type.__new__(cls, name, bases, dct))
A:pydantic.types.namespace->dict(gt=gt, ge=ge, lt=lt, le=le)
A:pydantic.types.v->list_validator(v)
A:pydantic.types.v_len->len(v)
A:pydantic.types.value->bytes_validator(value)
A:pydantic.types.digitsdecimals->abs(exponent)
A:pydantic.types.digits->len(digit_tuple)
A:pydantic.types.decimals->abs(exponent)
A:pydantic.types.self.brand->self._get_brand(card_number)
A:pydantic.types.sum_->int(card_number[-1])
A:pydantic.types.length->len(card_number)
A:pydantic.types.digit->int(card_number[i])
A:pydantic.types.byte_string_re->re.compile('^\\s*(\\d*\\.?\\d+)\\s*(\\w+)?', re.IGNORECASE)
A:pydantic.types.str_match->re.compile('^\\s*(\\d*\\.?\\d+)\\s*(\\w+)?', re.IGNORECASE).match(str(v))
A:pydantic.types.(scalar, unit)->re.compile('^\\s*(\\d*\\.?\\d+)\\s*(\\w+)?', re.IGNORECASE).match(str(v)).groups()
A:pydantic.types.num->float(self)
pydantic.ByteSize(int)
pydantic.ByteSize.__get_validators__(cls)->'CallableGenerator'
pydantic.ByteSize.human_readable(self,decimal:bool=False)->str
pydantic.ByteSize.to(self,unit:str)->float
pydantic.ByteSize.validate(cls,v:StrIntFloat)->'ByteSize'
pydantic.ConstrainedBytes(bytes)
pydantic.ConstrainedBytes.__get_validators__(cls)->'CallableGenerator'
pydantic.ConstrainedBytes.__modify_schema__(cls,field_schema:Dict[str,Any])->None
pydantic.ConstrainedDate(date,metaclass=ConstrainedNumberMeta)
pydantic.ConstrainedDate.__get_validators__(cls)->'CallableGenerator'
pydantic.ConstrainedDate.__modify_schema__(cls,field_schema:Dict[str,Any])->None
pydantic.ConstrainedDecimal(Decimal,metaclass=ConstrainedNumberMeta)
pydantic.ConstrainedDecimal.__get_validators__(cls)->'CallableGenerator'
pydantic.ConstrainedDecimal.__modify_schema__(cls,field_schema:Dict[str,Any])->None
pydantic.ConstrainedDecimal.validate(cls,value:Decimal)->Decimal
pydantic.ConstrainedFloat(float,metaclass=ConstrainedNumberMeta)
pydantic.ConstrainedFloat.__get_validators__(cls)->'CallableGenerator'
pydantic.ConstrainedFloat.__modify_schema__(cls,field_schema:Dict[str,Any])->None
pydantic.ConstrainedFrozenSet(frozenset)
pydantic.ConstrainedFrozenSet.__get_validators__(cls)->'CallableGenerator'
pydantic.ConstrainedFrozenSet.__modify_schema__(cls,field_schema:Dict[str,Any])->None
pydantic.ConstrainedFrozenSet.frozenset_length_validator(cls,v:'Optional[FrozenSet[T]]')->'Optional[FrozenSet[T]]'
pydantic.ConstrainedInt(int,metaclass=ConstrainedNumberMeta)
pydantic.ConstrainedInt.__get_validators__(cls)->'CallableGenerator'
pydantic.ConstrainedInt.__modify_schema__(cls,field_schema:Dict[str,Any])->None
pydantic.ConstrainedList(list)
pydantic.ConstrainedList.__get_validators__(cls)->'CallableGenerator'
pydantic.ConstrainedList.__modify_schema__(cls,field_schema:Dict[str,Any])->None
pydantic.ConstrainedList.list_length_validator(cls,v:'Optional[List[T]]')->'Optional[List[T]]'
pydantic.ConstrainedList.unique_items_validator(cls,v:'List[T]')->'List[T]'
pydantic.ConstrainedNumberMeta(cls,name:str,bases:Any,dct:Dict[str,Any])
pydantic.ConstrainedSet(set)
pydantic.ConstrainedSet.__get_validators__(cls)->'CallableGenerator'
pydantic.ConstrainedSet.__modify_schema__(cls,field_schema:Dict[str,Any])->None
pydantic.ConstrainedSet.set_length_validator(cls,v:'Optional[Set[T]]')->'Optional[Set[T]]'
pydantic.ConstrainedStr(str)
pydantic.ConstrainedStr.__get_validators__(cls)->'CallableGenerator'
pydantic.ConstrainedStr.__modify_schema__(cls,field_schema:Dict[str,Any])->None
pydantic.ConstrainedStr.validate(cls,value:Union[str])->Union[str]
pydantic.JsonMeta(type)
pydantic.JsonMeta.__getitem__(self,t:Type[Any])->Type[JsonWrapper]
pydantic.JsonWrapper
pydantic.PaymentCardBrand(str,Enum)
pydantic.PaymentCardBrand.__str__(self)->str
pydantic.PaymentCardNumber(self,card_number:str)
pydantic.PaymentCardNumber.__get_validators__(cls)->'CallableGenerator'
pydantic.PaymentCardNumber._get_brand(card_number:str)->PaymentCardBrand
pydantic.PaymentCardNumber.masked(self)->str
pydantic.PaymentCardNumber.validate_digits(cls,card_number:str)->str
pydantic.PaymentCardNumber.validate_length_for_brand(cls,card_number:'PaymentCardNumber')->'PaymentCardNumber'
pydantic.PaymentCardNumber.validate_luhn_check_digit(cls,card_number:str)->str
pydantic.SecretBytes(self,value:bytes)
pydantic.SecretBytes.__get_validators__(cls)->'CallableGenerator'
pydantic.SecretBytes.__len__(self)->int
pydantic.SecretBytes.__modify_schema__(cls,field_schema:Dict[str,Any])->None
pydantic.SecretBytes.__repr__(self)->str
pydantic.SecretBytes.display(self)->str
pydantic.SecretBytes.get_secret_value(self)->bytes
pydantic.SecretBytes.validate(cls,value:Any)->'SecretBytes'
pydantic.SecretField(abc.ABC)
pydantic.SecretField.__eq__(self,other:Any)->bool
pydantic.SecretField.__hash__(self)->int
pydantic.SecretField.__str__(self)->str
pydantic.SecretField.get_secret_value(self)->Any
pydantic.SecretStr(self,value:str)
pydantic.SecretStr.__get_validators__(cls)->'CallableGenerator'
pydantic.SecretStr.__len__(self)->int
pydantic.SecretStr.__modify_schema__(cls,field_schema:Dict[str,Any])->None
pydantic.SecretStr.__repr__(self)->str
pydantic.SecretStr.display(self)->str
pydantic.SecretStr.get_secret_value(self)->str
pydantic.SecretStr.validate(cls,value:Any)->'SecretStr'
pydantic._registered(typ:'ConstrainedNumberMeta')->'ConstrainedNumberMeta'
pydantic._registered(typ:Type[T])->Type[T]
pydantic._registered(typ:Union[Type[T],'ConstrainedNumberMeta'])->Union[Type[T], 'ConstrainedNumberMeta']
pydantic.conbytes(*,strip_whitespace:bool=False,to_upper:bool=False,to_lower:bool=False,min_length:int=None,max_length:int=None,strict:bool=False)->Type[bytes]
pydantic.condate(*,gt:date=None,ge:date=None,lt:date=None,le:date=None)->Type[date]
pydantic.condecimal(*,gt:Decimal=None,ge:Decimal=None,lt:Decimal=None,le:Decimal=None,max_digits:int=None,decimal_places:int=None,multiple_of:Decimal=None)->Type[Decimal]
pydantic.confloat(*,strict:bool=False,gt:float=None,ge:float=None,lt:float=None,le:float=None,multiple_of:float=None,allow_inf_nan:Optional[bool]=None)->Type[float]
pydantic.confrozenset(item_type:Type[T],*,min_items:int=None,max_items:int=None)->Type[FrozenSet[T]]
pydantic.conint(*,strict:bool=False,gt:int=None,ge:int=None,lt:int=None,le:int=None,multiple_of:int=None)->Type[int]
pydantic.conlist(item_type:Type[T],*,min_items:int=None,max_items:int=None,unique_items:bool=None)->Type[List[T]]
pydantic.conset(item_type:Type[T],*,min_items:int=None,max_items:int=None)->Type[Set[T]]
pydantic.constr(*,strip_whitespace:bool=False,to_upper:bool=False,to_lower:bool=False,strict:bool=False,min_length:int=None,max_length:int=None,curtail_length:int=None,regex:str=None)->Type[str]
pydantic.types.ByteSize(int)
pydantic.types.ByteSize.__get_validators__(cls)->'CallableGenerator'
pydantic.types.ByteSize.human_readable(self,decimal:bool=False)->str
pydantic.types.ByteSize.to(self,unit:str)->float
pydantic.types.ByteSize.validate(cls,v:StrIntFloat)->'ByteSize'
pydantic.types.ConstrainedBytes(bytes)
pydantic.types.ConstrainedBytes.__get_validators__(cls)->'CallableGenerator'
pydantic.types.ConstrainedBytes.__modify_schema__(cls,field_schema:Dict[str,Any])->None
pydantic.types.ConstrainedDate(date,metaclass=ConstrainedNumberMeta)
pydantic.types.ConstrainedDate.__get_validators__(cls)->'CallableGenerator'
pydantic.types.ConstrainedDate.__modify_schema__(cls,field_schema:Dict[str,Any])->None
pydantic.types.ConstrainedDecimal(Decimal,metaclass=ConstrainedNumberMeta)
pydantic.types.ConstrainedDecimal.__get_validators__(cls)->'CallableGenerator'
pydantic.types.ConstrainedDecimal.__modify_schema__(cls,field_schema:Dict[str,Any])->None
pydantic.types.ConstrainedDecimal.validate(cls,value:Decimal)->Decimal
pydantic.types.ConstrainedFloat(float,metaclass=ConstrainedNumberMeta)
pydantic.types.ConstrainedFloat.__get_validators__(cls)->'CallableGenerator'
pydantic.types.ConstrainedFloat.__modify_schema__(cls,field_schema:Dict[str,Any])->None
pydantic.types.ConstrainedFrozenSet(frozenset)
pydantic.types.ConstrainedFrozenSet.__get_validators__(cls)->'CallableGenerator'
pydantic.types.ConstrainedFrozenSet.__modify_schema__(cls,field_schema:Dict[str,Any])->None
pydantic.types.ConstrainedFrozenSet.frozenset_length_validator(cls,v:'Optional[FrozenSet[T]]')->'Optional[FrozenSet[T]]'
pydantic.types.ConstrainedInt(int,metaclass=ConstrainedNumberMeta)
pydantic.types.ConstrainedInt.__get_validators__(cls)->'CallableGenerator'
pydantic.types.ConstrainedInt.__modify_schema__(cls,field_schema:Dict[str,Any])->None
pydantic.types.ConstrainedList(list)
pydantic.types.ConstrainedList.__get_validators__(cls)->'CallableGenerator'
pydantic.types.ConstrainedList.__modify_schema__(cls,field_schema:Dict[str,Any])->None
pydantic.types.ConstrainedList.list_length_validator(cls,v:'Optional[List[T]]')->'Optional[List[T]]'
pydantic.types.ConstrainedList.unique_items_validator(cls,v:'List[T]')->'List[T]'
pydantic.types.ConstrainedNumberMeta(cls,name:str,bases:Any,dct:Dict[str,Any])
pydantic.types.ConstrainedSet(set)
pydantic.types.ConstrainedSet.__get_validators__(cls)->'CallableGenerator'
pydantic.types.ConstrainedSet.__modify_schema__(cls,field_schema:Dict[str,Any])->None
pydantic.types.ConstrainedSet.set_length_validator(cls,v:'Optional[Set[T]]')->'Optional[Set[T]]'
pydantic.types.ConstrainedStr(str)
pydantic.types.ConstrainedStr.__get_validators__(cls)->'CallableGenerator'
pydantic.types.ConstrainedStr.__modify_schema__(cls,field_schema:Dict[str,Any])->None
pydantic.types.ConstrainedStr.validate(cls,value:Union[str])->Union[str]
pydantic.types.JsonMeta(type)
pydantic.types.JsonMeta.__getitem__(self,t:Type[Any])->Type[JsonWrapper]
pydantic.types.JsonWrapper
pydantic.types.PaymentCardBrand(str,Enum)
pydantic.types.PaymentCardBrand.__str__(self)->str
pydantic.types.PaymentCardNumber(self,card_number:str)
pydantic.types.PaymentCardNumber.__get_validators__(cls)->'CallableGenerator'
pydantic.types.PaymentCardNumber._get_brand(card_number:str)->PaymentCardBrand
pydantic.types.PaymentCardNumber.masked(self)->str
pydantic.types.PaymentCardNumber.validate_digits(cls,card_number:str)->str
pydantic.types.PaymentCardNumber.validate_length_for_brand(cls,card_number:'PaymentCardNumber')->'PaymentCardNumber'
pydantic.types.PaymentCardNumber.validate_luhn_check_digit(cls,card_number:str)->str
pydantic.types.SecretBytes(self,value:bytes)
pydantic.types.SecretBytes.__get_validators__(cls)->'CallableGenerator'
pydantic.types.SecretBytes.__len__(self)->int
pydantic.types.SecretBytes.__modify_schema__(cls,field_schema:Dict[str,Any])->None
pydantic.types.SecretBytes.__repr__(self)->str
pydantic.types.SecretBytes.display(self)->str
pydantic.types.SecretBytes.get_secret_value(self)->bytes
pydantic.types.SecretBytes.validate(cls,value:Any)->'SecretBytes'
pydantic.types.SecretField(abc.ABC)
pydantic.types.SecretField.__eq__(self,other:Any)->bool
pydantic.types.SecretField.__hash__(self)->int
pydantic.types.SecretField.__str__(self)->str
pydantic.types.SecretField.get_secret_value(self)->Any
pydantic.types.SecretStr(self,value:str)
pydantic.types.SecretStr.__get_validators__(cls)->'CallableGenerator'
pydantic.types.SecretStr.__len__(self)->int
pydantic.types.SecretStr.__modify_schema__(cls,field_schema:Dict[str,Any])->None
pydantic.types.SecretStr.__repr__(self)->str
pydantic.types.SecretStr.display(self)->str
pydantic.types.SecretStr.get_secret_value(self)->str
pydantic.types.SecretStr.validate(cls,value:Any)->'SecretStr'
pydantic.types._registered(typ:'ConstrainedNumberMeta')->'ConstrainedNumberMeta'
pydantic.types._registered(typ:Type[T])->Type[T]
pydantic.types._registered(typ:Union[Type[T],'ConstrainedNumberMeta'])->Union[Type[T], 'ConstrainedNumberMeta']
pydantic.types.conbytes(*,strip_whitespace:bool=False,to_upper:bool=False,to_lower:bool=False,min_length:int=None,max_length:int=None,strict:bool=False)->Type[bytes]
pydantic.types.condate(*,gt:date=None,ge:date=None,lt:date=None,le:date=None)->Type[date]
pydantic.types.condecimal(*,gt:Decimal=None,ge:Decimal=None,lt:Decimal=None,le:Decimal=None,max_digits:int=None,decimal_places:int=None,multiple_of:Decimal=None)->Type[Decimal]
pydantic.types.confloat(*,strict:bool=False,gt:float=None,ge:float=None,lt:float=None,le:float=None,multiple_of:float=None,allow_inf_nan:Optional[bool]=None)->Type[float]
pydantic.types.confrozenset(item_type:Type[T],*,min_items:int=None,max_items:int=None)->Type[FrozenSet[T]]
pydantic.types.conint(*,strict:bool=False,gt:int=None,ge:int=None,lt:int=None,le:int=None,multiple_of:int=None)->Type[int]
pydantic.types.conlist(item_type:Type[T],*,min_items:int=None,max_items:int=None,unique_items:bool=None)->Type[List[T]]
pydantic.types.conset(item_type:Type[T],*,min_items:int=None,max_items:int=None)->Type[Set[T]]
pydantic.types.constr(*,strip_whitespace:bool=False,to_upper:bool=False,to_lower:bool=False,strict:bool=False,min_length:int=None,max_length:int=None,curtail_length:int=None,regex:str=None)->Type[str]


----------------------------------------/home/zhang/Packages/pydantic/pydantic1.10.1/color.py----------------------------------------
A:pydantic.color.self._rgba->parse_str(value)
A:pydantic.color.rgb->cast(Tuple[int, int, int], self.as_rgb_tuple())
A:pydantic.color.as_hex->''.join((as_hex[c] for c in range(0, len(as_hex), 2)))
A:pydantic.color.(h, s, li)->self.as_hsl_tuple(alpha=False)
A:pydantic.color.(h, s, li, a)->self.as_hsl_tuple(alpha=True)
A:pydantic.color.(h, l, s)->rgb_to_hls(self._rgba.r, self._rgba.g, self._rgba.b)
A:pydantic.color.value_lower->value.lower()
A:pydantic.color.m->re.fullmatch(r_hsla, value_lower)
A:pydantic.color.(*rgb, a)->re.fullmatch(r_hsla, value_lower).groups()
A:pydantic.color.(h, h_units, s, l_)->re.fullmatch(r_hsla, value_lower).groups()
A:pydantic.color.(h, h_units, s, l_, a)->re.fullmatch(r_hsla, value_lower).groups()
A:pydantic.color.color->float(value)
A:pydantic.color.alpha->float(value)
A:pydantic.color.h_value->float(h)
A:pydantic.color.(r, g, b)->hls_to_rgb(h_value, l_value, s_value)
pydantic.color.Color(self,value:ColorType)
pydantic.color.Color.__eq__(self,other:Any)->bool
pydantic.color.Color.__get_validators__(cls)->'CallableGenerator'
pydantic.color.Color.__hash__(self)->int
pydantic.color.Color.__modify_schema__(cls,field_schema:Dict[str,Any])->None
pydantic.color.Color.__repr_args__(self)->'ReprArgs'
pydantic.color.Color.__str__(self)->str
pydantic.color.Color._alpha_float(self)->float
pydantic.color.Color.as_hex(self)->str
pydantic.color.Color.as_hsl(self)->str
pydantic.color.Color.as_hsl_tuple(self,*,alpha:Optional[bool]=None)->HslColorTuple
pydantic.color.Color.as_named(self,*,fallback:bool=False)->str
pydantic.color.Color.as_rgb(self)->str
pydantic.color.Color.as_rgb_tuple(self,*,alpha:Optional[bool]=None)->ColorTuple
pydantic.color.Color.original(self)->ColorType
pydantic.color.RGBA(self,r:float,g:float,b:float,alpha:Optional[float])
pydantic.color.RGBA.__getitem__(self,item:Any)->Any
pydantic.color.float_to_255(c:float)->int
pydantic.color.ints_to_rgba(r:Union[int,str],g:Union[int,str],b:Union[int,str],alpha:Optional[float])->RGBA
pydantic.color.parse_color_value(value:Union[int,str],max_val:int=255)->float
pydantic.color.parse_float_alpha(value:Union[None,str,float,int])->Optional[float]
pydantic.color.parse_hsl(h:str,h_units:str,sat:str,light:str,alpha:Optional[float]=None)->RGBA
pydantic.color.parse_str(value:str)->RGBA
pydantic.color.parse_tuple(value:Tuple[Any,...])->RGBA


----------------------------------------/home/zhang/Packages/pydantic/pydantic1.10.1/annotated_types.py----------------------------------------
pydantic.annotated_types.create_model_from_namedtuple(namedtuple_cls:Type['NamedTuple'],**kwargs:Any)->Type['BaseModel']
pydantic.annotated_types.create_model_from_typeddict(typeddict_cls:Type['TypedDict'],**kwargs:Any)->Type['BaseModel']
pydantic.create_model_from_namedtuple(namedtuple_cls:Type['NamedTuple'],**kwargs:Any)->Type['BaseModel']
pydantic.create_model_from_typeddict(typeddict_cls:Type['TypedDict'],**kwargs:Any)->Type['BaseModel']


----------------------------------------/home/zhang/Packages/pydantic/pydantic1.10.1/dataclasses.py----------------------------------------
A:pydantic.dataclasses.DataclassT->TypeVar('DataclassT', bound='Dataclass')
A:pydantic.dataclasses._T->TypeVar('_T')
A:pydantic.dataclasses.the_config->get_config(config)
A:pydantic.dataclasses.dc_cls->dataclasses.dataclass(cls, init=init, repr=repr, eq=eq, order=order, unsafe_hash=unsafe_hash, frozen=frozen)
A:pydantic.dataclasses.initvars_and_values[f.name]->kwargs.get(f.name, f.default)
A:pydantic.dataclasses.field_info->Field(default=default, default_factory=default_factory, **field.metadata)
A:pydantic.dataclasses.validators->gather_all_validators(dc_cls)
A:pydantic.dataclasses.(d, _, validation_error)->validate_model(self.__pydantic_model__, input_data, cls=self.__class__)
A:pydantic.dataclasses.d->dict(self.__dict__)
A:pydantic.dataclasses.known_field->self.__pydantic_model__.__fields__.get(name, None)
A:pydantic.dataclasses.(value, error_)->self.__pydantic_model__.__fields__.get(name, None).validate(value, d, loc=name, cls=self.__class__)
pydantic.dataclasses.DataclassProxy(self,dc_cls:Type['Dataclass'])
pydantic.dataclasses.DataclassProxy.__getattr__(self,name:str)->Any
pydantic.dataclasses.DataclassProxy.__instancecheck__(self,instance:Any)->bool
pydantic.dataclasses._add_pydantic_validation_attributes(dc_cls:Type['Dataclass'],config:Type[BaseConfig],validate_on_init:bool,dc_cls_doc:str)->None
pydantic.dataclasses._dataclass_validate_assignment_setattr(self:'Dataclass',name:str,value:Any)->None
pydantic.dataclasses._dataclass_validate_values(self:'Dataclass')->None
pydantic.dataclasses._get_validators(cls:'DataclassClassOrWrapper')->'CallableGenerator'
pydantic.dataclasses._validate_dataclass(cls:Type['DataclassT'],v:Any)->'DataclassT'
pydantic.dataclasses.create_pydantic_model_from_dataclass(dc_cls:Type['Dataclass'],config:Type[Any]=BaseConfig,dc_cls_doc:Optional[str]=None)->Type['BaseModel']
pydantic.dataclasses.dataclass(_cls:Optional[Type[_T]]=None,*,init:bool=True,repr:bool=True,eq:bool=True,order:bool=False,unsafe_hash:bool=False,frozen:bool=False,config:Union[ConfigDict,Type[object],None]=None,validate_on_init:Optional[bool]=None,kw_only:bool=False)->Union[Callable[[Type[_T]], 'DataclassClassOrWrapper'], 'DataclassClassOrWrapper']
pydantic.dataclasses.is_builtin_dataclass(_cls:Type[Any])->bool
pydantic.dataclasses.make_dataclass_validator(dc_cls:Type['Dataclass'],config:Type[BaseConfig])->'CallableGenerator'
pydantic.dataclasses.set_validation(cls:Type['DataclassT'],value:bool)->Generator[Type['DataclassT'], None, None]


----------------------------------------/home/zhang/Packages/pydantic/pydantic1.10.1/class_validators.py----------------------------------------
A:pydantic.class_validators.f_cls->_prepare_validator(f, allow_reuse)
A:pydantic.class_validators.validators->self.validators.get(name, [])
A:pydantic.class_validators.unused_validators->set(chain.from_iterable(((v.func.__name__ for v in self.validators[f] if v.check_fields) for f in self.validators.keys() - self.used_validators)))
A:pydantic.class_validators.fn->', '.join(unused_validators)
A:pydantic.class_validators.validator_config->getattr(value, VALIDATOR_CONFIG_KEY, None)
A:pydantic.class_validators.sig->signature(validator)
A:pydantic.class_validators.args->list(sig.parameters.keys())
A:pydantic.class_validators.first_arg->list(sig.parameters.keys()).pop(0)
A:pydantic.class_validators.all_attributes->ChainMap(*[cls.__dict__ for cls in type_.__mro__])
pydantic.class_validators.Validator(self,func:AnyCallable,pre:bool=False,each_item:bool=False,always:bool=False,check_fields:bool=False,skip_on_failure:bool=False)
pydantic.class_validators.ValidatorGroup(self,validators:'ValidatorListDict')
pydantic.class_validators.ValidatorGroup.check_for_unused(self)->None
pydantic.class_validators.ValidatorGroup.get_validators(self,name:str)->Optional[Dict[str, Validator]]
pydantic.class_validators._generic_validator_basic(validator:AnyCallable,sig:'Signature',args:Set[str])->'ValidatorCallable'
pydantic.class_validators._generic_validator_cls(validator:AnyCallable,sig:'Signature',args:Set[str])->'ValidatorCallable'
pydantic.class_validators._prepare_validator(function:AnyCallable,allow_reuse:bool)->'AnyClassMethod'
pydantic.class_validators.extract_root_validators(namespace:Dict[str,Any])->Tuple[List[AnyCallable], List[Tuple[bool, AnyCallable]]]
pydantic.class_validators.extract_validators(namespace:Dict[str,Any])->Dict[str, List[Validator]]
pydantic.class_validators.gather_all_validators(type_:'ModelOrDc')->Dict[str, 'AnyClassMethod']
pydantic.class_validators.inherit_validators(base_validators:'ValidatorListDict',validators:'ValidatorListDict')->'ValidatorListDict'
pydantic.class_validators.make_generic_validator(validator:AnyCallable)->'ValidatorCallable'
pydantic.class_validators.prep_validators(v_funcs:Iterable[AnyCallable])->'ValidatorsList'
pydantic.class_validators.root_validator(*,pre:bool=False,allow_reuse:bool=False,skip_on_failure:bool=False)->Callable[[AnyCallable], 'AnyClassMethod']
pydantic.class_validators.root_validator(_func:AnyCallable)->'AnyClassMethod'
pydantic.class_validators.root_validator(_func:Optional[AnyCallable]=None,*,pre:bool=False,allow_reuse:bool=False,skip_on_failure:bool=False)->Union['AnyClassMethod', Callable[[AnyCallable], 'AnyClassMethod']]
pydantic.class_validators.validator(*fields:str,pre:bool=False,each_item:bool=False,always:bool=False,check_fields:bool=True,whole:bool=None,allow_reuse:bool=False)->Callable[[AnyCallable], 'AnyClassMethod']
pydantic.root_validator(*,pre:bool=False,allow_reuse:bool=False,skip_on_failure:bool=False)->Callable[[AnyCallable], 'AnyClassMethod']
pydantic.root_validator(_func:AnyCallable)->'AnyClassMethod'
pydantic.root_validator(_func:Optional[AnyCallable]=None,*,pre:bool=False,allow_reuse:bool=False,skip_on_failure:bool=False)->Union['AnyClassMethod', Callable[[AnyCallable], 'AnyClassMethod']]
pydantic.validator(*fields:str,pre:bool=False,each_item:bool=False,always:bool=False,check_fields:bool=True,whole:bool=None,allow_reuse:bool=False)->Callable[[AnyCallable], 'AnyClassMethod']


----------------------------------------/home/zhang/Packages/pydantic/pydantic1.10.1/validators.py----------------------------------------
A:pydantic.validators.v->v.lower().lower()
A:pydantic.validators.allow_inf_nan->getattr(field.type_, 'allow_inf_nan', None)
A:pydantic.validators.v_len->len(v)
A:pydantic.validators.enum_v->field.type_(v)
A:pydantic.validators.required_version->getattr(field.type_, '_required_version', None)
A:pydantic.validators.permitted_choices->all_literal_values(type_)
A:pydantic.validators.T->TypeVar('T')
A:pydantic.validators.str_value->str_validator(v)
A:pydantic.validators.NamedTupleT->TypeVar('NamedTupleT', bound=NamedTuple)
A:pydantic.validators.NamedTupleModel->create_model_from_namedtuple(namedtuple_cls, __config__=config, __module__=namedtuple_cls.__module__)
A:pydantic.validators.TypedDictModel->create_model_from_typeddict(typeddict_cls, __config__=config, __module__=typeddict_cls.__module__)
A:pydantic.validators.class_->get_class(type_)
pydantic.validators.IfConfig(self,validator:AnyCallable,*config_attr_names:str,ignored_value:Any=False)
pydantic.validators.IfConfig.check(self,config:Type['BaseConfig'])->bool
pydantic.validators.any_class_validator(v:Any)->Type[T]
pydantic.validators.anystr_length_validator(v:'StrBytes',config:'BaseConfig')->'StrBytes'
pydantic.validators.anystr_lower(v:'StrBytes')->'StrBytes'
pydantic.validators.anystr_strip_whitespace(v:'StrBytes')->'StrBytes'
pydantic.validators.anystr_upper(v:'StrBytes')->'StrBytes'
pydantic.validators.bool_validator(v:Any)->bool
pydantic.validators.bytes_validator(v:Any)->Union[bytes]
pydantic.validators.callable_validator(v:Any)->AnyCallable
pydantic.validators.constant_validator(v:'Any',field:'ModelField')->'Any'
pydantic.validators.constr_length_validator(v:'StrBytes',field:'ModelField',config:'BaseConfig')->'StrBytes'
pydantic.validators.constr_lower(v:'StrBytes',field:'ModelField',config:'BaseConfig')->'StrBytes'
pydantic.validators.constr_strip_whitespace(v:'StrBytes',field:'ModelField',config:'BaseConfig')->'StrBytes'
pydantic.validators.constr_upper(v:'StrBytes',field:'ModelField',config:'BaseConfig')->'StrBytes'
pydantic.validators.decimal_validator(v:Any)->Decimal
pydantic.validators.deque_validator(v:Any)->Deque[Any]
pydantic.validators.dict_validator(v:Any)->Dict[Any, Any]
pydantic.validators.enum_member_validator(v:Any,field:'ModelField',config:'BaseConfig')->Enum
pydantic.validators.enum_validator(v:Any)->Enum
pydantic.validators.find_validators(type_:Type[Any],config:Type['BaseConfig'])->Generator[AnyCallable, None, None]
pydantic.validators.float_finite_validator(v:'Number',field:'ModelField',config:'BaseConfig')->'Number'
pydantic.validators.float_validator(v:Any)->float
pydantic.validators.frozenset_validator(v:Any)->FrozenSet[Any]
pydantic.validators.hashable_validator(v:Any)->Hashable
pydantic.validators.int_enum_validator(v:Any)->IntEnum
pydantic.validators.int_validator(v:Any)->int
pydantic.validators.ip_v4_address_validator(v:Any)->IPv4Address
pydantic.validators.ip_v4_interface_validator(v:Any)->IPv4Interface
pydantic.validators.ip_v4_network_validator(v:Any)->IPv4Network
pydantic.validators.ip_v6_address_validator(v:Any)->IPv6Address
pydantic.validators.ip_v6_interface_validator(v:Any)->IPv6Interface
pydantic.validators.ip_v6_network_validator(v:Any)->IPv6Network
pydantic.validators.list_validator(v:Any)->List[Any]
pydantic.validators.make_arbitrary_type_validator(type_:Type[T])->Callable[[T], T]
pydantic.validators.make_class_validator(type_:Type[T])->Callable[[Any], Type[T]]
pydantic.validators.make_literal_validator(type_:Any)->Callable[[Any], Any]
pydantic.validators.make_namedtuple_validator(namedtuple_cls:Type[NamedTupleT],config:Type['BaseConfig'])->Callable[[Tuple[Any, ...]], NamedTupleT]
pydantic.validators.make_typeddict_validator(typeddict_cls:Type['TypedDict'],config:Type['BaseConfig'])->Callable[[Any], Dict[str, Any]]
pydantic.validators.none_validator(v:Any)->'Literal[None]'
pydantic.validators.number_multiple_validator(v:'Number',field:'ModelField')->'Number'
pydantic.validators.number_size_validator(v:'Number',field:'ModelField')->'Number'
pydantic.validators.ordered_dict_validator(v:Any)->'AnyOrderedDict'
pydantic.validators.path_exists_validator(v:Any)->Path
pydantic.validators.path_validator(v:Any)->Path
pydantic.validators.pattern_validator(v:Any)->Pattern[str]
pydantic.validators.set_validator(v:Any)->Set[Any]
pydantic.validators.str_validator(v:Any)->Union[str]
pydantic.validators.strict_bytes_validator(v:Any)->Union[bytes]
pydantic.validators.strict_float_validator(v:Any)->float
pydantic.validators.strict_int_validator(v:Any)->int
pydantic.validators.strict_str_validator(v:Any)->Union[str]
pydantic.validators.tuple_validator(v:Any)->Tuple[Any, ...]
pydantic.validators.uuid_validator(v:Any,field:'ModelField')->UUID
pydantic.validators.validate_json(v:Any,config:'BaseConfig')->Any


----------------------------------------/home/zhang/Packages/pydantic/pydantic1.10.1/utils.py----------------------------------------
A:pydantic.utils.(module_path, class_name)->dotted_path.strip(' ').rsplit('.', 1)
A:pydantic.utils.module->import_module(module_path)
A:pydantic.utils.v->v.__class__.__repr__(v).__class__.__repr__(v)
A:pydantic.utils.KeyType->TypeVar('KeyType')
A:pydantic.utils.updated_mapping->mapping.copy()
A:pydantic.utils.updated_mapping[k]->deep_update(updated_mapping[k], v)
A:pydantic.utils.present_params->signature(init).parameters.values()
A:pydantic.utils.merged_params[param_name]->Parameter(param_name, Parameter.KEYWORD_ONLY, annotation=field.annotation, **kwargs)
A:pydantic.utils.merged_params[var_kw_name]->var_kw.replace(name=var_kw_name)
A:pydantic.utils.pascal_string->to_camel(string)
A:pydantic.utils.T->TypeVar('T')
A:pydantic.utils.v_name->name_factory(v)
A:pydantic.utils.items->dict.fromkeys(items, ...)
A:pydantic.utils.item->self._items.get(e)
A:pydantic.utils.all_items->self._coerce_value(v)
A:pydantic.utils.normalized_items[normalized_i]->self.merge(v, normalized_items.get(normalized_i))
A:pydantic.utils.normalized_item->normalized_items.setdefault(i, {})
A:pydantic.utils.normalized_items[i]->self.merge(all_items, normalized_item)
A:pydantic.utils.override->cls._coerce_value(override)
A:pydantic.utils.base->cls._coerce_value(base)
A:pydantic.utils.merged_item->cls.merge(base.get(k), override.get(k), intersect=intersect)
A:pydantic.utils.class_name->getattr(items, '__class__', '???')
A:pydantic.utils.Obj->TypeVar('Obj')
A:pydantic.utils._EMPTY->object()
A:pydantic.utils.unique_aliases->set(all_aliases)
A:pydantic.utils.is_root_model->getattr(tp, '__custom_root_type__', False)
A:pydantic.utils.(alias, all_values)->_get_union_alias_and_all_values(union_type, discriminator_key)
A:pydantic.utils.(all_aliases, all_values)->zip(*zipped_aliases_values)
A:pydantic.utils.KT->TypeVar('KT')
A:pydantic.utils.VT->TypeVar('VT')
pydantic.utils.ClassAttribute(self,name:str,value:Any)
pydantic.utils.ClassAttribute.__get__(self,instance:Any,owner:Type[Any])->None
pydantic.utils.GetterDict(self,obj:Any)
pydantic.utils.GetterDict.__contains__(self,item:Any)->bool
pydantic.utils.GetterDict.__eq__(self,other:Any)->bool
pydantic.utils.GetterDict.__getitem__(self,key:str)->Any
pydantic.utils.GetterDict.__iter__(self)->Iterator[str]
pydantic.utils.GetterDict.__len__(self)->int
pydantic.utils.GetterDict.__repr_args__(self)->'ReprArgs'
pydantic.utils.GetterDict.__repr_name__(self)->str
pydantic.utils.GetterDict.extra_keys(self)->Set[Any]
pydantic.utils.GetterDict.get(self,key:Any,default:Any=None)->Any
pydantic.utils.GetterDict.items(self)->Iterator[Tuple[str, Any]]
pydantic.utils.GetterDict.keys(self)->List[Any]
pydantic.utils.GetterDict.values(self)->List[Any]
pydantic.utils.PyObjectStr(str)
pydantic.utils.PyObjectStr.__repr__(self)->str
pydantic.utils.Representation
pydantic.utils.Representation.__pretty__(self,fmt:Callable[[Any],Any],**kwargs:Any)->Generator[Any, None, None]
pydantic.utils.Representation.__repr__(self)->str
pydantic.utils.Representation.__repr_args__(self)->'ReprArgs'
pydantic.utils.Representation.__repr_name__(self)->str
pydantic.utils.Representation.__repr_str__(self,join_str:str)->str
pydantic.utils.Representation.__rich_repr__(self)->'RichReprResult'
pydantic.utils.Representation.__str__(self)->str
pydantic.utils.ValueItems(self,value:Any,items:Union['AbstractSetIntStr','MappingIntStrAny'])
pydantic.utils.ValueItems.__repr_args__(self)->'ReprArgs'
pydantic.utils.ValueItems._coerce_items(items:Union['AbstractSetIntStr','MappingIntStrAny'])->'MappingIntStrAny'
pydantic.utils.ValueItems._coerce_value(cls,value:Any)->Any
pydantic.utils.ValueItems._normalize_indexes(self,items:'MappingIntStrAny',v_length:int)->'DictIntStrAny'
pydantic.utils.ValueItems.for_element(self,e:'IntStr')->Optional[Union['AbstractSetIntStr', 'MappingIntStrAny']]
pydantic.utils.ValueItems.is_excluded(self,item:Any)->bool
pydantic.utils.ValueItems.is_included(self,item:Any)->bool
pydantic.utils.ValueItems.is_true(v:Any)->bool
pydantic.utils.ValueItems.merge(cls,base:Any,override:Any,intersect:bool=False)->Any
pydantic.utils._get_union_alias_and_all_values(union_type:Type[Any],discriminator_key:str)->Tuple[str, Tuple[Tuple[str, ...], ...]]
pydantic.utils.all_identical(left:Iterable[Any],right:Iterable[Any])->bool
pydantic.utils.almost_equal_floats(value_1:float,value_2:float,*,delta:float=1e-08)->bool
pydantic.utils.assert_never(obj:NoReturn,msg:str)->NoReturn
pydantic.utils.deep_update(mapping:Dict[KeyType,Any],*updating_mappings:Dict[KeyType,Any])->Dict[KeyType, Any]
pydantic.utils.generate_model_signature(init:Callable[...,None],fields:Dict[str,'ModelField'],config:Type['BaseConfig'])->'Signature'
pydantic.utils.get_discriminator_alias_and_values(tp:Any,discriminator_key:str)->Tuple[str, Tuple[str, ...]]
pydantic.utils.get_model(obj:Union[Type['BaseModel'],Type['Dataclass']])->Type['BaseModel']
pydantic.utils.get_unique_discriminator_alias(all_aliases:Collection[str],discriminator_key:str)->str
pydantic.utils.import_string(dotted_path:str)->Any
pydantic.utils.in_ipython()->bool
pydantic.utils.is_valid_field(name:str)->bool
pydantic.utils.is_valid_identifier(identifier:str)->bool
pydantic.utils.is_valid_private_name(name:str)->bool
pydantic.utils.lenient_isinstance(o:Any,class_or_tuple:Union[Type[Any],Tuple[Type[Any],...],None])->bool
pydantic.utils.lenient_issubclass(cls:Any,class_or_tuple:Union[Type[Any],Tuple[Type[Any],...],None])->bool
pydantic.utils.path_type(p:'Path')->str
pydantic.utils.sequence_like(v:Any)->bool
pydantic.utils.smart_deepcopy(obj:Obj)->Obj
pydantic.utils.to_camel(string:str)->str
pydantic.utils.to_lower_camel(string:str)->str
pydantic.utils.truncate(v:Union[str],*,max_len:int=80)->str
pydantic.utils.unique_list(input_list:Union[List[T],Tuple[T,...]],*,name_factory:Callable[[T],str]=str)->List[T]
pydantic.utils.update_not_none(mapping:Dict[Any,Any],**update:Any)->None
pydantic.utils.validate_field_name(bases:List[Type['BaseModel']],field_name:str)->None


----------------------------------------/home/zhang/Packages/pydantic/pydantic1.10.1/decorator.py----------------------------------------
A:pydantic.decorator.AnyCallableT->TypeVar('AnyCallableT', bound=AnyCallable)
A:pydantic.decorator.vd->ValidatedFunction(_func, config)
A:pydantic.decorator.self.positional_only_args->set()
A:pydantic.decorator.type_hints->get_all_type_hints(function)
A:pydantic.decorator.values->self.build_values(args, kwargs)
A:pydantic.decorator.m->self.init_model_instance(*args, **kwargs)
A:pydantic.decorator.arg_iter->enumerate(args)
A:pydantic.decorator.(i, a)->next(arg_iter)
A:pydantic.decorator.arg_name->self.arg_mapping.get(i)
A:pydantic.decorator.var_kwargs->d.pop(self.v_kwargs_name, {})
A:pydantic.decorator.pos_args->len(self.arg_mapping)
A:pydantic.decorator.CustomConfig->type('Config', (), config)
A:pydantic.decorator.keys->', '.join(map(repr, v))
A:pydantic.decorator.extra->getattr(CustomConfig, 'extra', Extra.forbid)
A:pydantic.decorator.self.model->create_model(to_camel(self.raw_function.__name__), __base__=DecoratorBaseModel, **fields)
pydantic.decorator.ValidatedFunction(self,function:'AnyCallableT',config:'ConfigType')
pydantic.decorator.ValidatedFunction.build_values(self,args:Tuple[Any,...],kwargs:Dict[str,Any])->Dict[str, Any]
pydantic.decorator.ValidatedFunction.call(self,*args:Any,**kwargs:Any)->Any
pydantic.decorator.ValidatedFunction.create_model(self,fields:Dict[str,Any],takes_args:bool,takes_kwargs:bool,config:'ConfigType')->None
pydantic.decorator.ValidatedFunction.execute(self,m:BaseModel)->Any
pydantic.decorator.ValidatedFunction.init_model_instance(self,*args:Any,**kwargs:Any)->BaseModel
pydantic.decorator.validate_arguments(func:'AnyCallableT')->'AnyCallableT'
pydantic.decorator.validate_arguments(func:None=None,*,config:'ConfigType'=None)->Callable[['AnyCallableT'], 'AnyCallableT']
pydantic.decorator.validate_arguments(func:Optional['AnyCallableT']=None,*,config:'ConfigType'=None)->Any
pydantic.validate_arguments(func:'AnyCallableT')->'AnyCallableT'
pydantic.validate_arguments(func:None=None,*,config:'ConfigType'=None)->Callable[['AnyCallableT'], 'AnyCallableT']
pydantic.validate_arguments(func:Optional['AnyCallableT']=None,*,config:'ConfigType'=None)->Any


----------------------------------------/home/zhang/Packages/pydantic/pydantic1.10.1/_hypothesis_plugin.py----------------------------------------
A:pydantic._hypothesis_plugin._color_regexes->'|'.join((pydantic.color.r_hex_short, pydantic.color.r_hex_long, pydantic.color.r_rgb, pydantic.color.r_rgba, pydantic.color.r_hsl, pydantic.color.r_hsla)).replace(pydantic.color._r_sl, '(?:(\\d\\d?(?:\\.\\d+)?|100(?:\\.0+)?)%)').replace(pydantic.color._r_alpha, '(?:(0(?:\\.\\d+)?|1(?:\\.0+)?|\\.\\d+|\\d{1,2}%))').replace(pydantic.color._r_255, '(?:((?:\\d|\\d\\d|[01]\\d\\d|2[0-4]\\d|25[0-4])(?:\\.\\d+)?|255(?:\\.0+)?))')
A:pydantic._hypothesis_plugin.finite->hypothesis.strategies.floats(allow_infinity=False, allow_nan=False)
A:pydantic._hypothesis_plugin.inner->hypothesis.strategies.recursive(base=st.one_of(st.none(), st.booleans(), st.integers(), finite, st.text()), extend=lambda x: st.lists(x) | st.dictionaries(st.text(), x))
A:pydantic._hypothesis_plugin.inner_type->getattr(cls, 'inner_type', None)
A:pydantic._hypothesis_plugin.repeats->'{{{},{}}}'.format(min_size - 2 if min_size > 2 else 0, max_size - 2 if (max_size or 0) > 2 else '')
A:pydantic._hypothesis_plugin.s->s.filter(lambda d: cls.gt < d).filter(lambda d: cls.gt < d)
A:pydantic._hypothesis_plugin.min_value->math.ceil(Fraction(min_value) / Fraction(cls.multiple_of))
A:pydantic._hypothesis_plugin.max_value->math.floor(Fraction(max_value) / Fraction(cls.multiple_of))
A:pydantic._hypothesis_plugin.strategy->hypothesis.strategies.from_regex(f'(\\W(.{repeats}\\W)?)?')
pydantic._hypothesis_plugin._registered(typ:Type[pydantic.types.T])->Type[pydantic.types.T]
pydantic._hypothesis_plugin._registered(typ:Union[Type[pydantic.types.T],pydantic.types.ConstrainedNumberMeta])->Union[Type[pydantic.types.T], pydantic.types.ConstrainedNumberMeta]
pydantic._hypothesis_plugin._registered(typ:pydantic.types.ConstrainedNumberMeta)->pydantic.types.ConstrainedNumberMeta
pydantic._hypothesis_plugin.add_luhn_digit(card_number:str)->str
pydantic._hypothesis_plugin.resolve_conbytes(cls)
pydantic._hypothesis_plugin.resolve_condate(cls)
pydantic._hypothesis_plugin.resolve_condecimal(cls)
pydantic._hypothesis_plugin.resolve_confloat(cls)
pydantic._hypothesis_plugin.resolve_conint(cls)
pydantic._hypothesis_plugin.resolve_constr(cls)
pydantic._hypothesis_plugin.resolve_json(cls)
pydantic._hypothesis_plugin.resolves(typ:Union[type,pydantic.types.ConstrainedNumberMeta])->Callable[[Callable[..., st.SearchStrategy]], Callable[..., st.SearchStrategy]]


----------------------------------------/home/zhang/Packages/pydantic/pydantic1.10.1/parse.py----------------------------------------
A:pydantic.parse.b->Path(path).read_bytes()
A:pydantic.parse.path->Path(path)
pydantic.Protocol(str,Enum)
pydantic.parse.Protocol(str,Enum)
pydantic.parse.load_file(path:Union[str,Path],*,content_type:str=None,encoding:str='utf8',proto:Protocol=None,allow_pickle:bool=False,json_loads:Callable[[str],Any]=json.loads)->Any
pydantic.parse.load_str_bytes(b:StrBytes,*,content_type:str=None,encoding:str='utf8',proto:Protocol=None,allow_pickle:bool=False,json_loads:Callable[[str],Any]=json.loads)->Any


----------------------------------------/home/zhang/Packages/pydantic/pydantic1.10.1/env_settings.py----------------------------------------
A:pydantic.env_settings.env_file_sentinel->str(object())
A:pydantic.env_settings.init_settings->InitSettingsSource(init_kwargs=init_kwargs)
A:pydantic.env_settings.env_settings->EnvSettingsSource(env_file=_env_file if _env_file != env_file_sentinel else self.__config__.env_file, env_file_encoding=_env_file_encoding if _env_file_encoding is not None else self.__config__.env_file_encoding, env_nested_delimiter=_env_nested_delimiter if _env_nested_delimiter is not None else self.__config__.env_nested_delimiter, env_prefix_len=len(self.__config__.env_prefix))
A:pydantic.env_settings.file_secret_settings->SecretsSettingsSource(secrets_dir=_secrets_dir or self.__config__.secrets_dir)
A:pydantic.env_settings.sources->self.__config__.customise_sources(init_settings=init_settings, env_settings=env_settings, file_secret_settings=file_secret_settings)
A:pydantic.env_settings.field_info_from_config->cls.get_field_info(field.name)
A:pydantic.env_settings.env_names->env_names.__class__((n.lower() for n in env_names)).__class__((n.lower() for n in env_names))
A:pydantic.env_settings.dotenv_vars->self._read_env_files(settings.__config__.case_sensitive)
A:pydantic.env_settings.env_val->settings.__config__.parse_env_var(field.name, env_val)
A:pydantic.env_settings.(is_complex, allow_parse_failure)->self.field_is_complex(field)
A:pydantic.env_settings.env_val_built->self.explode_env_vars(field, env_vars)
A:pydantic.env_settings.d[field.alias]->deep_update(env_val, self.explode_env_vars(field, env_vars))
A:pydantic.env_settings.env_path->Path(env_file).expanduser()
A:pydantic.env_settings.(_, *keys, last_key)->env_name_without_prefix.split(self.env_nested_delimiter)
A:pydantic.env_settings.env_var->env_var.setdefault(key, {}).setdefault(key, {})
A:pydantic.env_settings.secrets_path->Path(self.secrets_dir).expanduser()
A:pydantic.env_settings.path->find_case_path(secrets_path, env_name, settings.__config__.case_sensitive)
A:pydantic.env_settings.secret_value->settings.__config__.parse_env_var(field.name, secret_value)
pydantic.BaseSettings(__pydantic_self__,_env_file:Optional[DotenvType]=env_file_sentinel,_env_file_encoding:Optional[str]=None,_env_nested_delimiter:Optional[str]=None,_secrets_dir:Optional[StrPath]=None,**values:Any)
pydantic.BaseSettings.Config(BaseConfig)
pydantic.BaseSettings.Config.customise_sources(cls,init_settings:SettingsSourceCallable,env_settings:SettingsSourceCallable,file_secret_settings:SettingsSourceCallable)->Tuple[SettingsSourceCallable, ...]
pydantic.BaseSettings.Config.parse_env_var(cls,field_name:str,raw_val:str)->Any
pydantic.BaseSettings.Config.prepare_field(cls,field:ModelField)->None
pydantic.BaseSettings._build_values(self,init_kwargs:Dict[str,Any],_env_file:Optional[DotenvType]=None,_env_file_encoding:Optional[str]=None,_env_nested_delimiter:Optional[str]=None,_secrets_dir:Optional[StrPath]=None)->Dict[str, Any]
pydantic.env_settings.BaseSettings(__pydantic_self__,_env_file:Optional[DotenvType]=env_file_sentinel,_env_file_encoding:Optional[str]=None,_env_nested_delimiter:Optional[str]=None,_secrets_dir:Optional[StrPath]=None,**values:Any)
pydantic.env_settings.BaseSettings.Config(BaseConfig)
pydantic.env_settings.BaseSettings.Config.customise_sources(cls,init_settings:SettingsSourceCallable,env_settings:SettingsSourceCallable,file_secret_settings:SettingsSourceCallable)->Tuple[SettingsSourceCallable, ...]
pydantic.env_settings.BaseSettings.Config.parse_env_var(cls,field_name:str,raw_val:str)->Any
pydantic.env_settings.BaseSettings.Config.prepare_field(cls,field:ModelField)->None
pydantic.env_settings.BaseSettings._build_values(self,init_kwargs:Dict[str,Any],_env_file:Optional[DotenvType]=None,_env_file_encoding:Optional[str]=None,_env_nested_delimiter:Optional[str]=None,_secrets_dir:Optional[StrPath]=None)->Dict[str, Any]
pydantic.env_settings.EnvSettingsSource(self,env_file:Optional[DotenvType],env_file_encoding:Optional[str],env_nested_delimiter:Optional[str]=None,env_prefix_len:int=0)
pydantic.env_settings.EnvSettingsSource.__repr__(self)->str
pydantic.env_settings.EnvSettingsSource._read_env_files(self,case_sensitive:bool)->Dict[str, Optional[str]]
pydantic.env_settings.EnvSettingsSource.explode_env_vars(self,field:ModelField,env_vars:Mapping[str,Optional[str]])->Dict[str, Any]
pydantic.env_settings.EnvSettingsSource.field_is_complex(self,field:ModelField)->Tuple[bool, bool]
pydantic.env_settings.InitSettingsSource(self,init_kwargs:Dict[str,Any])
pydantic.env_settings.InitSettingsSource.__repr__(self)->str
pydantic.env_settings.SecretsSettingsSource(self,secrets_dir:Optional[StrPath])
pydantic.env_settings.SecretsSettingsSource.__repr__(self)->str
pydantic.env_settings.SettingsError(ValueError)
pydantic.env_settings.find_case_path(dir_path:Path,file_name:str,case_sensitive:bool)->Optional[Path]
pydantic.env_settings.read_env_file(file_path:StrPath,*,encoding:str=None,case_sensitive:bool=False)->Dict[str, Optional[str]]


----------------------------------------/home/zhang/Packages/pydantic/pydantic1.10.1/tools.py----------------------------------------
A:pydantic.tools.type_name->type_name(type_)
A:pydantic.tools.T->TypeVar('T')
A:pydantic.tools.model_type->_get_parsing_type(type_, type_name=type_name)
A:pydantic.tools.obj->load_str_bytes(b, proto=proto, content_type=content_type, encoding=encoding, allow_pickle=allow_pickle, json_loads=json_loads)
pydantic._generate_parsing_type_name(type_:Any)->str
pydantic._get_parsing_type(type_:Any,*,type_name:Optional[NameFactory]=None)->Any
pydantic.parse_file_as(type_:Type[T],path:Union[str,Path],*,content_type:str=None,encoding:str='utf8',proto:Protocol=None,allow_pickle:bool=False,json_loads:Callable[[str],Any]=json.loads,type_name:Optional[NameFactory]=None)->T
pydantic.parse_obj_as(type_:Type[T],obj:Any,*,type_name:Optional[NameFactory]=None)->T
pydantic.parse_raw_as(type_:Type[T],b:StrBytes,*,content_type:str=None,encoding:str='utf8',proto:Protocol=None,allow_pickle:bool=False,json_loads:Callable[[str],Any]=json.loads,type_name:Optional[NameFactory]=None)->T
pydantic.schema_json_of(type_:Any,*,title:Optional[NameFactory]=None,**schema_json_kwargs:Any)->str
pydantic.schema_of(type_:Any,*,title:Optional[NameFactory]=None,**schema_kwargs:Any)->'DictStrAny'
pydantic.tools._generate_parsing_type_name(type_:Any)->str
pydantic.tools._get_parsing_type(type_:Any,*,type_name:Optional[NameFactory]=None)->Any
pydantic.tools.parse_file_as(type_:Type[T],path:Union[str,Path],*,content_type:str=None,encoding:str='utf8',proto:Protocol=None,allow_pickle:bool=False,json_loads:Callable[[str],Any]=json.loads,type_name:Optional[NameFactory]=None)->T
pydantic.tools.parse_obj_as(type_:Type[T],obj:Any,*,type_name:Optional[NameFactory]=None)->T
pydantic.tools.parse_raw_as(type_:Type[T],b:StrBytes,*,content_type:str=None,encoding:str='utf8',proto:Protocol=None,allow_pickle:bool=False,json_loads:Callable[[str],Any]=json.loads,type_name:Optional[NameFactory]=None)->T
pydantic.tools.schema_json_of(type_:Any,*,title:Optional[NameFactory]=None,**schema_json_kwargs:Any)->str
pydantic.tools.schema_of(type_:Any,*,title:Optional[NameFactory]=None,**schema_kwargs:Any)->'DictStrAny'


----------------------------------------/home/zhang/Packages/pydantic/pydantic1.10.1/datetime_parse.py----------------------------------------
A:pydantic.datetime_parse.date_re->re.compile(f'{date_expr}$')
A:pydantic.datetime_parse.time_re->re.compile(time_expr)
A:pydantic.datetime_parse.datetime_re->re.compile(f'{date_expr}[T ]{time_expr}')
A:pydantic.datetime_parse.standard_duration_re->re.compile('^(?:(?P<days>-?\\d+) (days?, )?)?((?:(?P<hours>-?\\d+):)(?=\\d+:\\d+))?(?:(?P<minutes>-?\\d+):)?(?P<seconds>-?\\d+)(?:\\.(?P<microseconds>\\d{1,6})\\d{0,6})?$')
A:pydantic.datetime_parse.iso8601_duration_re->re.compile('^(?P<sign>[-+]?)P(?:(?P<days>\\d+(.\\d+)?)D)?(?:T(?:(?P<hours>\\d+(.\\d+)?)H)?(?:(?P<minutes>\\d+(.\\d+)?)M)?(?:(?P<seconds>\\d+(.\\d+)?)S)?)?$')
A:pydantic.datetime_parse.EPOCH->datetime(1970, 1, 1)
A:pydantic.datetime_parse.MS_WATERSHED->int(20000000000.0)
A:pydantic.datetime_parse.MAX_NUMBER->int(3e+20)
A:pydantic.datetime_parse.number->get_numeric(value, 'datetime')
A:pydantic.datetime_parse.value->value.decode().decode()
A:pydantic.datetime_parse.match->re.compile(f'{date_expr}[T ]{time_expr}').match(value)
A:pydantic.datetime_parse.kw->re.compile(f'{date_expr}[T ]{time_expr}').match(value).groupdict()
A:pydantic.datetime_parse.kw['microsecond']->kw['microsecond'].ljust(6, '0').ljust(6, '0')
A:pydantic.datetime_parse.tzinfo->_parse_timezone(kw.pop('tzinfo'), errors.DateTimeError)
A:pydantic.datetime_parse.kw['microseconds']->kw['microseconds'].ljust(6, '0').ljust(6, '0')
pydantic.datetime_parse._parse_timezone(value:Optional[str],error:Type[Exception])->Union[None, int, timezone]
pydantic.datetime_parse.from_unix_seconds(seconds:Union[int,float])->datetime
pydantic.datetime_parse.get_numeric(value:StrBytesIntFloat,native_expected_type:str)->Union[None, int, float]
pydantic.datetime_parse.parse_date(value:Union[date,StrBytesIntFloat])->date
pydantic.datetime_parse.parse_datetime(value:Union[datetime,StrBytesIntFloat])->datetime
pydantic.datetime_parse.parse_duration(value:StrBytesIntFloat)->timedelta
pydantic.datetime_parse.parse_time(value:Union[time,StrBytesIntFloat])->time


----------------------------------------/home/zhang/Packages/pydantic/pydantic1.10.1/errors.py----------------------------------------
A:pydantic.errors.permitted->', '.join((repr(v.value) for v in self.enum_values))
pydantic.AnyStrMaxLengthError(self,*,limit_value:int)
pydantic.AnyStrMinLengthError(self,*,limit_value:int)
pydantic.ArbitraryTypeError(self,*,expected_arbitrary_type:Type[Any])
pydantic.BoolError(PydanticTypeError)
pydantic.BytesError(PydanticTypeError)
pydantic.CallableError(PydanticTypeError)
pydantic.ClassError(PydanticTypeError)
pydantic.ColorError(PydanticValueError)
pydantic.ConfigError(RuntimeError)
pydantic.DataclassTypeError(PydanticTypeError)
pydantic.DateError(PydanticValueError)
pydantic.DateNotInTheFutureError(PydanticValueError)
pydantic.DateNotInThePastError(PydanticValueError)
pydantic.DateTimeError(PydanticValueError)
pydantic.DecimalError(PydanticTypeError)
pydantic.DecimalIsNotFiniteError(PydanticValueError)
pydantic.DecimalMaxDigitsError(self,*,max_digits:int)
pydantic.DecimalMaxPlacesError(self,*,decimal_places:int)
pydantic.DecimalWholeDigitsError(self,*,whole_digits:int)
pydantic.DequeError(PydanticTypeError)
pydantic.DictError(PydanticTypeError)
pydantic.DurationError(PydanticValueError)
pydantic.EmailError(PydanticValueError)
pydantic.EnumError(PydanticTypeError)
pydantic.EnumMemberError(PydanticTypeError)
pydantic.EnumMemberError.__str__(self)->str
pydantic.ExtraError(PydanticValueError)
pydantic.FloatError(PydanticTypeError)
pydantic.FrozenSetError(PydanticTypeError)
pydantic.FrozenSetMaxLengthError(self,*,limit_value:int)
pydantic.FrozenSetMinLengthError(self,*,limit_value:int)
pydantic.HashableError(PydanticTypeError)
pydantic.IPv4AddressError(PydanticValueError)
pydantic.IPv4InterfaceError(PydanticValueError)
pydantic.IPv4NetworkError(PydanticValueError)
pydantic.IPv6AddressError(PydanticValueError)
pydantic.IPv6InterfaceError(PydanticValueError)
pydantic.IPv6NetworkError(PydanticValueError)
pydantic.IPvAnyAddressError(PydanticValueError)
pydantic.IPvAnyInterfaceError(PydanticValueError)
pydantic.IPvAnyNetworkError(PydanticValueError)
pydantic.IntEnumError(PydanticTypeError)
pydantic.IntegerError(PydanticTypeError)
pydantic.InvalidByteSize(PydanticValueError)
pydantic.InvalidByteSizeUnit(PydanticValueError)
pydantic.InvalidDiscriminator(self,*,discriminator_key:str,discriminator_value:Any,allowed_values:Sequence[Any])
pydantic.InvalidLengthForBrand(PydanticValueError)
pydantic.IterableError(PydanticTypeError)
pydantic.JsonError(PydanticValueError)
pydantic.JsonTypeError(PydanticTypeError)
pydantic.ListError(PydanticTypeError)
pydantic.ListMaxLengthError(self,*,limit_value:int)
pydantic.ListMinLengthError(self,*,limit_value:int)
pydantic.ListUniqueItemsError(PydanticValueError)
pydantic.LuhnValidationError(PydanticValueError)
pydantic.MissingDiscriminator(PydanticValueError)
pydantic.MissingError(PydanticValueError)
pydantic.NoneIsAllowedError(PydanticTypeError)
pydantic.NoneIsNotAllowedError(PydanticTypeError)
pydantic.NotDigitError(PydanticValueError)
pydantic.NotNoneError(PydanticTypeError)
pydantic.NumberNotFiniteError(PydanticValueError)
pydantic.NumberNotGeError(_NumberBoundError)
pydantic.NumberNotGtError(_NumberBoundError)
pydantic.NumberNotLeError(_NumberBoundError)
pydantic.NumberNotLtError(_NumberBoundError)
pydantic.NumberNotMultipleError(self,*,multiple_of:Union[int,float,Decimal])
pydantic.PathError(PydanticTypeError)
pydantic.PathNotADirectoryError(_PathValueError)
pydantic.PathNotAFileError(_PathValueError)
pydantic.PathNotExistsError(_PathValueError)
pydantic.PatternError(PydanticValueError)
pydantic.PyObjectError(PydanticTypeError)
pydantic.PydanticErrorMixin(self,**ctx:Any)
pydantic.PydanticErrorMixin.__reduce__(self)->Tuple[Callable[..., 'PydanticErrorMixin'], Tuple[Type['PydanticErrorMixin'], 'DictStrAny']]
pydantic.PydanticErrorMixin.__str__(self)->str
pydantic.PydanticTypeError(PydanticErrorMixin,TypeError)
pydantic.PydanticValueError(PydanticErrorMixin,ValueError)
pydantic.SequenceError(PydanticTypeError)
pydantic.SetError(PydanticTypeError)
pydantic.SetMaxLengthError(self,*,limit_value:int)
pydantic.SetMinLengthError(self,*,limit_value:int)
pydantic.StrError(PydanticTypeError)
pydantic.StrRegexError(self,*,pattern:str)
pydantic.StrictBoolError(PydanticValueError)
pydantic.SubclassError(self,*,expected_class:Type[Any])
pydantic.TimeError(PydanticValueError)
pydantic.TupleError(PydanticTypeError)
pydantic.TupleLengthError(self,*,actual_length:int,expected_length:int)
pydantic.UUIDError(PydanticTypeError)
pydantic.UUIDVersionError(self,*,required_version:int)
pydantic.UrlError(PydanticValueError)
pydantic.UrlExtraError(UrlError)
pydantic.UrlHostError(UrlError)
pydantic.UrlHostTldError(UrlError)
pydantic.UrlPortError(UrlError)
pydantic.UrlSchemeError(UrlError)
pydantic.UrlSchemePermittedError(self,allowed_schemes:Set[str])
pydantic.UrlUserInfoError(UrlError)
pydantic.WrongConstantError(PydanticValueError)
pydantic.WrongConstantError.__str__(self)->str
pydantic._NumberBoundError(self,*,limit_value:Union[int,float,Decimal])
pydantic._PathValueError(self,*,path:Path)
pydantic.cls_kwargs(cls:Type['PydanticErrorMixin'],ctx:'DictStrAny')->'PydanticErrorMixin'
pydantic.errors.AnyStrMaxLengthError(self,*,limit_value:int)
pydantic.errors.AnyStrMinLengthError(self,*,limit_value:int)
pydantic.errors.ArbitraryTypeError(self,*,expected_arbitrary_type:Type[Any])
pydantic.errors.BoolError(PydanticTypeError)
pydantic.errors.BytesError(PydanticTypeError)
pydantic.errors.CallableError(PydanticTypeError)
pydantic.errors.ClassError(PydanticTypeError)
pydantic.errors.ColorError(PydanticValueError)
pydantic.errors.ConfigError(RuntimeError)
pydantic.errors.DataclassTypeError(PydanticTypeError)
pydantic.errors.DateError(PydanticValueError)
pydantic.errors.DateNotInTheFutureError(PydanticValueError)
pydantic.errors.DateNotInThePastError(PydanticValueError)
pydantic.errors.DateTimeError(PydanticValueError)
pydantic.errors.DecimalError(PydanticTypeError)
pydantic.errors.DecimalIsNotFiniteError(PydanticValueError)
pydantic.errors.DecimalMaxDigitsError(self,*,max_digits:int)
pydantic.errors.DecimalMaxPlacesError(self,*,decimal_places:int)
pydantic.errors.DecimalWholeDigitsError(self,*,whole_digits:int)
pydantic.errors.DequeError(PydanticTypeError)
pydantic.errors.DictError(PydanticTypeError)
pydantic.errors.DurationError(PydanticValueError)
pydantic.errors.EmailError(PydanticValueError)
pydantic.errors.EnumError(PydanticTypeError)
pydantic.errors.EnumMemberError(PydanticTypeError)
pydantic.errors.EnumMemberError.__str__(self)->str
pydantic.errors.ExtraError(PydanticValueError)
pydantic.errors.FloatError(PydanticTypeError)
pydantic.errors.FrozenSetError(PydanticTypeError)
pydantic.errors.FrozenSetMaxLengthError(self,*,limit_value:int)
pydantic.errors.FrozenSetMinLengthError(self,*,limit_value:int)
pydantic.errors.HashableError(PydanticTypeError)
pydantic.errors.IPv4AddressError(PydanticValueError)
pydantic.errors.IPv4InterfaceError(PydanticValueError)
pydantic.errors.IPv4NetworkError(PydanticValueError)
pydantic.errors.IPv6AddressError(PydanticValueError)
pydantic.errors.IPv6InterfaceError(PydanticValueError)
pydantic.errors.IPv6NetworkError(PydanticValueError)
pydantic.errors.IPvAnyAddressError(PydanticValueError)
pydantic.errors.IPvAnyInterfaceError(PydanticValueError)
pydantic.errors.IPvAnyNetworkError(PydanticValueError)
pydantic.errors.IntEnumError(PydanticTypeError)
pydantic.errors.IntegerError(PydanticTypeError)
pydantic.errors.InvalidByteSize(PydanticValueError)
pydantic.errors.InvalidByteSizeUnit(PydanticValueError)
pydantic.errors.InvalidDiscriminator(self,*,discriminator_key:str,discriminator_value:Any,allowed_values:Sequence[Any])
pydantic.errors.InvalidLengthForBrand(PydanticValueError)
pydantic.errors.IterableError(PydanticTypeError)
pydantic.errors.JsonError(PydanticValueError)
pydantic.errors.JsonTypeError(PydanticTypeError)
pydantic.errors.ListError(PydanticTypeError)
pydantic.errors.ListMaxLengthError(self,*,limit_value:int)
pydantic.errors.ListMinLengthError(self,*,limit_value:int)
pydantic.errors.ListUniqueItemsError(PydanticValueError)
pydantic.errors.LuhnValidationError(PydanticValueError)
pydantic.errors.MissingDiscriminator(PydanticValueError)
pydantic.errors.MissingError(PydanticValueError)
pydantic.errors.NoneIsAllowedError(PydanticTypeError)
pydantic.errors.NoneIsNotAllowedError(PydanticTypeError)
pydantic.errors.NotDigitError(PydanticValueError)
pydantic.errors.NotNoneError(PydanticTypeError)
pydantic.errors.NumberNotFiniteError(PydanticValueError)
pydantic.errors.NumberNotGeError(_NumberBoundError)
pydantic.errors.NumberNotGtError(_NumberBoundError)
pydantic.errors.NumberNotLeError(_NumberBoundError)
pydantic.errors.NumberNotLtError(_NumberBoundError)
pydantic.errors.NumberNotMultipleError(self,*,multiple_of:Union[int,float,Decimal])
pydantic.errors.PathError(PydanticTypeError)
pydantic.errors.PathNotADirectoryError(_PathValueError)
pydantic.errors.PathNotAFileError(_PathValueError)
pydantic.errors.PathNotExistsError(_PathValueError)
pydantic.errors.PatternError(PydanticValueError)
pydantic.errors.PyObjectError(PydanticTypeError)
pydantic.errors.PydanticErrorMixin(self,**ctx:Any)
pydantic.errors.PydanticErrorMixin.__reduce__(self)->Tuple[Callable[..., 'PydanticErrorMixin'], Tuple[Type['PydanticErrorMixin'], 'DictStrAny']]
pydantic.errors.PydanticErrorMixin.__str__(self)->str
pydantic.errors.PydanticTypeError(PydanticErrorMixin,TypeError)
pydantic.errors.PydanticValueError(PydanticErrorMixin,ValueError)
pydantic.errors.SequenceError(PydanticTypeError)
pydantic.errors.SetError(PydanticTypeError)
pydantic.errors.SetMaxLengthError(self,*,limit_value:int)
pydantic.errors.SetMinLengthError(self,*,limit_value:int)
pydantic.errors.StrError(PydanticTypeError)
pydantic.errors.StrRegexError(self,*,pattern:str)
pydantic.errors.StrictBoolError(PydanticValueError)
pydantic.errors.SubclassError(self,*,expected_class:Type[Any])
pydantic.errors.TimeError(PydanticValueError)
pydantic.errors.TupleError(PydanticTypeError)
pydantic.errors.TupleLengthError(self,*,actual_length:int,expected_length:int)
pydantic.errors.UUIDError(PydanticTypeError)
pydantic.errors.UUIDVersionError(self,*,required_version:int)
pydantic.errors.UrlError(PydanticValueError)
pydantic.errors.UrlExtraError(UrlError)
pydantic.errors.UrlHostError(UrlError)
pydantic.errors.UrlHostTldError(UrlError)
pydantic.errors.UrlPortError(UrlError)
pydantic.errors.UrlSchemeError(UrlError)
pydantic.errors.UrlSchemePermittedError(self,allowed_schemes:Set[str])
pydantic.errors.UrlUserInfoError(UrlError)
pydantic.errors.WrongConstantError(PydanticValueError)
pydantic.errors.WrongConstantError.__str__(self)->str
pydantic.errors._NumberBoundError(self,*,limit_value:Union[int,float,Decimal])
pydantic.errors._PathValueError(self,*,path:Path)
pydantic.errors.cls_kwargs(cls:Type['PydanticErrorMixin'],ctx:'DictStrAny')->'PydanticErrorMixin'


----------------------------------------/home/zhang/Packages/pydantic/pydantic1.10.1/error_wrappers.py----------------------------------------
A:pydantic.error_wrappers.self._error_cache->list(flatten_errors(self.raw_errors, config))
A:pydantic.error_wrappers.errors->self.errors()
A:pydantic.error_wrappers.no_errors->len(errors)
A:pydantic.error_wrappers.ctx->error.get('ctx')
A:pydantic.error_wrappers.error_loc->error.loc_tuple()
A:pydantic.error_wrappers.type_->get_exc_type(exc.__class__)
A:pydantic.error_wrappers.msg->str(exc)
A:pydantic.error_wrappers.r->_get_exc_type(cls)
pydantic.ValidationError(self,errors:Sequence[ErrorList],model:'ModelOrDc')
pydantic.ValidationError.__repr_args__(self)->'ReprArgs'
pydantic.ValidationError.__str__(self)->str
pydantic.ValidationError.errors(self)->List['ErrorDict']
pydantic.ValidationError.json(self,*,indent:Union[None,int,str]=2)->str
pydantic.error_wrappers.ErrorWrapper(self,exc:Exception,loc:Union[str,'Loc'])
pydantic.error_wrappers.ErrorWrapper.__repr_args__(self)->'ReprArgs'
pydantic.error_wrappers.ErrorWrapper.loc_tuple(self)->'Loc'
pydantic.error_wrappers.ValidationError(self,errors:Sequence[ErrorList],model:'ModelOrDc')
pydantic.error_wrappers.ValidationError.__repr_args__(self)->'ReprArgs'
pydantic.error_wrappers.ValidationError.__str__(self)->str
pydantic.error_wrappers.ValidationError.errors(self)->List['ErrorDict']
pydantic.error_wrappers.ValidationError.json(self,*,indent:Union[None,int,str]=2)->str
pydantic.error_wrappers._display_error_loc(error:'ErrorDict')->str
pydantic.error_wrappers._display_error_type_and_ctx(error:'ErrorDict')->str
pydantic.error_wrappers._get_exc_type(cls:Type[Exception])->str
pydantic.error_wrappers.display_errors(errors:List['ErrorDict'])->str
pydantic.error_wrappers.error_dict(exc:Exception,config:Type['BaseConfig'],loc:'Loc')->'ErrorDict'
pydantic.error_wrappers.flatten_errors(errors:Sequence[Any],config:Type['BaseConfig'],loc:Optional['Loc']=None)->Generator['ErrorDict', None, None]
pydantic.error_wrappers.get_exc_type(cls:Type[Exception])->str


----------------------------------------/home/zhang/Packages/pydantic/pydantic1.10.1/main.py----------------------------------------
A:pydantic.main.Model->TypeVar('Model', bound='BaseModel')
A:pydantic.main._T->TypeVar('_T')
A:pydantic.main.config->inherit_config(config_from_namespace, config, **config_kwargs)
A:pydantic.main.validators->inherit_validators(extract_validators(namespace), validators)
A:pydantic.main.resolve_forward_refs->kwargs.pop('__resolve_forward_refs__', True)
A:pydantic.main.config_from_namespace->namespace.get('Config')
A:pydantic.main.vg->ValidatorGroup(validators)
A:pydantic.main.extra_validators->ValidatorGroup(validators).get_validators(f.name)
A:pydantic.main.annotations->resolve_annotations(namespace.get('__annotations__', {}), namespace.get('__module__', None))
A:pydantic.main.value->field.get_default()
A:pydantic.main.fields[ann_name]->fields.ModelField.infer(name=ann_name, value=value, annotation=ann_type, class_validators=vg.get_validators(ann_name), config=config)
A:pydantic.main.private_attributes[ann_name]->PrivateAttr()
A:pydantic.main.private_attributes[var_name]->PrivateAttr(default=value)
A:pydantic.main.inferred->fields.ModelField.infer(name=var_name, value=value, annotation=annotations.get(var_name, Undefined), class_validators=vg.get_validators(var_name), config=config)
A:pydantic.main.json_encoder->partial(custom_pydantic_encoder, config.json_encoders)
A:pydantic.main.(pre_rv_new, post_rv_new)->extract_root_validators(namespace)
A:pydantic.main.hash_func->generate_hash_function(config.frozen)
A:pydantic.main.cls->super().__new__(mcs, name, bases, new_namespace, **kwargs)
A:pydantic.main.cls.__signature__->ClassAttribute('__signature__', generate_model_signature(cls.__init__, fields, config))
A:pydantic.main.set_name->getattr(obj, '__set_name__', None)
A:pydantic.main.(values, fields_set, validation_error)->validate_model(cls, obj)
A:pydantic.main.new_values->validator(self.__class__, new_values)
A:pydantic.main.known_field->self.__fields__.get(name, None)
A:pydantic.main.(value, error_)->self.__fields__.get(name, None).validate(value, dict_without_original_value, loc=name, cls=self.__class__)
A:pydantic.main.default->private_attr.get_default()
A:pydantic.main.encoder->cast(Callable[[Any], Any], encoder or self.__json_encoder__)
A:pydantic.main.data->dict(self._iter(to_dict=models_as_dict, by_alias=by_alias, include=include, exclude=exclude, exclude_unset=exclude_unset, exclude_defaults=exclude_defaults, exclude_none=exclude_none))
A:pydantic.main.obj->load_file(path, proto=proto, content_type=content_type, encoding=encoding, allow_pickle=allow_pickle, json_loads=cls.__config__.json_loads)
A:pydantic.main.exc->TypeError(f'{cls.__name__} expected dict not {obj.__class__.__name__}')
A:pydantic.main.m->super().__new__(mcs, name, bases, new_namespace, **kwargs).__new__(cls)
A:pydantic.main.fields_values[name]->field.get_default()
A:pydantic.main._fields_set->set(values.keys())
A:pydantic.main.values->validator(cls_, values)
A:pydantic.main.fields_set->set()
A:pydantic.main.cached->super().__new__(mcs, name, bases, new_namespace, **kwargs).__schema_cache__.get((by_alias, ref_template))
A:pydantic.main.s->model_schema(cls, by_alias=by_alias, ref_template=ref_template)
A:pydantic.main.value_as_dict->dict(value)
A:pydantic.main.v_dict->self._get_value(v, to_dict=to_dict, by_alias=by_alias, include=value_include and value_include.for_element(field_key), exclude=value_exclude and value_exclude.for_element(field_key), exclude_unset=exclude_unset, exclude_defaults=exclude_defaults, exclude_none=exclude_none).dict(by_alias=by_alias, exclude_unset=exclude_unset, exclude_defaults=exclude_defaults, include=include, exclude=exclude, exclude_none=exclude_none)
A:pydantic.main.exclude->utils.ValueItems.merge(self.__exclude_fields__, exclude)
A:pydantic.main.include->utils.ValueItems.merge(self.__include_fields__, include, intersect=True)
A:pydantic.main.allowed_keys->self._calculate_keys(include=include, exclude=exclude, exclude_unset=exclude_unset)
A:pydantic.main.model_field->self.__fields__.get(field_key)
A:pydantic.main.v->self._get_value(v, to_dict=to_dict, by_alias=by_alias, include=value_include and value_include.for_element(field_key), exclude=value_exclude and value_exclude.for_element(field_key), exclude_unset=exclude_unset, exclude_defaults=exclude_defaults, exclude_none=exclude_none)
A:pydantic.main.keys->self.__dict__.keys()
A:pydantic.main.namespace['Config']->inherit_config(__config__, BaseConfig)
A:pydantic.main.resolved_bases->resolve_bases(__base__)
A:pydantic.main.(meta, ns, kwds)->prepare_class(__model_name, resolved_bases, kwds=__cls_kwargs__)
A:pydantic.main._missing->object()
A:pydantic.main.names_used->set()
A:pydantic.main.input_data->validator(cls_, input_data)
A:pydantic.main.(v_, errors_)->field.validate(value, values, loc=field.alias, cls=cls_)
pydantic.BaseModel(__pydantic_self__,**data:Any)
pydantic.BaseModel.__eq__(self,other:Any)->bool
pydantic.BaseModel.__get_validators__(cls)->'CallableGenerator'
pydantic.BaseModel.__getstate__(self)->'DictAny'
pydantic.BaseModel.__iter__(self)->'TupleGenerator'
pydantic.BaseModel.__repr_args__(self)->'ReprArgs'
pydantic.BaseModel.__setattr__(self,name,value)
pydantic.BaseModel.__setstate__(self,state:'DictAny')->None
pydantic.BaseModel.__try_update_forward_refs__(cls,**localns:Any)->None
pydantic.BaseModel._calculate_keys(self,include:Optional['MappingIntStrAny'],exclude:Optional['MappingIntStrAny'],exclude_unset:bool,update:Optional['DictStrAny']=None)->Optional[AbstractSet[str]]
pydantic.BaseModel._copy_and_set_values(self:'Model',values:'DictStrAny',fields_set:'SetStr',*,deep:bool)->'Model'
pydantic.BaseModel._decompose_class(cls:Type['Model'],obj:Any)->GetterDict
pydantic.BaseModel._enforce_dict_if_root(cls,obj:Any)->Any
pydantic.BaseModel._get_value(cls,v:Any,to_dict:bool,by_alias:bool,include:Optional[Union['AbstractSetIntStr','MappingIntStrAny']],exclude:Optional[Union['AbstractSetIntStr','MappingIntStrAny']],exclude_unset:bool,exclude_defaults:bool,exclude_none:bool)->Any
pydantic.BaseModel._init_private_attributes(self)->None
pydantic.BaseModel._iter(self,to_dict:bool=False,by_alias:bool=False,include:Optional[Union['AbstractSetIntStr','MappingIntStrAny']]=None,exclude:Optional[Union['AbstractSetIntStr','MappingIntStrAny']]=None,exclude_unset:bool=False,exclude_defaults:bool=False,exclude_none:bool=False)->'TupleGenerator'
pydantic.BaseModel.construct(cls:Type['Model'],_fields_set:Optional['SetStr']=None,**values:Any)->'Model'
pydantic.BaseModel.copy(self:'Model',*,include:Optional[Union['AbstractSetIntStr','MappingIntStrAny']]=None,exclude:Optional[Union['AbstractSetIntStr','MappingIntStrAny']]=None,update:Optional['DictStrAny']=None,deep:bool=False)->'Model'
pydantic.BaseModel.dict(self,*,include:Optional[Union['AbstractSetIntStr','MappingIntStrAny']]=None,exclude:Optional[Union['AbstractSetIntStr','MappingIntStrAny']]=None,by_alias:bool=False,skip_defaults:Optional[bool]=None,exclude_unset:bool=False,exclude_defaults:bool=False,exclude_none:bool=False)->'DictStrAny'
pydantic.BaseModel.from_orm(cls:Type['Model'],obj:Any)->'Model'
pydantic.BaseModel.json(self,*,include:Optional[Union['AbstractSetIntStr','MappingIntStrAny']]=None,exclude:Optional[Union['AbstractSetIntStr','MappingIntStrAny']]=None,by_alias:bool=False,skip_defaults:Optional[bool]=None,exclude_unset:bool=False,exclude_defaults:bool=False,exclude_none:bool=False,encoder:Optional[Callable[[Any],Any]]=None,models_as_dict:bool=True,**dumps_kwargs:Any)->str
pydantic.BaseModel.parse_file(cls:Type['Model'],path:Union[str,Path],*,content_type:str=None,encoding:str='utf8',proto:Protocol=None,allow_pickle:bool=False)->'Model'
pydantic.BaseModel.parse_obj(cls:Type['Model'],obj:Any)->'Model'
pydantic.BaseModel.parse_raw(cls:Type['Model'],b:StrBytes,*,content_type:str=None,encoding:str='utf8',proto:Protocol=None,allow_pickle:bool=False)->'Model'
pydantic.BaseModel.schema(cls,by_alias:bool=True,ref_template:str=default_ref_template)->'DictStrAny'
pydantic.BaseModel.schema_json(cls,*,by_alias:bool=True,ref_template:str=default_ref_template,**dumps_kwargs:Any)->str
pydantic.BaseModel.update_forward_refs(cls,**localns:Any)->None
pydantic.BaseModel.validate(cls:Type['Model'],value:Any)->'Model'
pydantic.ModelMetaclass(mcs,name,bases,namespace,**kwargs)
pydantic.ModelMetaclass.__instancecheck__(self,instance:Any)->bool
pydantic.create_model(__model_name:str,*,__config__:Optional[Type[BaseConfig]]=None,__base__:None=None,__module__:str=__name__,__validators__:Dict[str,'AnyClassMethod']=None,__cls_kwargs__:Dict[str,Any]=None,**field_definitions:Any)->Type['BaseModel']
pydantic.create_model(__model_name:str,*,__config__:Optional[Type[BaseConfig]]=None,__base__:Union[None,Type['Model'],Tuple[Type['Model'],...]]=None,__module__:str=__name__,__validators__:Dict[str,'AnyClassMethod']=None,__cls_kwargs__:Dict[str,Any]=None,__slots__:Optional[Tuple[str,...]]=None,**field_definitions:Any)->Type['Model']
pydantic.create_model(__model_name:str,*,__config__:Optional[Type[BaseConfig]]=None,__base__:Union[Type['Model'],Tuple[Type['Model'],...]],__module__:str=__name__,__validators__:Dict[str,'AnyClassMethod']=None,__cls_kwargs__:Dict[str,Any]=None,**field_definitions:Any)->Type['Model']
pydantic.generate_hash_function(frozen:bool)->Optional[Callable[[Any], int]]
pydantic.main.BaseModel(__pydantic_self__,**data:Any)
pydantic.main.BaseModel.__eq__(self,other:Any)->bool
pydantic.main.BaseModel.__get_validators__(cls)->'CallableGenerator'
pydantic.main.BaseModel.__getstate__(self)->'DictAny'
pydantic.main.BaseModel.__iter__(self)->'TupleGenerator'
pydantic.main.BaseModel.__repr_args__(self)->'ReprArgs'
pydantic.main.BaseModel.__setattr__(self,name,value)
pydantic.main.BaseModel.__setstate__(self,state:'DictAny')->None
pydantic.main.BaseModel.__try_update_forward_refs__(cls,**localns:Any)->None
pydantic.main.BaseModel._calculate_keys(self,include:Optional['MappingIntStrAny'],exclude:Optional['MappingIntStrAny'],exclude_unset:bool,update:Optional['DictStrAny']=None)->Optional[AbstractSet[str]]
pydantic.main.BaseModel._copy_and_set_values(self:'Model',values:'DictStrAny',fields_set:'SetStr',*,deep:bool)->'Model'
pydantic.main.BaseModel._decompose_class(cls:Type['Model'],obj:Any)->GetterDict
pydantic.main.BaseModel._enforce_dict_if_root(cls,obj:Any)->Any
pydantic.main.BaseModel._get_value(cls,v:Any,to_dict:bool,by_alias:bool,include:Optional[Union['AbstractSetIntStr','MappingIntStrAny']],exclude:Optional[Union['AbstractSetIntStr','MappingIntStrAny']],exclude_unset:bool,exclude_defaults:bool,exclude_none:bool)->Any
pydantic.main.BaseModel._init_private_attributes(self)->None
pydantic.main.BaseModel._iter(self,to_dict:bool=False,by_alias:bool=False,include:Optional[Union['AbstractSetIntStr','MappingIntStrAny']]=None,exclude:Optional[Union['AbstractSetIntStr','MappingIntStrAny']]=None,exclude_unset:bool=False,exclude_defaults:bool=False,exclude_none:bool=False)->'TupleGenerator'
pydantic.main.BaseModel.construct(cls:Type['Model'],_fields_set:Optional['SetStr']=None,**values:Any)->'Model'
pydantic.main.BaseModel.copy(self:'Model',*,include:Optional[Union['AbstractSetIntStr','MappingIntStrAny']]=None,exclude:Optional[Union['AbstractSetIntStr','MappingIntStrAny']]=None,update:Optional['DictStrAny']=None,deep:bool=False)->'Model'
pydantic.main.BaseModel.dict(self,*,include:Optional[Union['AbstractSetIntStr','MappingIntStrAny']]=None,exclude:Optional[Union['AbstractSetIntStr','MappingIntStrAny']]=None,by_alias:bool=False,skip_defaults:Optional[bool]=None,exclude_unset:bool=False,exclude_defaults:bool=False,exclude_none:bool=False)->'DictStrAny'
pydantic.main.BaseModel.from_orm(cls:Type['Model'],obj:Any)->'Model'
pydantic.main.BaseModel.json(self,*,include:Optional[Union['AbstractSetIntStr','MappingIntStrAny']]=None,exclude:Optional[Union['AbstractSetIntStr','MappingIntStrAny']]=None,by_alias:bool=False,skip_defaults:Optional[bool]=None,exclude_unset:bool=False,exclude_defaults:bool=False,exclude_none:bool=False,encoder:Optional[Callable[[Any],Any]]=None,models_as_dict:bool=True,**dumps_kwargs:Any)->str
pydantic.main.BaseModel.parse_file(cls:Type['Model'],path:Union[str,Path],*,content_type:str=None,encoding:str='utf8',proto:Protocol=None,allow_pickle:bool=False)->'Model'
pydantic.main.BaseModel.parse_obj(cls:Type['Model'],obj:Any)->'Model'
pydantic.main.BaseModel.parse_raw(cls:Type['Model'],b:StrBytes,*,content_type:str=None,encoding:str='utf8',proto:Protocol=None,allow_pickle:bool=False)->'Model'
pydantic.main.BaseModel.schema(cls,by_alias:bool=True,ref_template:str=default_ref_template)->'DictStrAny'
pydantic.main.BaseModel.schema_json(cls,*,by_alias:bool=True,ref_template:str=default_ref_template,**dumps_kwargs:Any)->str
pydantic.main.BaseModel.update_forward_refs(cls,**localns:Any)->None
pydantic.main.BaseModel.validate(cls:Type['Model'],value:Any)->'Model'
pydantic.main.ModelMetaclass(mcs,name,bases,namespace,**kwargs)
pydantic.main.ModelMetaclass.__instancecheck__(self,instance:Any)->bool
pydantic.main.create_model(__model_name:str,*,__config__:Optional[Type[BaseConfig]]=None,__base__:None=None,__module__:str=__name__,__validators__:Dict[str,'AnyClassMethod']=None,__cls_kwargs__:Dict[str,Any]=None,**field_definitions:Any)->Type['BaseModel']
pydantic.main.create_model(__model_name:str,*,__config__:Optional[Type[BaseConfig]]=None,__base__:Union[None,Type['Model'],Tuple[Type['Model'],...]]=None,__module__:str=__name__,__validators__:Dict[str,'AnyClassMethod']=None,__cls_kwargs__:Dict[str,Any]=None,__slots__:Optional[Tuple[str,...]]=None,**field_definitions:Any)->Type['Model']
pydantic.main.create_model(__model_name:str,*,__config__:Optional[Type[BaseConfig]]=None,__base__:Union[Type['Model'],Tuple[Type['Model'],...]],__module__:str=__name__,__validators__:Dict[str,'AnyClassMethod']=None,__cls_kwargs__:Dict[str,Any]=None,**field_definitions:Any)->Type['Model']
pydantic.main.generate_hash_function(frozen:bool)->Optional[Callable[[Any], int]]
pydantic.main.validate_custom_root_type(fields:Dict[str,ModelField])->None
pydantic.main.validate_model(model:Type[BaseModel],input_data:'DictStrAny',cls:'ModelOrDc'=None)->Tuple['DictStrAny', 'SetStr', Optional[ValidationError]]
pydantic.validate_custom_root_type(fields:Dict[str,ModelField])->None
pydantic.validate_model(model:Type[BaseModel],input_data:'DictStrAny',cls:'ModelOrDc'=None)->Tuple['DictStrAny', 'SetStr', Optional[ValidationError]]


----------------------------------------/home/zhang/Packages/pydantic/pydantic1.10.1/typing.py----------------------------------------
A:pydantic.typing._T->TypeVar('_T')
A:pydantic.typing.origin->get_origin(tp)
A:pydantic.typing.args->get_args(type_)
A:pydantic.typing.converted->tuple((ForwardRef(arg) if isinstance(arg, str) and isinstance(tp, TypingGenericAlias) else convert_generics(arg) for arg in args))
A:pydantic.typing.value->_eval_type(value, base_globals, None)
A:pydantic.typing.values->literal_values(type_)
A:pydantic.typing.test_type->NewType('test_type', str)
A:pydantic.typing.field.type_->evaluate_forwardref(field.type_, globalns, localns or None)
A:pydantic.typing.field.outer_type_->evaluate_forwardref(field.outer_type_, globalns, localns or None)
A:pydantic.typing.globalns->sys.modules[model.__module__].__dict__.copy()
A:pydantic.typing.new_key->evaluate_forwardref(fr, globalns, localns or None)
A:pydantic.typing.json_encoders[new_key]->json_encoders.pop(key)
pydantic.typing._check_classvar(v:Optional[Type[Any]])->bool
pydantic.typing._check_finalvar(v:Optional[Type[Any]])->bool
pydantic.typing._check_typeddict_special(type_:Any)->bool
pydantic.typing.all_literal_values(type_:Type[Any])->Tuple[Any, ...]
pydantic.typing.display_as_type(v:Type[Any])->str
pydantic.typing.get_class(type_:Type[Any])->Union[None, bool, Type[Any]]
pydantic.typing.get_sub_types(tp:Any)->List[Any]
pydantic.typing.is_callable_type(type_:Type[Any])->bool
pydantic.typing.is_classvar(ann_type:Type[Any])->bool
pydantic.typing.is_finalvar(ann_type:Type[Any])->bool
pydantic.typing.is_literal_type(type_:Type[Any])->bool
pydantic.typing.is_namedtuple(type_:Type[Any])->bool
pydantic.typing.is_new_type(type_:Type[Any])->bool
pydantic.typing.is_typeddict(type_:Type[Any])->bool
pydantic.typing.is_typeddict_special(type_:Any)->bool
pydantic.typing.literal_values(type_:Type[Any])->Tuple[Any, ...]
pydantic.typing.new_type_supertype(type_:Type[Any])->Type[Any]
pydantic.typing.resolve_annotations(raw_annotations:Dict[str,Type[Any]],module_name:Optional[str])->Dict[str, Type[Any]]
pydantic.typing.update_field_forward_refs(field:'ModelField',globalns:Any,localns:Any)->None
pydantic.typing.update_model_forward_refs(model:Type[Any],fields:Iterable['ModelField'],json_encoders:Dict[Union[Type[Any],str,ForwardRef],AnyCallable],localns:'DictStrAny',exc_to_suppress:Tuple[Type[BaseException],...]=())->None


----------------------------------------/home/zhang/Packages/pydantic/pydantic1.10.1/config.py----------------------------------------
A:pydantic.config.fields_value->cls.fields.get(name)
A:pydantic.config.alias->cls.alias_generator(name)
A:pydantic.config.config.extra->Extra(config.extra)
pydantic.BaseConfig
pydantic.BaseConfig.get_field_info(cls,name:str)->Dict[str, Any]
pydantic.BaseConfig.prepare_field(cls,field:'ModelField')->None
pydantic.Extra(str,Enum)
pydantic.config.BaseConfig
pydantic.config.BaseConfig.get_field_info(cls,name:str)->Dict[str, Any]
pydantic.config.BaseConfig.prepare_field(cls,field:'ModelField')->None
pydantic.config.Extra(str,Enum)
pydantic.config.get_config(config:Union[ConfigDict,Type[object],None])->Type[BaseConfig]
pydantic.config.inherit_config(self_config:'ConfigType',parent_config:'ConfigType',**namespace:Any)->'ConfigType'
pydantic.config.prepare_config(config:Type[BaseConfig],cls_name:str)->None


----------------------------------------/home/zhang/Packages/pydantic/pydantic1.10.1/networks.py----------------------------------------
A:pydantic.networks._url_regex_cache->re.compile(f'{_scheme_regex}{_user_info_regex}{_host_regex}{_path_regex}{_query_regex}{_fragment_regex}', re.IGNORECASE)
A:pydantic.networks._multi_host_url_regex_cache->re.compile(f'{_scheme_regex}{_user_info_regex}(?P<hosts>([^/]*)){_path_regex}{_query_regex}{_fragment_regex}', re.IGNORECASE)
A:pydantic.networks._ascii_domain_regex_cache->re.compile(f'(?:{ascii_chunk}\\.)*?{ascii_chunk}{ascii_domain_ending}', re.IGNORECASE)
A:pydantic.networks._int_domain_regex_cache->re.compile(f'(?:{int_chunk}\\.)*?{int_chunk}{int_domain_ending}', re.IGNORECASE)
A:pydantic.networks._host_regex_cache->re.compile(_host_regex, re.IGNORECASE)
A:pydantic.networks.parts->cls.validate_parts(parts)
A:pydantic.networks.queries->query.split('&')
A:pydantic.networks.value->str_validator(value)
A:pydantic.networks.m->re.compile('([\\w ]*?) *<(.*)> *').fullmatch(value)
A:pydantic.networks.original_parts->cast('Parts', m.groupdict())
A:pydantic.networks.(host, tld, host_type, rebuild)->cls.validate_host(d)
A:pydantic.networks.d->int_domain_regex().fullmatch(host)
A:pydantic.networks.tld->tld.encode('idna').decode('ascii').encode('idna').decode('ascii')
A:pydantic.networks.host->host.encode('idna').decode('ascii').encode('idna').decode('ascii')
A:pydantic.networks.extra->', '.join((f'{n}={getattr(self, n)!r}' for n in self.__slots__ if getattr(self, n) is not None))
A:pydantic.networks.host_re->host_regex()
A:pydantic.networks.port->int_domain_regex().fullmatch(host).get('port')
A:pydantic.networks.namespace->dict(strip_whitespace=strip_whitespace, min_length=min_length, max_length=max_length, tld_required=tld_required, host_required=host_required, allowed_schemes=allowed_schemes, quote_plus=quote_plus)
A:pydantic.networks.pretty_email_regex->re.compile('([\\w ]*?) *<(.*)> *')
A:pydantic.networks.(name, value)->re.compile('([\\w ]*?) *<(.*)> *').fullmatch(value).groups()
A:pydantic.networks.email->str_validator(value).strip()
A:pydantic.networks.at_index->str_validator(value).strip().index('@')
A:pydantic.networks.global_part->email[at_index:].lower()
pydantic.AmqpDsn(AnyUrl)
pydantic.AnyHttpUrl(AnyUrl)
pydantic.AnyUrl(self,url:str,*,scheme:str,user:Optional[str]=None,password:Optional[str]=None,host:Optional[str]=None,tld:Optional[str]=None,host_type:str='domain',port:Optional[str]=None,path:Optional[str]=None,query:Optional[str]=None,fragment:Optional[str]=None)
pydantic.AnyUrl.__get_validators__(cls)->'CallableGenerator'
pydantic.AnyUrl.__modify_schema__(cls,field_schema:Dict[str,Any])->None
pydantic.AnyUrl.__repr__(self)->str
pydantic.AnyUrl._build_url(cls,m:Match[str],url:str,parts:'Parts')->'AnyUrl'
pydantic.AnyUrl._match_url(url:str)->Optional[Match[str]]
pydantic.AnyUrl._validate_port(port:Optional[str])->None
pydantic.AnyUrl.apply_default_parts(cls,parts:'Parts')->'Parts'
pydantic.AnyUrl.build(cls,*,scheme:str,user:Optional[str]=None,password:Optional[str]=None,host:str,port:Optional[str]=None,path:Optional[str]=None,query:Optional[str]=None,fragment:Optional[str]=None,**_kwargs:str)->str
pydantic.AnyUrl.get_default_parts(parts:'Parts')->'Parts'
pydantic.AnyUrl.quote(cls,string:str,safe:str='')->str
pydantic.AnyUrl.validate(cls,value:Any,field:'ModelField',config:'BaseConfig')->'AnyUrl'
pydantic.AnyUrl.validate_host(cls,parts:'Parts')->Tuple[str, Optional[str], str, bool]
pydantic.AnyUrl.validate_parts(cls,parts:'Parts',validate_port:bool=True)->'Parts'
pydantic.CockroachDsn(AnyUrl)
pydantic.EmailStr(str)
pydantic.EmailStr.__get_validators__(cls)->'CallableGenerator'
pydantic.EmailStr.__modify_schema__(cls,field_schema:Dict[str,Any])->None
pydantic.EmailStr.validate(cls,value:Union[str])->str
pydantic.FileUrl(AnyUrl)
pydantic.HttpUrl(AnyHttpUrl)
pydantic.HttpUrl.get_default_parts(parts:'Parts')->'Parts'
pydantic.IPvAnyAddress(_BaseAddress)
pydantic.IPvAnyAddress.__get_validators__(cls)->'CallableGenerator'
pydantic.IPvAnyAddress.__modify_schema__(cls,field_schema:Dict[str,Any])->None
pydantic.IPvAnyAddress.validate(cls,value:Union[str,bytes,int])->Union[IPv4Address, IPv6Address]
pydantic.IPvAnyInterface(_BaseAddress)
pydantic.IPvAnyInterface.__get_validators__(cls)->'CallableGenerator'
pydantic.IPvAnyInterface.__modify_schema__(cls,field_schema:Dict[str,Any])->None
pydantic.IPvAnyInterface.validate(cls,value:NetworkType)->Union[IPv4Interface, IPv6Interface]
pydantic.IPvAnyNetwork(_BaseNetwork)
pydantic.IPvAnyNetwork.__get_validators__(cls)->'CallableGenerator'
pydantic.IPvAnyNetwork.__modify_schema__(cls,field_schema:Dict[str,Any])->None
pydantic.IPvAnyNetwork.validate(cls,value:NetworkType)->Union[IPv4Network, IPv6Network]
pydantic.KafkaDsn(AnyUrl)
pydantic.KafkaDsn.get_default_parts(parts:'Parts')->'Parts'
pydantic.MongoDsn(AnyUrl)
pydantic.MongoDsn.get_default_parts(parts:'Parts')->'Parts'
pydantic.MultiHostDsn(self,*args:Any,hosts:Optional[List['HostParts']]=None,**kwargs:Any)
pydantic.MultiHostDsn._build_url(cls,m:Match[str],url:str,parts:'Parts')->'MultiHostDsn'
pydantic.MultiHostDsn._match_url(url:str)->Optional[Match[str]]
pydantic.MultiHostDsn.validate_parts(cls,parts:'Parts',validate_port:bool=True)->'Parts'
pydantic.NameEmail(self,name:str,email:str)
pydantic.NameEmail.__eq__(self,other:Any)->bool
pydantic.NameEmail.__get_validators__(cls)->'CallableGenerator'
pydantic.NameEmail.__modify_schema__(cls,field_schema:Dict[str,Any])->None
pydantic.NameEmail.__str__(self)->str
pydantic.NameEmail.validate(cls,value:Any)->'NameEmail'
pydantic.PostgresDsn(MultiHostDsn)
pydantic.RedisDsn(AnyUrl)
pydantic.RedisDsn.get_default_parts(parts:'Parts')->'Parts'
pydantic.ascii_domain_regex()->Pattern[str]
pydantic.host_regex()->Pattern[str]
pydantic.import_email_validator()->None
pydantic.int_domain_regex()->Pattern[str]
pydantic.multi_host_url_regex()->Pattern[str]
pydantic.networks.AmqpDsn(AnyUrl)
pydantic.networks.AnyHttpUrl(AnyUrl)
pydantic.networks.AnyUrl(self,url:str,*,scheme:str,user:Optional[str]=None,password:Optional[str]=None,host:Optional[str]=None,tld:Optional[str]=None,host_type:str='domain',port:Optional[str]=None,path:Optional[str]=None,query:Optional[str]=None,fragment:Optional[str]=None)
pydantic.networks.AnyUrl.__get_validators__(cls)->'CallableGenerator'
pydantic.networks.AnyUrl.__modify_schema__(cls,field_schema:Dict[str,Any])->None
pydantic.networks.AnyUrl.__repr__(self)->str
pydantic.networks.AnyUrl._build_url(cls,m:Match[str],url:str,parts:'Parts')->'AnyUrl'
pydantic.networks.AnyUrl._match_url(url:str)->Optional[Match[str]]
pydantic.networks.AnyUrl._validate_port(port:Optional[str])->None
pydantic.networks.AnyUrl.apply_default_parts(cls,parts:'Parts')->'Parts'
pydantic.networks.AnyUrl.build(cls,*,scheme:str,user:Optional[str]=None,password:Optional[str]=None,host:str,port:Optional[str]=None,path:Optional[str]=None,query:Optional[str]=None,fragment:Optional[str]=None,**_kwargs:str)->str
pydantic.networks.AnyUrl.get_default_parts(parts:'Parts')->'Parts'
pydantic.networks.AnyUrl.quote(cls,string:str,safe:str='')->str
pydantic.networks.AnyUrl.validate(cls,value:Any,field:'ModelField',config:'BaseConfig')->'AnyUrl'
pydantic.networks.AnyUrl.validate_host(cls,parts:'Parts')->Tuple[str, Optional[str], str, bool]
pydantic.networks.AnyUrl.validate_parts(cls,parts:'Parts',validate_port:bool=True)->'Parts'
pydantic.networks.CockroachDsn(AnyUrl)
pydantic.networks.EmailStr(str)
pydantic.networks.EmailStr.__get_validators__(cls)->'CallableGenerator'
pydantic.networks.EmailStr.__modify_schema__(cls,field_schema:Dict[str,Any])->None
pydantic.networks.EmailStr.validate(cls,value:Union[str])->str
pydantic.networks.FileUrl(AnyUrl)
pydantic.networks.HttpUrl(AnyHttpUrl)
pydantic.networks.HttpUrl.get_default_parts(parts:'Parts')->'Parts'
pydantic.networks.IPvAnyAddress(_BaseAddress)
pydantic.networks.IPvAnyAddress.__get_validators__(cls)->'CallableGenerator'
pydantic.networks.IPvAnyAddress.__modify_schema__(cls,field_schema:Dict[str,Any])->None
pydantic.networks.IPvAnyAddress.validate(cls,value:Union[str,bytes,int])->Union[IPv4Address, IPv6Address]
pydantic.networks.IPvAnyInterface(_BaseAddress)
pydantic.networks.IPvAnyInterface.__get_validators__(cls)->'CallableGenerator'
pydantic.networks.IPvAnyInterface.__modify_schema__(cls,field_schema:Dict[str,Any])->None
pydantic.networks.IPvAnyInterface.validate(cls,value:NetworkType)->Union[IPv4Interface, IPv6Interface]
pydantic.networks.IPvAnyNetwork(_BaseNetwork)
pydantic.networks.IPvAnyNetwork.__get_validators__(cls)->'CallableGenerator'
pydantic.networks.IPvAnyNetwork.__modify_schema__(cls,field_schema:Dict[str,Any])->None
pydantic.networks.IPvAnyNetwork.validate(cls,value:NetworkType)->Union[IPv4Network, IPv6Network]
pydantic.networks.KafkaDsn(AnyUrl)
pydantic.networks.KafkaDsn.get_default_parts(parts:'Parts')->'Parts'
pydantic.networks.MongoDsn(AnyUrl)
pydantic.networks.MongoDsn.get_default_parts(parts:'Parts')->'Parts'
pydantic.networks.MultiHostDsn(self,*args:Any,hosts:Optional[List['HostParts']]=None,**kwargs:Any)
pydantic.networks.MultiHostDsn._build_url(cls,m:Match[str],url:str,parts:'Parts')->'MultiHostDsn'
pydantic.networks.MultiHostDsn._match_url(url:str)->Optional[Match[str]]
pydantic.networks.MultiHostDsn.validate_parts(cls,parts:'Parts',validate_port:bool=True)->'Parts'
pydantic.networks.NameEmail(self,name:str,email:str)
pydantic.networks.NameEmail.__eq__(self,other:Any)->bool
pydantic.networks.NameEmail.__get_validators__(cls)->'CallableGenerator'
pydantic.networks.NameEmail.__modify_schema__(cls,field_schema:Dict[str,Any])->None
pydantic.networks.NameEmail.__str__(self)->str
pydantic.networks.NameEmail.validate(cls,value:Any)->'NameEmail'
pydantic.networks.PostgresDsn(MultiHostDsn)
pydantic.networks.RedisDsn(AnyUrl)
pydantic.networks.RedisDsn.get_default_parts(parts:'Parts')->'Parts'
pydantic.networks.ascii_domain_regex()->Pattern[str]
pydantic.networks.host_regex()->Pattern[str]
pydantic.networks.import_email_validator()->None
pydantic.networks.int_domain_regex()->Pattern[str]
pydantic.networks.multi_host_url_regex()->Pattern[str]
pydantic.networks.stricturl(*,strip_whitespace:bool=True,min_length:int=1,max_length:int=2**16,tld_required:bool=True,host_required:bool=True,allowed_schemes:Optional[Collection[str]]=None,quote_plus:bool=False)->Type[AnyUrl]
pydantic.networks.url_regex()->Pattern[str]
pydantic.networks.validate_email(value:Union[str])->Tuple[str, str]
pydantic.stricturl(*,strip_whitespace:bool=True,min_length:int=1,max_length:int=2**16,tld_required:bool=True,host_required:bool=True,allowed_schemes:Optional[Collection[str]]=None,quote_plus:bool=False)->Type[AnyUrl]
pydantic.url_regex()->Pattern[str]
pydantic.validate_email(value:Union[str])->Tuple[str, str]


----------------------------------------/home/zhang/Packages/pydantic/pydantic1.10.1/generics.py----------------------------------------
A:pydantic.generics.GenericModelT->TypeVar('GenericModelT', bound='GenericModel')
A:pydantic.generics.cached->_generic_types_cache.get((cls, params))
A:pydantic.generics.model_name->cls.__concrete_name__(params)
A:pydantic.generics.validators->gather_all_validators(cls)
A:pydantic.generics.type_hints->get_all_type_hints(cls).items()
A:pydantic.generics.(model_module, called_globally)->get_caller_frame_info()
A:pydantic.generics.created_model->cast(Type[GenericModel], create_model(model_name, __module__=model_module or cls.__module__, __base__=(cls,) + tuple(cls.__parameterized_bases__(typevars_map)), __config__=None, __validators__=validators, __cls_kwargs__=None, **fields))
A:pydantic.generics.object_by_reference->reference_module_globals.setdefault(reference_name, created_model)
A:pydantic.generics.new_params->tuple({param: None for param in iter_contained_typevars(typevars_map.values())})
A:pydantic.generics.params_component->', '.join(param_names)
A:pydantic.generics.base_parameters->tuple((mapped_types[param] for param in base_model.__parameters__))
A:pydantic.generics.parameterized_base->base_model.__class_getitem__(base_parameters)
A:pydantic.generics.type_args->get_args(type_)
A:pydantic.generics.origin_type->getattr(typing, type_._name)
A:pydantic.generics.resolved_type_args->tuple((replace_types(t, type_map) for t in type_args))
A:pydantic.generics.resolved_list->list((replace_types(element, type_map) for element in type_))
A:pydantic.generics.type_.inner_type->replace_types(type_.inner_type, type_map)
A:pydantic.generics.actual->len(parameters)
A:pydantic.generics.expected->len(cls.__parameters__)
A:pydantic.generics.args->get_args(v)
A:pydantic.generics.previous_caller_frame->sys._getframe(2)
A:pydantic.generics.concrete_type->replace_types(field_type_hint, typevars_map)
pydantic.generics.GenericModel(BaseModel)
pydantic.generics.GenericModel.__class_getitem__(cls:Type[GenericModelT],params:Union[Type[Any],Tuple[Type[Any],...]])->Type[Any]
pydantic.generics.GenericModel.__concrete_name__(cls:Type[Any],params:Tuple[Type[Any],...])->str
pydantic.generics.GenericModel.__parameterized_bases__(cls,typevars_map:Parametrization)->Iterator[Type[Any]]
pydantic.generics._prepare_model_fields(created_model:Type[GenericModel],fields:Mapping[str,Any],instance_type_hints:Mapping[str,type],typevars_map:Mapping[Any,type])->None
pydantic.generics.check_parameters_count(cls:Type[GenericModel],parameters:Tuple[Any,...])->None
pydantic.generics.get_caller_frame_info()->Tuple[Optional[str], bool]
pydantic.generics.iter_contained_typevars(v:Any)->Iterator[TypeVarType]
pydantic.generics.replace_types(type_:Any,type_map:Mapping[Any,Any])->Any


----------------------------------------/home/zhang/Packages/pydantic/pydantic1.10.1/schema.py----------------------------------------
A:pydantic.schema.sig->signature(modify_schema)
A:pydantic.schema.args->get_args(field_type)
A:pydantic.schema.flat_models->get_flat_models_from_model(model)
A:pydantic.schema.model_name_map->get_model_name_map(flat_models)
A:pydantic.schema.(m_schema, m_definitions, m_nested_models)->model_process_schema(model, by_alias=by_alias, model_name_map=model_name_map, ref_prefix=ref_prefix, ref_template=ref_template)
A:pydantic.schema.model->cast(Type['BaseModel'], model)
A:pydantic.schema.(m_schema, m_definitions, nested_models)->model_type_schema(model, by_alias=by_alias, model_name_map=model_name_map, ref_prefix=ref_prefix, ref_template=ref_template, known_models=known_models)
A:pydantic.schema.m_schema->get_schema_ref(model_name, ref_prefix, ref_template, False)
A:pydantic.schema.schema_['default']->encode_default(field.default)
A:pydantic.schema.(s, schema_overrides)->get_field_info_schema(field)
A:pydantic.schema.validation_schema->get_field_schema_validations(field)
A:pydantic.schema.(f_schema, f_definitions, f_nested_models)->field_schema(f, by_alias=by_alias, model_name_map=model_name_map, ref_prefix=ref_prefix, ref_template=ref_template, known_models=known_models)
A:pydantic.schema.attr->getattr(field.field_info, attr_name, None)
A:pydantic.schema.modify_schema->getattr(field_type, '__modify_schema__', None)
A:pydantic.schema.model_name->get_long_model_name(model)
A:pydantic.schema.conflicting_model->name_model_map.pop(model_name)
A:pydantic.schema.fields->cast(Sequence[ModelField], model.__fields__.values())
A:pydantic.schema.(items_schema, f_definitions, f_nested_models)->field_singleton_schema(field, by_alias=by_alias, model_name_map=model_name_map, ref_prefix=ref_prefix, ref_template=ref_template, known_models=known_models)
A:pydantic.schema.key_field->cast(ModelField, field.key_field)
A:pydantic.schema.regex->getattr(key_field.type_, 'regex', None)
A:pydantic.schema.sub_fields->cast(List[ModelField], field.sub_fields)
A:pydantic.schema.(sf_schema, sf_definitions, sf_nested_models)->field_type_schema(sf, by_alias=by_alias, model_name_map=model_name_map, ref_prefix=ref_prefix, ref_template=ref_template, known_models=known_models)
A:pydantic.schema.sub_fields_len->len(sub_fields)
A:pydantic.schema.s->enum_process_schema(model, field=field)
A:pydantic.schema.doc->getdoc(model)
A:pydantic.schema.sub_models->get_sub_types(sub_field.type_)
A:pydantic.schema.discriminator_model_ref->get_schema_ref(discriminator_model_name, ref_prefix, ref_template, False)
A:pydantic.schema.(sub_schema, sub_definitions, sub_nested_models)->model_process_schema(field_type, by_alias=by_alias, model_name_map=model_name_map, ref_prefix=ref_prefix, ref_template=ref_template, known_models=known_models, field=field)
A:pydantic.schema.values->all_literal_values(field_type)
A:pydantic.schema.f_schema['enum']->list(values)
A:pydantic.schema.(f_schema, schema_overrides)->get_field_info_schema(field, schema_overrides)
A:pydantic.schema.definitions[enum_name]->enum_process_schema(field_type, field=field)
A:pydantic.schema.(sub_schema, *_)->model_process_schema(field_type.__pydantic_model__, by_alias=by_alias, model_name_map=model_name_map, ref_prefix=ref_prefix, ref_template=ref_template, known_models=known_models, field=field)
A:pydantic.schema.items_schemas->list(sub_schema['properties'].values())
A:pydantic.schema.schema_ref->get_schema_ref(model_name, ref_prefix, ref_template, schema_overrides)
A:pydantic.schema.literal_distinct_types->defaultdict(list)
A:pydantic.schema.constraints->field_info.get_constraints()
A:pydantic.schema.(annotation, used_constraints)->get_annotation_with_constraints(annotation, field_info)
A:pydantic.schema.origin->get_origin(type_)
A:pydantic.schema.numeric_type->next((t for t in numeric_types if issubclass(type_, t)))
A:pydantic.schema.constraint_func->cast(Callable[..., type], constraint_func)
pydantic.schema.SkipField(self,message:str)
pydantic.schema._apply_modify_schema(modify_schema:Callable[...,None],field:Optional[ModelField],field_schema:Dict[str,Any])->None
pydantic.schema.add_field_type_to_schema(field_type:Any,schema_:Dict[str,Any])->None
pydantic.schema.encode_default(dft:Any)->Any
pydantic.schema.enum_process_schema(enum:Type[Enum],*,field:Optional[ModelField]=None)->Dict[str, Any]
pydantic.schema.field_schema(field:ModelField,*,by_alias:bool=True,model_name_map:Dict[TypeModelOrEnum,str],ref_prefix:Optional[str]=None,ref_template:str=default_ref_template,known_models:TypeModelSet=None)->Tuple[Dict[str, Any], Dict[str, Any], Set[str]]
pydantic.schema.field_singleton_schema(field:ModelField,*,by_alias:bool,model_name_map:Dict[TypeModelOrEnum,str],ref_template:str,schema_overrides:bool=False,ref_prefix:Optional[str]=None,known_models:TypeModelSet)->Tuple[Dict[str, Any], Dict[str, Any], Set[str]]
pydantic.schema.field_singleton_sub_fields_schema(field:ModelField,*,by_alias:bool,model_name_map:Dict[TypeModelOrEnum,str],ref_template:str,schema_overrides:bool=False,ref_prefix:Optional[str]=None,known_models:TypeModelSet)->Tuple[Dict[str, Any], Dict[str, Any], Set[str]]
pydantic.schema.field_type_schema(field:ModelField,*,by_alias:bool,model_name_map:Dict[TypeModelOrEnum,str],ref_template:str,schema_overrides:bool=False,ref_prefix:Optional[str]=None,known_models:TypeModelSet)->Tuple[Dict[str, Any], Dict[str, Any], Set[str]]
pydantic.schema.get_annotation_from_field_info(annotation:Any,field_info:FieldInfo,field_name:str,validate_assignment:bool=False)->Type[Any]
pydantic.schema.get_annotation_with_constraints(annotation:Any,field_info:FieldInfo)->Tuple[Type[Any], Set[str]]
pydantic.schema.get_field_info_schema(field:ModelField,schema_overrides:bool=False)->Tuple[Dict[str, Any], bool]
pydantic.schema.get_field_schema_validations(field:ModelField)->Dict[str, Any]
pydantic.schema.get_flat_models_from_field(field:ModelField,known_models:TypeModelSet)->TypeModelSet
pydantic.schema.get_flat_models_from_fields(fields:Sequence[ModelField],known_models:TypeModelSet)->TypeModelSet
pydantic.schema.get_flat_models_from_model(model:Type['BaseModel'],known_models:TypeModelSet=None)->TypeModelSet
pydantic.schema.get_flat_models_from_models(models:Sequence[Type['BaseModel']])->TypeModelSet
pydantic.schema.get_long_model_name(model:TypeModelOrEnum)->str
pydantic.schema.get_model_name_map(unique_models:TypeModelSet)->Dict[TypeModelOrEnum, str]
pydantic.schema.get_schema_ref(name:str,ref_prefix:Optional[str],ref_template:str,schema_overrides:bool)->Dict[str, Any]
pydantic.schema.model_process_schema(model:TypeModelOrEnum,*,by_alias:bool=True,model_name_map:Dict[TypeModelOrEnum,str],ref_prefix:Optional[str]=None,ref_template:str=default_ref_template,known_models:TypeModelSet=None,field:Optional[ModelField]=None)->Tuple[Dict[str, Any], Dict[str, Any], Set[str]]
pydantic.schema.model_schema(model:Union[Type['BaseModel'],Type['Dataclass']],by_alias:bool=True,ref_prefix:Optional[str]=None,ref_template:str=default_ref_template)->Dict[str, Any]
pydantic.schema.model_type_schema(model:Type['BaseModel'],*,by_alias:bool,model_name_map:Dict[TypeModelOrEnum,str],ref_template:str,ref_prefix:Optional[str]=None,known_models:TypeModelSet)->Tuple[Dict[str, Any], Dict[str, Any], Set[str]]
pydantic.schema.multitypes_literal_field_for_schema(values:Tuple[Any,...],field:ModelField)->ModelField
pydantic.schema.normalize_name(name:str)->str
pydantic.schema.schema(models:Sequence[Union[Type['BaseModel'],Type['Dataclass']]],*,by_alias:bool=True,title:Optional[str]=None,description:Optional[str]=None,ref_prefix:Optional[str]=None,ref_template:str=default_ref_template)->Dict[str, Any]


----------------------------------------/home/zhang/Packages/pydantic/pydantic1.10.1/version.py----------------------------------------
pydantic.version.version_info()->str


----------------------------------------/home/zhang/Packages/pydantic/pydantic1.10.1/json.py----------------------------------------
A:pydantic.json.(minutes, seconds)->divmod(td.seconds, 60)
A:pydantic.json.(hours, minutes)->divmod(minutes, 60)
pydantic.json.custom_pydantic_encoder(type_encoders:Dict[Any,Callable[[Type[Any]],Any]],obj:Any)->Any
pydantic.json.decimal_encoder(dec_value:Decimal)->Union[int, float]
pydantic.json.isoformat(o:Union[datetime.date,datetime.time])->str
pydantic.json.pydantic_encoder(obj:Any)->Any
pydantic.json.timedelta_isoformat(td:datetime.timedelta)->str


----------------------------------------/home/zhang/Packages/pydantic/pydantic1.10.1/__init__.py----------------------------------------


----------------------------------------/home/zhang/Packages/pydantic/pydantic1.10.1/mypy.py----------------------------------------
A:pydantic.m.self.plugin_config->PydanticPluginConfig(options)
A:pydantic.m.sym->SymbolTableNode(MDEF, func)
A:pydantic.m.transformer->PydanticModelTransformer(ctx, self.plugin_config)
A:pydantic.m.toml_config->parse_toml(options.config_file)
A:pydantic.m.config->ModelConfigData()
A:pydantic.m.setting->ConfigParser().getboolean(CONFIGFILE_KEY, key, fallback=False)
A:pydantic.m.plugin_config->ConfigParser()
A:pydantic.m.pydantic_metadata->model_type.type.metadata.get(METADATA_KEY)
A:pydantic.m.orm_mode->model_type.type.metadata.get(METADATA_KEY).get('config', {}).get('orm_mode')
A:pydantic.m.fields->self.collect_fields(config)
A:pydantic.m.is_settings->any((get_fullname(base) == BASESETTINGS_FULLNAME for base in info.mro[:-1]))
A:pydantic.m.known_fields->set()
A:pydantic.m.is_required->self.get_is_required(cls, stmt, lhs)
A:pydantic.m.(alias, has_dynamic_alias)->self.get_alias_info(stmt)
A:pydantic.m.all_fields->self.collect_fields(config).copy()
A:pydantic.m.field->PydanticModelField.deserialize(info, data)
A:pydantic.m.init_arguments->self.get_field_arguments(fields, typed=typed, force_all_optional=force_all_optional, use_alias=use_alias)
A:pydantic.m.var->PydanticModelField.deserialize(info, data).to_var(info, use_alias=False)
A:pydantic.m.set_str->ctx.api.named_type(f'{BUILTINS_NAME}.set', [ctx.api.named_type(f'{BUILTINS_NAME}.str')])
A:pydantic.m.optional_set_str->UnionType([set_str, NoneType()])
A:pydantic.m.fields_set_argument->Argument(Var('_fields_set', optional_set_str), optional_set_str, None, ARG_OPT)
A:pydantic.m.construct_arguments->self.get_field_arguments(fields, typed=True, force_all_optional=False, use_alias=False)
A:pydantic.m.obj_type->ctx.api.named_type(f'{BUILTINS_NAME}.object')
A:pydantic.m.tvd->TypeVarDef(self_tvar_name, tvar_fullname, -1, [], obj_type)
A:pydantic.m.self_tvar_expr->TypeVarExpr(self_tvar_name, tvar_fullname, [], obj_type)
A:pydantic.m.ctx.cls.info.names[self_tvar_name]->SymbolTableNode(MDEF, self_tvar_expr)
A:pydantic.m.self_type->TypeVarType(tvd)
A:pydantic.m.sym_node->info.names.get(field.name)
A:pydantic.m.info.names[get_name(var)]->SymbolTableNode(MDEF, var)
A:pydantic.m.value_type->get_proper_type(cls.info[lhs.name].type)
A:pydantic.m.type_annotation->AnyType(TypeOfAny.explicit)
A:pydantic.m.ERROR_ORM->ErrorCode('pydantic-orm', 'Invalid from_orm call', 'Pydantic')
A:pydantic.m.ERROR_CONFIG->ErrorCode('pydantic-config', 'Invalid config value', 'Pydantic')
A:pydantic.m.ERROR_ALIAS->ErrorCode('pydantic-alias', 'Dynamic alias disallowed', 'Pydantic')
A:pydantic.m.ERROR_UNEXPECTED->ErrorCode('pydantic-unexpected', 'Unexpected behavior', 'Pydantic')
A:pydantic.m.ERROR_UNTYPED->ErrorCode('pydantic-field', 'Untyped field disallowed', 'Pydantic')
A:pydantic.m.ERROR_FIELD_DEFAULTS->ErrorCode('pydantic-field', 'Invalid Field defaults', 'Pydantic')
A:pydantic.m.function_type->ctx.api.named_type(f'{BUILTINS_NAME}.function')
A:pydantic.m.signature->CallableType(arg_types, arg_kinds, arg_names, return_type, function_type)
A:pydantic.m.func->FuncDef(name, args, Block([PassStmt()]))
A:pydantic.m.func.type->set_callable_name(signature, func)
A:pydantic.m.r_name->get_unique_redefinition_name(name, info.names)
A:pydantic.m.v->Var(name, func.type)
A:pydantic.m.dec->Decorator(func, [NameExpr('classmethod')], v)
pydantic.m.ModelConfigData(self,forbid_extra:Optional[bool]=None,allow_mutation:Optional[bool]=None,frozen:Optional[bool]=None,orm_mode:Optional[bool]=None,allow_population_by_field_name:Optional[bool]=None,has_alias_generator:Optional[bool]=None)
pydantic.m.ModelConfigData.set_values_dict(self)->Dict[str, Any]
pydantic.m.ModelConfigData.setdefault(self,key:str,value:Any)->None
pydantic.m.ModelConfigData.update(self,config:Optional['ModelConfigData'])->None
pydantic.m.PydanticModelField(self,name:str,is_required:bool,alias:Optional[str],has_dynamic_alias:bool,line:int,column:int)
pydantic.m.PydanticModelField.deserialize(cls,info:TypeInfo,data:JsonDict)->'PydanticModelField'
pydantic.m.PydanticModelField.serialize(self)->JsonDict
pydantic.m.PydanticModelField.to_argument(self,info:TypeInfo,typed:bool,force_optional:bool,use_alias:bool)->Argument
pydantic.m.PydanticModelField.to_var(self,info:TypeInfo,use_alias:bool)->Var
pydantic.m.PydanticModelTransformer(self,ctx:ClassDefContext,plugin_config:PydanticPluginConfig)
pydantic.m.PydanticModelTransformer.add_construct_method(self,fields:List['PydanticModelField'])->None
pydantic.m.PydanticModelTransformer.add_initializer(self,fields:List['PydanticModelField'],config:'ModelConfigData',is_settings:bool)->None
pydantic.m.PydanticModelTransformer.adjust_validator_signatures(self)->None
pydantic.m.PydanticModelTransformer.collect_config(self)->'ModelConfigData'
pydantic.m.PydanticModelTransformer.collect_fields(self,model_config:'ModelConfigData')->List['PydanticModelField']
pydantic.m.PydanticModelTransformer.get_alias_info(stmt:AssignmentStmt)->Tuple[Optional[str], bool]
pydantic.m.PydanticModelTransformer.get_config_update(self,substmt:AssignmentStmt)->Optional['ModelConfigData']
pydantic.m.PydanticModelTransformer.get_field_arguments(self,fields:List['PydanticModelField'],typed:bool,force_all_optional:bool,use_alias:bool)->List[Argument]
pydantic.m.PydanticModelTransformer.get_is_required(cls:ClassDef,stmt:AssignmentStmt,lhs:NameExpr)->bool
pydantic.m.PydanticModelTransformer.is_dynamic_alias_present(fields:List['PydanticModelField'],has_alias_generator:bool)->bool
pydantic.m.PydanticModelTransformer.set_frozen(self,fields:List['PydanticModelField'],frozen:bool)->None
pydantic.m.PydanticModelTransformer.should_init_forbid_extra(self,fields:List['PydanticModelField'],config:'ModelConfigData')->bool
pydantic.m.PydanticModelTransformer.transform(self)->None
pydantic.m.PydanticPlugin(self,options:Options)
pydantic.m.PydanticPlugin._pydantic_field_callback(self,ctx:FunctionContext)->'Type'
pydantic.m.PydanticPlugin._pydantic_model_class_maker_callback(self,ctx:ClassDefContext)->None
pydantic.m.PydanticPlugin.get_base_class_hook(self,fullname:str)->'Optional[Callable[[ClassDefContext], None]]'
pydantic.m.PydanticPlugin.get_class_decorator_hook(self,fullname:str)->Optional[Callable[[ClassDefContext], None]]
pydantic.m.PydanticPlugin.get_function_hook(self,fullname:str)->'Optional[Callable[[FunctionContext], Type]]'
pydantic.m.PydanticPlugin.get_method_hook(self,fullname:str)->Optional[Callable[[MethodContext], Type]]
pydantic.m.PydanticPluginConfig(self,options:Options)
pydantic.m.add_method(ctx:ClassDefContext,name:str,args:List[Argument],return_type:Type,self_type:Optional[Type]=None,tvar_def:Optional[TypeVarDef]=None,is_classmethod:bool=False,is_new:bool=False)->None
pydantic.m.error_default_and_default_factory_specified(api:CheckerPluginInterface,context:Context)->None
pydantic.m.error_from_orm(model_name:str,api:CheckerPluginInterface,context:Context)->None
pydantic.m.error_invalid_config_value(name:str,api:SemanticAnalyzerPluginInterface,context:Context)->None
pydantic.m.error_required_dynamic_aliases(api:SemanticAnalyzerPluginInterface,context:Context)->None
pydantic.m.error_unexpected_behavior(detail:str,api:CheckerPluginInterface,context:Context)->None
pydantic.m.error_untyped_fields(api:SemanticAnalyzerPluginInterface,context:Context)->None
pydantic.m.from_orm_callback(ctx:MethodContext)->Type
pydantic.m.get_fullname(x:Union[FuncBase,SymbolNode])->str
pydantic.m.get_name(x:Union[FuncBase,SymbolNode])->str
pydantic.m.parse_mypy_version(version:str)->Tuple[int, ...]
pydantic.m.parse_toml(config_file:str)->Optional[Dict[str, Any]]
pydantic.m.plugin(version:str)->'TypingType[Plugin]'


----------------------------------------/home/zhang/Packages/pydantic/pydantic1.10.1/fields.py----------------------------------------
A:pydantic.fields.T->TypeVar('T')
A:pydantic.fields.Undefined->UndefinedType()
A:pydantic.fields.self.default_factory->kwargs.pop('default_factory', None)
A:pydantic.fields.self.alias->kwargs.pop('alias', None)
A:pydantic.fields.self.alias_priority->kwargs.pop('alias_priority', 2 if self.alias is not None else None)
A:pydantic.fields.self.title->kwargs.pop('title', None)
A:pydantic.fields.self.description->kwargs.pop('description', None)
A:pydantic.fields.self.exclude->utils.ValueItems.merge(value, current_value)
A:pydantic.fields.self.include->utils.ValueItems.merge(value, current_value, intersect=True)
A:pydantic.fields.self.const->kwargs.pop('const', None)
A:pydantic.fields.self.gt->kwargs.pop('gt', None)
A:pydantic.fields.self.ge->kwargs.pop('ge', None)
A:pydantic.fields.self.lt->kwargs.pop('lt', None)
A:pydantic.fields.self.le->kwargs.pop('le', None)
A:pydantic.fields.self.multiple_of->kwargs.pop('multiple_of', None)
A:pydantic.fields.self.allow_inf_nan->kwargs.pop('allow_inf_nan', None)
A:pydantic.fields.self.max_digits->kwargs.pop('max_digits', None)
A:pydantic.fields.self.decimal_places->kwargs.pop('decimal_places', None)
A:pydantic.fields.self.min_items->kwargs.pop('min_items', None)
A:pydantic.fields.self.max_items->kwargs.pop('max_items', None)
A:pydantic.fields.self.unique_items->kwargs.pop('unique_items', None)
A:pydantic.fields.self.min_length->kwargs.pop('min_length', None)
A:pydantic.fields.self.max_length->kwargs.pop('max_length', None)
A:pydantic.fields.self.allow_mutation->kwargs.pop('allow_mutation', True)
A:pydantic.fields.self.regex->kwargs.pop('regex', None)
A:pydantic.fields.self.discriminator->kwargs.pop('discriminator', None)
A:pydantic.fields.self.repr->kwargs.pop('repr', True)
A:pydantic.fields.current_value->getattr(self, attr_name)
A:pydantic.fields.field_info->FieldInfo(value, **field_info_from_config)
A:pydantic.fields.field_info_from_config->config.get_field_info(field_name)
A:pydantic.fields.(field_info, value)->cls._get_field_info(name, annotation, value, config)
A:pydantic.fields.annotation->get_annotation_from_field_info(annotation, field_info, name, config.validate_assignment)
A:pydantic.fields.info_from_config->config.get_field_info(self.name)
A:pydantic.fields.new_alias->config.get_field_info(self.name).get('alias')
A:pydantic.fields.new_exclude->config.get_field_info(self.name).get('exclude')
A:pydantic.fields.self.field_info.exclude->utils.ValueItems.merge(self.field_info.exclude, new_exclude)
A:pydantic.fields.new_include->config.get_field_info(self.name).get('include')
A:pydantic.fields.self.field_info.include->utils.ValueItems.merge(self.field_info.include, new_include, intersect=True)
A:pydantic.fields.default_value->self.get_default()
A:pydantic.fields.self.type_->new_type_supertype(self.type_)
A:pydantic.fields.origin->get_origin(self.type_)
A:pydantic.fields.args->get_args(self.type_)
A:pydantic.fields.get_validators->getattr(self.type_, '__get_validators__', None)
A:pydantic.fields.self.key_field->self._create_sub_type(get_args(self.type_)[0], 'key_' + self.name, for_keys=True)
A:pydantic.fields.(alias, discriminator_values)->get_discriminator_alias_and_values(t, self.discriminator_key)
A:pydantic.fields.self.discriminator_alias->get_unique_discriminator_alias(all_aliases, self.discriminator_key)
A:pydantic.fields.(field_info, _)->self._get_field_info(name, type_, None, self.model_config)
A:pydantic.fields.class_validators_->self.class_validators.values()
A:pydantic.fields.self.validators->prep_validators(v_funcs)
A:pydantic.fields.(v, errors)->self._apply_validators(v, values, loc, cls, self.post_validators)
A:pydantic.fields.e->errors_.TupleLengthError(actual_length=actual_length, expected_length=expected_length)
A:pydantic.fields.(r, ee)->field.validate(v_, values, loc=v_loc, cls=cls)
A:pydantic.fields.converted->deque(result)
A:pydantic.fields.iterable->iter(v)
A:pydantic.fields.v_iter->dict_validator(v)
A:pydantic.fields.(key_result, key_errors)->self.key_field.validate(k, values, loc=v_loc, cls=cls)
A:pydantic.fields.(value_result, value_errors)->self._validate_singleton(v_, values, v_loc, cls)
A:pydantic.fields.(value, error)->field.validate(v, values, loc=loc, cls=cls)
A:pydantic.fields.discriminator_value->getattr(v, self.discriminator_key)
A:pydantic.fields.v->validator(cls, v, values, self, self.model_config)
A:pydantic.fields.t->SHAPE_NAME_LOOKUP[self.shape].format(t)
pydantic.Field(default:Any=Undefined,*,default_factory:Optional[NoArgAnyCallable]=None,alias:str=None,title:str=None,description:str=None,exclude:Union['AbstractSetIntStr','MappingIntStrAny',Any]=None,include:Union['AbstractSetIntStr','MappingIntStrAny',Any]=None,const:bool=None,gt:float=None,ge:float=None,lt:float=None,le:float=None,multiple_of:float=None,allow_inf_nan:bool=None,max_digits:int=None,decimal_places:int=None,min_items:int=None,max_items:int=None,unique_items:bool=None,min_length:int=None,max_length:int=None,allow_mutation:bool=True,regex:str=None,discriminator:str=None,repr:bool=True,**extra:Any)->Any
pydantic.FieldInfo(self,default:Any=Undefined,**kwargs:Any)
pydantic.FieldInfo.__repr_args__(self)->'ReprArgs'
pydantic.FieldInfo._validate(self)->None
pydantic.FieldInfo.get_constraints(self)->Set[str]
pydantic.FieldInfo.update_from_config(self,from_config:Dict[str,Any])->None
pydantic.PrivateAttr(default:Any=Undefined,*,default_factory:Optional[NoArgAnyCallable]=None)->Any
pydantic.fields.DeferredType
pydantic.fields.Field(default:Any=Undefined,*,default_factory:Optional[NoArgAnyCallable]=None,alias:str=None,title:str=None,description:str=None,exclude:Union['AbstractSetIntStr','MappingIntStrAny',Any]=None,include:Union['AbstractSetIntStr','MappingIntStrAny',Any]=None,const:bool=None,gt:float=None,ge:float=None,lt:float=None,le:float=None,multiple_of:float=None,allow_inf_nan:bool=None,max_digits:int=None,decimal_places:int=None,min_items:int=None,max_items:int=None,unique_items:bool=None,min_length:int=None,max_length:int=None,allow_mutation:bool=True,regex:str=None,discriminator:str=None,repr:bool=True,**extra:Any)->Any
pydantic.fields.FieldInfo(self,default:Any=Undefined,**kwargs:Any)
pydantic.fields.FieldInfo.__repr_args__(self)->'ReprArgs'
pydantic.fields.FieldInfo._validate(self)->None
pydantic.fields.FieldInfo.get_constraints(self)->Set[str]
pydantic.fields.FieldInfo.update_from_config(self,from_config:Dict[str,Any])->None
pydantic.fields.ModelField(self,*,name:str,type_:Type[Any],class_validators:Optional[Dict[str,Validator]],model_config:Type['BaseConfig'],default:Any=None,default_factory:Optional[NoArgAnyCallable]=None,required:'BoolUndefined'=Undefined,final:bool=False,alias:str=None,field_info:Optional[FieldInfo]=None)
pydantic.fields.ModelField.__repr_args__(self)->'ReprArgs'
pydantic.fields.ModelField._apply_validators(self,v:Any,values:Dict[str,Any],loc:'LocStr',cls:Optional['ModelOrDc'],validators:'ValidatorsList')->'ValidateReturn'
pydantic.fields.ModelField._create_sub_type(self,type_:Type[Any],name:str,*,for_keys:bool=False)->'ModelField'
pydantic.fields.ModelField._get_field_info(field_name:str,annotation:Any,value:Any,config:Type['BaseConfig'])->Tuple[FieldInfo, Any]
pydantic.fields.ModelField._get_mapping_value(self,original:T,converted:Dict[Any,Any])->Union[T, Dict[Any, Any]]
pydantic.fields.ModelField._set_default_and_type(self)->None
pydantic.fields.ModelField._type_analysis(self)->None
pydantic.fields.ModelField._type_display(self)->PyObjectStr
pydantic.fields.ModelField._validate_discriminated_union(self,v:Any,values:Dict[str,Any],loc:'LocStr',cls:Optional['ModelOrDc'])->'ValidateReturn'
pydantic.fields.ModelField._validate_iterable(self,v:Any,values:Dict[str,Any],loc:'LocStr',cls:Optional['ModelOrDc'])->'ValidateReturn'
pydantic.fields.ModelField._validate_mapping_like(self,v:Any,values:Dict[str,Any],loc:'LocStr',cls:Optional['ModelOrDc'])->'ValidateReturn'
pydantic.fields.ModelField._validate_sequence_like(self,v:Any,values:Dict[str,Any],loc:'LocStr',cls:Optional['ModelOrDc'])->'ValidateReturn'
pydantic.fields.ModelField._validate_singleton(self,v:Any,values:Dict[str,Any],loc:'LocStr',cls:Optional['ModelOrDc'])->'ValidateReturn'
pydantic.fields.ModelField._validate_tuple(self,v:Any,values:Dict[str,Any],loc:'LocStr',cls:Optional['ModelOrDc'])->'ValidateReturn'
pydantic.fields.ModelField.alt_alias(self)->bool
pydantic.fields.ModelField.get_default(self)->Any
pydantic.fields.ModelField.infer(cls,*,name:str,value:Any,annotation:Any,class_validators:Optional[Dict[str,Validator]],config:Type['BaseConfig'])->'ModelField'
pydantic.fields.ModelField.is_complex(self)->bool
pydantic.fields.ModelField.populate_validators(self)->None
pydantic.fields.ModelField.prepare(self)->None
pydantic.fields.ModelField.prepare_discriminated_union_sub_fields(self)->None
pydantic.fields.ModelField.set_config(self,config:Type['BaseConfig'])->None
pydantic.fields.ModelField.validate(self,v:Any,values:Dict[str,Any],*,loc:'LocStr',cls:Optional['ModelOrDc']=None)->'ValidateReturn'
pydantic.fields.ModelPrivateAttr(self,default:Any=Undefined,*,default_factory:Optional[NoArgAnyCallable]=None)
pydantic.fields.ModelPrivateAttr.__eq__(self,other:Any)->bool
pydantic.fields.ModelPrivateAttr.get_default(self)->Any
pydantic.fields.PrivateAttr(default:Any=Undefined,*,default_factory:Optional[NoArgAnyCallable]=None)->Any
pydantic.fields.UndefinedType
pydantic.fields.UndefinedType.__copy__(self:T)->T
pydantic.fields.UndefinedType.__deepcopy__(self:T,_:Any)->T
pydantic.fields.UndefinedType.__reduce__(self)->str
pydantic.fields.UndefinedType.__repr__(self)->str
pydantic.fields.is_finalvar_with_default_val(type_:Type[Any],val:Any)->bool

