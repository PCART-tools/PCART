
----------------------------------------/home/zhang/Packages/pydantic/pydantic2.0b1/types.py----------------------------------------
A:pydantic.types.HashableItemType->TypeVar('HashableItemType', bound=Hashable)
A:pydantic.types.AnyItemType->TypeVar('AnyItemType')
A:pydantic.types.AnyType->TypeVar('AnyType')
A:pydantic.types.serializer->pydantic_core.core_schema.plain_serializer_function_ser_schema(cls._serialize, when_used='json')
A:pydantic.types.field_schema->handler(core_schema)
A:pydantic.types.SecretType->TypeVar('SecretType', str, bytes)
A:pydantic.types.(metadata, remaining_annotations)->_internal._known_annotated_metadata.collect_known_metadata(annotations)
A:pydantic.types.value->value.decode().decode()
A:pydantic.types.schema->handler(source)
A:pydantic.types.json_schema->handler(source)
A:pydantic.types.self.inner_schema->handler(str if self.field_type is SecretStr else bytes)
A:pydantic.types.card_number->self.validate_luhn_check_digit(card_number)
A:pydantic.types.self.brand->self.validate_brand(card_number)
A:pydantic.types.sum_->int(card_number[-1])
A:pydantic.types.length->len(card_number)
A:pydantic.types.digit->int(card_number[i])
A:pydantic.types.byte_string_re->re.compile('^\\s*(\\d*\\.?\\d+)\\s*(\\w+)?', re.IGNORECASE)
A:pydantic.types.str_match->re.compile('^\\s*(\\d*\\.?\\d+)\\s*(\\w+)?', re.IGNORECASE).match(str(__input_value))
A:pydantic.types.(scalar, unit)->re.compile('^\\s*(\\d*\\.?\\d+)\\s*(\\w+)?', re.IGNORECASE).match(str(__input_value)).groups()
A:pydantic.types.num->float(self)
A:pydantic.types.python_schema->pydantic_core.core_schema.is_instance_schema(_generics.get_origin(source) or source)
A:pydantic.types.__getattr__->getattr_migration(__name__)
A:pydantic.types.original_schema->handler.generate_schema(source)
A:pydantic.types.metadata->_internal._core_metadata.build_metadata_dict(js_functions=[lambda _c, h: h(original_schema)])
pydantic.AllowInfNan(_fields.PydanticMetadata)
pydantic.AllowInfNan.__hash__(self)->int
pydantic.Base64Encoder(EncoderProtocol)
pydantic.Base64Encoder.decode(cls,data:bytes)->bytes
pydantic.Base64Encoder.encode(cls,value:bytes)->bytes
pydantic.Base64Encoder.get_json_format(cls)->str
pydantic.ByteSize(int)
pydantic.ByteSize.__get_pydantic_core_schema__(cls,source:type[Any],handler:_annotated_handlers.GetCoreSchemaHandler)->core_schema.CoreSchema
pydantic.ByteSize.human_readable(self,decimal:bool=False)->str
pydantic.ByteSize.to(self,unit:str)->float
pydantic.ByteSize.validate(cls,__input_value:Any,_:core_schema.ValidationInfo)->ByteSize
pydantic.EncodedBytes
pydantic.EncodedBytes.__get_pydantic_core_schema__(self,source:type[Any],handler:Callable[[Any],core_schema.CoreSchema])->core_schema.CoreSchema
pydantic.EncodedBytes.__get_pydantic_json_schema__(self,core_schema:core_schema.CoreSchema,handler:_annotated_handlers.GetJsonSchemaHandler)->JsonSchemaValue
pydantic.EncodedBytes.__hash__(self)->int
pydantic.EncodedBytes.decode(self,data:bytes,_:core_schema.ValidationInfo)->bytes
pydantic.EncodedBytes.encode(self,value:bytes)->bytes
pydantic.EncodedStr(EncodedBytes)
pydantic.EncodedStr.__get_pydantic_core_schema__(self,source:type[Any],handler:Callable[[Any],core_schema.CoreSchema])->core_schema.CoreSchema
pydantic.EncodedStr.decode_str(self,data:bytes,_:core_schema.ValidationInfo)->str
pydantic.EncodedStr.encode_str(self,value:str)->str
pydantic.EncoderProtocol(Protocol)
pydantic.EncoderProtocol.decode(cls,data:bytes)->bytes
pydantic.EncoderProtocol.encode(cls,value:bytes)->bytes
pydantic.EncoderProtocol.get_json_format(cls)->str
pydantic.PathType
pydantic.PathType.__get_pydantic_core_schema__(self,source:Any,handler:_annotated_handlers.GetCoreSchemaHandler)->core_schema.CoreSchema
pydantic.PathType.__get_pydantic_json_schema__(self,core_schema:core_schema.CoreSchema,handler:_annotated_handlers.GetJsonSchemaHandler)->JsonSchemaValue
pydantic.PathType.__hash__(self)->int
pydantic.PathType.validate_directory(path:Path,_:core_schema.ValidationInfo)->Path
pydantic.PathType.validate_file(path:Path,_:core_schema.ValidationInfo)->Path
pydantic.PathType.validate_new(path:Path,_:core_schema.ValidationInfo)->Path
pydantic.PaymentCardBrand(str,Enum)
pydantic.PaymentCardBrand.__str__(self)->str
pydantic.PaymentCardNumber(self,card_number:str)
pydantic.PaymentCardNumber.__get_pydantic_core_schema__(cls,source:type[Any],handler:_annotated_handlers.GetCoreSchemaHandler)->core_schema.CoreSchema
pydantic.PaymentCardNumber.masked(self)->str
pydantic.PaymentCardNumber.validate(cls,__input_value:str,_:core_schema.ValidationInfo)->PaymentCardNumber
pydantic.PaymentCardNumber.validate_brand(card_number:str)->PaymentCardBrand
pydantic.PaymentCardNumber.validate_digits(cls,card_number:str)->None
pydantic.PaymentCardNumber.validate_luhn_check_digit(cls,card_number:str)->str
pydantic.SecretBytes(SecretField[bytes])
pydantic.SecretBytes._display(self)->bytes
pydantic.SecretField(self,secret_value:SecretType)
pydantic.SecretField.__eq__(self,other:Any)->bool
pydantic.SecretField.__hash__(self)->int
pydantic.SecretField.__len__(self)->int
pydantic.SecretField.__prepare_pydantic_annotations__(cls,source:type[Any],annotations:tuple[Any,...],_config:ConfigDict)->tuple[Any, Iterable[Any]]
pydantic.SecretField.__repr__(self)->str
pydantic.SecretField.__str__(self)->str
pydantic.SecretField._display(self)->SecretType
pydantic.SecretField.get_secret_value(self)->SecretType
pydantic.SecretStr(SecretField[str])
pydantic.SecretStr._display(self)->str
pydantic.Strict(_fields.PydanticMetadata)
pydantic.Strict.__hash__(self)->int
pydantic.TransformSchema
pydantic.TransformSchema.__get_pydantic_core_schema__(self,source_type:type[Any],handler:_annotated_handlers.GetCoreSchemaHandler)->CoreSchema
pydantic.UuidVersion
pydantic.UuidVersion.__get_pydantic_core_schema__(self,source:Any,handler:_annotated_handlers.GetCoreSchemaHandler)->core_schema.CoreSchema
pydantic.UuidVersion.__get_pydantic_json_schema__(self,core_schema:core_schema.CoreSchema,handler:_annotated_handlers.GetJsonSchemaHandler)->JsonSchemaValue
pydantic.UuidVersion.__hash__(self)->int
pydantic.UuidVersion.validate(self,value:UUID,_:core_schema.ValidationInfo)->UUID
pydantic.WithJsonSchema
pydantic.WithJsonSchema.__get_pydantic_json_schema__(self,_core_schema:core_schema.CoreSchema,handler:_annotated_handlers.GetJsonSchemaHandler)->JsonSchemaValue
pydantic._SecretFieldValidator
pydantic._SecretFieldValidator.__get_pydantic_core_schema__(self,source:type[Any],handler:_annotated_handlers.GetCoreSchemaHandler)->core_schema.CoreSchema
pydantic._SecretFieldValidator.__get_pydantic_json_schema__(self,_core_schema:core_schema.CoreSchema,handler:_annotated_handlers.GetJsonSchemaHandler)->JsonSchemaValue
pydantic._SecretFieldValidator.serialize(self,value:SecretField[SecretType],info:core_schema.SerializationInfo)->str | SecretField[SecretType]
pydantic._SecretFieldValidator.validate(self,value:SecretField[SecretType]|SecretType,_:core_schema.ValidationInfo)->Any
pydantic._check_annotated_type(annotated_type:str,expected_type:str,annotation:str)->None
pydantic._secret_display(value:str|bytes)->str
pydantic.conbytes(*,min_length:int|None=None,max_length:int|None=None,strict:bool|None=None)->type[bytes]
pydantic.condate(*,strict:bool|None=None,gt:date|None=None,ge:date|None=None,lt:date|None=None,le:date|None=None)->type[date]
pydantic.condecimal(*,strict:bool|None=None,gt:int|Decimal|None=None,ge:int|Decimal|None=None,lt:int|Decimal|None=None,le:int|Decimal|None=None,multiple_of:int|Decimal|None=None,max_digits:int|None=None,decimal_places:int|None=None,allow_inf_nan:bool|None=None)->type[Decimal]
pydantic.confloat(*,strict:bool|None=None,gt:float|None=None,ge:float|None=None,lt:float|None=None,le:float|None=None,multiple_of:float|None=None,allow_inf_nan:bool|None=None)->type[float]
pydantic.confrozenset(item_type:type[HashableItemType],*,min_length:int|None=None,max_length:int|None=None)->type[frozenset[HashableItemType]]
pydantic.conint(*,strict:bool|None=None,gt:int|None=None,ge:int|None=None,lt:int|None=None,le:int|None=None,multiple_of:int|None=None)->type[int]
pydantic.conlist(item_type:type[AnyItemType],*,min_length:int|None=None,max_length:int|None=None,unique_items:bool|None=None)->type[list[AnyItemType]]
pydantic.conset(item_type:type[HashableItemType],*,min_length:int|None=None,max_length:int|None=None)->type[set[HashableItemType]]
pydantic.constr(*,strip_whitespace:bool|None=None,to_upper:bool|None=None,to_lower:bool|None=None,strict:bool|None=None,min_length:int|None=None,max_length:int|None=None,pattern:str|None=None)->type[str]
pydantic.types.AllowInfNan(_fields.PydanticMetadata)
pydantic.types.AllowInfNan.__hash__(self)->int
pydantic.types.Base64Encoder(EncoderProtocol)
pydantic.types.Base64Encoder.decode(cls,data:bytes)->bytes
pydantic.types.Base64Encoder.encode(cls,value:bytes)->bytes
pydantic.types.Base64Encoder.get_json_format(cls)->str
pydantic.types.ByteSize(int)
pydantic.types.ByteSize.__get_pydantic_core_schema__(cls,source:type[Any],handler:_annotated_handlers.GetCoreSchemaHandler)->core_schema.CoreSchema
pydantic.types.ByteSize.human_readable(self,decimal:bool=False)->str
pydantic.types.ByteSize.to(self,unit:str)->float
pydantic.types.ByteSize.validate(cls,__input_value:Any,_:core_schema.ValidationInfo)->ByteSize
pydantic.types.EncodedBytes
pydantic.types.EncodedBytes.__get_pydantic_core_schema__(self,source:type[Any],handler:Callable[[Any],core_schema.CoreSchema])->core_schema.CoreSchema
pydantic.types.EncodedBytes.__get_pydantic_json_schema__(self,core_schema:core_schema.CoreSchema,handler:_annotated_handlers.GetJsonSchemaHandler)->JsonSchemaValue
pydantic.types.EncodedBytes.__hash__(self)->int
pydantic.types.EncodedBytes.decode(self,data:bytes,_:core_schema.ValidationInfo)->bytes
pydantic.types.EncodedBytes.encode(self,value:bytes)->bytes
pydantic.types.EncodedStr(EncodedBytes)
pydantic.types.EncodedStr.__get_pydantic_core_schema__(self,source:type[Any],handler:Callable[[Any],core_schema.CoreSchema])->core_schema.CoreSchema
pydantic.types.EncodedStr.decode_str(self,data:bytes,_:core_schema.ValidationInfo)->str
pydantic.types.EncodedStr.encode_str(self,value:str)->str
pydantic.types.EncoderProtocol(Protocol)
pydantic.types.EncoderProtocol.decode(cls,data:bytes)->bytes
pydantic.types.EncoderProtocol.encode(cls,value:bytes)->bytes
pydantic.types.EncoderProtocol.get_json_format(cls)->str
pydantic.types.PathType
pydantic.types.PathType.__get_pydantic_core_schema__(self,source:Any,handler:_annotated_handlers.GetCoreSchemaHandler)->core_schema.CoreSchema
pydantic.types.PathType.__get_pydantic_json_schema__(self,core_schema:core_schema.CoreSchema,handler:_annotated_handlers.GetJsonSchemaHandler)->JsonSchemaValue
pydantic.types.PathType.__hash__(self)->int
pydantic.types.PathType.validate_directory(path:Path,_:core_schema.ValidationInfo)->Path
pydantic.types.PathType.validate_file(path:Path,_:core_schema.ValidationInfo)->Path
pydantic.types.PathType.validate_new(path:Path,_:core_schema.ValidationInfo)->Path
pydantic.types.PaymentCardBrand(str,Enum)
pydantic.types.PaymentCardBrand.__str__(self)->str
pydantic.types.PaymentCardNumber(self,card_number:str)
pydantic.types.PaymentCardNumber.__get_pydantic_core_schema__(cls,source:type[Any],handler:_annotated_handlers.GetCoreSchemaHandler)->core_schema.CoreSchema
pydantic.types.PaymentCardNumber.masked(self)->str
pydantic.types.PaymentCardNumber.validate(cls,__input_value:str,_:core_schema.ValidationInfo)->PaymentCardNumber
pydantic.types.PaymentCardNumber.validate_brand(card_number:str)->PaymentCardBrand
pydantic.types.PaymentCardNumber.validate_digits(cls,card_number:str)->None
pydantic.types.PaymentCardNumber.validate_luhn_check_digit(cls,card_number:str)->str
pydantic.types.SecretBytes(SecretField[bytes])
pydantic.types.SecretBytes._display(self)->bytes
pydantic.types.SecretField(self,secret_value:SecretType)
pydantic.types.SecretField.__eq__(self,other:Any)->bool
pydantic.types.SecretField.__hash__(self)->int
pydantic.types.SecretField.__len__(self)->int
pydantic.types.SecretField.__prepare_pydantic_annotations__(cls,source:type[Any],annotations:tuple[Any,...],_config:ConfigDict)->tuple[Any, Iterable[Any]]
pydantic.types.SecretField.__repr__(self)->str
pydantic.types.SecretField.__str__(self)->str
pydantic.types.SecretField._display(self)->SecretType
pydantic.types.SecretField.get_secret_value(self)->SecretType
pydantic.types.SecretStr(SecretField[str])
pydantic.types.SecretStr._display(self)->str
pydantic.types.Strict(_fields.PydanticMetadata)
pydantic.types.Strict.__hash__(self)->int
pydantic.types.TransformSchema
pydantic.types.TransformSchema.__get_pydantic_core_schema__(self,source_type:type[Any],handler:_annotated_handlers.GetCoreSchemaHandler)->CoreSchema
pydantic.types.UuidVersion
pydantic.types.UuidVersion.__get_pydantic_core_schema__(self,source:Any,handler:_annotated_handlers.GetCoreSchemaHandler)->core_schema.CoreSchema
pydantic.types.UuidVersion.__get_pydantic_json_schema__(self,core_schema:core_schema.CoreSchema,handler:_annotated_handlers.GetJsonSchemaHandler)->JsonSchemaValue
pydantic.types.UuidVersion.__hash__(self)->int
pydantic.types.UuidVersion.validate(self,value:UUID,_:core_schema.ValidationInfo)->UUID
pydantic.types.WithJsonSchema
pydantic.types.WithJsonSchema.__get_pydantic_json_schema__(self,_core_schema:core_schema.CoreSchema,handler:_annotated_handlers.GetJsonSchemaHandler)->JsonSchemaValue
pydantic.types._SecretFieldValidator
pydantic.types._SecretFieldValidator.__get_pydantic_core_schema__(self,source:type[Any],handler:_annotated_handlers.GetCoreSchemaHandler)->core_schema.CoreSchema
pydantic.types._SecretFieldValidator.__get_pydantic_json_schema__(self,_core_schema:core_schema.CoreSchema,handler:_annotated_handlers.GetJsonSchemaHandler)->JsonSchemaValue
pydantic.types._SecretFieldValidator.serialize(self,value:SecretField[SecretType],info:core_schema.SerializationInfo)->str | SecretField[SecretType]
pydantic.types._SecretFieldValidator.validate(self,value:SecretField[SecretType]|SecretType,_:core_schema.ValidationInfo)->Any
pydantic.types._check_annotated_type(annotated_type:str,expected_type:str,annotation:str)->None
pydantic.types._secret_display(value:str|bytes)->str
pydantic.types.conbytes(*,min_length:int|None=None,max_length:int|None=None,strict:bool|None=None)->type[bytes]
pydantic.types.condate(*,strict:bool|None=None,gt:date|None=None,ge:date|None=None,lt:date|None=None,le:date|None=None)->type[date]
pydantic.types.condecimal(*,strict:bool|None=None,gt:int|Decimal|None=None,ge:int|Decimal|None=None,lt:int|Decimal|None=None,le:int|Decimal|None=None,multiple_of:int|Decimal|None=None,max_digits:int|None=None,decimal_places:int|None=None,allow_inf_nan:bool|None=None)->type[Decimal]
pydantic.types.confloat(*,strict:bool|None=None,gt:float|None=None,ge:float|None=None,lt:float|None=None,le:float|None=None,multiple_of:float|None=None,allow_inf_nan:bool|None=None)->type[float]
pydantic.types.confrozenset(item_type:type[HashableItemType],*,min_length:int|None=None,max_length:int|None=None)->type[frozenset[HashableItemType]]
pydantic.types.conint(*,strict:bool|None=None,gt:int|None=None,ge:int|None=None,lt:int|None=None,le:int|None=None,multiple_of:int|None=None)->type[int]
pydantic.types.conlist(item_type:type[AnyItemType],*,min_length:int|None=None,max_length:int|None=None,unique_items:bool|None=None)->type[list[AnyItemType]]
pydantic.types.conset(item_type:type[HashableItemType],*,min_length:int|None=None,max_length:int|None=None)->type[set[HashableItemType]]
pydantic.types.constr(*,strip_whitespace:bool|None=None,to_upper:bool|None=None,to_lower:bool|None=None,strict:bool|None=None,min_length:int|None=None,max_length:int|None=None,pattern:str|None=None)->type[str]


----------------------------------------/home/zhang/Packages/pydantic/pydantic2.0b1/color.py----------------------------------------
A:pydantic.color.self._rgba->parse_str(value)
A:pydantic.color.rgb->cast(Tuple[int, int, int], self.as_rgb_tuple())
A:pydantic.color.as_hex->''.join((as_hex[c] for c in range(0, len(as_hex), 2)))
A:pydantic.color.(h, s, li)->self.as_hsl_tuple(alpha=False)
A:pydantic.color.(h, s, li, a)->self.as_hsl_tuple(alpha=True)
A:pydantic.color.(h, l, s)->rgb_to_hls(self._rgba.r, self._rgba.g, self._rgba.b)
A:pydantic.color.value_lower->value.lower()
A:pydantic.color.m->re.fullmatch(r_hex_long, value_lower)
A:pydantic.color.(*rgb, a)->re.fullmatch(r_hex_long, value_lower).groups()
A:pydantic.color.color->float(value)
A:pydantic.color.alpha->float(value)
A:pydantic.color.h_value->float(h)
A:pydantic.color.(r, g, b)->hls_to_rgb(h_value, l_value, s_value)
pydantic.color.Color(self,value:ColorType)
pydantic.color.Color.__eq__(self,other:Any)->bool
pydantic.color.Color.__get_pydantic_core_schema__(cls,source:Type[Any],handler:Callable[[Any],CoreSchema])->core_schema.CoreSchema
pydantic.color.Color.__get_pydantic_json_schema__(cls,core_schema:core_schema.CoreSchema,handler:_GetJsonSchemaHandler)->JsonSchemaValue
pydantic.color.Color.__hash__(self)->int
pydantic.color.Color.__repr_args__(self)->'_repr.ReprArgs'
pydantic.color.Color.__str__(self)->str
pydantic.color.Color._alpha_float(self)->float
pydantic.color.Color._validate(cls,__input_value:Any,_:Any)->'Color'
pydantic.color.Color.as_hex(self)->str
pydantic.color.Color.as_hsl(self)->str
pydantic.color.Color.as_hsl_tuple(self,*,alpha:Optional[bool]=None)->HslColorTuple
pydantic.color.Color.as_named(self,*,fallback:bool=False)->str
pydantic.color.Color.as_rgb(self)->str
pydantic.color.Color.as_rgb_tuple(self,*,alpha:Optional[bool]=None)->ColorTuple
pydantic.color.Color.original(self)->ColorType
pydantic.color.RGBA(self,r:float,g:float,b:float,alpha:Optional[float])
pydantic.color.RGBA.__getitem__(self,item:Any)->Any
pydantic.color.float_to_255(c:float)->int
pydantic.color.ints_to_rgba(r:Union[int,str],g:Union[int,str],b:Union[int,str],alpha:Optional[float]=None)->RGBA
pydantic.color.parse_color_value(value:Union[int,str],max_val:int=255)->float
pydantic.color.parse_float_alpha(value:Union[None,str,float,int])->Optional[float]
pydantic.color.parse_hsl(h:str,h_units:str,sat:str,light:str,alpha:Optional[float]=None)->RGBA
pydantic.color.parse_str(value:str)->RGBA
pydantic.color.parse_tuple(value:Tuple[Any,...])->RGBA


----------------------------------------/home/zhang/Packages/pydantic/pydantic2.0b1/dataclasses.py----------------------------------------
A:pydantic.dataclasses._T->TypeVar('_T')
A:pydantic.dataclasses.kwargs->dict(kw_only=kw_only, slots=slots)
A:pydantic.dataclasses.config_wrapper->_internal._config.ConfigWrapper(config)
A:pydantic.dataclasses.decorators->_internal._decorators.DecoratorInfos.build(cls)
A:pydantic.dataclasses.cls->dataclasses.dataclass(cls, init=init, repr=repr, eq=eq, order=order, unsafe_hash=unsafe_hash, frozen=frozen, **kwargs)
A:pydantic.dataclasses.pydantic_complete->_internal._dataclasses.complete_dataclass(cls, config_wrapper, raise_errors=False, types_namespace=None)
A:pydantic.dataclasses.__getattr__->getattr_migration(__name__)
A:pydantic.dataclasses.types_namespace->_internal._typing_extra.get_cls_types_namespace(cls, types_namespace)
pydantic.dataclasses.dataclass(_cls:type[_T]|None=None,*,init:Literal[False]=False,repr:bool=True,eq:bool=True,order:bool=False,unsafe_hash:bool=False,frozen:bool=False,config:ConfigDict|type[object]|None=None,validate_on_init:bool|None=None,kw_only:bool=False,slots:bool=False)->Callable[[type[_T]], type[PydanticDataclass]] | type[PydanticDataclass]
pydantic.dataclasses.rebuild_dataclass(cls:type[PydanticDataclass],*,force:bool=False,raise_errors:bool=True,_parent_namespace_depth:int=2,_types_namespace:dict[str,Any]|None=None)->bool | None


----------------------------------------/home/zhang/Packages/pydantic/pydantic2.0b1/class_validators.py----------------------------------------
A:pydantic.class_validators.__getattr__->getattr_migration(__name__)


----------------------------------------/home/zhang/Packages/pydantic/pydantic2.0b1/validators.py----------------------------------------
A:pydantic.validators.__getattr__->getattr_migration(__name__)


----------------------------------------/home/zhang/Packages/pydantic/pydantic2.0b1/utils.py----------------------------------------
A:pydantic.utils.__getattr__->getattr_migration(__name__)


----------------------------------------/home/zhang/Packages/pydantic/pydantic2.0b1/decorator.py----------------------------------------
A:pydantic.decorator.__getattr__->getattr_migration(__name__)


----------------------------------------/home/zhang/Packages/pydantic/pydantic2.0b1/parse.py----------------------------------------
A:pydantic.parse.__getattr__->getattr_migration(__name__)


----------------------------------------/home/zhang/Packages/pydantic/pydantic2.0b1/functional_validators.py----------------------------------------
A:pydantic.functional_validators.schema->handler(source_type)
A:pydantic.functional_validators.info_arg->_inspect_validator(self.func, 'wrap')
A:pydantic.functional_validators._V2BeforeAfterOrPlainValidatorType->TypeVar('_V2BeforeAfterOrPlainValidatorType', _V2Validator, _PartialClsOrStaticMethod)
A:pydantic.functional_validators._V2WrapValidatorType->TypeVar('_V2WrapValidatorType', _V2WrapValidator, _PartialClsOrStaticMethod)
A:pydantic.functional_validators.f->_internal._decorators.ensure_classmethod_based_on_signature(f)
A:pydantic.functional_validators.dec_info->_internal._decorators.ModelValidatorDecoratorInfo(mode=mode)
A:pydantic.functional_validators._ModelType->TypeVar('_ModelType')
A:pydantic.functional_validators._ModelTypeCo->TypeVar('_ModelTypeCo', covariant=True)
pydantic.field_validator(__field:str,*fields:str,mode:FieldValidatorModes='after',check_fields:bool|None=None)->Callable[[Any], Any]
pydantic.field_validator(__field:str,*fields:str,mode:Literal['before','after','plain']=...,check_fields:bool|None=...)->Callable[[_V2BeforeAfterOrPlainValidatorType], _V2BeforeAfterOrPlainValidatorType]
pydantic.field_validator(__field:str,*fields:str,mode:Literal['wrap'],check_fields:bool|None=...)->Callable[[_V2WrapValidatorType], _V2WrapValidatorType]
pydantic.functional_validators.AfterValidator
pydantic.functional_validators.AfterValidator.__get_pydantic_core_schema__(self,source_type:Any,handler:_GetCoreSchemaHandler)->core_schema.CoreSchema
pydantic.functional_validators.BeforeValidator
pydantic.functional_validators.BeforeValidator.__get_pydantic_core_schema__(self,source_type:Any,handler:_GetCoreSchemaHandler)->core_schema.CoreSchema
pydantic.functional_validators.ModelAfterValidator(self:_ModelType,__info:_core_schema.ValidationInfo)
pydantic.functional_validators.ModelAfterValidatorWithoutInfo(self:_ModelType)
pydantic.functional_validators.ModelBeforeValidator(self,cls:Any,__value:Any,__info:_core_schema.ValidationInfo)
pydantic.functional_validators.ModelBeforeValidatorWithoutInfo(self,cls:Any,__value:Any)
pydantic.functional_validators.ModelWrapValidator(self,cls:type[_ModelType],__value:Any,__handler:ModelWrapValidatorHandler[_ModelType],__info:_core_schema.ValidationInfo)
pydantic.functional_validators.ModelWrapValidatorHandler(self,input_value:Any,outer_location:str|int|None=None)
pydantic.functional_validators.ModelWrapValidatorWithoutInfo(self,cls:type[_ModelType],__value:Any,__handler:ModelWrapValidatorHandler[_ModelType])
pydantic.functional_validators.PlainValidator
pydantic.functional_validators.PlainValidator.__get_pydantic_core_schema__(self,source_type:Any,handler:_GetCoreSchemaHandler)->core_schema.CoreSchema
pydantic.functional_validators.WrapValidator
pydantic.functional_validators.WrapValidator.__get_pydantic_core_schema__(self,source_type:Any,handler:_GetCoreSchemaHandler)->core_schema.CoreSchema
pydantic.functional_validators.field_validator(__field:str,*fields:str,mode:FieldValidatorModes='after',check_fields:bool|None=None)->Callable[[Any], Any]
pydantic.functional_validators.field_validator(__field:str,*fields:str,mode:Literal['before','after','plain']=...,check_fields:bool|None=...)->Callable[[_V2BeforeAfterOrPlainValidatorType], _V2BeforeAfterOrPlainValidatorType]
pydantic.functional_validators.field_validator(__field:str,*fields:str,mode:Literal['wrap'],check_fields:bool|None=...)->Callable[[_V2WrapValidatorType], _V2WrapValidatorType]
pydantic.functional_validators.model_validator(*,mode:Literal['after'])->Callable[[_AnyModeAfterValidator], _decorators.PydanticDescriptorProxy[_decorators.ModelValidatorDecoratorInfo]]
pydantic.functional_validators.model_validator(*,mode:Literal['before'])->Callable[[_AnyModeBeforeValidator], _decorators.PydanticDescriptorProxy[_decorators.ModelValidatorDecoratorInfo]]
pydantic.functional_validators.model_validator(*,mode:Literal['wrap','before','after'])->Any
pydantic.functional_validators.model_validator(*,mode:Literal['wrap'])->Callable[[_AnyModelWrapValidator], _decorators.PydanticDescriptorProxy[_decorators.ModelValidatorDecoratorInfo]]
pydantic.model_validator(*,mode:Literal['after'])->Callable[[_AnyModeAfterValidator], _decorators.PydanticDescriptorProxy[_decorators.ModelValidatorDecoratorInfo]]
pydantic.model_validator(*,mode:Literal['before'])->Callable[[_AnyModeBeforeValidator], _decorators.PydanticDescriptorProxy[_decorators.ModelValidatorDecoratorInfo]]
pydantic.model_validator(*,mode:Literal['wrap','before','after'])->Any
pydantic.model_validator(*,mode:Literal['wrap'])->Callable[[_AnyModelWrapValidator], _decorators.PydanticDescriptorProxy[_decorators.ModelValidatorDecoratorInfo]]


----------------------------------------/home/zhang/Packages/pydantic/pydantic2.0b1/env_settings.py----------------------------------------
A:pydantic.env_settings.__getattr__->getattr_migration(__name__)


----------------------------------------/home/zhang/Packages/pydantic/pydantic2.0b1/tools.py----------------------------------------
A:pydantic.tools.__getattr__->getattr_migration(__name__)


----------------------------------------/home/zhang/Packages/pydantic/pydantic2.0b1/datetime_parse.py----------------------------------------
A:pydantic.datetime_parse.__getattr__->getattr_migration(__name__)


----------------------------------------/home/zhang/Packages/pydantic/pydantic2.0b1/_migration.py----------------------------------------
pydantic._migration.getattr_migration(module:str)->Callable[[str], Any]
pydantic.getattr_migration(module:str)->Callable[[str], Any]


----------------------------------------/home/zhang/Packages/pydantic/pydantic2.0b1/errors.py----------------------------------------
A:pydantic.errors.name->re.search(".*'(.+?)'", str(name_error)).group(1)
A:pydantic.errors.__getattr__->getattr_migration(__name__)
pydantic.PydanticErrorMixin(self,message:str,*,code:PydanticErrorCodes|None)
pydantic.PydanticErrorMixin.__str__(self)->str
pydantic.PydanticImportError(self,message:str)
pydantic.PydanticInvalidForJsonSchema(self,message:str)
pydantic.PydanticSchemaGenerationError(self,message:str)
pydantic.PydanticUndefinedAnnotation(self,name:str,message:str)
pydantic.PydanticUndefinedAnnotation.from_name_error(cls,name_error:NameError)->Self
pydantic.PydanticUserError(PydanticErrorMixin,TypeError)
pydantic.errors.PydanticErrorMixin(self,message:str,*,code:PydanticErrorCodes|None)
pydantic.errors.PydanticErrorMixin.__str__(self)->str
pydantic.errors.PydanticImportError(self,message:str)
pydantic.errors.PydanticInvalidForJsonSchema(self,message:str)
pydantic.errors.PydanticSchemaGenerationError(self,message:str)
pydantic.errors.PydanticUndefinedAnnotation(self,name:str,message:str)
pydantic.errors.PydanticUndefinedAnnotation.from_name_error(cls,name_error:NameError)->Self
pydantic.errors.PydanticUserError(PydanticErrorMixin,TypeError)


----------------------------------------/home/zhang/Packages/pydantic/pydantic2.0b1/type_adapter.py----------------------------------------
A:pydantic.type_adapter.T->TypeVar('T')
A:pydantic.type_adapter.local_ns->_internal._typing_extra.parent_frame_namespace(parent_depth=parent_depth)
A:pydantic.type_adapter.global_ns->sys._getframe(max(parent_depth - 1, 1)).f_globals.copy()
A:pydantic.type_adapter.gen->_internal._generate_schema.GenerateSchema(config_wrapper, types_namespace=global_ns, typevars_map={})
A:pydantic.type_adapter.slots->getattr(obj, '__slots__', None)
A:pydantic.type_adapter.config_wrapper->_internal._config.ConfigWrapper(config)
A:pydantic.type_adapter.core_schema->_internal._core_utils.flatten_schema_defs(core_schema)
A:pydantic.type_adapter.simplified_core_schema->_internal._core_utils.inline_schema_defs(core_schema)
A:pydantic.type_adapter.core_config->_internal._config.ConfigWrapper(config).core_config(None)
A:pydantic.type_adapter.validator->SchemaValidator(simplified_core_schema, core_config)
A:pydantic.type_adapter.serializer->SchemaSerializer(simplified_core_schema, core_config)
A:pydantic.type_adapter.schema_generator_instance->schema_generator(by_alias=by_alias, ref_template=ref_template)
A:pydantic.type_adapter.(key_map, definitions)->schema_generator(by_alias=by_alias, ref_template=ref_template).generate_definitions(inputs)
pydantic.TypeAdapter(self,type:Any,*,config:ConfigDict|None=None,_parent_depth:int=2)
pydantic.TypeAdapter.dump_json(self,__instance:T,*,indent:int|None=None,include:IncEx|None=None,exclude:IncEx|None=None,by_alias:bool=False,exclude_unset:bool=False,exclude_defaults:bool=False,exclude_none:bool=False,round_trip:bool=False,warnings:bool=True)->bytes
pydantic.TypeAdapter.dump_python(self,__instance:T,*,mode:Literal['json','python']='python',include:IncEx|None=None,exclude:IncEx|None=None,by_alias:bool=False,exclude_unset:bool=False,exclude_defaults:bool=False,exclude_none:bool=False,round_trip:bool=False,warnings:bool=True)->Any
pydantic.TypeAdapter.get_default_value(self,*,strict:bool|None=None,context:dict[str,Any]|None=None)->Some[T] | None
pydantic.TypeAdapter.json_schema(self,*,by_alias:bool=True,ref_template:str=DEFAULT_REF_TEMPLATE,schema_generator:type[GenerateJsonSchema]=GenerateJsonSchema,mode:JsonSchemaMode='validation')->dict[str, Any]
pydantic.TypeAdapter.json_schemas(__inputs:Iterable[tuple[JsonSchemaKeyT,JsonSchemaMode,TypeAdapter[Any]]],*,by_alias:bool=True,title:str|None=None,description:str|None=None,ref_template:str=DEFAULT_REF_TEMPLATE,schema_generator:type[GenerateJsonSchema]=GenerateJsonSchema)->tuple[dict[tuple[JsonSchemaKeyT, JsonSchemaMode], DefsRef], JsonSchemaValue]
pydantic.TypeAdapter.validate_json(self,__data:str|bytes,*,strict:bool|None=None,context:dict[str,Any]|None=None)->T
pydantic.TypeAdapter.validate_python(self,__object:Any,*,strict:bool|None=None,context:dict[str,Any]|None=None)->T
pydantic.type_adapter.TypeAdapter(self,type:Any,*,config:ConfigDict|None=None,_parent_depth:int=2)
pydantic.type_adapter.TypeAdapter.dump_json(self,__instance:T,*,indent:int|None=None,include:IncEx|None=None,exclude:IncEx|None=None,by_alias:bool=False,exclude_unset:bool=False,exclude_defaults:bool=False,exclude_none:bool=False,round_trip:bool=False,warnings:bool=True)->bytes
pydantic.type_adapter.TypeAdapter.dump_python(self,__instance:T,*,mode:Literal['json','python']='python',include:IncEx|None=None,exclude:IncEx|None=None,by_alias:bool=False,exclude_unset:bool=False,exclude_defaults:bool=False,exclude_none:bool=False,round_trip:bool=False,warnings:bool=True)->Any
pydantic.type_adapter.TypeAdapter.get_default_value(self,*,strict:bool|None=None,context:dict[str,Any]|None=None)->Some[T] | None
pydantic.type_adapter.TypeAdapter.json_schema(self,*,by_alias:bool=True,ref_template:str=DEFAULT_REF_TEMPLATE,schema_generator:type[GenerateJsonSchema]=GenerateJsonSchema,mode:JsonSchemaMode='validation')->dict[str, Any]
pydantic.type_adapter.TypeAdapter.json_schemas(__inputs:Iterable[tuple[JsonSchemaKeyT,JsonSchemaMode,TypeAdapter[Any]]],*,by_alias:bool=True,title:str|None=None,description:str|None=None,ref_template:str=DEFAULT_REF_TEMPLATE,schema_generator:type[GenerateJsonSchema]=GenerateJsonSchema)->tuple[dict[tuple[JsonSchemaKeyT, JsonSchemaMode], DefsRef], JsonSchemaValue]
pydantic.type_adapter.TypeAdapter.validate_json(self,__data:str|bytes,*,strict:bool|None=None,context:dict[str,Any]|None=None)->T
pydantic.type_adapter.TypeAdapter.validate_python(self,__object:Any,*,strict:bool|None=None,context:dict[str,Any]|None=None)->T
pydantic.type_adapter._get_schema(type_:Any,config_wrapper:_config.ConfigWrapper,parent_depth:int)->CoreSchema
pydantic.type_adapter._getattr_no_parents(obj:Any,attribute:str)->Any


----------------------------------------/home/zhang/Packages/pydantic/pydantic2.0b1/error_wrappers.py----------------------------------------
A:pydantic.error_wrappers.__getattr__->getattr_migration(__name__)


----------------------------------------/home/zhang/Packages/pydantic/pydantic2.0b1/main.py----------------------------------------
A:pydantic.main.Model->typing.TypeVar('Model', bound='BaseModel')
A:pydantic.main.__pydantic_decorators__->_internal._decorators.DecoratorInfos()
A:pydantic.main.__pydantic_validator__->_internal._model_construction.MockValidator('Pydantic models should inherit from BaseModel, BaseModel cannot be instantiated directly', code='base-model-instantiated')
A:pydantic.main.model_config->ConfigDict()
A:pydantic.main.attr->getattr(self.__class__, name, None)
A:pydantic.main.m->type(self).__new__(cls)
A:pydantic.main.fields_values[name]->field.get_default(call_default_factory=True)
A:pydantic.main._fields_set->set(values.keys())
A:pydantic.main.types_namespace->_internal._typing_extra.get_cls_types_namespace(cls, types_namespace)
A:pydantic.main.cls->type(self)
A:pydantic.main.cached->_internal._generics.get_cached_generic_type_late(cls, typevar_values, origin, args)
A:pydantic.main.args->tuple((_generics.replace_types(arg, typevars_map) for arg in parent_args))
A:pydantic.main.model_name->origin.model_parametrized_name(args)
A:pydantic.main.params->tuple({param: None for param in _generics.iter_contained_typevars(typevars_map.values())})
A:pydantic.main.submodel->_internal._generics.create_generic_submodel(model_name, origin, args, params)
A:pydantic.main.params_component->', '.join(param_names)
A:pydantic.main.obj->deprecated.parse.load_file(path, proto=proto, content_type=content_type, encoding=encoding, allow_pickle=allow_pickle)
A:pydantic.main.values->dict(_deprecated_copy_internals._iter(self, to_dict=False, by_alias=False, include=include, exclude=exclude, exclude_unset=False), **update or {})
A:pydantic.main.extra->self.__pydantic_extra__.copy()
A:pydantic.main.extra[k]->dict(_deprecated_copy_internals._iter(self, to_dict=False, by_alias=False, include=include, exclude=exclude, exclude_unset=False), **update or {}).pop(k)
A:pydantic.main.fields_set->set(self.__pydantic_fields_set__)
A:pydantic.main.RootModelRootType->typing.TypeVar('RootModelRootType')
A:pydantic.main.f_def->typing.cast('tuple[str, Any]', f_def)
A:pydantic.main.resolved_bases->types.resolve_bases(__base__)
A:pydantic.main.(meta, ns, kwds)->types.prepare_class(__model_name, resolved_bases, kwds=__cls_kwargs__)
A:pydantic.main.__getattr__->getattr_migration(__name__)
pydantic.BaseModel(__pydantic_self__,**data:Any)
pydantic.BaseModel.__class_getitem__(cls,typevar_values:type[Any]|tuple[type[Any],...])->type[BaseModel] | _forward_ref.PydanticForwardRef | _forward_ref.PydanticRecursiveRef
pydantic.BaseModel.__copy__(self:Model)->Model
pydantic.BaseModel.__deepcopy__(self:Model,memo:dict[int,Any]|None=None)->Model
pydantic.BaseModel.__eq__(self,other:Any)->bool
pydantic.BaseModel.__fields__(self)->dict[str, FieldInfo]
pydantic.BaseModel.__fields_set__(self)->set[str]
pydantic.BaseModel.__get_pydantic_core_schema__(cls,__source:type[BaseModel],__handler:_annotated_handlers.GetCoreSchemaHandler)->CoreSchema
pydantic.BaseModel.__get_pydantic_json_schema__(cls,__core_schema:CoreSchema,__handler:_annotated_handlers.GetJsonSchemaHandler)->JsonSchemaValue
pydantic.BaseModel.__getstate__(self)->dict[Any, Any]
pydantic.BaseModel.__iter__(self)->TupleGenerator
pydantic.BaseModel.__pydantic_init_subclass__(cls,**kwargs:Any)->None
pydantic.BaseModel.__repr__(self)->str
pydantic.BaseModel.__repr_args__(self)->_repr.ReprArgs
pydantic.BaseModel.__setattr__(self,name:str,value:Any)->None
pydantic.BaseModel.__setstate__(self,state:dict[Any,Any])->None
pydantic.BaseModel.__str__(self)->str
pydantic.BaseModel._calculate_keys(self,*args:Any,**kwargs:Any)->Any
pydantic.BaseModel._copy_and_set_values(self,*args:Any,**kwargs:Any)->Any
pydantic.BaseModel._get_value(cls,*args:Any,**kwargs:Any)->Any
pydantic.BaseModel._iter(self,*args:Any,**kwargs:Any)->Any
pydantic.BaseModel.construct(cls:type[Model],_fields_set:set[str]|None=None,**values:Any)->Model
pydantic.BaseModel.copy(self:Model,*,include:AbstractSetIntStr|MappingIntStrAny|None=None,exclude:AbstractSetIntStr|MappingIntStrAny|None=None,update:typing.Dict[str,Any]|None=None,deep:bool=False)->Model
pydantic.BaseModel.dict(self,*,include:IncEx=None,exclude:IncEx=None,by_alias:bool=False,exclude_unset:bool=False,exclude_defaults:bool=False,exclude_none:bool=False)->typing.Dict[str, Any]
pydantic.BaseModel.from_orm(cls:type[Model],obj:Any)->Model
pydantic.BaseModel.json(self,*,include:IncEx=None,exclude:IncEx=None,by_alias:bool=False,exclude_unset:bool=False,exclude_defaults:bool=False,exclude_none:bool=False,encoder:typing.Callable[[Any],Any]|None=_Undefined,models_as_dict:bool=_Undefined,**dumps_kwargs:Any)->str
pydantic.BaseModel.model_computed_fields(self)->dict[str, ComputedFieldInfo]
pydantic.BaseModel.model_construct(cls:type[Model],_fields_set:set[str]|None=None,**values:Any)->Model
pydantic.BaseModel.model_copy(self:Model,*,update:dict[str,Any]|None=None,deep:bool=False)->Model
pydantic.BaseModel.model_dump(self,*,mode:Literal['json','python']|str='python',include:IncEx=None,exclude:IncEx=None,by_alias:bool=False,exclude_unset:bool=False,exclude_defaults:bool=False,exclude_none:bool=False,round_trip:bool=False,warnings:bool=True)->dict[str, Any]
pydantic.BaseModel.model_dump_json(self,*,indent:int|None=None,include:IncEx=None,exclude:IncEx=None,by_alias:bool=False,exclude_unset:bool=False,exclude_defaults:bool=False,exclude_none:bool=False,round_trip:bool=False,warnings:bool=True)->str
pydantic.BaseModel.model_extra(self)->dict[str, Any] | None
pydantic.BaseModel.model_fields_set(self)->set[str]
pydantic.BaseModel.model_json_schema(cls,by_alias:bool=True,ref_template:str=DEFAULT_REF_TEMPLATE,schema_generator:type[GenerateJsonSchema]=GenerateJsonSchema,mode:JsonSchemaMode='validation')->dict[str, Any]
pydantic.BaseModel.model_parametrized_name(cls,params:tuple[type[Any],...])->str
pydantic.BaseModel.model_post_init(self,__context:Any)->None
pydantic.BaseModel.model_rebuild(cls,*,force:bool=False,raise_errors:bool=True,_parent_namespace_depth:int=2,_types_namespace:dict[str,Any]|None=None)->bool | None
pydantic.BaseModel.model_validate(cls:type[Model],obj:Any,*,strict:bool|None=None,context:dict[str,Any]|None=None)->Model
pydantic.BaseModel.model_validate_json(cls:type[Model],json_data:str|bytes|bytearray,*,strict:bool|None=None,context:dict[str,Any]|None=None)->Model
pydantic.BaseModel.parse_file(cls:type[Model],path:str|Path,*,content_type:str|None=None,encoding:str='utf8',proto:_deprecated_parse.Protocol|None=None,allow_pickle:bool=False)->Model
pydantic.BaseModel.parse_obj(cls:type[Model],obj:Any)->Model
pydantic.BaseModel.parse_raw(cls:type[Model],b:str|bytes,*,content_type:str|None=None,encoding:str='utf8',proto:_deprecated_parse.Protocol|None=None,allow_pickle:bool=False)->Model
pydantic.BaseModel.schema(cls,by_alias:bool=True,ref_template:str=DEFAULT_REF_TEMPLATE)->typing.Dict[str, Any]
pydantic.BaseModel.schema_json(cls,*,by_alias:bool=True,ref_template:str=DEFAULT_REF_TEMPLATE,**dumps_kwargs:Any)->str
pydantic.BaseModel.update_forward_refs(cls,**localns:Any)->None
pydantic.BaseModel.validate(cls:type[Model],value:Any)->Model
pydantic.RootModel(__pydantic_self__,root:RootModelRootType)
pydantic.RootModel.__eq__(self,other:Any)->bool
pydantic.RootModel.__repr_args__(self)->_repr.ReprArgs
pydantic.RootModel.model_construct(cls:type[Model],root:RootModelRootType,_fields_set:set[str]|None=None)->Model
pydantic.create_model(__model_name:str,*,__config__:ConfigDict|None=None,__base__:None=None,__module__:str=__name__,__validators__:dict[str,AnyClassMethod]|None=None,__cls_kwargs__:dict[str,Any]|None=None,**field_definitions:Any)->type[BaseModel]
pydantic.create_model(__model_name:str,*,__config__:ConfigDict|None=None,__base__:type[Model]|tuple[type[Model],...],__module__:str=__name__,__validators__:dict[str,AnyClassMethod]|None=None,__cls_kwargs__:dict[str,Any]|None=None,**field_definitions:Any)->type[Model]
pydantic.create_model(__model_name:str,*,__config__:ConfigDict|None=None,__base__:type[Model]|tuple[type[Model],...]|None=None,__module__:str=__name__,__validators__:dict[str,AnyClassMethod]|None=None,__cls_kwargs__:dict[str,Any]|None=None,__slots__:tuple[str,...]|None=None,**field_definitions:Any)->type[Model]
pydantic.main.BaseModel(__pydantic_self__,**data:Any)
pydantic.main.BaseModel.__class_getitem__(cls,typevar_values:type[Any]|tuple[type[Any],...])->type[BaseModel] | _forward_ref.PydanticForwardRef | _forward_ref.PydanticRecursiveRef
pydantic.main.BaseModel.__copy__(self:Model)->Model
pydantic.main.BaseModel.__deepcopy__(self:Model,memo:dict[int,Any]|None=None)->Model
pydantic.main.BaseModel.__eq__(self,other:Any)->bool
pydantic.main.BaseModel.__fields__(self)->dict[str, FieldInfo]
pydantic.main.BaseModel.__fields_set__(self)->set[str]
pydantic.main.BaseModel.__get_pydantic_core_schema__(cls,__source:type[BaseModel],__handler:_annotated_handlers.GetCoreSchemaHandler)->CoreSchema
pydantic.main.BaseModel.__get_pydantic_json_schema__(cls,__core_schema:CoreSchema,__handler:_annotated_handlers.GetJsonSchemaHandler)->JsonSchemaValue
pydantic.main.BaseModel.__getstate__(self)->dict[Any, Any]
pydantic.main.BaseModel.__iter__(self)->TupleGenerator
pydantic.main.BaseModel.__pydantic_init_subclass__(cls,**kwargs:Any)->None
pydantic.main.BaseModel.__repr__(self)->str
pydantic.main.BaseModel.__repr_args__(self)->_repr.ReprArgs
pydantic.main.BaseModel.__setattr__(self,name:str,value:Any)->None
pydantic.main.BaseModel.__setstate__(self,state:dict[Any,Any])->None
pydantic.main.BaseModel.__str__(self)->str
pydantic.main.BaseModel._calculate_keys(self,*args:Any,**kwargs:Any)->Any
pydantic.main.BaseModel._copy_and_set_values(self,*args:Any,**kwargs:Any)->Any
pydantic.main.BaseModel._get_value(cls,*args:Any,**kwargs:Any)->Any
pydantic.main.BaseModel._iter(self,*args:Any,**kwargs:Any)->Any
pydantic.main.BaseModel.construct(cls:type[Model],_fields_set:set[str]|None=None,**values:Any)->Model
pydantic.main.BaseModel.copy(self:Model,*,include:AbstractSetIntStr|MappingIntStrAny|None=None,exclude:AbstractSetIntStr|MappingIntStrAny|None=None,update:typing.Dict[str,Any]|None=None,deep:bool=False)->Model
pydantic.main.BaseModel.dict(self,*,include:IncEx=None,exclude:IncEx=None,by_alias:bool=False,exclude_unset:bool=False,exclude_defaults:bool=False,exclude_none:bool=False)->typing.Dict[str, Any]
pydantic.main.BaseModel.from_orm(cls:type[Model],obj:Any)->Model
pydantic.main.BaseModel.json(self,*,include:IncEx=None,exclude:IncEx=None,by_alias:bool=False,exclude_unset:bool=False,exclude_defaults:bool=False,exclude_none:bool=False,encoder:typing.Callable[[Any],Any]|None=_Undefined,models_as_dict:bool=_Undefined,**dumps_kwargs:Any)->str
pydantic.main.BaseModel.model_computed_fields(self)->dict[str, ComputedFieldInfo]
pydantic.main.BaseModel.model_construct(cls:type[Model],_fields_set:set[str]|None=None,**values:Any)->Model
pydantic.main.BaseModel.model_copy(self:Model,*,update:dict[str,Any]|None=None,deep:bool=False)->Model
pydantic.main.BaseModel.model_dump(self,*,mode:Literal['json','python']|str='python',include:IncEx=None,exclude:IncEx=None,by_alias:bool=False,exclude_unset:bool=False,exclude_defaults:bool=False,exclude_none:bool=False,round_trip:bool=False,warnings:bool=True)->dict[str, Any]
pydantic.main.BaseModel.model_dump_json(self,*,indent:int|None=None,include:IncEx=None,exclude:IncEx=None,by_alias:bool=False,exclude_unset:bool=False,exclude_defaults:bool=False,exclude_none:bool=False,round_trip:bool=False,warnings:bool=True)->str
pydantic.main.BaseModel.model_extra(self)->dict[str, Any] | None
pydantic.main.BaseModel.model_fields_set(self)->set[str]
pydantic.main.BaseModel.model_json_schema(cls,by_alias:bool=True,ref_template:str=DEFAULT_REF_TEMPLATE,schema_generator:type[GenerateJsonSchema]=GenerateJsonSchema,mode:JsonSchemaMode='validation')->dict[str, Any]
pydantic.main.BaseModel.model_parametrized_name(cls,params:tuple[type[Any],...])->str
pydantic.main.BaseModel.model_post_init(self,__context:Any)->None
pydantic.main.BaseModel.model_rebuild(cls,*,force:bool=False,raise_errors:bool=True,_parent_namespace_depth:int=2,_types_namespace:dict[str,Any]|None=None)->bool | None
pydantic.main.BaseModel.model_validate(cls:type[Model],obj:Any,*,strict:bool|None=None,context:dict[str,Any]|None=None)->Model
pydantic.main.BaseModel.model_validate_json(cls:type[Model],json_data:str|bytes|bytearray,*,strict:bool|None=None,context:dict[str,Any]|None=None)->Model
pydantic.main.BaseModel.parse_file(cls:type[Model],path:str|Path,*,content_type:str|None=None,encoding:str='utf8',proto:_deprecated_parse.Protocol|None=None,allow_pickle:bool=False)->Model
pydantic.main.BaseModel.parse_obj(cls:type[Model],obj:Any)->Model
pydantic.main.BaseModel.parse_raw(cls:type[Model],b:str|bytes,*,content_type:str|None=None,encoding:str='utf8',proto:_deprecated_parse.Protocol|None=None,allow_pickle:bool=False)->Model
pydantic.main.BaseModel.schema(cls,by_alias:bool=True,ref_template:str=DEFAULT_REF_TEMPLATE)->typing.Dict[str, Any]
pydantic.main.BaseModel.schema_json(cls,*,by_alias:bool=True,ref_template:str=DEFAULT_REF_TEMPLATE,**dumps_kwargs:Any)->str
pydantic.main.BaseModel.update_forward_refs(cls,**localns:Any)->None
pydantic.main.BaseModel.validate(cls:type[Model],value:Any)->Model
pydantic.main.RootModel(__pydantic_self__,root:RootModelRootType)
pydantic.main.RootModel.__eq__(self,other:Any)->bool
pydantic.main.RootModel.__repr_args__(self)->_repr.ReprArgs
pydantic.main.RootModel.model_construct(cls:type[Model],root:RootModelRootType,_fields_set:set[str]|None=None)->Model
pydantic.main.create_model(__model_name:str,*,__config__:ConfigDict|None=None,__base__:None=None,__module__:str=__name__,__validators__:dict[str,AnyClassMethod]|None=None,__cls_kwargs__:dict[str,Any]|None=None,**field_definitions:Any)->type[BaseModel]
pydantic.main.create_model(__model_name:str,*,__config__:ConfigDict|None=None,__base__:type[Model]|tuple[type[Model],...],__module__:str=__name__,__validators__:dict[str,AnyClassMethod]|None=None,__cls_kwargs__:dict[str,Any]|None=None,**field_definitions:Any)->type[Model]
pydantic.main.create_model(__model_name:str,*,__config__:ConfigDict|None=None,__base__:type[Model]|tuple[type[Model],...]|None=None,__module__:str=__name__,__validators__:dict[str,AnyClassMethod]|None=None,__cls_kwargs__:dict[str,Any]|None=None,__slots__:tuple[str,...]|None=None,**field_definitions:Any)->type[Model]


----------------------------------------/home/zhang/Packages/pydantic/pydantic2.0b1/typing.py----------------------------------------
A:pydantic.typing.__getattr__->getattr_migration(__name__)


----------------------------------------/home/zhang/Packages/pydantic/pydantic2.0b1/config.py----------------------------------------
A:pydantic.config.Extra->_Extra()
A:pydantic.config.__getattr__->getattr_migration(__name__)
pydantic.ConfigDict(TypedDict,total=False)
pydantic.config.ConfigDict(TypedDict,total=False)
pydantic.config.JsonSchemaExtraCallable(self,schema:dict[str,Any],model_class:type[Any])
pydantic.config._Extra
pydantic.config._Extra.__getattribute__(self,__name:str)->Any


----------------------------------------/home/zhang/Packages/pydantic/pydantic2.0b1/functional_serializers.py----------------------------------------
A:pydantic.functional_serializers.schema->handler(source_type)
A:pydantic.functional_serializers.return_type->_internal._decorators.get_function_return_type(self.func, self.return_type)
A:pydantic.functional_serializers.schema['serialization']->pydantic_core.core_schema.wrap_serializer_function_ser_schema(function=self.func, info_arg=_decorators.inspect_annotated_serializer(self.func, 'wrap'), return_schema=return_schema, when_used=self.when_used)
A:pydantic.functional_serializers._PlainSerializeMethodType->TypeVar('_PlainSerializeMethodType', bound=_PlainSerializationFunction)
A:pydantic.functional_serializers._WrapSerializeMethodType->TypeVar('_WrapSerializeMethodType', bound=_WrapSerializationFunction)
A:pydantic.functional_serializers.dec_info->_internal._decorators.ModelSerializerDecoratorInfo(mode=mode, return_type=_decorators.get_function_return_type(f, return_type), when_used=when_used)
A:pydantic.functional_serializers.FuncType->TypeVar('FuncType', bound=Callable[..., Any])
pydantic.PlainSerializer
pydantic.PlainSerializer.__get_pydantic_core_schema__(self,source_type:Any,handler:_annotated_handlers.GetCoreSchemaHandler)->core_schema.CoreSchema
pydantic.WrapSerializer
pydantic.WrapSerializer.__get_pydantic_core_schema__(self,source_type:Any,handler:_annotated_handlers.GetCoreSchemaHandler)->core_schema.CoreSchema
pydantic.field_serializer(*fields:str,mode:Literal['plain','wrap']='plain',return_type:Any=None,when_used:Literal['always','unless-none','json','json-unless-none']='always',check_fields:bool|None=None)->Callable[[Any], Any]
pydantic.field_serializer(__field:str,*fields:str,mode:Literal['plain'],return_type:Any=...,when_used:Literal['always','unless-none','json','json-unless-none']=...,check_fields:bool|None=...)->Callable[[_PlainSerializeMethodType], _PlainSerializeMethodType]
pydantic.field_serializer(__field:str,*fields:str,mode:Literal['wrap'],return_type:Any=...,when_used:Literal['always','unless-none','json','json-unless-none']=...,check_fields:bool|None=...)->Callable[[_WrapSerializeMethodType], _WrapSerializeMethodType]
pydantic.field_serializer(__field:str,*fields:str,return_type:Any=...,when_used:Literal['always','unless-none','json','json-unless-none']=...,check_fields:bool|None=...)->Callable[[_PlainSerializeMethodType], _PlainSerializeMethodType]
pydantic.functional_serializers.PlainSerializer
pydantic.functional_serializers.PlainSerializer.__get_pydantic_core_schema__(self,source_type:Any,handler:_annotated_handlers.GetCoreSchemaHandler)->core_schema.CoreSchema
pydantic.functional_serializers.WrapSerializer
pydantic.functional_serializers.WrapSerializer.__get_pydantic_core_schema__(self,source_type:Any,handler:_annotated_handlers.GetCoreSchemaHandler)->core_schema.CoreSchema
pydantic.functional_serializers.field_serializer(*fields:str,mode:Literal['plain','wrap']='plain',return_type:Any=None,when_used:Literal['always','unless-none','json','json-unless-none']='always',check_fields:bool|None=None)->Callable[[Any], Any]
pydantic.functional_serializers.field_serializer(__field:str,*fields:str,mode:Literal['plain'],return_type:Any=...,when_used:Literal['always','unless-none','json','json-unless-none']=...,check_fields:bool|None=...)->Callable[[_PlainSerializeMethodType], _PlainSerializeMethodType]
pydantic.functional_serializers.field_serializer(__field:str,*fields:str,mode:Literal['wrap'],return_type:Any=...,when_used:Literal['always','unless-none','json','json-unless-none']=...,check_fields:bool|None=...)->Callable[[_WrapSerializeMethodType], _WrapSerializeMethodType]
pydantic.functional_serializers.field_serializer(__field:str,*fields:str,return_type:Any=...,when_used:Literal['always','unless-none','json','json-unless-none']=...,check_fields:bool|None=...)->Callable[[_PlainSerializeMethodType], _PlainSerializeMethodType]
pydantic.functional_serializers.model_serializer(*,mode:Literal['plain','wrap']=...,when_used:Literal['always','unless-none','json','json-unless-none']='always',return_type:Any=...)->Callable[[FuncType], FuncType]
pydantic.functional_serializers.model_serializer(__f:Callable[...,Any]|None=None,*,mode:Literal['plain','wrap']='plain',when_used:Literal['always','unless-none','json','json-unless-none']='always',return_type:Any=None)->Callable[[Any], Any]
pydantic.functional_serializers.model_serializer(__f:FuncType)->FuncType
pydantic.model_serializer(*,mode:Literal['plain','wrap']=...,when_used:Literal['always','unless-none','json','json-unless-none']='always',return_type:Any=...)->Callable[[FuncType], FuncType]
pydantic.model_serializer(__f:Callable[...,Any]|None=None,*,mode:Literal['plain','wrap']='plain',when_used:Literal['always','unless-none','json','json-unless-none']='always',return_type:Any=None)->Callable[[Any], Any]
pydantic.model_serializer(__f:FuncType)->FuncType


----------------------------------------/home/zhang/Packages/pydantic/pydantic2.0b1/json_schema.py----------------------------------------
A:pydantic.json_schema.CoreRef->NewType('CoreRef', str)
A:pydantic.json_schema.DefsRef->NewType('DefsRef', str)
A:pydantic.json_schema.JsonRef->NewType('JsonRef', str)
A:pydantic.json_schema.JsonSchemaKeyT->TypeVar('JsonSchemaKeyT', bound=Hashable)
A:pydantic.json_schema.self._schema_type_to_method->self.build_schema_type_to_method()
A:pydantic.json_schema.mapping[key]->getattr(self, method_name)
A:pydantic.json_schema.json_schema->json_schema.copy().copy()
A:pydantic.json_schema.json_ref->JsonRef(schema['$ref'])
A:pydantic.json_schema.defs_ref->self.get_defs_ref(core_mode_ref)
A:pydantic.json_schema.json_ref_counts->self.get_json_ref_counts(json_schema)
A:pydantic.json_schema.ref->item.get('$ref')
A:pydantic.json_schema.ref_json_schema->self.get_schema_from_definitions(ref)
A:pydantic.json_schema.all_json_refs->list(self.json_to_defs_refs.keys())
A:pydantic.json_schema.core_ref->CoreRef(schema['schema_ref'])
A:pydantic.json_schema.metadata_handler->_internal._core_metadata.CoreMetadataHandler(schema)
A:pydantic.json_schema.(defs_ref, ref_json_schema)->self.get_cache_defs_ref_schema(core_ref)
A:pydantic.json_schema.current_handler->_internal._schema_generation_shared.GenerateJsonSchemaHandler(self, new_handler_func)
A:pydantic.json_schema.json_schema['minItems']->len(schema['items_schema'])
A:pydantic.json_schema.json_schema['items']->self.generate_inner(schema['extra_schema'])
A:pydantic.json_schema.json_schema['maxItems']->len(prefix_items)
A:pydantic.json_schema.items->self.generate_inner(schema['items_schema'])
A:pydantic.json_schema.keys_pattern->keys_schema.pop('pattern', None)
A:pydantic.json_schema.default->schema['default_factory']()
A:pydantic.json_schema.encoded_default->self.encode_default(default)
A:pydantic.json_schema.inner_json_schema->self.generate_inner(schema['schema'])
A:pydantic.json_schema.generated[str(k)]->self.generate_inner(v).copy()
A:pydantic.json_schema.one_of_choices->_deduplicate_schemas(generated.values())
A:pydantic.json_schema.openapi_discriminator->self._extract_discriminator(schema, one_of_choices)
A:pydantic.json_schema.properties->choice.get('properties', {})
A:pydantic.json_schema.use_strict->schema.get('strict', False)
A:pydantic.json_schema.name->self.get_argument_name(argument)
A:pydantic.json_schema.field_json_schema->self.handle_ref_overrides(field_json_schema)
A:pydantic.json_schema.title->config.get('title')
A:pydantic.json_schema.alias->argument.get('alias')
A:pydantic.json_schema.cls->cast('type[BaseModel]', schema['cls'])
A:pydantic.json_schema.json_schema_extra->config.get('json_schema_extra')
A:pydantic.json_schema.prefer_positional->metadata.get('pydantic_js_prefer_positional_arguments')
A:pydantic.json_schema.var_args_schema->schema.get('var_args_schema')
A:pydantic.json_schema.var_kwargs_schema->schema.get('var_kwargs_schema')
A:pydantic.json_schema.argument_schema->self.generate_inner(argument['schema']).copy()
A:pydantic.json_schema.argument_schema['title']->self.get_title_from_name(name)
A:pydantic.json_schema.additional_properties_schema->self.generate_inner(var_kwargs_schema)
A:pydantic.json_schema.items_schema->self.generate_inner(var_args_schema)
A:pydantic.json_schema.(_, ref_json_schema)->self.get_cache_defs_ref_schema(core_ref)
A:pydantic.json_schema.components->re.split('([\\][,])', core_ref)
A:pydantic.json_schema.core_ref_no_id->''.join(components)
A:pydantic.json_schema.short_ref->''.join(components)
A:pydantic.json_schema.new_json_ref->JsonRef(self.ref_template.format(model=new))
A:pydantic.json_schema.self.definitions[new]->self.definitions.pop(old)
A:pydantic.json_schema.self.defs_to_core_refs[new]->self.defs_to_core_refs.pop(old)
A:pydantic.json_schema.self.definitions[k]->walk_replace_json_schema_ref(v)
A:pydantic.json_schema.maybe_defs_ref->self.core_to_defs_refs.get(core_mode_ref)
A:pydantic.json_schema.referenced_json_schema->self.get_schema_from_definitions(JsonRef(json_schema['$ref']))
A:pydantic.json_schema.members->_deduplicate_schemas(members)
A:pydantic.json_schema.message->self.render_warning_message(kind, detail)
A:pydantic.json_schema.schema_generator_instance->schema_generator(by_alias=by_alias, ref_template=ref_template)
A:pydantic.json_schema.instance->schema_generator(by_alias=by_alias, ref_template=ref_template)
A:pydantic.json_schema.(key_map, definitions)->schema_generator(by_alias=by_alias, ref_template=ref_template).generate_definitions(inputs)
pydantic.json_schema.GenerateJsonSchema(self,by_alias:bool=True,ref_template:str=DEFAULT_REF_TEMPLATE)
pydantic.json_schema.GenerateJsonSchema.ValidationsMapping
pydantic.json_schema.GenerateJsonSchema._common_set_schema(self,schema:core_schema.SetSchema|core_schema.FrozenSetSchema)->JsonSchemaValue
pydantic.json_schema.GenerateJsonSchema._extract_discriminator(self,schema:core_schema.TaggedUnionSchema,one_of_choices:list[_JsonDict])->str | None
pydantic.json_schema.GenerateJsonSchema._function_schema(self,schema:_core_utils.AnyFunctionSchema)->JsonSchemaValue
pydantic.json_schema.GenerateJsonSchema._get_alias_name(self,field:CoreSchemaField,name:str)->str
pydantic.json_schema.GenerateJsonSchema._name_required_computed_fields(computed_fields:list[ComputedField])->list[tuple[str, bool, core_schema.ComputedField]]
pydantic.json_schema.GenerateJsonSchema._named_required_fields_schema(self,named_required_fields:Sequence[tuple[str,bool,CoreSchemaField]])->JsonSchemaValue
pydantic.json_schema.GenerateJsonSchema._update_class_schema(self,json_schema:JsonSchemaValue,title:str|None,forbid_additional_properties:bool,cls:type[Any],json_schema_extra:dict[str,Any]|JsonSchemaExtraCallable|None)->JsonSchemaValue
pydantic.json_schema.GenerateJsonSchema.any_schema(self,schema:core_schema.AnySchema)->JsonSchemaValue
pydantic.json_schema.GenerateJsonSchema.arguments_schema(self,schema:core_schema.ArgumentsSchema)->JsonSchemaValue
pydantic.json_schema.GenerateJsonSchema.bool_schema(self,schema:core_schema.BoolSchema)->JsonSchemaValue
pydantic.json_schema.GenerateJsonSchema.build_schema_type_to_method(self)->dict[CoreSchemaOrFieldType, Callable[[CoreSchemaOrField], JsonSchemaValue]]
pydantic.json_schema.GenerateJsonSchema.bytes_schema(self,schema:core_schema.BytesSchema)->JsonSchemaValue
pydantic.json_schema.GenerateJsonSchema.call_schema(self,schema:core_schema.CallSchema)->JsonSchemaValue
pydantic.json_schema.GenerateJsonSchema.callable_schema(self,schema:core_schema.CallableSchema)->JsonSchemaValue
pydantic.json_schema.GenerateJsonSchema.chain_schema(self,schema:core_schema.ChainSchema)->JsonSchemaValue
pydantic.json_schema.GenerateJsonSchema.change_defs_ref(self,old:DefsRef,new:DefsRef,json_schema:JsonSchemaValue)->JsonSchemaValue
pydantic.json_schema.GenerateJsonSchema.computed_field_schema(self,schema:core_schema.ComputedField)->JsonSchemaValue
pydantic.json_schema.GenerateJsonSchema.custom_error_schema(self,schema:core_schema.CustomErrorSchema)->JsonSchemaValue
pydantic.json_schema.GenerateJsonSchema.dataclass_args_schema(self,schema:core_schema.DataclassArgsSchema)->JsonSchemaValue
pydantic.json_schema.GenerateJsonSchema.dataclass_field_schema(self,schema:core_schema.DataclassField)->JsonSchemaValue
pydantic.json_schema.GenerateJsonSchema.dataclass_schema(self,schema:core_schema.DataclassSchema)->JsonSchemaValue
pydantic.json_schema.GenerateJsonSchema.date_schema(self,schema:core_schema.DateSchema)->JsonSchemaValue
pydantic.json_schema.GenerateJsonSchema.datetime_schema(self,schema:core_schema.DatetimeSchema)->JsonSchemaValue
pydantic.json_schema.GenerateJsonSchema.default_schema(self,schema:core_schema.WithDefaultSchema)->JsonSchemaValue
pydantic.json_schema.GenerateJsonSchema.definition_ref_schema(self,schema:core_schema.DefinitionReferenceSchema)->JsonSchemaValue
pydantic.json_schema.GenerateJsonSchema.definitions_schema(self,schema:core_schema.DefinitionsSchema)->JsonSchemaValue
pydantic.json_schema.GenerateJsonSchema.dict_schema(self,schema:core_schema.DictSchema)->JsonSchemaValue
pydantic.json_schema.GenerateJsonSchema.emit_warning(self,kind:JsonSchemaWarningKind,detail:str)->None
pydantic.json_schema.GenerateJsonSchema.encode_default(self,dft:Any)->Any
pydantic.json_schema.GenerateJsonSchema.field_is_present(self,field:CoreSchemaField)->bool
pydantic.json_schema.GenerateJsonSchema.field_is_required(self,field:core_schema.ModelField|core_schema.DataclassField|core_schema.TypedDictField)->bool
pydantic.json_schema.GenerateJsonSchema.field_title_should_be_set(self,schema:CoreSchemaOrField)->bool
pydantic.json_schema.GenerateJsonSchema.float_schema(self,schema:core_schema.FloatSchema)->JsonSchemaValue
pydantic.json_schema.GenerateJsonSchema.frozenset_schema(self,schema:core_schema.FrozenSetSchema)->JsonSchemaValue
pydantic.json_schema.GenerateJsonSchema.function_after_schema(self,schema:core_schema.AfterValidatorFunctionSchema)->JsonSchemaValue
pydantic.json_schema.GenerateJsonSchema.function_before_schema(self,schema:core_schema.BeforeValidatorFunctionSchema)->JsonSchemaValue
pydantic.json_schema.GenerateJsonSchema.function_plain_schema(self,schema:core_schema.PlainValidatorFunctionSchema)->JsonSchemaValue
pydantic.json_schema.GenerateJsonSchema.function_wrap_schema(self,schema:core_schema.WrapValidatorFunctionSchema)->JsonSchemaValue
pydantic.json_schema.GenerateJsonSchema.generate(self,schema:CoreSchema,mode:JsonSchemaMode='validation')->JsonSchemaValue
pydantic.json_schema.GenerateJsonSchema.generate_definitions(self,inputs:Sequence[tuple[JsonSchemaKeyT,JsonSchemaMode,core_schema.CoreSchema]])->tuple[dict[tuple[JsonSchemaKeyT, JsonSchemaMode], DefsRef], dict[DefsRef, JsonSchemaValue]]
pydantic.json_schema.GenerateJsonSchema.generate_inner(self,schema:CoreSchemaOrField)->JsonSchemaValue
pydantic.json_schema.GenerateJsonSchema.generator_schema(self,schema:core_schema.GeneratorSchema)->JsonSchemaValue
pydantic.json_schema.GenerateJsonSchema.get_argument_name(self,argument:core_schema.ArgumentsParameter)->str
pydantic.json_schema.GenerateJsonSchema.get_cache_defs_ref_schema(self,core_ref:CoreRef)->tuple[DefsRef, JsonSchemaValue]
pydantic.json_schema.GenerateJsonSchema.get_defs_ref(self,core_mode_ref:CoreModeRef)->DefsRef
pydantic.json_schema.GenerateJsonSchema.get_flattened_anyof(self,schemas:list[JsonSchemaValue])->JsonSchemaValue
pydantic.json_schema.GenerateJsonSchema.get_json_ref_counts(self,json_schema:JsonSchemaValue)->dict[JsonRef, int]
pydantic.json_schema.GenerateJsonSchema.get_schema_from_definitions(self,json_ref:JsonRef)->JsonSchemaValue | None
pydantic.json_schema.GenerateJsonSchema.get_title_from_name(self,name:str)->str
pydantic.json_schema.GenerateJsonSchema.handle_invalid_for_json_schema(self,schema:CoreSchemaOrField,error_info:str)->JsonSchemaValue
pydantic.json_schema.GenerateJsonSchema.handle_ref_overrides(self,json_schema:JsonSchemaValue)->JsonSchemaValue
pydantic.json_schema.GenerateJsonSchema.int_schema(self,schema:core_schema.IntSchema)->JsonSchemaValue
pydantic.json_schema.GenerateJsonSchema.is_instance_schema(self,schema:core_schema.IsInstanceSchema)->JsonSchemaValue
pydantic.json_schema.GenerateJsonSchema.is_subclass_schema(self,schema:core_schema.IsSubclassSchema)->JsonSchemaValue
pydantic.json_schema.GenerateJsonSchema.json_or_python_schema(self,schema:core_schema.JsonOrPythonSchema)->JsonSchemaValue
pydantic.json_schema.GenerateJsonSchema.json_schema(self,schema:core_schema.JsonSchema)->JsonSchemaValue
pydantic.json_schema.GenerateJsonSchema.kw_arguments_schema(self,arguments:list[core_schema.ArgumentsParameter],var_kwargs_schema:CoreSchema|None)->JsonSchemaValue
pydantic.json_schema.GenerateJsonSchema.lax_or_strict_schema(self,schema:core_schema.LaxOrStrictSchema)->JsonSchemaValue
pydantic.json_schema.GenerateJsonSchema.list_schema(self,schema:core_schema.ListSchema)->JsonSchemaValue
pydantic.json_schema.GenerateJsonSchema.literal_schema(self,schema:core_schema.LiteralSchema)->JsonSchemaValue
pydantic.json_schema.GenerateJsonSchema.model_field_schema(self,schema:core_schema.ModelField)->JsonSchemaValue
pydantic.json_schema.GenerateJsonSchema.model_fields_schema(self,schema:core_schema.ModelFieldsSchema)->JsonSchemaValue
pydantic.json_schema.GenerateJsonSchema.model_schema(self,schema:core_schema.ModelSchema)->JsonSchemaValue
pydantic.json_schema.GenerateJsonSchema.multi_host_url_schema(self,schema:core_schema.MultiHostUrlSchema)->JsonSchemaValue
pydantic.json_schema.GenerateJsonSchema.none_schema(self,schema:core_schema.NoneSchema)->JsonSchemaValue
pydantic.json_schema.GenerateJsonSchema.normalize_name(self,name:str)->str
pydantic.json_schema.GenerateJsonSchema.nullable_schema(self,schema:core_schema.NullableSchema)->JsonSchemaValue
pydantic.json_schema.GenerateJsonSchema.p_arguments_schema(self,arguments:list[core_schema.ArgumentsParameter],var_args_schema:CoreSchema|None)->JsonSchemaValue
pydantic.json_schema.GenerateJsonSchema.render_warning_message(self,kind:JsonSchemaWarningKind,detail:str)->str | None
pydantic.json_schema.GenerateJsonSchema.resolve_collisions(self,json_schema:JsonSchemaValue)->JsonSchemaValue
pydantic.json_schema.GenerateJsonSchema.set_schema(self,schema:core_schema.SetSchema)->JsonSchemaValue
pydantic.json_schema.GenerateJsonSchema.str_schema(self,schema:core_schema.StringSchema)->JsonSchemaValue
pydantic.json_schema.GenerateJsonSchema.tagged_union_schema(self,schema:core_schema.TaggedUnionSchema)->JsonSchemaValue
pydantic.json_schema.GenerateJsonSchema.time_schema(self,schema:core_schema.TimeSchema)->JsonSchemaValue
pydantic.json_schema.GenerateJsonSchema.timedelta_schema(self,schema:core_schema.TimedeltaSchema)->JsonSchemaValue
pydantic.json_schema.GenerateJsonSchema.tuple_positional_schema(self,schema:core_schema.TuplePositionalSchema)->JsonSchemaValue
pydantic.json_schema.GenerateJsonSchema.tuple_variable_schema(self,schema:core_schema.TupleVariableSchema)->JsonSchemaValue
pydantic.json_schema.GenerateJsonSchema.typed_dict_field_schema(self,schema:core_schema.TypedDictField)->JsonSchemaValue
pydantic.json_schema.GenerateJsonSchema.typed_dict_schema(self,schema:core_schema.TypedDictSchema)->JsonSchemaValue
pydantic.json_schema.GenerateJsonSchema.union_schema(self,schema:core_schema.UnionSchema)->JsonSchemaValue
pydantic.json_schema.GenerateJsonSchema.update_with_validations(self,json_schema:JsonSchemaValue,core_schema:CoreSchema,mapping:dict[str,str])->None
pydantic.json_schema.GenerateJsonSchema.url_schema(self,schema:core_schema.UrlSchema)->JsonSchemaValue
pydantic.json_schema.PydanticJsonSchemaWarning(UserWarning)
pydantic.json_schema._deduplicate_schemas(schemas:Iterable[_JsonDict])->list[_JsonDict]
pydantic.json_schema._make_json_hashable(value:_Json)->_HashableJson
pydantic.json_schema.model_json_schema(cls:type[BaseModel]|type[PydanticDataclass],by_alias:bool=True,ref_template:str=DEFAULT_REF_TEMPLATE,schema_generator:type[GenerateJsonSchema]=GenerateJsonSchema,mode:JsonSchemaMode='validation')->dict[str, Any]
pydantic.json_schema.models_json_schema(models:Sequence[tuple[type[BaseModel]|type[PydanticDataclass],JsonSchemaMode]],*,by_alias:bool=True,title:str|None=None,description:str|None=None,ref_template:str=DEFAULT_REF_TEMPLATE,schema_generator:type[GenerateJsonSchema]=GenerateJsonSchema)->tuple[dict[tuple[type[BaseModel] | type[PydanticDataclass], JsonSchemaMode], DefsRef], JsonSchemaValue]
pydantic.json_schema.update_json_schema(schema:JsonSchemaValue,updates:dict[str,Any])->JsonSchemaValue


----------------------------------------/home/zhang/Packages/pydantic/pydantic2.0b1/validate_call.py----------------------------------------
A:pydantic.validate_call.AnyCallableT->TypeVar('AnyCallableT', bound=Callable[..., Any])
pydantic.validate_call(*,config:ConfigDict|None=None,validate_return:bool=False)->Callable[[AnyCallableT], AnyCallableT]
pydantic.validate_call(__func:AnyCallableT)->AnyCallableT
pydantic.validate_call(__func:AnyCallableT|None=None,*,config:ConfigDict|None=None,validate_return:bool=False)->AnyCallableT | Callable[[AnyCallableT], AnyCallableT]
pydantic.validate_call.validate_call(*,config:ConfigDict|None=None,validate_return:bool=False)->Callable[[AnyCallableT], AnyCallableT]
pydantic.validate_call.validate_call(__func:AnyCallableT)->AnyCallableT
pydantic.validate_call.validate_call(__func:AnyCallableT|None=None,*,config:ConfigDict|None=None,validate_return:bool=False)->AnyCallableT | Callable[[AnyCallableT], AnyCallableT]


----------------------------------------/home/zhang/Packages/pydantic/pydantic2.0b1/networks.py----------------------------------------
A:pydantic.networks.field_schema->handler(core_schema)
A:pydantic.networks.(name, email)->validate_email(__input_value)
A:pydantic.networks.pretty_email_regex->re.compile(' *([\\w ]*?) *<(.+?)> *')
A:pydantic.networks.m->re.compile(' *([\\w ]*?) *<(.+?)> *').fullmatch(value)
A:pydantic.networks.(name, value)->re.compile(' *([\\w ]*?) *<(.+?)> *').fullmatch(value).groups()
A:pydantic.networks.email->value.strip()
A:pydantic.networks.parts->email_validator.validate_email(email, check_deliverability=False)
A:pydantic.networks.__getattr__->getattr_migration(__name__)
pydantic.IPvAnyAddress(cls,value:Any)
pydantic.IPvAnyAddress.__get_pydantic_core_schema__(cls,source:type[Any])->core_schema.CoreSchema
pydantic.IPvAnyAddress.__get_pydantic_json_schema__(cls,core_schema:core_schema.CoreSchema,handler:_schema_generation_shared.GetJsonSchemaHandler)->JsonSchemaValue
pydantic.IPvAnyAddress._validate(cls,__input_value:Any,_:core_schema.ValidationInfo)->IPv4Address | IPv6Address
pydantic.IPvAnyInterface(cls,value:NetworkType)
pydantic.IPvAnyInterface.__get_pydantic_core_schema__(cls,source:type[Any])->core_schema.CoreSchema
pydantic.IPvAnyInterface.__get_pydantic_json_schema__(cls,core_schema:core_schema.CoreSchema,handler:_schema_generation_shared.GetJsonSchemaHandler)->JsonSchemaValue
pydantic.IPvAnyInterface._validate(cls,__input_value:NetworkType,_:core_schema.ValidationInfo)->IPv4Interface | IPv6Interface
pydantic.IPvAnyNetwork(cls,value:NetworkType)
pydantic.IPvAnyNetwork.__get_pydantic_core_schema__(cls,source:type[Any])->core_schema.CoreSchema
pydantic.IPvAnyNetwork.__get_pydantic_json_schema__(cls,core_schema:core_schema.CoreSchema,handler:_schema_generation_shared.GetJsonSchemaHandler)->JsonSchemaValue
pydantic.IPvAnyNetwork._validate(cls,__input_value:NetworkType,_:core_schema.ValidationInfo)->IPv4Network | IPv6Network
pydantic.NameEmail(self,name:str,email:str)
pydantic.NameEmail.__eq__(self,other:Any)->bool
pydantic.NameEmail.__get_pydantic_core_schema__(cls,source:type[Any])->core_schema.CoreSchema
pydantic.NameEmail.__get_pydantic_json_schema__(cls,core_schema:core_schema.CoreSchema,handler:_schema_generation_shared.GetJsonSchemaHandler)->JsonSchemaValue
pydantic.NameEmail.__str__(self)->str
pydantic.NameEmail._validate(cls,__input_value:NameEmail|str,_:core_schema.ValidationInfo)->NameEmail
pydantic.UrlConstraints(_fields.PydanticMetadata)
pydantic.UrlConstraints.__hash__(self)->int
pydantic.import_email_validator()->None
pydantic.networks.IPvAnyAddress(cls,value:Any)
pydantic.networks.IPvAnyAddress.__get_pydantic_core_schema__(cls,source:type[Any])->core_schema.CoreSchema
pydantic.networks.IPvAnyAddress.__get_pydantic_json_schema__(cls,core_schema:core_schema.CoreSchema,handler:_schema_generation_shared.GetJsonSchemaHandler)->JsonSchemaValue
pydantic.networks.IPvAnyAddress._validate(cls,__input_value:Any,_:core_schema.ValidationInfo)->IPv4Address | IPv6Address
pydantic.networks.IPvAnyInterface(cls,value:NetworkType)
pydantic.networks.IPvAnyInterface.__get_pydantic_core_schema__(cls,source:type[Any])->core_schema.CoreSchema
pydantic.networks.IPvAnyInterface.__get_pydantic_json_schema__(cls,core_schema:core_schema.CoreSchema,handler:_schema_generation_shared.GetJsonSchemaHandler)->JsonSchemaValue
pydantic.networks.IPvAnyInterface._validate(cls,__input_value:NetworkType,_:core_schema.ValidationInfo)->IPv4Interface | IPv6Interface
pydantic.networks.IPvAnyNetwork(cls,value:NetworkType)
pydantic.networks.IPvAnyNetwork.__get_pydantic_core_schema__(cls,source:type[Any])->core_schema.CoreSchema
pydantic.networks.IPvAnyNetwork.__get_pydantic_json_schema__(cls,core_schema:core_schema.CoreSchema,handler:_schema_generation_shared.GetJsonSchemaHandler)->JsonSchemaValue
pydantic.networks.IPvAnyNetwork._validate(cls,__input_value:NetworkType,_:core_schema.ValidationInfo)->IPv4Network | IPv6Network
pydantic.networks.NameEmail(self,name:str,email:str)
pydantic.networks.NameEmail.__eq__(self,other:Any)->bool
pydantic.networks.NameEmail.__get_pydantic_core_schema__(cls,source:type[Any])->core_schema.CoreSchema
pydantic.networks.NameEmail.__get_pydantic_json_schema__(cls,core_schema:core_schema.CoreSchema,handler:_schema_generation_shared.GetJsonSchemaHandler)->JsonSchemaValue
pydantic.networks.NameEmail.__str__(self)->str
pydantic.networks.NameEmail._validate(cls,__input_value:NameEmail|str,_:core_schema.ValidationInfo)->NameEmail
pydantic.networks.UrlConstraints(_fields.PydanticMetadata)
pydantic.networks.UrlConstraints.__hash__(self)->int
pydantic.networks.import_email_validator()->None
pydantic.networks.validate_email(value:str)->tuple[str, str]
pydantic.validate_email(value:str)->tuple[str, str]


----------------------------------------/home/zhang/Packages/pydantic/pydantic2.0b1/generics.py----------------------------------------
A:pydantic.generics.__getattr__->getattr_migration(__name__)


----------------------------------------/home/zhang/Packages/pydantic/pydantic2.0b1/schema.py----------------------------------------
A:pydantic.schema.__getattr__->getattr_migration(__name__)


----------------------------------------/home/zhang/Packages/pydantic/pydantic2.0b1/version.py----------------------------------------
pydantic.version.version_info()->str


----------------------------------------/home/zhang/Packages/pydantic/pydantic2.0b1/json.py----------------------------------------
A:pydantic.json.__getattr__->getattr_migration(__name__)


----------------------------------------/home/zhang/Packages/pydantic/pydantic2.0b1/alias_generators.py----------------------------------------
A:pydantic.alias_generators.camel->to_pascal(snake)
A:pydantic.alias_generators.snake->re.sub('([a-z0-9])([A-Z])', lambda m: f'{m.group(1)}_{m.group(2)}', snake)
pydantic.alias_generators.to_camel(snake:str)->str
pydantic.alias_generators.to_pascal(snake:str)->str
pydantic.alias_generators.to_snake(camel:str)->str


----------------------------------------/home/zhang/Packages/pydantic/pydantic2.0b1/__init__.py----------------------------------------
A:pydantic.__init__.__getattr__->getattr_migration(__name__)


----------------------------------------/home/zhang/Packages/pydantic/pydantic2.0b1/mypy.py----------------------------------------
A:pydantic.m.MYPY_VERSION_TUPLE->parse_mypy_version(mypy_version)
A:pydantic.m.self.plugin_config->PydanticPluginConfig(options)
A:pydantic.m.self._plugin_data->self.plugin_config.to_data()
A:pydantic.m.sym->SymbolTableNode(MDEF, func)
A:pydantic.m.transformer->PydanticModelTransformer(ctx, self.plugin_config)
A:pydantic.m.args->getattr(ret_type, 'args', None)
A:pydantic.m.ret_type.args->tuple((default_any_type for _ in args))
A:pydantic.m.toml_config->parse_toml(options.config_file)
A:pydantic.m.config->ModelConfigData()
A:pydantic.m.setting->ConfigParser().getboolean(CONFIGFILE_KEY, key, fallback=False)
A:pydantic.m.plugin_config->ConfigParser()
A:pydantic.m.pydantic_metadata->model_type.type.metadata.get(METADATA_KEY)
A:pydantic.m.from_attributes->model_type.type.metadata.get(METADATA_KEY).get('config', {}).get('from_attributes')
A:pydantic.m.fields->self.collect_fields(config)
A:pydantic.m.config_data->self.get_config_update(name, expr)
A:pydantic.m.maybe_field->self.collect_field_from_stmt(stmt, model_config)
A:pydantic.m.all_fields->self.collect_fields(config).copy()
A:pydantic.m.field->PydanticModelField.deserialize(info, data)
A:pydantic.m.is_required->self.get_is_required(cls, stmt, lhs)
A:pydantic.m.(alias, has_dynamic_alias)->self.get_alias_info(stmt)
A:pydantic.m.force_all_optional->bool(config.has_alias_generator and (not config.populate_by_name))
A:pydantic.m.init_arguments->self.get_field_arguments(fields, typed=typed, force_all_optional=force_all_optional, use_alias=use_alias)
A:pydantic.m.var->PydanticModelField.deserialize(info, data).to_var(info, use_alias=False)
A:pydantic.m.set_str->ctx.api.named_type(f'{BUILTINS_NAME}.set', [ctx.api.named_type(f'{BUILTINS_NAME}.str')])
A:pydantic.m.optional_set_str->UnionType([set_str, NoneType()])
A:pydantic.m.fields_set_argument->Argument(Var('_fields_set', optional_set_str), optional_set_str, None, ARG_OPT)
A:pydantic.m.construct_arguments->self.get_field_arguments(fields, typed=True, force_all_optional=False, use_alias=False)
A:pydantic.m.obj_type->ctx.api.named_type(f'{BUILTINS_NAME}.object')
A:pydantic.m.self_type->TypeVarDef(self_tvar_name, tvar_fullname, -1, [], obj_type)
A:pydantic.m.self_tvar_expr->TypeVarExpr(self_tvar_name, tvar_fullname, [], obj_type)
A:pydantic.m.ctx.cls.info.names[self_tvar_name]->SymbolTableNode(MDEF, self_tvar_expr)
A:pydantic.m.sym_node->info.names.get(field.name)
A:pydantic.m.var_str->repr(var)
A:pydantic.m.info.names[get_name(var)]->SymbolTableNode(MDEF, var)
A:pydantic.m.value_type->get_proper_type(cls.info[lhs.name].type)
A:pydantic.m.type_annotation->AnyType(TypeOfAny.explicit)
A:pydantic.m.ERROR_ORM->ErrorCode('pydantic-orm', 'Invalid from_attributes call', 'Pydantic')
A:pydantic.m.ERROR_CONFIG->ErrorCode('pydantic-config', 'Invalid config value', 'Pydantic')
A:pydantic.m.ERROR_ALIAS->ErrorCode('pydantic-alias', 'Dynamic alias disallowed', 'Pydantic')
A:pydantic.m.ERROR_UNEXPECTED->ErrorCode('pydantic-unexpected', 'Unexpected behavior', 'Pydantic')
A:pydantic.m.ERROR_UNTYPED->ErrorCode('pydantic-field', 'Untyped field disallowed', 'Pydantic')
A:pydantic.m.ERROR_FIELD_DEFAULTS->ErrorCode('pydantic-field', 'Invalid Field defaults', 'Pydantic')
A:pydantic.m.function_type->ctx.api.named_type(f'{BUILTINS_NAME}.function')
A:pydantic.m.signature->CallableType(arg_types, arg_kinds, arg_names, return_type, function_type)
A:pydantic.m.func->FuncDef(name, args, Block([PassStmt()]))
A:pydantic.m.func.type->set_callable_name(signature, func)
A:pydantic.m.r_name->get_unique_redefinition_name(name, info.names)
A:pydantic.m.v->Var(name, func.type)
A:pydantic.m.dec->Decorator(func, [NameExpr('classmethod')], v)
pydantic.m.ModelConfigData(self,forbid_extra:bool|None=None,frozen:bool|None=None,from_attributes:bool|None=None,populate_by_name:bool|None=None,has_alias_generator:bool|None=None)
pydantic.m.ModelConfigData.set_values_dict(self)->dict[str, Any]
pydantic.m.ModelConfigData.setdefault(self,key:str,value:Any)->None
pydantic.m.ModelConfigData.update(self,config:ModelConfigData|None)->None
pydantic.m.PydanticModelField(self,name:str,is_required:bool,alias:str|None,has_dynamic_alias:bool,line:int,column:int)
pydantic.m.PydanticModelField.deserialize(cls,info:TypeInfo,data:JsonDict)->PydanticModelField
pydantic.m.PydanticModelField.serialize(self)->JsonDict
pydantic.m.PydanticModelField.to_argument(self,info:TypeInfo,typed:bool,force_optional:bool,use_alias:bool)->Argument
pydantic.m.PydanticModelField.to_var(self,info:TypeInfo,use_alias:bool)->Var
pydantic.m.PydanticModelTransformer(self,ctx:ClassDefContext,plugin_config:PydanticPluginConfig)
pydantic.m.PydanticModelTransformer.add_initializer(self,fields:list[PydanticModelField],config:ModelConfigData)->None
pydantic.m.PydanticModelTransformer.add_model_construct_method(self,fields:list[PydanticModelField])->None
pydantic.m.PydanticModelTransformer.adjust_validator_signatures(self)->None
pydantic.m.PydanticModelTransformer.collect_config(self)->ModelConfigData
pydantic.m.PydanticModelTransformer.collect_field_from_stmt(self,stmt:Statement,model_config:ModelConfigData)->PydanticModelField | None
pydantic.m.PydanticModelTransformer.collect_fields(self,model_config:ModelConfigData)->list[PydanticModelField]
pydantic.m.PydanticModelTransformer.get_alias_info(stmt:AssignmentStmt)->tuple[str | None, bool]
pydantic.m.PydanticModelTransformer.get_config_update(self,name:str,arg:Expression)->ModelConfigData | None
pydantic.m.PydanticModelTransformer.get_field_arguments(self,fields:list[PydanticModelField],typed:bool,force_all_optional:bool,use_alias:bool)->list[Argument]
pydantic.m.PydanticModelTransformer.get_is_required(cls:ClassDef,stmt:AssignmentStmt,lhs:NameExpr)->bool
pydantic.m.PydanticModelTransformer.is_dynamic_alias_present(fields:list[PydanticModelField],has_alias_generator:bool)->bool
pydantic.m.PydanticModelTransformer.set_frozen(self,fields:list[PydanticModelField],frozen:bool)->None
pydantic.m.PydanticModelTransformer.should_init_forbid_extra(self,fields:list[PydanticModelField],config:ModelConfigData)->bool
pydantic.m.PydanticModelTransformer.transform(self)->None
pydantic.m.PydanticPlugin(self,options:Options)
pydantic.m.PydanticPlugin._pydantic_field_callback(self,ctx:FunctionContext)->Type
pydantic.m.PydanticPlugin._pydantic_model_class_maker_callback(self,ctx:ClassDefContext)->None
pydantic.m.PydanticPlugin._pydantic_model_metaclass_marker_callback(self,ctx:ClassDefContext)->None
pydantic.m.PydanticPlugin.get_base_class_hook(self,fullname:str)->Callable[[ClassDefContext], None] | None
pydantic.m.PydanticPlugin.get_class_decorator_hook(self,fullname:str)->Callable[[ClassDefContext], None] | None
pydantic.m.PydanticPlugin.get_function_hook(self,fullname:str)->Callable[[FunctionContext], Type] | None
pydantic.m.PydanticPlugin.get_metaclass_hook(self,fullname:str)->Callable[[ClassDefContext], None] | None
pydantic.m.PydanticPlugin.get_method_hook(self,fullname:str)->Callable[[MethodContext], Type] | None
pydantic.m.PydanticPlugin.report_config_data(self,ctx:ReportConfigContext)->dict[str, Any]
pydantic.m.PydanticPluginConfig(self,options:Options)
pydantic.m.PydanticPluginConfig.to_data(self)->dict[str, Any]
pydantic.m.add_method(ctx:ClassDefContext,name:str,args:list[Argument],return_type:Type,self_type:Type|None=None,tvar_def:TypeVarDef|None=None,is_classmethod:bool=False,is_new:bool=False)->None
pydantic.m.error_default_and_default_factory_specified(api:CheckerPluginInterface,context:Context)->None
pydantic.m.error_from_attributes(model_name:str,api:CheckerPluginInterface,context:Context)->None
pydantic.m.error_invalid_config_value(name:str,api:SemanticAnalyzerPluginInterface,context:Context)->None
pydantic.m.error_required_dynamic_aliases(api:SemanticAnalyzerPluginInterface,context:Context)->None
pydantic.m.error_unexpected_behavior(detail:str,api:CheckerPluginInterface|SemanticAnalyzerPluginInterface,context:Context)->None
pydantic.m.error_untyped_fields(api:SemanticAnalyzerPluginInterface,context:Context)->None
pydantic.m.from_attributes_callback(ctx:MethodContext)->Type
pydantic.m.get_fullname(x:FuncBase|SymbolNode)->str
pydantic.m.get_name(x:FuncBase|SymbolNode)->str
pydantic.m.parse_mypy_version(version:str)->tuple[int, ...]
pydantic.m.parse_toml(config_file:str)->dict[str, Any] | None
pydantic.m.plugin(version:str)->type[Plugin]


----------------------------------------/home/zhang/Packages/pydantic/pydantic2.0b1/fields.py----------------------------------------
A:pydantic.fields.(self.annotation, annotation_metadata)->self._extract_metadata(kwargs.get('annotation'))
A:pydantic.fields.default->kwargs.pop('default', _Undefined)
A:pydantic.fields.self.default_factory->kwargs.pop('default_factory', None)
A:pydantic.fields.self.alias->kwargs.pop('alias', None)
A:pydantic.fields.self.title->kwargs.pop('title', None)
A:pydantic.fields.self.validation_alias->kwargs.pop('validation_alias', None)
A:pydantic.fields.self.serialization_alias->kwargs.pop('serialization_alias', None)
A:pydantic.fields.self.description->kwargs.pop('description', None)
A:pydantic.fields.self.examples->kwargs.pop('examples', None)
A:pydantic.fields.self.exclude->kwargs.pop('exclude', None)
A:pydantic.fields.self.include->kwargs.pop('include', None)
A:pydantic.fields.self.discriminator->kwargs.pop('discriminator', None)
A:pydantic.fields.self.repr->kwargs.pop('repr', True)
A:pydantic.fields.self.json_schema_extra->kwargs.pop('json_schema_extra', None)
A:pydantic.fields.self.validate_default->kwargs.pop('validate_default', None)
A:pydantic.fields.self.frozen->kwargs.pop('frozen', None)
A:pydantic.fields.self.final->kwargs.pop('final', None)
A:pydantic.fields.self.init_var->kwargs.pop('init_var', None)
A:pydantic.fields.self.kw_only->kwargs.pop('kw_only', None)
A:pydantic.fields.(first_arg, *extra_args)->typing_extensions.get_args(annotation)
A:pydantic.fields.field_info->cls._find_field_info_arg(extra_args)
A:pydantic.fields.new_field_info->copy(field_info)
A:pydantic.fields.(default.annotation, annotation_metadata)->cls._extract_metadata(annotation)
A:pydantic.fields.pydantic_field->cls._from_dataclass_field(default)
A:pydantic.fields.(pydantic_field.annotation, annotation_metadata)->cls._extract_metadata(annotation)
A:pydantic.fields.pydantic_field.kw_only->getattr(default, 'kw_only', None)
A:pydantic.fields.field->Field(default=default, default_factory=default_factory, repr=dc_field.repr, **dc_field.metadata)
A:pydantic.fields.(field.annotation, annotation_metadata)->cls._extract_metadata(dc_field.type)
A:pydantic.fields.annotation->_internal._typing_extra.eval_type_lenient(self.annotation, types_namespace, None)
A:pydantic.fields.self.annotation->_internal._generics.replace_types(annotation, typevars_map)
A:pydantic.fields.value->getattr(self, s)
A:pydantic.fields.const->extra.pop('const', None)
A:pydantic.fields.min_items->extra.pop('min_items', None)
A:pydantic.fields.max_items->extra.pop('max_items', None)
A:pydantic.fields.unique_items->extra.pop('unique_items', None)
A:pydantic.fields.allow_mutation->extra.pop('allow_mutation', None)
A:pydantic.fields.regex->extra.pop('regex', None)
A:pydantic.fields.PropertyT->typing.TypeVar('PropertyT')
A:pydantic.fields.description->inspect.cleandoc(f.__doc__)
A:pydantic.fields.return_type->_internal._decorators.get_function_return_type(f, return_type)
A:pydantic.fields.f->_internal._decorators.ensure_property(f)
A:pydantic.fields.dec_info->ComputedFieldInfo(f, return_type, alias, alias_priority, title, description, repr)
pydantic.AliasChoices(self,first_choice:str|AliasPath,*choices:str|AliasPath)
pydantic.AliasChoices.convert_to_aliases(self)->list[list[str | int]]
pydantic.AliasPath(self,first_arg:str,*args:str|int)
pydantic.AliasPath.convert_to_aliases(self)->list[str | int]
pydantic.Field(default:Any=_Undefined,*,default_factory:typing.Callable[[],Any]|None=None,alias:str|None=None,alias_priority:int|None=None,validation_alias:str|AliasPath|AliasChoices|None=None,serialization_alias:str|None=None,title:str|None=None,description:str|None=None,examples:list[Any]|None=None,exclude:bool|None=None,include:bool|None=None,discriminator:str|None=None,json_schema_extra:dict[str,Any]|None=None,frozen:bool|None=None,final:bool|None=None,validate_default:bool|None=None,repr:bool=True,init_var:bool|None=None,kw_only:bool|None=None,pattern:str|None=None,strict:bool|None=None,gt:float|None=None,ge:float|None=None,lt:float|None=None,le:float|None=None,multiple_of:float|None=None,allow_inf_nan:bool|None=None,max_digits:int|None=None,decimal_places:int|None=None,min_length:int|None=None,max_length:int|None=None,**extra:typing_extensions.Unpack[_EmptyKwargs])->Any
pydantic.FieldInfo(self,**kwargs:typing_extensions.Unpack[_FieldInfoInputs])
pydantic.FieldInfo.__repr_args__(self)->ReprArgs
pydantic.FieldInfo._collect_metadata(cls,kwargs:dict[str,Any])->list[Any]
pydantic.FieldInfo._extract_metadata(cls,annotation:type[Any]|None)->tuple[type[Any] | None, list[Any]]
pydantic.FieldInfo._find_field_info_arg(args:Any)->FieldInfo | None
pydantic.FieldInfo._from_dataclass_field(cls,dc_field:DataclassField[Any])->typing_extensions.Self
pydantic.FieldInfo.apply_typevars_map(self,typevars_map:dict[Any,Any]|None,types_namespace:dict[str,Any]|None)->None
pydantic.FieldInfo.from_annotated_attribute(cls,annotation:type[Any],default:Any)->typing_extensions.Self
pydantic.FieldInfo.from_annotation(cls,annotation:type[Any])->typing_extensions.Self
pydantic.FieldInfo.from_field(cls,default:Any=_Undefined,**kwargs:typing_extensions.Unpack[_FromFieldInfoInputs])->typing_extensions.Self
pydantic.FieldInfo.get_default(self,*,call_default_factory:bool=False)->Any
pydantic.FieldInfo.is_required(self)->bool
pydantic.FieldInfo.rebuild_annotation(self)->Any
pydantic.PrivateAttr(default:Any=_Undefined,*,default_factory:typing.Callable[[],Any]|None=None)->Any
pydantic.computed_field(*,return_type:Any=None,alias:str|None=None,alias_priority:int|None=None,title:str|None=None,description:str|None=None,repr:bool=True)->typing.Callable[[PropertyT], PropertyT]
pydantic.computed_field(__f:PropertyT|None=None,*,alias:str|None=None,alias_priority:int|None=None,title:str|None=None,description:str|None=None,repr:bool=True,return_type:Any=None)->PropertyT | typing.Callable[[PropertyT], PropertyT]
pydantic.computed_field(__func:PropertyT)->PropertyT
pydantic.fields.AliasChoices(self,first_choice:str|AliasPath,*choices:str|AliasPath)
pydantic.fields.AliasChoices.convert_to_aliases(self)->list[list[str | int]]
pydantic.fields.AliasPath(self,first_arg:str,*args:str|int)
pydantic.fields.AliasPath.convert_to_aliases(self)->list[str | int]
pydantic.fields.ComputedFieldInfo
pydantic.fields.Field(default:Any=_Undefined,*,default_factory:typing.Callable[[],Any]|None=None,alias:str|None=None,alias_priority:int|None=None,validation_alias:str|AliasPath|AliasChoices|None=None,serialization_alias:str|None=None,title:str|None=None,description:str|None=None,examples:list[Any]|None=None,exclude:bool|None=None,include:bool|None=None,discriminator:str|None=None,json_schema_extra:dict[str,Any]|None=None,frozen:bool|None=None,final:bool|None=None,validate_default:bool|None=None,repr:bool=True,init_var:bool|None=None,kw_only:bool|None=None,pattern:str|None=None,strict:bool|None=None,gt:float|None=None,ge:float|None=None,lt:float|None=None,le:float|None=None,multiple_of:float|None=None,allow_inf_nan:bool|None=None,max_digits:int|None=None,decimal_places:int|None=None,min_length:int|None=None,max_length:int|None=None,**extra:typing_extensions.Unpack[_EmptyKwargs])->Any
pydantic.fields.FieldInfo(self,**kwargs:typing_extensions.Unpack[_FieldInfoInputs])
pydantic.fields.FieldInfo.__repr_args__(self)->ReprArgs
pydantic.fields.FieldInfo._collect_metadata(cls,kwargs:dict[str,Any])->list[Any]
pydantic.fields.FieldInfo._extract_metadata(cls,annotation:type[Any]|None)->tuple[type[Any] | None, list[Any]]
pydantic.fields.FieldInfo._find_field_info_arg(args:Any)->FieldInfo | None
pydantic.fields.FieldInfo._from_dataclass_field(cls,dc_field:DataclassField[Any])->typing_extensions.Self
pydantic.fields.FieldInfo.apply_typevars_map(self,typevars_map:dict[Any,Any]|None,types_namespace:dict[str,Any]|None)->None
pydantic.fields.FieldInfo.from_annotated_attribute(cls,annotation:type[Any],default:Any)->typing_extensions.Self
pydantic.fields.FieldInfo.from_annotation(cls,annotation:type[Any])->typing_extensions.Self
pydantic.fields.FieldInfo.from_field(cls,default:Any=_Undefined,**kwargs:typing_extensions.Unpack[_FromFieldInfoInputs])->typing_extensions.Self
pydantic.fields.FieldInfo.get_default(self,*,call_default_factory:bool=False)->Any
pydantic.fields.FieldInfo.is_required(self)->bool
pydantic.fields.FieldInfo.rebuild_annotation(self)->Any
pydantic.fields.ModelPrivateAttr(self,default:Any=_Undefined,*,default_factory:typing.Callable[[],Any]|None=None)
pydantic.fields.ModelPrivateAttr.__eq__(self,other:Any)->bool
pydantic.fields.ModelPrivateAttr.__getattr__(self,item:str)->Any
pydantic.fields.ModelPrivateAttr.__set_name__(self,cls:type[Any],name:str)->None
pydantic.fields.ModelPrivateAttr.get_default(self)->Any
pydantic.fields.PrivateAttr(default:Any=_Undefined,*,default_factory:typing.Callable[[],Any]|None=None)->Any
pydantic.fields._EmptyKwargs(typing_extensions.TypedDict)
pydantic.fields._FieldInfoInputs(_FromFieldInfoInputs,total=False)
pydantic.fields._FromFieldInfoInputs(typing_extensions.TypedDict,total=False)
pydantic.fields.computed_field(*,return_type:Any=None,alias:str|None=None,alias_priority:int|None=None,title:str|None=None,description:str|None=None,repr:bool=True)->typing.Callable[[PropertyT], PropertyT]
pydantic.fields.computed_field(__f:PropertyT|None=None,*,alias:str|None=None,alias_priority:int|None=None,title:str|None=None,description:str|None=None,repr:bool=True,return_type:Any=None)->PropertyT | typing.Callable[[PropertyT], PropertyT]
pydantic.fields.computed_field(__func:PropertyT)->PropertyT


----------------------------------------/home/zhang/Packages/pydantic/pydantic2.0b1/deprecated/class_validators.py----------------------------------------
A:pydantic.deprecated.class_validators._V1ValidatorType->TypeVar('_V1ValidatorType', V1Validator, _PartialClsOrStaticMethod)
A:pydantic.deprecated.class_validators._V1RootValidatorFunctionType->TypeVar('_V1RootValidatorFunctionType', _decorators_v1.V1RootValidatorFunction, _V1RootValidatorClsMethod, _PartialClsOrStaticMethod)
A:pydantic.deprecated.class_validators.fields->tuple((__field, *fields))
A:pydantic.deprecated.class_validators.f->_internal._decorators.ensure_classmethod_based_on_signature(f)
A:pydantic.deprecated.class_validators.validator_wrapper_info->_internal._decorators.ValidatorDecoratorInfo(fields=fields, mode=mode, each_item=each_item, always=always, check_fields=check_fields)
A:pydantic.deprecated.class_validators.wrap->partial(_decorators_v1.make_v1_generic_root_validator, pre=pre)
A:pydantic.deprecated.class_validators.res->_internal._decorators.ensure_classmethod_based_on_signature(f)
A:pydantic.deprecated.class_validators.dec_info->_internal._decorators.RootValidatorDecoratorInfo(mode=mode)
pydantic.deprecated.class_validators.root_validator(*,pre:Literal[False],skip_on_failure:Literal[True],allow_reuse:bool=...)->Callable[[_V1RootValidatorFunctionType], _V1RootValidatorFunctionType]
pydantic.deprecated.class_validators.root_validator(*,pre:Literal[True],allow_reuse:bool=...)->Callable[[_V1RootValidatorFunctionType], _V1RootValidatorFunctionType]
pydantic.deprecated.class_validators.root_validator(*,pre:bool=False,skip_on_failure:bool=False,allow_reuse:bool=False)->Any
pydantic.deprecated.class_validators.root_validator(*,skip_on_failure:Literal[True],allow_reuse:bool=...)->Callable[[_V1RootValidatorFunctionType], _V1RootValidatorFunctionType]
pydantic.deprecated.class_validators.validator(__field:str,*fields:str,pre:bool=False,each_item:bool=False,always:bool=False,check_fields:bool|None=None,allow_reuse:bool=False)->Callable[[_V1ValidatorType], _V1ValidatorType]
pydantic.root_validator(*,pre:Literal[False],skip_on_failure:Literal[True],allow_reuse:bool=...)->Callable[[_V1RootValidatorFunctionType], _V1RootValidatorFunctionType]
pydantic.root_validator(*,pre:Literal[True],allow_reuse:bool=...)->Callable[[_V1RootValidatorFunctionType], _V1RootValidatorFunctionType]
pydantic.root_validator(*,pre:bool=False,skip_on_failure:bool=False,allow_reuse:bool=False)->Any
pydantic.root_validator(*,skip_on_failure:Literal[True],allow_reuse:bool=...)->Callable[[_V1RootValidatorFunctionType], _V1RootValidatorFunctionType]
pydantic.validator(__field:str,*fields:str,pre:bool=False,each_item:bool=False,always:bool=False,check_fields:bool|None=None,allow_reuse:bool=False)->Callable[[_V1ValidatorType], _V1ValidatorType]


----------------------------------------/home/zhang/Packages/pydantic/pydantic2.0b1/deprecated/decorator.py----------------------------------------
A:pydantic.deprecated.decorator.AnyCallableT->TypeVar('AnyCallableT', bound=AnyCallable)
A:pydantic.deprecated.decorator.vd->ValidatedFunction(_func, config)
A:pydantic.deprecated.decorator.type_hints->_internal._typing_extra.get_type_hints(function, include_extras=True)
A:pydantic.deprecated.decorator.values->self.build_values(args, kwargs)
A:pydantic.deprecated.decorator.m->self.init_model_instance(*args, **kwargs)
A:pydantic.deprecated.decorator.arg_iter->enumerate(args)
A:pydantic.deprecated.decorator.(i, a)->next(arg_iter)
A:pydantic.deprecated.decorator.arg_name->self.arg_mapping.get(i)
A:pydantic.deprecated.decorator.var_kwargs->d.pop(self.v_kwargs_name, {})
A:pydantic.deprecated.decorator.pos_args->len(self.arg_mapping)
A:pydantic.deprecated.decorator.config_wrapper->_internal._config.ConfigWrapper(config)
A:pydantic.deprecated.decorator.keys->', '.join(map(repr, v))
A:pydantic.deprecated.decorator.self.model->create_model(to_pascal(self.raw_function.__name__), __base__=DecoratorBaseModel, **fields)
pydantic.deprecated.decorator.ValidatedFunction(self,function:'AnyCallable',config:'ConfigType')
pydantic.deprecated.decorator.ValidatedFunction.build_values(self,args:Tuple[Any,...],kwargs:Dict[str,Any])->Dict[str, Any]
pydantic.deprecated.decorator.ValidatedFunction.call(self,*args:Any,**kwargs:Any)->Any
pydantic.deprecated.decorator.ValidatedFunction.create_model(self,fields:Dict[str,Any],takes_args:bool,takes_kwargs:bool,config:'ConfigType')->None
pydantic.deprecated.decorator.ValidatedFunction.execute(self,m:BaseModel)->Any
pydantic.deprecated.decorator.ValidatedFunction.init_model_instance(self,*args:Any,**kwargs:Any)->BaseModel
pydantic.deprecated.decorator.validate_arguments(func:'AnyCallableT')->'AnyCallableT'
pydantic.deprecated.decorator.validate_arguments(func:None=None,*,config:'ConfigType'=None)->Callable[['AnyCallableT'], 'AnyCallableT']
pydantic.deprecated.decorator.validate_arguments(func:Optional['AnyCallableT']=None,*,config:'ConfigType'=None)->Any


----------------------------------------/home/zhang/Packages/pydantic/pydantic2.0b1/deprecated/parse.py----------------------------------------
A:pydantic.deprecated.parse.b->Path(path).read_bytes()
A:pydantic.deprecated.parse.path->Path(path)
pydantic.deprecated.parse.Protocol(str,Enum)
pydantic.deprecated.parse.load_file(path:str|Path,*,content_type:str|None=None,encoding:str='utf8',proto:Protocol|None=None,allow_pickle:bool=False,json_loads:Callable[[str],Any]=json.loads)->Any
pydantic.deprecated.parse.load_str_bytes(b:str|bytes,*,content_type:str|None=None,encoding:str='utf8',proto:Protocol|None=None,allow_pickle:bool=False,json_loads:Callable[[str],Any]=json.loads)->Any


----------------------------------------/home/zhang/Packages/pydantic/pydantic2.0b1/deprecated/tools.py----------------------------------------
A:pydantic.deprecated.tools.T->TypeVar('T')
A:pydantic.deprecated.tools.res->TypeAdapter(type_).json_schema(by_alias=by_alias, schema_generator=schema_generator, ref_template=ref_template)
A:pydantic.deprecated.tools.res['title']->title(type_)
pydantic.deprecated.tools.parse_obj_as(type_:type[T],obj:Any,type_name:NameFactory|None=None)->T
pydantic.deprecated.tools.schema_json_of(type_:Any,*,title:NameFactory|None=None,by_alias:bool=True,ref_template:str=DEFAULT_REF_TEMPLATE,schema_generator:type[GenerateJsonSchema]=GenerateJsonSchema,**dumps_kwargs:Any)->str
pydantic.deprecated.tools.schema_of(type_:Any,*,title:NameFactory|None=None,by_alias:bool=True,ref_template:str=DEFAULT_REF_TEMPLATE,schema_generator:type[GenerateJsonSchema]=GenerateJsonSchema)->dict[str, Any]
pydantic.parse_obj_as(type_:type[T],obj:Any,type_name:NameFactory|None=None)->T
pydantic.schema_json_of(type_:Any,*,title:NameFactory|None=None,by_alias:bool=True,ref_template:str=DEFAULT_REF_TEMPLATE,schema_generator:type[GenerateJsonSchema]=GenerateJsonSchema,**dumps_kwargs:Any)->str
pydantic.schema_of(type_:Any,*,title:NameFactory|None=None,by_alias:bool=True,ref_template:str=DEFAULT_REF_TEMPLATE,schema_generator:type[GenerateJsonSchema]=GenerateJsonSchema)->dict[str, Any]


----------------------------------------/home/zhang/Packages/pydantic/pydantic2.0b1/deprecated/config.py----------------------------------------
pydantic.BaseConfig(metaclass=_ConfigMetaclass)
pydantic.BaseConfig.__getattr__(self,item:str)->Any
pydantic.BaseConfig.__init_subclass__(cls,**kwargs:Any)->None
pydantic.deprecated.config.BaseConfig(metaclass=_ConfigMetaclass)
pydantic.deprecated.config.BaseConfig.__getattr__(self,item:str)->Any
pydantic.deprecated.config.BaseConfig.__init_subclass__(cls,**kwargs:Any)->None
pydantic.deprecated.config._ConfigMetaclass(type)
pydantic.deprecated.config._ConfigMetaclass.__getattr__(self,item:str)->Any


----------------------------------------/home/zhang/Packages/pydantic/pydantic2.0b1/deprecated/json.py----------------------------------------
A:pydantic.deprecated.json.(minutes, seconds)->divmod(td.seconds, 60)
A:pydantic.deprecated.json.(hours, minutes)->divmod(minutes, 60)
pydantic.deprecated.json.custom_pydantic_encoder(type_encoders:Dict[Any,Callable[[Type[Any]],Any]],obj:Any)->Any
pydantic.deprecated.json.decimal_encoder(dec_value:Decimal)->Union[int, float]
pydantic.deprecated.json.isoformat(o:Union[datetime.date,datetime.time])->str
pydantic.deprecated.json.pydantic_encoder(obj:Any)->Any
pydantic.deprecated.json.timedelta_isoformat(td:datetime.timedelta)->str


----------------------------------------/home/zhang/Packages/pydantic/pydantic2.0b1/deprecated/copy_internals.py----------------------------------------
A:pydantic.deprecated.copy_internals.Model->typing.TypeVar('Model', bound='BaseModel')
A:pydantic.deprecated.copy_internals.exclude->_internal._utils.ValueItems.merge({k: v.exclude for (k, v) in self.model_fields.items() if v.exclude is not None}, exclude)
A:pydantic.deprecated.copy_internals.include->_internal._utils.ValueItems.merge({k: v.include for (k, v) in self.model_fields.items()}, include, intersect=True)
A:pydantic.deprecated.copy_internals.allowed_keys->_calculate_keys(self, include=include, exclude=exclude, exclude_unset=exclude_unset)
A:pydantic.deprecated.copy_internals.items->self.__dict__.items()
A:pydantic.deprecated.copy_internals.v->_get_value(type(self), v, to_dict=to_dict, by_alias=by_alias, include=value_include and value_include.for_element(field_key), exclude=value_exclude and value_exclude.for_element(field_key), exclude_unset=exclude_unset, exclude_defaults=exclude_defaults, exclude_none=exclude_none)
A:pydantic.deprecated.copy_internals.values->deepcopy(values)
A:pydantic.deprecated.copy_internals.extra->deepcopy(extra)
A:pydantic.deprecated.copy_internals.private->deepcopy(private)
A:pydantic.deprecated.copy_internals.m->cls.__new__(cls)
A:pydantic.deprecated.copy_internals.keys->set(self.__dict__.keys())
pydantic.deprecated.copy_internals._calculate_keys(self:BaseModel,include:MappingIntStrAny|None,exclude:MappingIntStrAny|None,exclude_unset:bool,update:typing.Dict[str,Any]|None=None)->typing.AbstractSet[str] | None
pydantic.deprecated.copy_internals._copy_and_set_values(self:Model,values:dict[str,Any],fields_set:set[str],extra:dict[str,Any]|None=None,private:dict[str,Any]|None=None,*,deep:bool)->Model
pydantic.deprecated.copy_internals._get_value(cls:type[BaseModel],v:Any,to_dict:bool,by_alias:bool,include:AbstractSetIntStr|MappingIntStrAny|None,exclude:AbstractSetIntStr|MappingIntStrAny|None,exclude_unset:bool,exclude_defaults:bool,exclude_none:bool)->Any
pydantic.deprecated.copy_internals._iter(self:BaseModel,to_dict:bool=False,by_alias:bool=False,include:AbstractSetIntStr|MappingIntStrAny|None=None,exclude:AbstractSetIntStr|MappingIntStrAny|None=None,exclude_unset:bool=False,exclude_defaults:bool=False,exclude_none:bool=False)->TupleGenerator


----------------------------------------/home/zhang/Packages/pydantic/pydantic2.0b1/deprecated/__init__.py----------------------------------------


----------------------------------------/home/zhang/Packages/pydantic/pydantic2.0b1/_internal/_utils.py----------------------------------------
A:pydantic._internal._utils.KeyType->TypeVar('KeyType')
A:pydantic._internal._utils.updated_mapping->mapping.copy()
A:pydantic._internal._utils.updated_mapping[k]->deep_update(updated_mapping[k], v)
A:pydantic._internal._utils.T->TypeVar('T')
A:pydantic._internal._utils.v_name->name_factory(v)
A:pydantic._internal._utils.items->dict.fromkeys(items, ...)
A:pydantic._internal._utils.item->self._items.get(e)
A:pydantic._internal._utils.all_items->self._coerce_value(v)
A:pydantic._internal._utils.normalized_items[normalized_i]->self.merge(v, normalized_items.get(normalized_i))
A:pydantic._internal._utils.normalized_item->normalized_items.setdefault(i, {})
A:pydantic._internal._utils.normalized_items[i]->self.merge(all_items, normalized_item)
A:pydantic._internal._utils.override->cls._coerce_value(override)
A:pydantic._internal._utils.base->cls._coerce_value(base)
A:pydantic._internal._utils.merged_item->cls.merge(base.get(k), override.get(k), intersect=intersect)
A:pydantic._internal._utils.class_name->getattr(items, '__class__', '???')
A:pydantic._internal._utils.Obj->TypeVar('Obj')
A:pydantic._internal._utils._EMPTY->object()
pydantic._internal._utils.ValueItems(self,value:Any,items:AbstractSetIntStr|MappingIntStrAny)
pydantic._internal._utils.ValueItems.__repr_args__(self)->_repr.ReprArgs
pydantic._internal._utils.ValueItems._coerce_items(items:AbstractSetIntStr|MappingIntStrAny)->MappingIntStrAny
pydantic._internal._utils.ValueItems._coerce_value(cls,value:Any)->Any
pydantic._internal._utils.ValueItems._normalize_indexes(self,items:MappingIntStrAny,v_length:int)->dict[int | str, Any]
pydantic._internal._utils.ValueItems.for_element(self,e:int|str)->AbstractSetIntStr | MappingIntStrAny | None
pydantic._internal._utils.ValueItems.is_excluded(self,item:Any)->bool
pydantic._internal._utils.ValueItems.is_included(self,item:Any)->bool
pydantic._internal._utils.ValueItems.is_true(v:Any)->bool
pydantic._internal._utils.ValueItems.merge(cls,base:Any,override:Any,intersect:bool=False)->Any
pydantic._internal._utils.all_identical(left:typing.Iterable[Any],right:typing.Iterable[Any])->bool
pydantic._internal._utils.almost_equal_floats(value_1:float,value_2:float,*,delta:float=1e-08)->bool
pydantic._internal._utils.deep_update(mapping:dict[KeyType,Any],*updating_mappings:dict[KeyType,Any])->dict[KeyType, Any]
pydantic._internal._utils.is_basemodel(cls:Any)->TypeGuard[type[BaseModel]]
pydantic._internal._utils.is_valid_identifier(identifier:str)->bool
pydantic._internal._utils.lenient_isinstance(o:Any,class_or_tuple:type[Any]|tuple[type[Any],...]|None)->bool
pydantic._internal._utils.lenient_issubclass(cls:Any,class_or_tuple:Any)->bool
pydantic._internal._utils.sequence_like(v:Any)->bool
pydantic._internal._utils.smart_deepcopy(obj:Obj)->Obj
pydantic._internal._utils.unique_list(input_list:list[T]|tuple[T,...],*,name_factory:typing.Callable[[T],str]=str)->list[T]
pydantic._internal._utils.update_not_none(mapping:dict[Any,Any],**update:Any)->None


----------------------------------------/home/zhang/Packages/pydantic/pydantic2.0b1/_internal/_config.py----------------------------------------
A:pydantic._internal._config.self.config_dict->cast(ConfigDict, config)
A:pydantic._internal._config.config_new->ConfigDict()
A:pydantic._internal._config.config->getattr(base, 'model_config', None)
A:pydantic._internal._config.config_class_from_namespace->namespace.get('Config')
A:pydantic._internal._config.config_dict_from_namespace->namespace.get('model_config')
A:pydantic._internal._config.config_new[k]->kwargs.pop(k)
A:pydantic._internal._config.core_config->pydantic_core.core_schema.CoreConfig(**core_schema.dict_not_none(title=self.config_dict.get('title') or (obj and obj.__name__), extra_fields_behavior=self.config_dict.get('extra'), allow_inf_nan=self.config_dict.get('allow_inf_nan'), populate_by_name=self.config_dict.get('populate_by_name'), str_strip_whitespace=self.config_dict.get('str_strip_whitespace'), str_to_lower=self.config_dict.get('str_to_lower'), str_to_upper=self.config_dict.get('str_to_upper'), strict=self.config_dict.get('strict'), ser_json_timedelta=self.config_dict.get('ser_json_timedelta'), ser_json_bytes=self.config_dict.get('ser_json_bytes'), from_attributes=self.config_dict.get('from_attributes'), loc_by_alias=self.config_dict.get('loc_by_alias'), revalidate_instances=self.config_dict.get('revalidate_instances'), validate_default=self.config_dict.get('validate_default'), str_max_length=self.config_dict.get('str_max_length'), str_min_length=self.config_dict.get('str_min_length'), hide_input_in_errors=self.config_dict.get('hide_input_in_errors')))
A:pydantic._internal._config.c->', '.join((f'{k}={v!r}' for (k, v) in self.config_dict.items()))
A:pydantic._internal._config.config_defaults->ConfigDict(title=None, str_to_lower=False, str_to_upper=False, str_strip_whitespace=False, str_min_length=0, str_max_length=None, extra=None, frozen=False, populate_by_name=False, use_enum_values=False, validate_assignment=False, arbitrary_types_allowed=False, from_attributes=False, loc_by_alias=True, alias_generator=None, ignored_types=(), allow_inf_nan=True, json_schema_extra=None, strict=False, revalidate_instances='never', ser_json_timedelta='iso8601', ser_json_bytes='utf8', validate_default=False, validate_return=False, protected_namespaces=('model_',), hide_input_in_errors=False)
A:pydantic._internal._config.config_dict->cast(ConfigDict, config)
A:pydantic._internal._config.config_keys->set(ConfigDict.__annotations__.keys())
A:pydantic._internal._config.message->'\n'.join(['Valid config keys have changed in V2:'] + renamed_bullets + removed_bullets)
pydantic._internal._config.ConfigWrapper(self,config:ConfigDict|dict[str,Any]|type[Any]|None,*,check:bool=True)
pydantic._internal._config.ConfigWrapper.__repr__(self)
pydantic._internal._config.ConfigWrapper.core_config(self,obj:Any)->core_schema.CoreConfig
pydantic._internal._config.ConfigWrapper.for_model(cls,bases:tuple[type[Any],...],namespace:dict[str,Any],kwargs:dict[str,Any])->Self
pydantic._internal._config.check_deprecated(config_dict:ConfigDict)->None
pydantic._internal._config.prepare_config(config:ConfigDict|dict[str,Any]|type[Any]|None)->ConfigDict


----------------------------------------/home/zhang/Packages/pydantic/pydantic2.0b1/_internal/_repr.py----------------------------------------
A:pydantic._internal._repr.__slots__->tuple()
A:pydantic._internal._repr.attrs_names->self.__dict__.keys()
A:pydantic._internal._repr.args->', '.join(map(display_as_type, typing_extensions.get_args(obj)))
pydantic._internal._repr.PlainRepr(str)
pydantic._internal._repr.PlainRepr.__repr__(self)->str
pydantic._internal._repr.Representation
pydantic._internal._repr.Representation.__pretty__(self,fmt:typing.Callable[[Any],Any],**kwargs:Any)->typing.Generator[Any, None, None]
pydantic._internal._repr.Representation.__repr__(self)->str
pydantic._internal._repr.Representation.__repr_args__(self)->ReprArgs
pydantic._internal._repr.Representation.__repr_name__(self)->str
pydantic._internal._repr.Representation.__repr_str__(self,join_str:str)->str
pydantic._internal._repr.Representation.__rich_repr__(self)->RichReprResult
pydantic._internal._repr.Representation.__str__(self)->str
pydantic._internal._repr.display_as_type(obj:Any)->str


----------------------------------------/home/zhang/Packages/pydantic/pydantic2.0b1/_internal/_annotated_handlers.py----------------------------------------
pydantic.GetCoreSchemaHandler(self,__source_type:Any)
pydantic.GetCoreSchemaHandler.generate_schema(self,__source_type:Any)->core_schema.CoreSchema
pydantic.GetJsonSchemaHandler(self,__core_schema:CoreSchemaOrField)
pydantic.GetJsonSchemaHandler.resolve_ref_schema(self,__maybe_ref_json_schema:JsonSchemaValue)->JsonSchemaValue
pydantic._internal._annotated_handlers.GetCoreSchemaHandler(self,__source_type:Any)
pydantic._internal._annotated_handlers.GetCoreSchemaHandler.generate_schema(self,__source_type:Any)->core_schema.CoreSchema
pydantic._internal._annotated_handlers.GetJsonSchemaHandler(self,__core_schema:CoreSchemaOrField)
pydantic._internal._annotated_handlers.GetJsonSchemaHandler.resolve_ref_schema(self,__maybe_ref_json_schema:JsonSchemaValue)->JsonSchemaValue


----------------------------------------/home/zhang/Packages/pydantic/pydantic2.0b1/_internal/_model_construction.py----------------------------------------
A:pydantic._internal._model_construction.(base_field_names, class_vars, base_private_attributes)->mcs._collect_bases_data(bases)
A:pydantic._internal._model_construction.config_wrapper->_config.ConfigWrapper.for_model(bases, namespace, kwargs)
A:pydantic._internal._model_construction.private_attributes->self.__dict__.get('__private_attributes__')
A:pydantic._internal._model_construction.cls.__pydantic_decorators__->_decorators.DecoratorInfos.build(cls)
A:pydantic._internal._model_construction.parameters->getattr(cls, '__parameters__', ())
A:pydantic._internal._model_construction.parent_parameters->getattr(cls, '__pydantic_generic_metadata__', {}).get('parameters', ())
A:pydantic._internal._model_construction.parameters_str->', '.join([str(x) for x in combined_parameters])
A:pydantic._internal._model_construction.cls.__pydantic_parent_namespace__->parent_frame_namespace()
A:pydantic._internal._model_construction.parent_namespace->getattr(cls, '__pydantic_parent_namespace__', None)
A:pydantic._internal._model_construction.types_namespace->get_cls_types_namespace(cls, parent_namespace)
A:pydantic._internal._model_construction.default->private_attr.get_default()
A:pydantic._internal._model_construction.raw_annotations->namespace.get('__annotations__', {})
A:pydantic._internal._model_construction.private_attributes[var_name]->PrivateAttr(default=value)
A:pydantic._internal._model_construction.private_attributes[ann_name]->PrivateAttr()
A:pydantic._internal._model_construction.typevars_map->get_model_typevars_map(cls)
A:pydantic._internal._model_construction.(fields, class_vars)->collect_model_fields(cls, bases, config_wrapper, types_namespace, typevars_map=typevars_map)
A:pydantic._internal._model_construction.gen_schema->GenerateSchema(config_wrapper, types_namespace, typevars_map)
A:pydantic._internal._model_construction.handler->CallbackGetCoreSchemaHandler(partial(gen_schema.generate_schema, from_dunder_get_core_schema=False), gen_schema.generate_schema)
A:pydantic._internal._model_construction.schema->flatten_schema_defs(schema)
A:pydantic._internal._model_construction.cls.__pydantic_validator__->SchemaValidator(simplified_core_schema, core_config)
A:pydantic._internal._model_construction.core_config->_config.ConfigWrapper.for_model(bases, namespace, kwargs).core_config(cls)
A:pydantic._internal._model_construction.simplified_core_schema->inline_schema_defs(schema)
A:pydantic._internal._model_construction.cls.__pydantic_serializer__->SchemaSerializer(simplified_core_schema, core_config)
A:pydantic._internal._model_construction.cls.__signature__->ClassAttribute('__signature__', generate_model_signature(cls.__init__, cls.model_fields, config_wrapper))
A:pydantic._internal._model_construction.present_params->signature(init).parameters.values()
A:pydantic._internal._model_construction.param->param.replace(annotation=Any).replace(annotation=Any)
A:pydantic._internal._model_construction.merged_params[param_name]->Parameter(param_name, Parameter.KEYWORD_ONLY, annotation=field.rebuild_annotation(), **kwargs)
A:pydantic._internal._model_construction.merged_params[var_kw_name]->var_kw.replace(name=var_kw_name)
A:pydantic._internal._model_construction.validator->self._attempt_rebuild()
pydantic._internal._model_construction.MockValidator(self,error_message:str,*,code:PydanticErrorCodes,attempt_rebuild:Callable[[],SchemaValidator|None]|None=None)
pydantic._internal._model_construction.MockValidator.__getattr__(self,item:str)->None
pydantic._internal._model_construction.ModelMetaclass(mcs,cls_name:str,bases:tuple[type[Any],...],namespace:dict[str,Any],__pydantic_generic_metadata__:PydanticGenericMetadata|None=None,__pydantic_reset_parent_namespace__:bool=True,**kwargs:Any)
pydantic._internal._model_construction.ModelMetaclass.__fields__(self)->dict[str, FieldInfo]
pydantic._internal._model_construction.ModelMetaclass.__getattr__(self,item:str)->Any
pydantic._internal._model_construction.ModelMetaclass.__instancecheck__(self,instance:Any)->bool
pydantic._internal._model_construction.ModelMetaclass.__prepare__(cls,*args:Any,**kwargs:Any)->Mapping[str, object]
pydantic._internal._model_construction.ModelMetaclass._collect_bases_data(bases:tuple[type[Any],...])->tuple[set[str], set[str], dict[str, ModelPrivateAttr]]
pydantic._internal._model_construction._ModelNamespaceDict(dict)
pydantic._internal._model_construction._ModelNamespaceDict.__setitem__(self,k:str,v:object)->None
pydantic._internal._model_construction.complete_model_class(cls:type[BaseModel],cls_name:str,config_wrapper:ConfigWrapper,*,raise_errors:bool=True,types_namespace:dict[str,Any]|None)->bool
pydantic._internal._model_construction.generate_model_signature(init:Callable[...,None],fields:dict[str,FieldInfo],config_wrapper:ConfigWrapper)->Signature
pydantic._internal._model_construction.init_private_attributes(self:BaseModel,__context:Any)->None
pydantic._internal._model_construction.inspect_namespace(namespace:dict[str,Any],ignored_types:tuple[type[Any],...],base_class_vars:set[str],base_class_fields:set[str])->dict[str, ModelPrivateAttr]
pydantic._internal._model_construction.model_extra_private_getattr(self:BaseModel,item:str)->Any
pydantic._internal._model_construction.model_private_delattr(self:BaseModel,item:str)->Any
pydantic._internal._model_construction.set_model_fields(cls:type[BaseModel],bases:tuple[type[Any],...],config_wrapper:ConfigWrapper,types_namespace:dict[str,Any])->None
pydantic._internal._model_construction.single_underscore(name:str)->bool


----------------------------------------/home/zhang/Packages/pydantic/pydantic2.0b1/_internal/_validators.py----------------------------------------
A:pydantic._internal._validators.value_type->type(__input_value)
A:pydantic._internal._validators.v_list->validator(__input_value)
A:pydantic._internal._validators.components->dotted_path.strip().split(':')
A:pydantic._internal._validators.module->import_module(module_path)
A:pydantic._internal._validators.(maybe_module_path, maybe_attribute)->dotted_path.strip().rsplit('.', 1)
A:pydantic._internal._validators.PatternType->typing.TypeVar('PatternType', str, bytes)
pydantic._internal._validators._import_string_logic(dotted_path:str)->Any
pydantic._internal._validators.compile_pattern(pattern:PatternType)->typing.Pattern[PatternType]
pydantic._internal._validators.greater_than_or_equal_validator(x:Any,ge:Any)->Any
pydantic._internal._validators.greater_than_validator(x:Any,gt:Any)->Any
pydantic._internal._validators.import_string(value:Any)->Any
pydantic._internal._validators.ip_v4_address_validator(__input_value:Any)->IPv4Address
pydantic._internal._validators.ip_v4_interface_validator(__input_value:Any)->IPv4Interface
pydantic._internal._validators.ip_v4_network_validator(__input_value:Any)->IPv4Network
pydantic._internal._validators.ip_v6_address_validator(__input_value:Any)->IPv6Address
pydantic._internal._validators.ip_v6_interface_validator(__input_value:Any)->IPv6Interface
pydantic._internal._validators.ip_v6_network_validator(__input_value:Any)->IPv6Network
pydantic._internal._validators.less_than_or_equal_validator(x:Any,le:Any)->Any
pydantic._internal._validators.less_than_validator(x:Any,lt:Any)->Any
pydantic._internal._validators.max_length_validator(x:Any,max_length:Any)->Any
pydantic._internal._validators.min_length_validator(x:Any,min_length:Any)->Any
pydantic._internal._validators.multiple_of_validator(x:Any,multiple_of:Any)->Any
pydantic._internal._validators.pattern_bytes_validator(__input_value:Any)->typing.Pattern[bytes]
pydantic._internal._validators.pattern_either_validator(__input_value:Any)->typing.Pattern[Any]
pydantic._internal._validators.pattern_str_validator(__input_value:Any)->typing.Pattern[str]
pydantic._internal._validators.sequence_validator(__input_value:typing.Sequence[Any],validator:core_schema.ValidatorFunctionWrapHandler)->typing.Sequence[Any]


----------------------------------------/home/zhang/Packages/pydantic/pydantic2.0b1/_internal/_decorators_v1.py----------------------------------------
A:pydantic._internal._decorators_v1.sig->signature(validator)
A:pydantic._internal._decorators_v1.val1->cast(V1ValidatorWithValues, validator)
A:pydantic._internal._decorators_v1.val2->cast(V1OnlyValueValidator, validator)
A:pydantic._internal._decorators_v1.values->validator(values)
A:pydantic._internal._decorators_v1.fields->set(model_dict.keys())
A:pydantic._internal._decorators_v1.model_dict_new->validator(model_dict)
A:pydantic._internal._decorators_v1.model_extra[k]->validator(model_dict).pop(k)
pydantic._internal._decorators_v1.V1OnlyValueValidator(self,__value:Any)
pydantic._internal._decorators_v1.V1RootValidatorFunction(self,__values:RootValidatorValues)
pydantic._internal._decorators_v1.V1ValidatorWithKwargs(self,__value:Any,**kwargs:Any)
pydantic._internal._decorators_v1.V1ValidatorWithValues(self,__value:Any,values:dict[str,Any])
pydantic._internal._decorators_v1.V1ValidatorWithValuesAndKwargs(self,__value:Any,values:dict[str,Any],**kwargs:Any)
pydantic._internal._decorators_v1.V1ValidatorWithValuesKwOnly(self,__value:Any,*,values:dict[str,Any])
pydantic._internal._decorators_v1.V2CoreAfterRootValidator(self,__fields_tuple:RootValidatorFieldsTuple,__info:core_schema.ValidationInfo)
pydantic._internal._decorators_v1.V2CoreBeforeRootValidator(self,__values:RootValidatorValues,__info:core_schema.ValidationInfo)
pydantic._internal._decorators_v1.can_be_keyword(param:Parameter)->bool
pydantic._internal._decorators_v1.make_generic_v1_field_validator(validator:V1Validator)->core_schema.FieldValidatorFunction
pydantic._internal._decorators_v1.make_v1_generic_root_validator(validator:V1RootValidatorFunction,pre:bool)->V2CoreBeforeRootValidator | V2CoreAfterRootValidator


----------------------------------------/home/zhang/Packages/pydantic/pydantic2.0b1/_internal/_schema_generation_shared.py----------------------------------------
A:pydantic._internal._schema_generation_shared.self.original_schema->self.handler(core_schema)
A:pydantic._internal._schema_generation_shared.original_referenced_schema->self.resolve_ref_schema(self.original_schema)
A:pydantic._internal._schema_generation_shared.wrapped_handler->UnpackedRefJsonSchemaHandler(handler)
A:pydantic._internal._schema_generation_shared.json_schema->self.generate_json_schema.get_schema_from_definitions(ref)
pydantic._internal._schema_generation_shared.CallbackGetCoreSchemaHandler(self,handler:Callable[[Any],core_schema.CoreSchema],generate_schema:Callable[[Any],core_schema.CoreSchema])
pydantic._internal._schema_generation_shared.CallbackGetCoreSchemaHandler.generate_schema(self,__source_type:Any)->core_schema.CoreSchema
pydantic._internal._schema_generation_shared.GenerateJsonSchemaHandler(self,generate_json_schema:GenerateJsonSchema,handler_override:HandlerOverride|None)
pydantic._internal._schema_generation_shared.GenerateJsonSchemaHandler.resolve_ref_schema(self,maybe_ref_json_schema:JsonSchemaValue)->JsonSchemaValue
pydantic._internal._schema_generation_shared.UnpackedRefJsonSchemaHandler(self,handler:GetJsonSchemaHandler)
pydantic._internal._schema_generation_shared.UnpackedRefJsonSchemaHandler.resolve_ref_schema(self,__maybe_ref_json_schema:JsonSchemaValue)->JsonSchemaValue
pydantic._internal._schema_generation_shared.UnpackedRefJsonSchemaHandler.update_schema(self,schema:JsonSchemaValue)->JsonSchemaValue
pydantic._internal._schema_generation_shared.wrap_json_schema_fn_for_model_or_custom_type_with_ref_unpacking(fn:GetJsonSchemaFunction)->GetJsonSchemaFunction


----------------------------------------/home/zhang/Packages/pydantic/pydantic2.0b1/_internal/_decorators.py----------------------------------------
A:pydantic._internal._decorators.ReturnType->TypeVar('ReturnType')
A:pydantic._internal._decorators.f->partial(self._call_wrapped_attr, name=attr)
A:pydantic._internal._decorators.self.wrapped->getattr(self.wrapped, name)(func)
A:pydantic._internal._decorators.DecoratorInfoType->TypeVar('DecoratorInfoType', bound=DecoratorInfo)
A:pydantic._internal._decorators.func->unwrap_wrapped_function(func)
A:pydantic._internal._decorators.bases->get_bases(tp)
A:pydantic._internal._decorators.res->DecoratorInfos()
A:pydantic._internal._decorators.existing->DecoratorInfos.build(base)
A:pydantic._internal._decorators.res.validators[var_name]->Decorator.build(model_dc, cls_var_name=var_name, shim=var_value.shim, info=info)
A:pydantic._internal._decorators.res.field_validators[var_name]->Decorator.build(model_dc, cls_var_name=var_name, shim=var_value.shim, info=info)
A:pydantic._internal._decorators.res.root_validators[var_name]->Decorator.build(model_dc, cls_var_name=var_name, shim=var_value.shim, info=info)
A:pydantic._internal._decorators.res.field_serializers[var_name]->Decorator.build(model_dc, cls_var_name=var_name, shim=var_value.shim, info=info)
A:pydantic._internal._decorators.res.model_validators[var_name]->Decorator.build(model_dc, cls_var_name=var_name, shim=var_value.shim, info=info)
A:pydantic._internal._decorators.res.model_serializers[var_name]->Decorator.build(model_dc, cls_var_name=var_name, shim=var_value.shim, info=info)
A:pydantic._internal._decorators.res.computed_fields[var_name]->Decorator.build(model_dc, cls_var_name=var_name, shim=None, info=info)
A:pydantic._internal._decorators.sig->signature(unwrap_wrapped_function(function))
A:pydantic._internal._decorators.n_positional->count_positional_params(sig)
A:pydantic._internal._decorators.first->next(iter(sig.parameters.values()), None)
A:pydantic._internal._decorators.info_arg->_serializer_info_arg(mode, count_positional_params(sig))
A:pydantic._internal._decorators.cached_property->type('', (), {})
A:pydantic._internal._decorators.hints->get_function_type_hints(unwrap_wrapped_function(func), include_keys={'return'})
pydantic._internal._decorators.Decorator(Generic[DecoratorInfoType])
pydantic._internal._decorators.Decorator.bind_to_cls(self,cls:Any)->Decorator[DecoratorInfoType]
pydantic._internal._decorators.Decorator.build(cls_:Any,*,cls_var_name:str,shim:Callable[[Any],Any]|None,info:DecoratorInfoType)->Decorator[DecoratorInfoType]
pydantic._internal._decorators.DecoratorInfos
pydantic._internal._decorators.DecoratorInfos.build(model_dc:type[Any])->DecoratorInfos
pydantic._internal._decorators.FieldSerializerDecoratorInfo
pydantic._internal._decorators.FieldValidatorDecoratorInfo
pydantic._internal._decorators.ModelSerializerDecoratorInfo
pydantic._internal._decorators.ModelValidatorDecoratorInfo
pydantic._internal._decorators.PydanticDescriptorProxy(Generic[ReturnType])
pydantic._internal._decorators.PydanticDescriptorProxy.__get__(self,obj:object|None,obj_type:type[object]|None=None)->PydanticDescriptorProxy[ReturnType]
pydantic._internal._decorators.PydanticDescriptorProxy.__getattr__(self,__name:str)->Any
pydantic._internal._decorators.PydanticDescriptorProxy.__post_init__(self)
pydantic._internal._decorators.PydanticDescriptorProxy.__set_name__(self,instance:Any,name:str)->None
pydantic._internal._decorators.PydanticDescriptorProxy._call_wrapped_attr(self,func:Callable[[Any],None],*,name:str)->PydanticDescriptorProxy[ReturnType]
pydantic._internal._decorators.RootValidatorDecoratorInfo
pydantic._internal._decorators.ValidatorDecoratorInfo
pydantic._internal._decorators._is_classmethod_from_sig(function:AnyDecoratorCallable)->bool
pydantic._internal._decorators._serializer_info_arg(mode:Literal['plain','wrap'],n_positional:int)->bool | None
pydantic._internal._decorators.can_be_positional(param:Parameter)->bool
pydantic._internal._decorators.count_positional_params(sig:Signature)->int
pydantic._internal._decorators.ensure_classmethod_based_on_signature(function:AnyDecoratorCallable)->Any
pydantic._internal._decorators.ensure_property(f:Any)->Any
pydantic._internal._decorators.get_attribute_from_bases(tp:type[Any],name:str)->Any
pydantic._internal._decorators.get_bases(tp:type[Any])->tuple[type[Any], ...]
pydantic._internal._decorators.get_function_return_type(func:Any,explicit_return_type:Any)->Any
pydantic._internal._decorators.inspect_annotated_serializer(serializer:Callable[...,Any],mode:Literal['plain','wrap'])->bool
pydantic._internal._decorators.inspect_field_serializer(serializer:Callable[...,Any],mode:Literal['plain','wrap'])->tuple[bool, bool]
pydantic._internal._decorators.inspect_model_serializer(serializer:Callable[...,Any],mode:Literal['plain','wrap'])->bool
pydantic._internal._decorators.inspect_validator(validator:Callable[...,Any],mode:FieldValidatorModes)->bool
pydantic._internal._decorators.is_instance_method_from_sig(function:AnyDecoratorCallable)->bool
pydantic._internal._decorators.mro(tp:type[Any])->tuple[type[Any], ...]
pydantic._internal._decorators.unwrap_wrapped_function(func:Any,*,unwrap_class_static_method:bool=True)->Any


----------------------------------------/home/zhang/Packages/pydantic/pydantic2.0b1/_internal/_core_utils.py----------------------------------------
A:pydantic._internal._core_utils.generic_metadata->getattr(type_, '__pydantic_generic_metadata__', None)
A:pydantic._internal._core_utils.module_name->getattr(origin, '__module__', '<No __module__>')
A:pydantic._internal._core_utils.qualname->getattr(origin, '__qualname__', f'<No __qualname__: {origin}>')
A:pydantic._internal._core_utils.top_ref->walk_core_schema(schema, inline_refs).get('ref', None)
A:pydantic._internal._core_utils.valid_definitions->dict()
A:pydantic._internal._core_utils.metadata->definition.get('metadata')
A:pydantic._internal._core_utils.valid_refs->collect_definitions(schema).keys()
A:pydantic._internal._core_utils.new_schema->walk_core_schema(schema, inline_refs).copy()
A:pydantic._internal._core_utils.refs->set()
A:pydantic._internal._core_utils.expected_missing_refs->allowed_missing_refs.difference(refs)
A:pydantic._internal._core_utils.T->TypeVar('T')
A:pydantic._internal._core_utils.self._schema_type_to_method->self._build_schema_type_to_method()
A:pydantic._internal._core_utils.mapping[key]->getattr(self, method_name, self._handle_other_schemas)
A:pydantic._internal._core_utils.schema->walk_core_schema(schema, inline_refs)
A:pydantic._internal._core_utils.schema['serialization']->self._handle_ser_schemas(ser_schema.copy(), f)
A:pydantic._internal._core_utils.schema['schema']->self.walk(schema['schema'], f)
A:pydantic._internal._core_utils.ser_schema['schema']->self.walk(schema, f)
A:pydantic._internal._core_utils.updated_definition->self.walk(definition, f)
A:pydantic._internal._core_utils.new_inner_schema->self.walk(schema['schema'], f)
A:pydantic._internal._core_utils.schema['items_schema']->self.walk(schema['items_schema'], f)
A:pydantic._internal._core_utils.schema['extra_schema']->self.walk(schema['extra_schema'], f)
A:pydantic._internal._core_utils.schema['keys_schema']->self.walk(schema['keys_schema'], f)
A:pydantic._internal._core_utils.schema['values_schema']->self.walk(schema['values_schema'], f)
A:pydantic._internal._core_utils.schema['lax_schema']->self.walk(schema['lax_schema'], f)
A:pydantic._internal._core_utils.schema['strict_schema']->self.walk(schema['strict_schema'], f)
A:pydantic._internal._core_utils.schema['json_schema']->self.walk(schema['json_schema'], f)
A:pydantic._internal._core_utils.schema['python_schema']->self.walk(schema['python_schema'], f)
A:pydantic._internal._core_utils.schema['extra_validator']->self.walk(schema['extra_validator'], f)
A:pydantic._internal._core_utils.replaced_field->field.copy()
A:pydantic._internal._core_utils.replaced_field['schema']->self.walk(field['schema'], f)
A:pydantic._internal._core_utils.replaced_param->param.copy()
A:pydantic._internal._core_utils.replaced_param['schema']->self.walk(param['schema'], f)
A:pydantic._internal._core_utils.schema['var_args_schema']->self.walk(schema['var_args_schema'], f)
A:pydantic._internal._core_utils.schema['var_kwargs_schema']->self.walk(schema['var_kwargs_schema'], f)
A:pydantic._internal._core_utils.schema['arguments_schema']->self.walk(schema['arguments_schema'], f)
A:pydantic._internal._core_utils.schema['return_schema']->self.walk(schema['return_schema'], f)
A:pydantic._internal._core_utils.definitions->list(defs)
A:pydantic._internal._core_utils.ref->get_ref(s)
A:pydantic._internal._core_utils.all_defs[ref]->recurse(definition, collect_refs).copy()
A:pydantic._internal._core_utils.s['schema']->recurse(s['schema'], flatten_refs)
A:pydantic._internal._core_utils.s->recurse(new, inline_refs)
A:pydantic._internal._core_utils.new->all_defs.pop(ref)
pydantic._internal._core_utils._WalkCoreSchema(self)
pydantic._internal._core_utils._WalkCoreSchema._build_schema_type_to_method(self)->dict[core_schema.CoreSchemaType, Recurse]
pydantic._internal._core_utils._WalkCoreSchema._handle_other_schemas(self,schema:core_schema.CoreSchema,f:Walk)->core_schema.CoreSchema
pydantic._internal._core_utils._WalkCoreSchema._handle_ser_schemas(self,ser_schema:core_schema.SerSchema,f:Walk)->core_schema.SerSchema
pydantic._internal._core_utils._WalkCoreSchema._walk(self,schema:core_schema.CoreSchema,f:Walk)->core_schema.CoreSchema
pydantic._internal._core_utils._WalkCoreSchema.handle_arguments_schema(self,schema:core_schema.ArgumentsSchema,f:Walk)->core_schema.CoreSchema
pydantic._internal._core_utils._WalkCoreSchema.handle_call_schema(self,schema:core_schema.CallSchema,f:Walk)->core_schema.CoreSchema
pydantic._internal._core_utils._WalkCoreSchema.handle_chain_schema(self,schema:core_schema.ChainSchema,f:Walk)->core_schema.CoreSchema
pydantic._internal._core_utils._WalkCoreSchema.handle_dataclass_args_schema(self,schema:core_schema.DataclassArgsSchema,f:Walk)->core_schema.CoreSchema
pydantic._internal._core_utils._WalkCoreSchema.handle_definitions_schema(self,schema:core_schema.DefinitionsSchema,f:Walk)->core_schema.CoreSchema
pydantic._internal._core_utils._WalkCoreSchema.handle_dict_schema(self,schema:core_schema.DictSchema,f:Walk)->core_schema.CoreSchema
pydantic._internal._core_utils._WalkCoreSchema.handle_frozenset_schema(self,schema:core_schema.FrozenSetSchema,f:Walk)->core_schema.CoreSchema
pydantic._internal._core_utils._WalkCoreSchema.handle_function_schema(self,schema:AnyFunctionSchema,f:Walk)->core_schema.CoreSchema
pydantic._internal._core_utils._WalkCoreSchema.handle_generator_schema(self,schema:core_schema.GeneratorSchema,f:Walk)->core_schema.CoreSchema
pydantic._internal._core_utils._WalkCoreSchema.handle_json_or_python_schema(self,schema:core_schema.JsonOrPythonSchema,f:Walk)->core_schema.CoreSchema
pydantic._internal._core_utils._WalkCoreSchema.handle_lax_or_strict_schema(self,schema:core_schema.LaxOrStrictSchema,f:Walk)->core_schema.CoreSchema
pydantic._internal._core_utils._WalkCoreSchema.handle_list_schema(self,schema:core_schema.ListSchema,f:Walk)->core_schema.CoreSchema
pydantic._internal._core_utils._WalkCoreSchema.handle_model_fields_schema(self,schema:core_schema.ModelFieldsSchema,f:Walk)->core_schema.CoreSchema
pydantic._internal._core_utils._WalkCoreSchema.handle_set_schema(self,schema:core_schema.SetSchema,f:Walk)->core_schema.CoreSchema
pydantic._internal._core_utils._WalkCoreSchema.handle_tagged_union_schema(self,schema:core_schema.TaggedUnionSchema,f:Walk)->core_schema.CoreSchema
pydantic._internal._core_utils._WalkCoreSchema.handle_tuple_positional_schema(self,schema:core_schema.TupleVariableSchema|core_schema.TuplePositionalSchema,f:Walk)->core_schema.CoreSchema
pydantic._internal._core_utils._WalkCoreSchema.handle_tuple_variable_schema(self,schema:core_schema.TupleVariableSchema|core_schema.TuplePositionalSchema,f:Walk)->core_schema.CoreSchema
pydantic._internal._core_utils._WalkCoreSchema.handle_typed_dict_schema(self,schema:core_schema.TypedDictSchema,f:Walk)->core_schema.CoreSchema
pydantic._internal._core_utils._WalkCoreSchema.handle_union_schema(self,schema:core_schema.UnionSchema,f:Walk)->core_schema.CoreSchema
pydantic._internal._core_utils._WalkCoreSchema.walk(self,schema:core_schema.CoreSchema,f:Walk)->core_schema.CoreSchema
pydantic._internal._core_utils._simplify_schema_references(schema:core_schema.CoreSchema,inline:bool)->core_schema.CoreSchema
pydantic._internal._core_utils.collect_definitions(schema:core_schema.CoreSchema)->dict[str, core_schema.CoreSchema]
pydantic._internal._core_utils.collect_invalid_schemas(schema:core_schema.CoreSchema)->list[core_schema.CoreSchema]
pydantic._internal._core_utils.consolidate_refs(schema:core_schema.CoreSchema)->core_schema.CoreSchema
pydantic._internal._core_utils.define_expected_missing_refs(schema:core_schema.CoreSchema,allowed_missing_refs:set[str])->core_schema.CoreSchema
pydantic._internal._core_utils.flatten_schema_defs(schema:core_schema.CoreSchema)->core_schema.CoreSchema
pydantic._internal._core_utils.get_type_ref(type_:type[Any],args_override:tuple[type[Any],...]|None=None)->str
pydantic._internal._core_utils.inline_schema_defs(schema:core_schema.CoreSchema)->core_schema.CoreSchema
pydantic._internal._core_utils.is_core_schema(schema:CoreSchemaOrField)->TypeGuard[CoreSchema]
pydantic._internal._core_utils.is_core_schema_field(schema:CoreSchemaOrField)->TypeGuard[CoreSchemaField]
pydantic._internal._core_utils.is_definition_ref_schema(s:core_schema.CoreSchema)->TypeGuard[core_schema.DefinitionReferenceSchema]
pydantic._internal._core_utils.is_definitions_schema(s:core_schema.CoreSchema)->TypeGuard[core_schema.DefinitionsSchema]
pydantic._internal._core_utils.is_function_with_inner_schema(schema:CoreSchemaOrField)->TypeGuard[FunctionSchemaWithInnerSchema]
pydantic._internal._core_utils.is_list_like_schema_with_items_schema(schema:CoreSchema)->TypeGuard[core_schema.ListSchema | core_schema.TupleVariableSchema | core_schema.SetSchema | core_schema.FrozenSetSchema]
pydantic._internal._core_utils.remove_unnecessary_invalid_definitions(schema:core_schema.CoreSchema)->core_schema.CoreSchema
pydantic._internal._core_utils.walk_core_schema(schema:core_schema.CoreSchema,f:Walk)->core_schema.CoreSchema


----------------------------------------/home/zhang/Packages/pydantic/pydantic2.0b1/_internal/_fields.py----------------------------------------
A:pydantic._internal._fields.module_name->getattr(obj, '__module__', None)
A:pydantic._internal._fields.Undefined->_UndefinedType()
A:pydantic._internal._fields.type_hints->get_cls_type_hints_lenient(cls, types_namespace)
A:pydantic._internal._fields.annotations->cls.__dict__.get('__annotations__', {})
A:pydantic._internal._fields.generic_origin->getattr(cls, '__pydantic_generic_metadata__', {}).get('origin')
A:pydantic._internal._fields.default->getattr(cls, ann_name, Undefined)
A:pydantic._internal._fields.field_info->fields.FieldInfo.from_annotated_attribute(ann_type, dataclass_field)
A:pydantic._internal._fields.cls_localns->dict(vars(cls))
A:pydantic._internal._fields.ann_type->_typing_extra.eval_type_lenient(dataclass_field.type, types_namespace, cls_localns)
pydantic._internal._fields.PydanticGeneralMetadata(self,**metadata:Any)
pydantic._internal._fields.PydanticMetadata(Representation)
pydantic._internal._fields._UndefinedType
pydantic._internal._fields._UndefinedType.__copy__(self)->_UndefinedType
pydantic._internal._fields._UndefinedType.__deepcopy__(self,_:Any)->_UndefinedType
pydantic._internal._fields._UndefinedType.__reduce__(self)->str
pydantic._internal._fields._UndefinedType.__repr__(self)->str
pydantic._internal._fields._is_finalvar_with_default_val(type_:type[Any],val:Any)->bool
pydantic._internal._fields.collect_dataclass_fields(cls:type[StandardDataclass],types_namespace:dict[str,Any]|None,*,typevars_map:dict[Any,Any]|None=None)->dict[str, FieldInfo]
pydantic._internal._fields.collect_model_fields(cls:type[BaseModel],bases:tuple[type[Any],...],config_wrapper:ConfigWrapper,types_namespace:dict[str,Any]|None,*,typevars_map:dict[Any,Any]|None=None)->tuple[dict[str, FieldInfo], set[str]]
pydantic._internal._fields.get_type_hints_infer_globalns(obj:Any,localns:dict[str,Any]|None=None,include_extras:bool=False)->dict[str, Any]


----------------------------------------/home/zhang/Packages/pydantic/pydantic2.0b1/_internal/_discriminated_union.py----------------------------------------
A:pydantic._internal._discriminated_union.old_definitions->collect_definitions(schema)
A:pydantic._internal._discriminated_union.schema->pydantic_core.core_schema.definitions_schema(schema, missing_definitions)
A:pydantic._internal._discriminated_union.new_definitions->collect_definitions(schema)
A:pydantic._internal._discriminated_union.wrapped->self._apply_to_root(schema['schema'])
A:pydantic._internal._discriminated_union.nullable_wrapper->pydantic_core.core_schema.definitions_schema(schema, missing_definitions).copy()
A:pydantic._internal._discriminated_union.definitions_wrapper->pydantic_core.core_schema.definitions_schema(schema, missing_definitions).copy()
A:pydantic._internal._discriminated_union.choice->self._choices_to_handle.pop()
A:pydantic._internal._discriminated_union.inferred_discriminator_values->self._infer_discriminator_values_for_choice(choice, source_name=None)
A:pydantic._internal._discriminated_union.subchoice_values->self._infer_discriminator_values_for_choice(subchoice, source_name=None)
A:pydantic._internal._discriminated_union.field->choice['fields'].get(self.discriminator)
A:pydantic._internal._discriminated_union.alias->choice['fields'].get(self.discriminator).get('validation_alias', self.discriminator)
A:pydantic._internal._discriminated_union.choice_values->self._infer_discriminator_values_for_inner_schema(choice, source)
pydantic._internal._discriminated_union._ApplyInferredDiscriminator(self,discriminator:str,definitions:dict[str,core_schema.CoreSchema])
pydantic._internal._discriminated_union._ApplyInferredDiscriminator._apply_to_root(self,schema:core_schema.CoreSchema)->core_schema.CoreSchema
pydantic._internal._discriminated_union._ApplyInferredDiscriminator._handle_choice(self,choice:core_schema.CoreSchema)->None
pydantic._internal._discriminated_union._ApplyInferredDiscriminator._infer_discriminator_values_for_choice(self,choice:core_schema.CoreSchema,source_name:str|None)->list[str | int]
pydantic._internal._discriminated_union._ApplyInferredDiscriminator._infer_discriminator_values_for_dataclass_choice(self,choice:core_schema.DataclassArgsSchema,source_name:str|None=None)->list[str | int]
pydantic._internal._discriminated_union._ApplyInferredDiscriminator._infer_discriminator_values_for_field(self,field:CoreSchemaField,source:str)->list[str | int]
pydantic._internal._discriminated_union._ApplyInferredDiscriminator._infer_discriminator_values_for_inner_schema(self,schema:core_schema.CoreSchema,source:str)->list[str | int]
pydantic._internal._discriminated_union._ApplyInferredDiscriminator._infer_discriminator_values_for_model_choice(self,choice:core_schema.ModelFieldsSchema,source_name:str|None=None)->list[str | int]
pydantic._internal._discriminated_union._ApplyInferredDiscriminator._infer_discriminator_values_for_typed_dict_choice(self,choice:core_schema.TypedDictSchema,source_name:str|None=None)->list[str | int]
pydantic._internal._discriminated_union._ApplyInferredDiscriminator._is_discriminator_shared(self,choice:core_schema.TaggedUnionSchema)->bool
pydantic._internal._discriminated_union._ApplyInferredDiscriminator._set_unique_choice_for_values(self,choice:core_schema.CoreSchema,values:Sequence[str|int])->None
pydantic._internal._discriminated_union._ApplyInferredDiscriminator.apply(self,schema:core_schema.CoreSchema)->core_schema.CoreSchema
pydantic._internal._discriminated_union.apply_discriminator(schema:core_schema.CoreSchema,discriminator:str,definitions:dict[str,core_schema.CoreSchema]|None=None)->core_schema.CoreSchema


----------------------------------------/home/zhang/Packages/pydantic/pydantic2.0b1/_internal/_generics.py----------------------------------------
A:pydantic._internal._generics.KT->TypeVar('KT')
A:pydantic._internal._generics.VT->TypeVar('VT')
A:pydantic._internal._generics._GENERIC_TYPES_CACHE->GenericTypesCache()
A:pydantic._internal._generics.(meta, ns, kwds)->prepare_class(model_name, bases)
A:pydantic._internal._generics.created_model->meta(model_name, bases, namespace, __pydantic_generic_metadata__={'origin': origin, 'args': args, 'parameters': params}, __pydantic_reset_parent_namespace__=False, **kwds)
A:pydantic._internal._generics.(model_module, called_globally)->_get_caller_frame_info(depth=3)
A:pydantic._internal._generics.object_by_reference->reference_module_globals.setdefault(reference_name, created_model)
A:pydantic._internal._generics.previous_caller_frame->sys._getframe(depth)
A:pydantic._internal._generics.args->get_args(v)
A:pydantic._internal._generics.origin->get_origin(cls)
A:pydantic._internal._generics.type_args->get_args(type_)
A:pydantic._internal._generics.origin_type->getattr(typing, type_._name)
A:pydantic._internal._generics.annotated->replace_types(annotated_type, type_map)
A:pydantic._internal._generics.resolved_type_args->tuple((replace_types(t, type_map) for t in parameters))
A:pydantic._internal._generics.resolved_list->list((replace_types(element, type_map) for element in type_))
A:pydantic._internal._generics.actual->len(parameters)
A:pydantic._internal._generics.expected->len(cls.__pydantic_generic_metadata__['parameters'])
A:pydantic._internal._generics.previously_seen_type_refs->set()
A:pydantic._internal._generics.token->_generic_recursion_cache.set(previously_seen_type_refs)
A:pydantic._internal._generics.type_ref->get_type_ref(origin, args_override=args)
A:pydantic._internal._generics.self_type->PydanticRecursiveRef(type_ref=type_ref)
A:pydantic._internal._generics.visited->_generic_recursion_cache.get()
A:pydantic._internal._generics.cached->GenericTypesCache().get(_late_cache_key(origin, args, typevar_values))
pydantic._internal._generics.PydanticGenericMetadata(typing_extensions.TypedDict)
pydantic._internal._generics._early_cache_key(cls:type[BaseModel],typevar_values:Any)->GenericTypesCacheKey
pydantic._internal._generics._get_caller_frame_info(depth:int=2)->tuple[str | None, bool]
pydantic._internal._generics._late_cache_key(origin:type[BaseModel],args:tuple[Any,...],typevar_values:Any)->GenericTypesCacheKey
pydantic._internal._generics._union_orderings_key(typevar_values:Any)->Any
pydantic._internal._generics.check_parameters_count(cls:type[BaseModel],parameters:tuple[Any,...])->None
pydantic._internal._generics.create_generic_submodel(model_name:str,origin:type[BaseModel],args:tuple[Any,...],params:tuple[Any,...])->type[BaseModel]
pydantic._internal._generics.generic_recursion_self_type(origin:type[BaseModel],args:tuple[Any,...])->Iterator[PydanticForwardRef | PydanticRecursiveRef | None]
pydantic._internal._generics.get_args(v:Any)->Any
pydantic._internal._generics.get_cached_generic_type_early(parent:type[BaseModel],typevar_values:Any)->type[BaseModel] | None
pydantic._internal._generics.get_cached_generic_type_late(parent:type[BaseModel],typevar_values:Any,origin:type[BaseModel],args:tuple[Any,...])->type[BaseModel] | None
pydantic._internal._generics.get_model_typevars_map(cls:type[BaseModel])->dict[TypeVarType, Any] | None
pydantic._internal._generics.get_origin(v:Any)->Any
pydantic._internal._generics.get_standard_typevars_map(cls:type[Any])->dict[TypeVarType, Any] | None
pydantic._internal._generics.iter_contained_typevars(v:Any)->Iterator[TypeVarType]
pydantic._internal._generics.recursively_defined_type_refs()->set[str]
pydantic._internal._generics.replace_types(type_:Any,type_map:Mapping[Any,Any]|None)->Any
pydantic._internal._generics.set_cached_generic_type(parent:type[BaseModel],typevar_values:tuple[Any,...],type_:type[BaseModel],origin:type[BaseModel]|None=None,args:tuple[Any,...]|None=None)->None


----------------------------------------/home/zhang/Packages/pydantic/pydantic2.0b1/_internal/_typing_extra.py----------------------------------------
A:pydantic._internal._typing_extra.NoneType->type(None)
A:pydantic._internal._typing_extra.EllipsisType->type(Ellipsis)
A:pydantic._internal._typing_extra.values->literal_values(type_)
A:pydantic._internal._typing_extra.origin->get_origin(ann_type)
A:pydantic._internal._typing_extra.test_new_type->typing.NewType('test_new_type', str)
A:pydantic._internal._typing_extra.frame->sys._getframe(parent_depth)
A:pydantic._internal._typing_extra.module_name->getattr(obj, '__module__', None)
A:pydantic._internal._typing_extra.ns->add_module_globals(cls, parent_namespace)
A:pydantic._internal._typing_extra.ann->base.__dict__.get('__annotations__', {})
A:pydantic._internal._typing_extra.localns->dict(vars(base))
A:pydantic._internal._typing_extra.hints[name]->eval_type_lenient(value, globalns, localns)
A:pydantic._internal._typing_extra.value->typing._eval_type(value, globalns, localns)
A:pydantic._internal._typing_extra.globalns->getattr(nsobj, '__globals__', {})
A:pydantic._internal._typing_extra.type_hints[name]->typing._eval_type(value, globalns, None)
A:pydantic._internal._typing_extra.res->typing.ForwardRef(arg, is_argument, is_class=is_class)
A:pydantic._internal._typing_extra.base_globals->getattr(sys.modules.get(base.__module__, None), '__dict__', {})
A:pydantic._internal._typing_extra.hints->dict(hints)
A:pydantic._internal._typing_extra.defaults->typing._get_defaults(obj)
pydantic._internal._typing_extra._check_classvar(v:type[Any]|None)->bool
pydantic._internal._typing_extra._check_finalvar(v:type[Any]|None)->bool
pydantic._internal._typing_extra.add_module_globals(obj:Any,globalns:dict[str,Any]|None=None)->dict[str, Any]
pydantic._internal._typing_extra.all_literal_values(type_:type[Any])->list[Any]
pydantic._internal._typing_extra.eval_type_lenient(value:Any,globalns:dict[str,Any]|None,localns:dict[str,Any]|None)->Any
pydantic._internal._typing_extra.get_cls_type_hints_lenient(obj:Any,globalns:dict[str,Any]|None=None)->dict[str, Any]
pydantic._internal._typing_extra.get_cls_types_namespace(cls:type[Any],parent_namespace:dict[str,Any]|None=None)->dict[str, Any]
pydantic._internal._typing_extra.get_function_type_hints(function:Callable[...,Any],*,include_keys:set[str]|None=None)->dict[str, Any]
pydantic._internal._typing_extra.is_annotated(ann_type:Any)->bool
pydantic._internal._typing_extra.is_callable_type(type_:type[Any])->bool
pydantic._internal._typing_extra.is_classvar(ann_type:type[Any])->bool
pydantic._internal._typing_extra.is_dataclass(_cls:type[Any])->TypeGuard[type[StandardDataclass]]
pydantic._internal._typing_extra.is_finalvar(ann_type:Any)->bool
pydantic._internal._typing_extra.is_literal_type(type_:type[Any])->bool
pydantic._internal._typing_extra.is_namedtuple(type_:type[Any])->bool
pydantic._internal._typing_extra.is_new_type(type_:type[Any])->bool
pydantic._internal._typing_extra.is_none_type(type_:Any)->bool
pydantic._internal._typing_extra.literal_values(type_:type[Any])->tuple[Any, ...]
pydantic._internal._typing_extra.origin_is_type_alias_type(origin:Any)->TypeGuard[TypeAliasType]
pydantic._internal._typing_extra.parent_frame_namespace(*,parent_depth:int=2)->dict[str, Any] | None


----------------------------------------/home/zhang/Packages/pydantic/pydantic2.0b1/_internal/_core_metadata.py----------------------------------------
A:pydantic._internal._core_metadata.metadata->CoreMetadata(pydantic_js_functions=js_functions or [], pydantic_js_prefer_positional_arguments=js_prefer_positional_arguments)
A:pydantic._internal._core_metadata.schema['metadata']->CoreMetadata()
A:pydantic._internal._core_metadata.self._schema['metadata']metadata->CoreMetadata()
A:pydantic._internal._core_metadata.js_function->self.metadata.get('pydantic_js_function')
pydantic._internal._core_metadata.CoreMetadata(typing_extensions.TypedDict,total=False)
pydantic._internal._core_metadata.CoreMetadataHandler(self,schema:CoreSchemaOrField)
pydantic._internal._core_metadata.CoreMetadataHandler.get_json_schema(self,core_schema:CoreSchemaOrField,handler:GetJsonSchemaHandler)->JsonSchemaValue
pydantic._internal._core_metadata.CoreMetadataHandler.metadata(self)->CoreMetadata
pydantic._internal._core_metadata.UpdateCoreSchemaCallable(self,schema:CoreSchema,**kwargs:Any)
pydantic._internal._core_metadata.build_metadata_dict(*,js_functions:list[GetJsonSchemaFunction]|None=None,js_prefer_positional_arguments:bool|None=None,initial_metadata:Any|None=None)->Any


----------------------------------------/home/zhang/Packages/pydantic/pydantic2.0b1/_internal/_forward_ref.py----------------------------------------
A:pydantic._internal._forward_ref.model->replace_types(model, action['typevars_map'])
pydantic._internal._forward_ref.DeferredClassGetitem(TypedDict)
pydantic._internal._forward_ref.DeferredReplaceTypes(TypedDict)
pydantic._internal._forward_ref.PydanticForwardRef(self)
pydantic._internal._forward_ref.PydanticForwardRef.__getitem__(self,item:Any)->PydanticForwardRef
pydantic._internal._forward_ref.PydanticForwardRef.replace_types(self,typevars_map:Any)->PydanticForwardRef
pydantic._internal._forward_ref.PydanticForwardRef.resolve_model(self)->type[Any] | PydanticForwardRef
pydantic._internal._forward_ref.PydanticRecursiveRef(self)


----------------------------------------/home/zhang/Packages/pydantic/pydantic2.0b1/_internal/_internal_dataclass.py----------------------------------------


----------------------------------------/home/zhang/Packages/pydantic/pydantic2.0b1/_internal/_known_annotated_metadata.py----------------------------------------
A:pydantic._internal._known_annotated_metadata.annotation->copy(annotation)
A:pydantic._internal._known_annotated_metadata.schema->schema.copy().copy()
A:pydantic._internal._known_annotated_metadata.(schema_update, _)->collect_known_metadata([annotation])
A:pydantic._internal._known_annotated_metadata.annotations->expand_grouped_metadata(annotations)
pydantic._internal._known_annotated_metadata.apply_known_metadata(annotation:Any,schema:CoreSchema)->CoreSchema
pydantic._internal._known_annotated_metadata.check_metadata(metadata:dict[str,Any],allowed:Iterable[str],source_type:Any)->None
pydantic._internal._known_annotated_metadata.collect_known_metadata(annotations:Iterable[Any])->tuple[dict[str, Any], list[Any]]
pydantic._internal._known_annotated_metadata.expand_grouped_metadata(annotations:Iterable[Any])->Iterable[Any]


----------------------------------------/home/zhang/Packages/pydantic/pydantic2.0b1/_internal/_generate_schema.py----------------------------------------
A:pydantic._internal._generate_schema.FieldDecoratorInfoType->TypeVar('FieldDecoratorInfoType', bound=FieldDecoratorInfo)
A:pydantic._internal._generate_schema.fields->collect_dataclass_fields(dataclass, self.types_namespace, typevars_map=typevars_map)
A:pydantic._internal._generate_schema.schema['schema']->apply_each_item_validators(schema['schema'], each_item_validators)
A:pydantic._internal._generate_schema.inner_schema->apply_model_validators(inner_schema, model_validators, 'inner')
A:pydantic._internal._generate_schema.schema['items_schema']->apply_validators(inner_schema, each_item_validators)
A:pydantic._internal._generate_schema.schema['values_schema']->apply_validators(inner_schema, each_item_validators)
A:pydantic._internal._generate_schema.wrapped_handler->UnpackedRefJsonSchemaHandler(handler)
A:pydantic._internal._generate_schema.json_schema->handler(schema_or_field)
A:pydantic._internal._generate_schema.original_schema->UnpackedRefJsonSchemaHandler(handler).resolve_ref_schema(json_schema)
A:pydantic._internal._generate_schema.schema->_discriminated_union.apply_discriminator(schema, metadata.discriminator, definitions)
A:pydantic._internal._generate_schema.from_property->self._generate_schema_from_property(obj, obj)
A:pydantic._internal._generate_schema.metadata_js_function->_extract_get_pydantic_json_schema(annotation, schema)
A:pydantic._internal._generate_schema.ref->_discriminated_union.apply_discriminator(schema, metadata.discriminator, definitions).get('ref', None)
A:pydantic._internal._generate_schema.(model_ref, schema)->self._get_or_cache_recursive_ref(cls)
A:pydantic._internal._generate_schema.config_wrapper->ConfigWrapper(config, check=False)
A:pydantic._internal._generate_schema.core_config->ConfigWrapper(config, check=False).core_config(dataclass)
A:pydantic._internal._generate_schema.metadata->build_metadata_dict(js_functions=[lambda _1, _2: {'type': 'string', 'format': 'regex'}])
A:pydantic._internal._generate_schema.model_validators->_decorators.DecoratorInfos.build(typed_dict_cls).model_validators.values()
A:pydantic._internal._generate_schema.root_field->self._common_field_schema('root', fields['root'], decorators)
A:pydantic._internal._generate_schema.model_schema->consolidate_refs(model_schema)
A:pydantic._internal._generate_schema.(new_obj, new_annotations)->self._prepare_annotations(obj, [])
A:pydantic._internal._generate_schema.get_schema->getattr(obj, '__get_pydantic_core_schema__', None)
A:pydantic._internal._generate_schema.obj->replace_types(obj, self.typevars_map)
A:pydantic._internal._generate_schema.resolved_model->replace_types(obj, self.typevars_map).resolve_model()
A:pydantic._internal._generate_schema.model_ref->get_type_ref(resolved_model)
A:pydantic._internal._generate_schema.origin->cast(Any, origin)
A:pydantic._internal._generate_schema.common_field->self._common_field_schema(name, field_info, decorators)
A:pydantic._internal._generate_schema.this_field_validators->filter_field_decorator_info_by_field(decorators.validators.values(), name)
A:pydantic._internal._generate_schema.alias->alias_generator(d.cls_var_name)
A:pydantic._internal._generate_schema.validation_alias->fields.FieldInfo.from_annotation(annotation).validation_alias.convert_to_aliases()
A:pydantic._internal._generate_schema.args->sorted((self._generate_dc_field_schema(k, v, decorators) for (k, v) in fields.items()), key=lambda a: a.get('kw_only') is not False)
A:pydantic._internal._generate_schema.s->pydantic_core.core_schema.nullable_schema(s)
A:pydantic._internal._generate_schema.(ref, schema)->self._get_or_cache_recursive_ref(obj)
A:pydantic._internal._generate_schema.namespace->(self.types_namespace or {}).copy()
A:pydantic._internal._generate_schema.typevars_map->get_standard_typevars_map(dataclass)
A:pydantic._internal._generate_schema.annotation->replace_types(annotation, typevars_map)
A:pydantic._internal._generate_schema.expected->_typing_extra.all_literal_values(literal_type)
A:pydantic._internal._generate_schema.(typed_dict_ref, schema)->self._get_or_cache_recursive_ref(typed_dict_cls)
A:pydantic._internal._generate_schema.decorators->_decorators.DecoratorInfos.build(typed_dict_cls)
A:pydantic._internal._generate_schema.field_info->fields.FieldInfo.from_annotation(annotation)
A:pydantic._internal._generate_schema.fields[field_name]->self._generate_td_field_schema(field_name, field_info, decorators, required=required)
A:pydantic._internal._generate_schema.td_schema->pydantic_core.core_schema.typed_dict_schema(fields, extra_behavior='forbid', ref=typed_dict_ref, metadata=metadata, config=core_config)
A:pydantic._internal._generate_schema.arguments_schema->pydantic_core.core_schema.ArgumentsSchema(type='arguments', arguments_schema=[self._generate_parameter_schema(field_name, annotation) for (field_name, annotation) in annotations.items()], metadata=build_metadata_dict(js_prefer_positional_arguments=True))
A:pydantic._internal._generate_schema.field->fields.FieldInfo.from_annotated_attribute(annotation, default)
A:pydantic._internal._generate_schema.parameter_schema->pydantic_core.core_schema.arguments_parameter(name, schema)
A:pydantic._internal._generate_schema.parameter_schema['alias']->alias_generator(name)
A:pydantic._internal._generate_schema.params->get_args(tuple_type)
A:pydantic._internal._generate_schema.sv->pydantic_core.core_schema.tuple_variable_schema(self.generate_schema(params[0]))
A:pydantic._internal._generate_schema.type_param->get_first_arg(type_)
A:pydantic._internal._generate_schema.item_type->get_first_arg(type_)
A:pydantic._internal._generate_schema.items_schema->self._generate_schema(item_type)
A:pydantic._internal._generate_schema.list_schema->pydantic_core.core_schema.list_schema(self.generate_schema(item_type))
A:pydantic._internal._generate_schema.python_schema->pydantic_core.core_schema.chain_schema([python_schema, core_schema.no_info_wrap_validator_function(sequence_validator, list_schema)])
A:pydantic._internal._generate_schema.ser->pydantic_core.core_schema.plain_serializer_function_ser_schema(attrgetter('pattern'), when_used='json', return_schema=core_schema.str_schema())
A:pydantic._internal._generate_schema.(dataclass_ref, schema)->self._get_or_cache_recursive_ref(dataclass)
A:pydantic._internal._generate_schema.has_post_init->hasattr(dataclass, '__post_init__')
A:pydantic._internal._generate_schema.has_slots->hasattr(dataclass, '__slots__')
A:pydantic._internal._generate_schema.config->getattr(dataclass, '__pydantic_config__', None)
A:pydantic._internal._generate_schema.args_schema->pydantic_core.core_schema.dataclass_args_schema(dataclass.__name__, args, computed_fields=[self._computed_field_schema(d) for d in decorators.computed_fields.values()], collect_init_only=has_post_init)
A:pydantic._internal._generate_schema.dc_schema->pydantic_core.core_schema.dataclass_schema(dataclass, inner_schema, post_init=has_post_init, ref=dataclass_ref, fields=[field.name for field in dataclasses.fields(dataclass)], slots=has_slots, config=core_config)
A:pydantic._internal._generate_schema.sig->signature(function)
A:pydantic._internal._generate_schema.type_hints->_typing_extra.get_function_type_hints(function)
A:pydantic._internal._generate_schema.parameter_mode->mode_lookup.get(p.kind)
A:pydantic._internal._generate_schema.arg_schema->self._generate_parameter_schema(name, annotation, p.default, parameter_mode)
A:pydantic._internal._generate_schema.var_args_schema->self.generate_schema(annotation)
A:pydantic._internal._generate_schema.var_kwargs_schema->self.generate_schema(annotation)
A:pydantic._internal._generate_schema.return_hint->_typing_extra.get_function_type_hints(function).get('return')
A:pydantic._internal._generate_schema.return_schema->self.generate_schema(serializer.info.return_type)
A:pydantic._internal._generate_schema.obj_ref->get_type_ref(cls)
A:pydantic._internal._generate_schema.self.recursion_cache[obj_ref]->pydantic_core.core_schema.definition_reference_schema(obj_ref)
A:pydantic._internal._generate_schema.return_type_schema->self.generate_schema(d.info.return_type)
A:pydantic._internal._generate_schema.(source_type, *annotations)->get_args(annotated_type)
A:pydantic._internal._generate_schema.res->self._get_prepare_pydantic_annotations_for_known_type(source_type, tuple(annotations))
A:pydantic._internal._generate_schema.prepare->getattr(annotation, '__prepare_pydantic_annotations__', None)
A:pydantic._internal._generate_schema.annotations->list(annotations)
A:pydantic._internal._generate_schema.(source_type, annotations)->prepare(source_type, tuple(annotations), self.config_wrapper.config_dict)
A:pydantic._internal._generate_schema.get_inner_schema->self._get_wrapped_inner_schema(get_inner_schema, annotation, self.definitions, pydantic_js_functions)
A:pydantic._internal._generate_schema.(new_source_type, remaining)->prepare(source_type, tuple(remaining), self.config_wrapper.config_dict)
A:pydantic._internal._generate_schema.(is_field_serializer, info_arg)->inspect_field_serializer(serializer.func, serializer.info.mode)
A:pydantic._internal._generate_schema.schema['serialization']->pydantic_core.core_schema.plain_serializer_function_ser_schema(serializer.func, is_field_serializer=is_field_serializer, info_arg=info_arg, return_schema=return_schema, when_used=serializer.info.when_used)
A:pydantic._internal._generate_schema.info_arg->inspect_validator(validator.func, validator.info.mode)
A:pydantic._internal._generate_schema.ser_schema->pydantic_core.core_schema.plain_serializer_function_ser_schema(serializer.func, info_arg=info_arg, return_schema=return_schema, when_used=serializer.info.when_used)
A:pydantic._internal._generate_schema.inner->apply_single_annotation(inner, metadata, definitions)
A:pydantic._internal._generate_schema.js_modify_function->wrap_json_schema_fn_for_model_or_custom_type_with_ref_unpacking(js_modify_function)
pydantic._internal._generate_schema.GenerateSchema(self,config_wrapper:ConfigWrapper,types_namespace:dict[str,Any]|None,typevars_map:dict[Any,Any]|None=None)
pydantic._internal._generate_schema.GenerateSchema._annotated_schema(self,annotated_type:Any)->core_schema.CoreSchema
pydantic._internal._generate_schema.GenerateSchema._apply_annotations(self,transform_inner_schema:Callable[[CoreSchema],CoreSchema],source_type:Any,annotations:list[Any])->CoreSchema
pydantic._internal._generate_schema.GenerateSchema._apply_field_serializers(self,schema:core_schema.CoreSchema,serializers:list[Decorator[FieldSerializerDecoratorInfo]])->core_schema.CoreSchema
pydantic._internal._generate_schema.GenerateSchema._apply_model_serializers(self,schema:core_schema.CoreSchema,serializers:Iterable[Decorator[ModelSerializerDecoratorInfo]])->core_schema.CoreSchema
pydantic._internal._generate_schema.GenerateSchema._arbitrary_type_schema(self,obj:Any,type_:Any)->CoreSchema
pydantic._internal._generate_schema.GenerateSchema._callable_schema(self,function:Callable[...,Any])->core_schema.CallSchema
pydantic._internal._generate_schema.GenerateSchema._common_field_schema(self,name:str,field_info:FieldInfo,decorators:DecoratorInfos)->_CommonField
pydantic._internal._generate_schema.GenerateSchema._computed_field_schema(self,d:Decorator[ComputedFieldInfo])->core_schema.ComputedField
pydantic._internal._generate_schema.GenerateSchema._dataclass_schema(self,dataclass:type[StandardDataclass],origin:type[StandardDataclass]|None)->core_schema.CoreSchema
pydantic._internal._generate_schema.GenerateSchema._generate_dc_field_schema(self,name:str,field_info:FieldInfo,decorators:DecoratorInfos)->core_schema.DataclassField
pydantic._internal._generate_schema.GenerateSchema._generate_md_field_schema(self,name:str,field_info:FieldInfo,decorators:DecoratorInfos,*,required:bool=True)->core_schema.ModelField
pydantic._internal._generate_schema.GenerateSchema._generate_parameter_schema(self,name:str,annotation:type[Any],default:Any=Parameter.empty,mode:Literal['positional_only','positional_or_keyword','keyword_only']|None=None)->core_schema.ArgumentsParameter
pydantic._internal._generate_schema.GenerateSchema._generate_schema(self,obj:Any)->core_schema.CoreSchema
pydantic._internal._generate_schema.GenerateSchema._generate_schema_for_type(self,obj:Any,from_dunder_get_core_schema:bool=True,from_prepare_args:bool=True)->CoreSchema
pydantic._internal._generate_schema.GenerateSchema._generate_schema_from_prepare_annotations(self,obj:Any)->core_schema.CoreSchema | None
pydantic._internal._generate_schema.GenerateSchema._generate_schema_from_property(self,obj:Any,source:Any)->core_schema.CoreSchema | None
pydantic._internal._generate_schema.GenerateSchema._generate_td_field_schema(self,name:str,field_info:FieldInfo,decorators:DecoratorInfos,*,required:bool=True)->core_schema.TypedDictField
pydantic._internal._generate_schema.GenerateSchema._get_or_cache_recursive_ref(self,cls:type[Any])->tuple[str, core_schema.DefinitionReferenceSchema | None]
pydantic._internal._generate_schema.GenerateSchema._get_prepare_pydantic_annotations_for_known_type(self,obj:Any,annotations:tuple[Any,...])->tuple[Any, list[Any]] | None
pydantic._internal._generate_schema.GenerateSchema._get_wrapped_inner_schema(self,get_inner_schema:GetCoreSchemaHandler,annotation:Any,definitions:dict[str,core_schema.CoreSchema],pydantic_js_functions:list[GetJsonSchemaFunction])->CallbackGetCoreSchemaHandler
pydantic._internal._generate_schema.GenerateSchema._hashable_schema(self)->core_schema.CoreSchema
pydantic._internal._generate_schema.GenerateSchema._iterable_schema(self,type_:Any)->core_schema.GeneratorSchema
pydantic._internal._generate_schema.GenerateSchema._literal_schema(self,literal_type:Any)->core_schema.LiteralSchema
pydantic._internal._generate_schema.GenerateSchema._namedtuple_schema(self,namedtuple_cls:Any)->core_schema.CallSchema
pydantic._internal._generate_schema.GenerateSchema._pattern_schema(self,pattern_type:Any)->core_schema.CoreSchema
pydantic._internal._generate_schema.GenerateSchema._prepare_annotations(self,source_type:Any,annotations:Iterable[Any])->tuple[Any, list[Any]]
pydantic._internal._generate_schema.GenerateSchema._sequence_schema(self,sequence_type:Any)->core_schema.CoreSchema
pydantic._internal._generate_schema.GenerateSchema._subclass_schema(self,type_:Any)->core_schema.CoreSchema
pydantic._internal._generate_schema.GenerateSchema._tuple_schema(self,tuple_type:Any)->core_schema.CoreSchema
pydantic._internal._generate_schema.GenerateSchema._type_alias_type_schema(self,obj:Any)->CoreSchema
pydantic._internal._generate_schema.GenerateSchema._type_schema(self)->core_schema.CoreSchema
pydantic._internal._generate_schema.GenerateSchema._typed_dict_schema(self,typed_dict_cls:Any,origin:Any)->core_schema.CoreSchema
pydantic._internal._generate_schema.GenerateSchema._union_schema(self,union_type:Any)->core_schema.CoreSchema
pydantic._internal._generate_schema.GenerateSchema._unsubstituted_typevar_schema(self,typevar:typing.TypeVar)->core_schema.CoreSchema
pydantic._internal._generate_schema.GenerateSchema.arbitrary_types(self)->bool
pydantic._internal._generate_schema.GenerateSchema.config_wrapper(self)->ConfigWrapper
pydantic._internal._generate_schema.GenerateSchema.generate_schema(self,obj:Any,from_dunder_get_core_schema:bool=True,from_prepare_args:bool=True)->core_schema.CoreSchema
pydantic._internal._generate_schema.GenerateSchema.model_schema(self,cls:type[BaseModel])->core_schema.CoreSchema
pydantic._internal._generate_schema._CommonField(TypedDict)
pydantic._internal._generate_schema._common_field(schema:core_schema.CoreSchema,*,validation_alias:str|list[str|int]|list[list[str|int]]|None=None,serialization_alias:str|None=None,serialization_exclude:bool|None=None,frozen:bool|None=None,metadata:Any=None)->_CommonField
pydantic._internal._generate_schema._extract_get_pydantic_json_schema(tp:Any,schema:CoreSchema)->GetJsonSchemaFunction | None
pydantic._internal._generate_schema._validators_require_validate_default(validators:Iterable[Decorator[ValidatorDecoratorInfo]])->bool
pydantic._internal._generate_schema.apply_each_item_validators(schema:core_schema.CoreSchema,each_item_validators:list[Decorator[ValidatorDecoratorInfo]])->core_schema.CoreSchema
pydantic._internal._generate_schema.apply_model_validators(schema:core_schema.CoreSchema,validators:Iterable[Decorator[ModelValidatorDecoratorInfo]],mode:Literal['inner','outer','all'])->core_schema.CoreSchema
pydantic._internal._generate_schema.apply_single_annotation(schema:core_schema.CoreSchema,metadata:Any,definitions:dict[str,core_schema.CoreSchema])->core_schema.CoreSchema
pydantic._internal._generate_schema.apply_validators(schema:core_schema.CoreSchema,validators:Iterable[Decorator[RootValidatorDecoratorInfo]]|Iterable[Decorator[ValidatorDecoratorInfo]]|Iterable[Decorator[FieldValidatorDecoratorInfo]])->core_schema.CoreSchema
pydantic._internal._generate_schema.check_decorator_fields_exist(decorators:Iterable[AnyFieldDecorator],fields:Iterable[str])->None
pydantic._internal._generate_schema.check_validator_fields_against_field_name(info:FieldDecoratorInfo,field:str)->bool
pydantic._internal._generate_schema.filter_field_decorator_info_by_field(validator_functions:Iterable[Decorator[FieldDecoratorInfoType]],field:str)->list[Decorator[FieldDecoratorInfoType]]
pydantic._internal._generate_schema.get_first_arg(type_:Any)->Any
pydantic._internal._generate_schema.modify_model_json_schema(schema_or_field:CoreSchemaOrField,handler:GetJsonSchemaHandler,*,cls:Any)->JsonSchemaValue
pydantic._internal._generate_schema.wrap_default(field_info:FieldInfo,schema:core_schema.CoreSchema)->core_schema.CoreSchema


----------------------------------------/home/zhang/Packages/pydantic/pydantic2.0b1/_internal/_std_types_schema.py----------------------------------------
A:pydantic._internal._std_types_schema.schema->pydantic_core.core_schema.lax_or_strict_schema(lax_schema=lax, strict_schema=strict)
A:pydantic._internal._std_types_schema.expected->repr(cases[0].value)
A:pydantic._internal._std_types_schema.enum_ref->get_type_ref(enum_type)
A:pydantic._internal._std_types_schema.json_schema->handler(core_schema.literal_schema([x.value for x in cases]))
A:pydantic._internal._std_types_schema.original_schema->handler.resolve_ref_schema(json_schema)
A:pydantic._internal._std_types_schema.to_enum_validator->pydantic_core.core_schema.no_info_plain_validator_function(to_enum)
A:pydantic._internal._std_types_schema.lax->coerce_instance_wrap(constrained_schema)
A:pydantic._internal._std_types_schema.strict->pydantic_core.core_schema.chain_schema([check_instance, coerce_instance_wrap(constrained_schema)])
A:pydantic._internal._std_types_schema.outer_schema->pydantic_core.core_schema.lax_or_strict_schema(lax_schema=lax, strict_schema=strict, ref=enum_ref)
A:pydantic._internal._std_types_schema.string_schema->handler(core_schema.str_schema())
A:pydantic._internal._std_types_schema.float_schema->handler(core_schema.float_schema(allow_inf_nan=self.allow_inf_nan, multiple_of=None if self.multiple_of is None else float(self.multiple_of), le=None if self.le is None else float(self.le), ge=None if self.ge is None else float(self.ge), lt=None if self.lt is None else float(self.lt), gt=None if self.gt is None else float(self.gt)))
A:pydantic._internal._std_types_schema.is_instance_schema->pydantic_core.core_schema.json_or_python_schema(json_schema=core_schema.no_info_after_validator_function(decimal.Decimal, core_schema.union_schema(primitive_type_union)), python_schema=core_schema.is_instance_schema(decimal.Decimal))
A:pydantic._internal._std_types_schema.value->decimal.Decimal(str(__input_value))
A:pydantic._internal._std_types_schema.normalized_value->decimal.Decimal(str(__input_value)).normalize()
A:pydantic._internal._std_types_schema.(_1, digit_tuple, exponent)->decimal.Decimal(str(__input_value)).normalize().as_tuple()
A:pydantic._internal._std_types_schema.digitsdecimals->abs(exponent)
A:pydantic._internal._std_types_schema.digits->len(digit_tuple)
A:pydantic._internal._std_types_schema.decimals->abs(exponent)
A:pydantic._internal._std_types_schema.(metadata, remaining_annotations)->_known_annotated_metadata.collect_known_metadata(annotations)
A:pydantic._internal._std_types_schema.config_allow_inf_nan->config.get('allow_inf_nan')
A:pydantic._internal._std_types_schema.js_schema->handler(self.js_core_schema or self.core_schema)
A:pydantic._internal._std_types_schema.sv->InnerSchemaValidator(core_schema.timedelta_schema(**metadata))
A:pydantic._internal._std_types_schema.from_primitive_type_schema->pydantic_core.core_schema.no_info_after_validator_function(uuid_validator, core_schema.union_schema([core_schema.str_schema(), core_schema.bytes_schema()]))
A:pydantic._internal._std_types_schema.constrained_str_schema->pydantic_core.core_schema.str_schema(**metadata)
A:pydantic._internal._std_types_schema.instance_schema->pydantic_core.core_schema.json_or_python_schema(json_schema=core_schema.no_info_after_validator_function(path_validator, constrained_str_schema), python_schema=core_schema.is_instance_schema(source_type))
A:pydantic._internal._std_types_schema.maxlen->min(maxlens)
A:pydantic._internal._std_types_schema.v->handler(item, index)
A:pydantic._internal._std_types_schema.items_schema->handler.generate_schema(self.item_source_type)
A:pydantic._internal._std_types_schema.constrained_schema->pydantic_core.core_schema.dict_schema(keys_schema, values_schema, **metadata)
A:pydantic._internal._std_types_schema.coerce_instance_wrap->partial(core_schema.no_info_after_validator_function, self.mapped_origin)
A:pydantic._internal._std_types_schema.check_instance->pydantic_core.core_schema.json_or_python_schema(json_schema=core_schema.dict_schema(), python_schema=core_schema.is_instance_schema(self.mapped_origin))
A:pydantic._internal._std_types_schema.serialization->pydantic_core.core_schema.wrap_serializer_function_ser_schema(self.serialize_mapping_via_dict, schema=core_schema.dict_schema(keys_schema or core_schema.any_schema(), values_schema or core_schema.any_schema()), info_arg=False)
A:pydantic._internal._std_types_schema.args->get_args(source_type)
A:pydantic._internal._std_types_schema.allowed_msg->', '.join([t.__name__ for t in set(allowed_default_types.values())])
A:pydantic._internal._std_types_schema.field_info->next((v for v in get_args(values_source_type) if isinstance(v, FieldInfo)), None)
A:pydantic._internal._std_types_schema.default_default_factory->get_defaultdict_default_default_factory(self.values_source_type)
A:pydantic._internal._std_types_schema.keys_schema->handler.generate_schema(self.keys_source_type)
A:pydantic._internal._std_types_schema.values_schema->handler.generate_schema(self.values_source_type)
pydantic._internal._std_types_schema.DecimalValidator
pydantic._internal._std_types_schema.DecimalValidator.__get_pydantic_core_schema__(self,_source_type:Any,_handler:GetCoreSchemaHandler)->CoreSchema
pydantic._internal._std_types_schema.DecimalValidator.__get_pydantic_json_schema__(self,_schema:CoreSchema,handler:GetJsonSchemaHandler)->JsonSchemaValue
pydantic._internal._std_types_schema.DecimalValidator.__post_init__(self)->None
pydantic._internal._std_types_schema.DecimalValidator.validate(self,__input_value:int|float|str)->decimal.Decimal
pydantic._internal._std_types_schema.InnerSchemaValidator
pydantic._internal._std_types_schema.InnerSchemaValidator.__get_pydantic_core_schema__(self,_source_type:Any,_handler:GetCoreSchemaHandler)->CoreSchema
pydantic._internal._std_types_schema.InnerSchemaValidator.__get_pydantic_json_schema__(self,_schema:CoreSchema,handler:GetJsonSchemaHandler)->JsonSchemaValue
pydantic._internal._std_types_schema.MappingValidator
pydantic._internal._std_types_schema.MappingValidator.__get_pydantic_core_schema__(self,source_type:Any,handler:GetCoreSchemaHandler)->CoreSchema
pydantic._internal._std_types_schema.MappingValidator.serialize_mapping_via_dict(self,v:Any,handler:core_schema.SerializerFunctionWrapHandler)->Any
pydantic._internal._std_types_schema.SchemaTransformer
pydantic._internal._std_types_schema.SchemaTransformer.__get_pydantic_core_schema__(self,source_type:Any,handler:GetCoreSchemaHandler)->CoreSchema
pydantic._internal._std_types_schema.SchemaTransformer.__get_pydantic_json_schema__(self,schema:CoreSchema,handler:GetJsonSchemaHandler)->JsonSchemaValue
pydantic._internal._std_types_schema.SequenceValidator
pydantic._internal._std_types_schema.SequenceValidator.__get_pydantic_core_schema__(self,source_type:Any,handler:GetCoreSchemaHandler)->CoreSchema
pydantic._internal._std_types_schema.SequenceValidator.serialize_sequence_via_list(self,v:Any,handler:core_schema.SerializerFunctionWrapHandler,info:core_schema.SerializationInfo)->Any
pydantic._internal._std_types_schema.datetime_prepare_pydantic_annotations(source_type:Any,annotations:Iterable[Any],_config:ConfigDict)->tuple[Any, list[Any]] | None
pydantic._internal._std_types_schema.decimal_prepare_pydantic_annotations(source:Any,annotations:Iterable[Any],config:ConfigDict)->tuple[Any, list[Any]] | None
pydantic._internal._std_types_schema.defaultdict_validator(input_value:Any,handler:core_schema.ValidatorFunctionWrapHandler,default_default_factory:Callable[[],Any])->collections.defaultdict[Any, Any]
pydantic._internal._std_types_schema.dequeue_validator(input_value:Any,handler:core_schema.ValidatorFunctionWrapHandler,maxlen:None|int)->collections.deque[Any]
pydantic._internal._std_types_schema.enum_prepare_pydantic_annotations(source_type:Any,annotations:Iterable[Any],_config:ConfigDict)->tuple[Any, list[Any]] | None
pydantic._internal._std_types_schema.get_defaultdict_default_default_factory(values_source_type:Any)->Callable[[], Any]
pydantic._internal._std_types_schema.identity(s:CoreSchema)->CoreSchema
pydantic._internal._std_types_schema.ip_prepare_pydantic_annotations(source_type:Any,annotations:Iterable[Any],_config:ConfigDict)->tuple[Any, list[Any]] | None
pydantic._internal._std_types_schema.mapping_like_prepare_pydantic_annotations(source_type:Any,annotations:Iterable[Any],_config:ConfigDict)->tuple[Any, list[Any]] | None
pydantic._internal._std_types_schema.path_schema_prepare_pydantic_annotations(source_type:Any,annotations:Iterable[Any],_config:ConfigDict)->tuple[Any, list[Any]] | None
pydantic._internal._std_types_schema.sequence_like_prepare_pydantic_annotations(source_type:Any,annotations:Iterable[Any],_config:ConfigDict)->tuple[Any, list[Any]] | None
pydantic._internal._std_types_schema.url_prepare_pydantic_annotations(source_type:Any,annotations:Iterable[Any],_config:ConfigDict)->tuple[Any, list[Any]] | None
pydantic._internal._std_types_schema.uuid_prepare_pydantic_annotations(source_type:Any,annotations:Iterable[Any],_config:ConfigDict)->tuple[Any, list[Any]] | None


----------------------------------------/home/zhang/Packages/pydantic/pydantic2.0b1/_internal/_dataclasses.py----------------------------------------
A:pydantic._internal._dataclasses.typevars_map->get_standard_typevars_map(cls)
A:pydantic._internal._dataclasses.fields->collect_dataclass_fields(cls, types_namespace, typevars_map=typevars_map)
A:pydantic._internal._dataclasses.types_namespace->_typing_extra.get_cls_types_namespace(cls)
A:pydantic._internal._dataclasses.gen_schema->GenerateSchema(config_wrapper, types_namespace, typevars_map)
A:pydantic._internal._dataclasses.get_core_schema->getattr(cls, '__get_pydantic_core_schema__', None)
A:pydantic._internal._dataclasses.schema->GenerateSchema(config_wrapper, types_namespace, typevars_map).generate_schema(cls, from_dunder_get_core_schema=False)
A:pydantic._internal._dataclasses.cls.__pydantic_validator__->MockValidator(undefined_type_error_message, code='class-not-fully-defined', attempt_rebuild=attempt_rebuild)
A:pydantic._internal._dataclasses.core_config->config_wrapper.core_config(cls)
A:pydantic._internal._dataclasses.cls->typing.cast('type[PydanticDataclass]', cls)
A:pydantic._internal._dataclasses.simplified_core_schema->inline_schema_defs(flatten_schema_defs(schema))
A:pydantic._internal._dataclasses.cls.__pydantic_validator__validator->SchemaValidator(simplified_core_schema, core_config)
A:pydantic._internal._dataclasses.cls.__pydantic_serializer__->SchemaSerializer(simplified_core_schema, core_config)
A:pydantic._internal._dataclasses.cls.__setattr__->validated_setattr.__get__(None, cls)
pydantic._internal._dataclasses.complete_dataclass(cls:type[Any],config_wrapper:_config.ConfigWrapper,*,raise_errors:bool=True,types_namespace:dict[str,Any]|None)->bool
pydantic._internal._dataclasses.is_builtin_dataclass(_cls:type[Any])->TypeGuard[type[StandardDataclass]]
pydantic._internal._dataclasses.is_pydantic_dataclass(_cls:type[Any])->TypeGuard[type[PydanticDataclass]]
pydantic._internal._dataclasses.set_dataclass_fields(cls:type[StandardDataclass],types_namespace:dict[str,Any]|None=None)->None


----------------------------------------/home/zhang/Packages/pydantic/pydantic2.0b1/_internal/__init__.py----------------------------------------


----------------------------------------/home/zhang/Packages/pydantic/pydantic2.0b1/_internal/_validate_call.py----------------------------------------
A:pydantic._internal._validate_call.self.__signature__->inspect.signature(function)
A:pydantic._internal._validate_call.namespace->_typing_extra.add_module_globals(function, None)
A:pydantic._internal._validate_call.config_wrapper->ConfigWrapper(config)
A:pydantic._internal._validate_call.gen_schema->_generate_schema.GenerateSchema(config_wrapper, namespace)
A:pydantic._internal._validate_call.self.__pydantic_core_schema__schema->_generate_schema.GenerateSchema(config_wrapper, namespace).generate_schema(function)
A:pydantic._internal._validate_call.core_config->ConfigWrapper(config).core_config(self)
A:pydantic._internal._validate_call.schema->flatten_schema_defs(schema)
A:pydantic._internal._validate_call.simplified_schema->inline_schema_defs(schema)
A:pydantic._internal._validate_call.self.__pydantic_validator__->pydantic_core.SchemaValidator(simplified_schema, core_config)
A:pydantic._internal._validate_call.bound_function->self.raw_function.__get__(obj, objtype)
pydantic._internal._validate_call.CallMarker
pydantic._internal._validate_call.ValidateCallWrapper(self,function:Callable[...,Any],config:ConfigDict|None,validate_return:bool)
pydantic._internal._validate_call.ValidateCallWrapper.__get__(self,obj:Any,objtype:type[Any]|None=None)->ValidateCallWrapper
pydantic._internal._validate_call.ValidateCallWrapper.__repr__(self)->str


----------------------------------------/home/zhang/Packages/pydantic/pydantic2.0b1/v1/types.py----------------------------------------
A:pydantic.v1.types.T->TypeVar('T')
A:pydantic.v1.types.new_cls->cast('ConstrainedInt', type.__new__(cls, name, bases, dct))
A:pydantic.v1.types.namespace->dict(gt=gt, ge=ge, lt=lt, le=le)
A:pydantic.v1.types.v->list_validator(v)
A:pydantic.v1.types.v_len->len(v)
A:pydantic.v1.types.value->bytes_validator(value)
A:pydantic.v1.types.digitsdecimals->abs(exponent)
A:pydantic.v1.types.digits->len(digit_tuple)
A:pydantic.v1.types.decimals->abs(exponent)
A:pydantic.v1.types.self.brand->self._get_brand(card_number)
A:pydantic.v1.types.sum_->int(card_number[-1])
A:pydantic.v1.types.length->len(card_number)
A:pydantic.v1.types.digit->int(card_number[i])
A:pydantic.v1.types.byte_string_re->re.compile('^\\s*(\\d*\\.?\\d+)\\s*(\\w+)?', re.IGNORECASE)
A:pydantic.v1.types.str_match->re.compile('^\\s*(\\d*\\.?\\d+)\\s*(\\w+)?', re.IGNORECASE).match(str(v))
A:pydantic.v1.types.(scalar, unit)->re.compile('^\\s*(\\d*\\.?\\d+)\\s*(\\w+)?', re.IGNORECASE).match(str(v)).groups()
A:pydantic.v1.types.num->float(self)
pydantic.v1.ByteSize(int)
pydantic.v1.ByteSize.__get_validators__(cls)->'CallableGenerator'
pydantic.v1.ByteSize.human_readable(self,decimal:bool=False)->str
pydantic.v1.ByteSize.to(self,unit:str)->float
pydantic.v1.ByteSize.validate(cls,v:StrIntFloat)->'ByteSize'
pydantic.v1.ConstrainedBytes(bytes)
pydantic.v1.ConstrainedBytes.__get_validators__(cls)->'CallableGenerator'
pydantic.v1.ConstrainedBytes.__modify_schema__(cls,field_schema:Dict[str,Any])->None
pydantic.v1.ConstrainedDate(date,metaclass=ConstrainedNumberMeta)
pydantic.v1.ConstrainedDate.__get_validators__(cls)->'CallableGenerator'
pydantic.v1.ConstrainedDate.__modify_schema__(cls,field_schema:Dict[str,Any])->None
pydantic.v1.ConstrainedDecimal(Decimal,metaclass=ConstrainedNumberMeta)
pydantic.v1.ConstrainedDecimal.__get_validators__(cls)->'CallableGenerator'
pydantic.v1.ConstrainedDecimal.__modify_schema__(cls,field_schema:Dict[str,Any])->None
pydantic.v1.ConstrainedDecimal.validate(cls,value:Decimal)->Decimal
pydantic.v1.ConstrainedFloat(float,metaclass=ConstrainedNumberMeta)
pydantic.v1.ConstrainedFloat.__get_validators__(cls)->'CallableGenerator'
pydantic.v1.ConstrainedFloat.__modify_schema__(cls,field_schema:Dict[str,Any])->None
pydantic.v1.ConstrainedFrozenSet(frozenset)
pydantic.v1.ConstrainedFrozenSet.__get_validators__(cls)->'CallableGenerator'
pydantic.v1.ConstrainedFrozenSet.__modify_schema__(cls,field_schema:Dict[str,Any])->None
pydantic.v1.ConstrainedFrozenSet.frozenset_length_validator(cls,v:'Optional[FrozenSet[T]]')->'Optional[FrozenSet[T]]'
pydantic.v1.ConstrainedInt(int,metaclass=ConstrainedNumberMeta)
pydantic.v1.ConstrainedInt.__get_validators__(cls)->'CallableGenerator'
pydantic.v1.ConstrainedInt.__modify_schema__(cls,field_schema:Dict[str,Any])->None
pydantic.v1.ConstrainedList(list)
pydantic.v1.ConstrainedList.__get_validators__(cls)->'CallableGenerator'
pydantic.v1.ConstrainedList.__modify_schema__(cls,field_schema:Dict[str,Any])->None
pydantic.v1.ConstrainedList.list_length_validator(cls,v:'Optional[List[T]]')->'Optional[List[T]]'
pydantic.v1.ConstrainedList.unique_items_validator(cls,v:'Optional[List[T]]')->'Optional[List[T]]'
pydantic.v1.ConstrainedNumberMeta(cls,name:str,bases:Any,dct:Dict[str,Any])
pydantic.v1.ConstrainedSet(set)
pydantic.v1.ConstrainedSet.__get_validators__(cls)->'CallableGenerator'
pydantic.v1.ConstrainedSet.__modify_schema__(cls,field_schema:Dict[str,Any])->None
pydantic.v1.ConstrainedSet.set_length_validator(cls,v:'Optional[Set[T]]')->'Optional[Set[T]]'
pydantic.v1.ConstrainedStr(str)
pydantic.v1.ConstrainedStr.__get_validators__(cls)->'CallableGenerator'
pydantic.v1.ConstrainedStr.__modify_schema__(cls,field_schema:Dict[str,Any])->None
pydantic.v1.ConstrainedStr._get_pattern(regex:Union[str,Pattern[str]])->str
pydantic.v1.ConstrainedStr.validate(cls,value:Union[str])->Union[str]
pydantic.v1.JsonMeta(type)
pydantic.v1.JsonMeta.__getitem__(self,t:Type[Any])->Type[JsonWrapper]
pydantic.v1.JsonWrapper
pydantic.v1.PaymentCardBrand(str,Enum)
pydantic.v1.PaymentCardBrand.__str__(self)->str
pydantic.v1.PaymentCardNumber(self,card_number:str)
pydantic.v1.PaymentCardNumber.__get_validators__(cls)->'CallableGenerator'
pydantic.v1.PaymentCardNumber._get_brand(card_number:str)->PaymentCardBrand
pydantic.v1.PaymentCardNumber.masked(self)->str
pydantic.v1.PaymentCardNumber.validate_digits(cls,card_number:str)->str
pydantic.v1.PaymentCardNumber.validate_length_for_brand(cls,card_number:'PaymentCardNumber')->'PaymentCardNumber'
pydantic.v1.PaymentCardNumber.validate_luhn_check_digit(cls,card_number:str)->str
pydantic.v1.SecretBytes(self,value:bytes)
pydantic.v1.SecretBytes.__get_validators__(cls)->'CallableGenerator'
pydantic.v1.SecretBytes.__len__(self)->int
pydantic.v1.SecretBytes.__modify_schema__(cls,field_schema:Dict[str,Any])->None
pydantic.v1.SecretBytes.__repr__(self)->str
pydantic.v1.SecretBytes.display(self)->str
pydantic.v1.SecretBytes.get_secret_value(self)->bytes
pydantic.v1.SecretBytes.validate(cls,value:Any)->'SecretBytes'
pydantic.v1.SecretField(abc.ABC)
pydantic.v1.SecretField.__eq__(self,other:Any)->bool
pydantic.v1.SecretField.__hash__(self)->int
pydantic.v1.SecretField.__str__(self)->str
pydantic.v1.SecretField.get_secret_value(self)->Any
pydantic.v1.SecretStr(self,value:str)
pydantic.v1.SecretStr.__get_validators__(cls)->'CallableGenerator'
pydantic.v1.SecretStr.__len__(self)->int
pydantic.v1.SecretStr.__modify_schema__(cls,field_schema:Dict[str,Any])->None
pydantic.v1.SecretStr.__repr__(self)->str
pydantic.v1.SecretStr.display(self)->str
pydantic.v1.SecretStr.get_secret_value(self)->str
pydantic.v1.SecretStr.validate(cls,value:Any)->'SecretStr'
pydantic.v1._registered(typ:'ConstrainedNumberMeta')->'ConstrainedNumberMeta'
pydantic.v1._registered(typ:Type[T])->Type[T]
pydantic.v1._registered(typ:Union[Type[T],'ConstrainedNumberMeta'])->Union[Type[T], 'ConstrainedNumberMeta']
pydantic.v1.conbytes(*,strip_whitespace:bool=False,to_upper:bool=False,to_lower:bool=False,min_length:Optional[int]=None,max_length:Optional[int]=None,strict:bool=False)->Type[bytes]
pydantic.v1.condate(*,gt:date=None,ge:date=None,lt:date=None,le:date=None)->Type[date]
pydantic.v1.condecimal(*,gt:Decimal=None,ge:Decimal=None,lt:Decimal=None,le:Decimal=None,max_digits:Optional[int]=None,decimal_places:Optional[int]=None,multiple_of:Decimal=None)->Type[Decimal]
pydantic.v1.confloat(*,strict:bool=False,gt:float=None,ge:float=None,lt:float=None,le:float=None,multiple_of:float=None,allow_inf_nan:Optional[bool]=None)->Type[float]
pydantic.v1.confrozenset(item_type:Type[T],*,min_items:Optional[int]=None,max_items:Optional[int]=None)->Type[FrozenSet[T]]
pydantic.v1.conint(*,strict:bool=False,gt:Optional[int]=None,ge:Optional[int]=None,lt:Optional[int]=None,le:Optional[int]=None,multiple_of:Optional[int]=None)->Type[int]
pydantic.v1.conlist(item_type:Type[T],*,min_items:Optional[int]=None,max_items:Optional[int]=None,unique_items:bool=None)->Type[List[T]]
pydantic.v1.conset(item_type:Type[T],*,min_items:Optional[int]=None,max_items:Optional[int]=None)->Type[Set[T]]
pydantic.v1.constr(*,strip_whitespace:bool=False,to_upper:bool=False,to_lower:bool=False,strict:bool=False,min_length:Optional[int]=None,max_length:Optional[int]=None,curtail_length:Optional[int]=None,regex:Optional[str]=None)->Type[str]
pydantic.v1.types.ByteSize(int)
pydantic.v1.types.ByteSize.__get_validators__(cls)->'CallableGenerator'
pydantic.v1.types.ByteSize.human_readable(self,decimal:bool=False)->str
pydantic.v1.types.ByteSize.to(self,unit:str)->float
pydantic.v1.types.ByteSize.validate(cls,v:StrIntFloat)->'ByteSize'
pydantic.v1.types.ConstrainedBytes(bytes)
pydantic.v1.types.ConstrainedBytes.__get_validators__(cls)->'CallableGenerator'
pydantic.v1.types.ConstrainedBytes.__modify_schema__(cls,field_schema:Dict[str,Any])->None
pydantic.v1.types.ConstrainedDate(date,metaclass=ConstrainedNumberMeta)
pydantic.v1.types.ConstrainedDate.__get_validators__(cls)->'CallableGenerator'
pydantic.v1.types.ConstrainedDate.__modify_schema__(cls,field_schema:Dict[str,Any])->None
pydantic.v1.types.ConstrainedDecimal(Decimal,metaclass=ConstrainedNumberMeta)
pydantic.v1.types.ConstrainedDecimal.__get_validators__(cls)->'CallableGenerator'
pydantic.v1.types.ConstrainedDecimal.__modify_schema__(cls,field_schema:Dict[str,Any])->None
pydantic.v1.types.ConstrainedDecimal.validate(cls,value:Decimal)->Decimal
pydantic.v1.types.ConstrainedFloat(float,metaclass=ConstrainedNumberMeta)
pydantic.v1.types.ConstrainedFloat.__get_validators__(cls)->'CallableGenerator'
pydantic.v1.types.ConstrainedFloat.__modify_schema__(cls,field_schema:Dict[str,Any])->None
pydantic.v1.types.ConstrainedFrozenSet(frozenset)
pydantic.v1.types.ConstrainedFrozenSet.__get_validators__(cls)->'CallableGenerator'
pydantic.v1.types.ConstrainedFrozenSet.__modify_schema__(cls,field_schema:Dict[str,Any])->None
pydantic.v1.types.ConstrainedFrozenSet.frozenset_length_validator(cls,v:'Optional[FrozenSet[T]]')->'Optional[FrozenSet[T]]'
pydantic.v1.types.ConstrainedInt(int,metaclass=ConstrainedNumberMeta)
pydantic.v1.types.ConstrainedInt.__get_validators__(cls)->'CallableGenerator'
pydantic.v1.types.ConstrainedInt.__modify_schema__(cls,field_schema:Dict[str,Any])->None
pydantic.v1.types.ConstrainedList(list)
pydantic.v1.types.ConstrainedList.__get_validators__(cls)->'CallableGenerator'
pydantic.v1.types.ConstrainedList.__modify_schema__(cls,field_schema:Dict[str,Any])->None
pydantic.v1.types.ConstrainedList.list_length_validator(cls,v:'Optional[List[T]]')->'Optional[List[T]]'
pydantic.v1.types.ConstrainedList.unique_items_validator(cls,v:'Optional[List[T]]')->'Optional[List[T]]'
pydantic.v1.types.ConstrainedNumberMeta(cls,name:str,bases:Any,dct:Dict[str,Any])
pydantic.v1.types.ConstrainedSet(set)
pydantic.v1.types.ConstrainedSet.__get_validators__(cls)->'CallableGenerator'
pydantic.v1.types.ConstrainedSet.__modify_schema__(cls,field_schema:Dict[str,Any])->None
pydantic.v1.types.ConstrainedSet.set_length_validator(cls,v:'Optional[Set[T]]')->'Optional[Set[T]]'
pydantic.v1.types.ConstrainedStr(str)
pydantic.v1.types.ConstrainedStr.__get_validators__(cls)->'CallableGenerator'
pydantic.v1.types.ConstrainedStr.__modify_schema__(cls,field_schema:Dict[str,Any])->None
pydantic.v1.types.ConstrainedStr._get_pattern(regex:Union[str,Pattern[str]])->str
pydantic.v1.types.ConstrainedStr.validate(cls,value:Union[str])->Union[str]
pydantic.v1.types.JsonMeta(type)
pydantic.v1.types.JsonMeta.__getitem__(self,t:Type[Any])->Type[JsonWrapper]
pydantic.v1.types.JsonWrapper
pydantic.v1.types.PaymentCardBrand(str,Enum)
pydantic.v1.types.PaymentCardBrand.__str__(self)->str
pydantic.v1.types.PaymentCardNumber(self,card_number:str)
pydantic.v1.types.PaymentCardNumber.__get_validators__(cls)->'CallableGenerator'
pydantic.v1.types.PaymentCardNumber._get_brand(card_number:str)->PaymentCardBrand
pydantic.v1.types.PaymentCardNumber.masked(self)->str
pydantic.v1.types.PaymentCardNumber.validate_digits(cls,card_number:str)->str
pydantic.v1.types.PaymentCardNumber.validate_length_for_brand(cls,card_number:'PaymentCardNumber')->'PaymentCardNumber'
pydantic.v1.types.PaymentCardNumber.validate_luhn_check_digit(cls,card_number:str)->str
pydantic.v1.types.SecretBytes(self,value:bytes)
pydantic.v1.types.SecretBytes.__get_validators__(cls)->'CallableGenerator'
pydantic.v1.types.SecretBytes.__len__(self)->int
pydantic.v1.types.SecretBytes.__modify_schema__(cls,field_schema:Dict[str,Any])->None
pydantic.v1.types.SecretBytes.__repr__(self)->str
pydantic.v1.types.SecretBytes.display(self)->str
pydantic.v1.types.SecretBytes.get_secret_value(self)->bytes
pydantic.v1.types.SecretBytes.validate(cls,value:Any)->'SecretBytes'
pydantic.v1.types.SecretField(abc.ABC)
pydantic.v1.types.SecretField.__eq__(self,other:Any)->bool
pydantic.v1.types.SecretField.__hash__(self)->int
pydantic.v1.types.SecretField.__str__(self)->str
pydantic.v1.types.SecretField.get_secret_value(self)->Any
pydantic.v1.types.SecretStr(self,value:str)
pydantic.v1.types.SecretStr.__get_validators__(cls)->'CallableGenerator'
pydantic.v1.types.SecretStr.__len__(self)->int
pydantic.v1.types.SecretStr.__modify_schema__(cls,field_schema:Dict[str,Any])->None
pydantic.v1.types.SecretStr.__repr__(self)->str
pydantic.v1.types.SecretStr.display(self)->str
pydantic.v1.types.SecretStr.get_secret_value(self)->str
pydantic.v1.types.SecretStr.validate(cls,value:Any)->'SecretStr'
pydantic.v1.types._registered(typ:'ConstrainedNumberMeta')->'ConstrainedNumberMeta'
pydantic.v1.types._registered(typ:Type[T])->Type[T]
pydantic.v1.types._registered(typ:Union[Type[T],'ConstrainedNumberMeta'])->Union[Type[T], 'ConstrainedNumberMeta']
pydantic.v1.types.conbytes(*,strip_whitespace:bool=False,to_upper:bool=False,to_lower:bool=False,min_length:Optional[int]=None,max_length:Optional[int]=None,strict:bool=False)->Type[bytes]
pydantic.v1.types.condate(*,gt:date=None,ge:date=None,lt:date=None,le:date=None)->Type[date]
pydantic.v1.types.condecimal(*,gt:Decimal=None,ge:Decimal=None,lt:Decimal=None,le:Decimal=None,max_digits:Optional[int]=None,decimal_places:Optional[int]=None,multiple_of:Decimal=None)->Type[Decimal]
pydantic.v1.types.confloat(*,strict:bool=False,gt:float=None,ge:float=None,lt:float=None,le:float=None,multiple_of:float=None,allow_inf_nan:Optional[bool]=None)->Type[float]
pydantic.v1.types.confrozenset(item_type:Type[T],*,min_items:Optional[int]=None,max_items:Optional[int]=None)->Type[FrozenSet[T]]
pydantic.v1.types.conint(*,strict:bool=False,gt:Optional[int]=None,ge:Optional[int]=None,lt:Optional[int]=None,le:Optional[int]=None,multiple_of:Optional[int]=None)->Type[int]
pydantic.v1.types.conlist(item_type:Type[T],*,min_items:Optional[int]=None,max_items:Optional[int]=None,unique_items:bool=None)->Type[List[T]]
pydantic.v1.types.conset(item_type:Type[T],*,min_items:Optional[int]=None,max_items:Optional[int]=None)->Type[Set[T]]
pydantic.v1.types.constr(*,strip_whitespace:bool=False,to_upper:bool=False,to_lower:bool=False,strict:bool=False,min_length:Optional[int]=None,max_length:Optional[int]=None,curtail_length:Optional[int]=None,regex:Optional[str]=None)->Type[str]


----------------------------------------/home/zhang/Packages/pydantic/pydantic2.0b1/v1/color.py----------------------------------------
A:pydantic.v1.color.self._rgba->parse_str(value)
A:pydantic.v1.color.rgb->cast(Tuple[int, int, int], self.as_rgb_tuple())
A:pydantic.v1.color.as_hex->''.join((as_hex[c] for c in range(0, len(as_hex), 2)))
A:pydantic.v1.color.(h, s, li)->self.as_hsl_tuple(alpha=False)
A:pydantic.v1.color.(h, s, li, a)->self.as_hsl_tuple(alpha=True)
A:pydantic.v1.color.(h, l, s)->rgb_to_hls(self._rgba.r, self._rgba.g, self._rgba.b)
A:pydantic.v1.color.value_lower->value.lower()
A:pydantic.v1.color.m->re.fullmatch(r_hsla, value_lower)
A:pydantic.v1.color.(*rgb, a)->re.fullmatch(r_hsla, value_lower).groups()
A:pydantic.v1.color.(h, h_units, s, l_)->re.fullmatch(r_hsla, value_lower).groups()
A:pydantic.v1.color.(h, h_units, s, l_, a)->re.fullmatch(r_hsla, value_lower).groups()
A:pydantic.v1.color.color->float(value)
A:pydantic.v1.color.alpha->float(value)
A:pydantic.v1.color.h_value->float(h)
A:pydantic.v1.color.(r, g, b)->hls_to_rgb(h_value, l_value, s_value)
pydantic.v1.color.Color(self,value:ColorType)
pydantic.v1.color.Color.__eq__(self,other:Any)->bool
pydantic.v1.color.Color.__get_validators__(cls)->'CallableGenerator'
pydantic.v1.color.Color.__hash__(self)->int
pydantic.v1.color.Color.__modify_schema__(cls,field_schema:Dict[str,Any])->None
pydantic.v1.color.Color.__repr_args__(self)->'ReprArgs'
pydantic.v1.color.Color.__str__(self)->str
pydantic.v1.color.Color._alpha_float(self)->float
pydantic.v1.color.Color.as_hex(self)->str
pydantic.v1.color.Color.as_hsl(self)->str
pydantic.v1.color.Color.as_hsl_tuple(self,*,alpha:Optional[bool]=None)->HslColorTuple
pydantic.v1.color.Color.as_named(self,*,fallback:bool=False)->str
pydantic.v1.color.Color.as_rgb(self)->str
pydantic.v1.color.Color.as_rgb_tuple(self,*,alpha:Optional[bool]=None)->ColorTuple
pydantic.v1.color.Color.original(self)->ColorType
pydantic.v1.color.RGBA(self,r:float,g:float,b:float,alpha:Optional[float])
pydantic.v1.color.RGBA.__getitem__(self,item:Any)->Any
pydantic.v1.color.float_to_255(c:float)->int
pydantic.v1.color.ints_to_rgba(r:Union[int,str],g:Union[int,str],b:Union[int,str],alpha:Optional[float])->RGBA
pydantic.v1.color.parse_color_value(value:Union[int,str],max_val:int=255)->float
pydantic.v1.color.parse_float_alpha(value:Union[None,str,float,int])->Optional[float]
pydantic.v1.color.parse_hsl(h:str,h_units:str,sat:str,light:str,alpha:Optional[float]=None)->RGBA
pydantic.v1.color.parse_str(value:str)->RGBA
pydantic.v1.color.parse_tuple(value:Tuple[Any,...])->RGBA


----------------------------------------/home/zhang/Packages/pydantic/pydantic2.0b1/v1/annotated_types.py----------------------------------------
pydantic.v1.annotated_types.create_model_from_namedtuple(namedtuple_cls:Type['NamedTuple'],**kwargs:Any)->Type['BaseModel']
pydantic.v1.annotated_types.create_model_from_typeddict(typeddict_cls:Type['TypedDict'],**kwargs:Any)->Type['BaseModel']
pydantic.v1.create_model_from_namedtuple(namedtuple_cls:Type['NamedTuple'],**kwargs:Any)->Type['BaseModel']
pydantic.v1.create_model_from_typeddict(typeddict_cls:Type['TypedDict'],**kwargs:Any)->Type['BaseModel']


----------------------------------------/home/zhang/Packages/pydantic/pydantic2.0b1/v1/dataclasses.py----------------------------------------
A:pydantic.v1.dataclasses.DataclassT->TypeVar('DataclassT', bound='Dataclass')
A:pydantic.v1.dataclasses._T->TypeVar('_T')
A:pydantic.v1.dataclasses.the_config->get_config(config)
A:pydantic.v1.dataclasses.dc_cls->dataclasses.dataclass(cls, init=init, repr=repr, eq=eq, order=order, unsafe_hash=unsafe_hash, frozen=frozen)
A:pydantic.v1.dataclasses.initvars_and_values[f.name]->kwargs.get(f.name, f.default)
A:pydantic.v1.dataclasses.field_info->Field(default=default, default_factory=default_factory, **field.metadata)
A:pydantic.v1.dataclasses.validators->gather_all_validators(dc_cls)
A:pydantic.v1.dataclasses.(d, _, validation_error)->validate_model(self.__pydantic_model__, input_data, cls=self.__class__)
A:pydantic.v1.dataclasses.d->dict(self.__dict__)
A:pydantic.v1.dataclasses.known_field->self.__pydantic_model__.__fields__.get(name, None)
A:pydantic.v1.dataclasses.(value, error_)->self.__pydantic_model__.__fields__.get(name, None).validate(value, d, loc=name, cls=self.__class__)
pydantic.v1.dataclasses.DataclassProxy(self,dc_cls:Type['Dataclass'])
pydantic.v1.dataclasses.DataclassProxy.__copy__(self)->'DataclassProxy'
pydantic.v1.dataclasses.DataclassProxy.__deepcopy__(self,memo:Any)->'DataclassProxy'
pydantic.v1.dataclasses.DataclassProxy.__getattr__(self,name:str)->Any
pydantic.v1.dataclasses.DataclassProxy.__instancecheck__(self,instance:Any)->bool
pydantic.v1.dataclasses.DataclassProxy.__setattr__(self,__name:str,__value:Any)->None
pydantic.v1.dataclasses._add_pydantic_validation_attributes(dc_cls:Type['Dataclass'],config:Type[BaseConfig],validate_on_init:bool,dc_cls_doc:str)->None
pydantic.v1.dataclasses._dataclass_validate_assignment_setattr(self:'Dataclass',name:str,value:Any)->None
pydantic.v1.dataclasses._dataclass_validate_values(self:'Dataclass')->None
pydantic.v1.dataclasses._get_validators(cls:'DataclassClassOrWrapper')->'CallableGenerator'
pydantic.v1.dataclasses._validate_dataclass(cls:Type['DataclassT'],v:Any)->'DataclassT'
pydantic.v1.dataclasses.create_pydantic_model_from_dataclass(dc_cls:Type['Dataclass'],config:Type[Any]=BaseConfig,dc_cls_doc:Optional[str]=None)->Type['BaseModel']
pydantic.v1.dataclasses.dataclass(_cls:Optional[Type[_T]]=None,*,init:bool=True,repr:bool=True,eq:bool=True,order:bool=False,unsafe_hash:bool=False,frozen:bool=False,config:Union[ConfigDict,Type[object],None]=None,validate_on_init:Optional[bool]=None,use_proxy:Optional[bool]=None,kw_only:bool=False)->Union[Callable[[Type[_T]], 'DataclassClassOrWrapper'], 'DataclassClassOrWrapper']
pydantic.v1.dataclasses.is_builtin_dataclass(_cls:Type[Any])->bool
pydantic.v1.dataclasses.make_dataclass_validator(dc_cls:Type['Dataclass'],config:Type[BaseConfig])->'CallableGenerator'
pydantic.v1.dataclasses.set_validation(cls:Type['DataclassT'],value:bool)->Generator[Type['DataclassT'], None, None]


----------------------------------------/home/zhang/Packages/pydantic/pydantic2.0b1/v1/class_validators.py----------------------------------------
A:pydantic.v1.class_validators.f_cls->_prepare_validator(f, allow_reuse)
A:pydantic.v1.class_validators.validators->self.validators.get(name, [])
A:pydantic.v1.class_validators.unused_validators->set(chain.from_iterable(((getattr(v.func, '__name__', f'<No __name__: id:{id(v.func)}>') for v in self.validators[f] if v.check_fields) for f in self.validators.keys() - self.used_validators)))
A:pydantic.v1.class_validators.fn->', '.join(unused_validators)
A:pydantic.v1.class_validators.validator_config->getattr(value, VALIDATOR_CONFIG_KEY, None)
A:pydantic.v1.class_validators.sig->signature(validator.func)
A:pydantic.v1.class_validators.args->list(sig.parameters.keys())
A:pydantic.v1.class_validators.first_arg->list(sig.parameters.keys()).pop(0)
A:pydantic.v1.class_validators.all_attributes->ChainMap(*[cls.__dict__ for cls in type_.__mro__])
pydantic.v1.class_validators.Validator(self,func:AnyCallable,pre:bool=False,each_item:bool=False,always:bool=False,check_fields:bool=False,skip_on_failure:bool=False)
pydantic.v1.class_validators.ValidatorGroup(self,validators:'ValidatorListDict')
pydantic.v1.class_validators.ValidatorGroup.check_for_unused(self)->None
pydantic.v1.class_validators.ValidatorGroup.get_validators(self,name:str)->Optional[Dict[str, Validator]]
pydantic.v1.class_validators._generic_validator_basic(validator:AnyCallable,sig:'Signature',args:Set[str])->'ValidatorCallable'
pydantic.v1.class_validators._generic_validator_cls(validator:AnyCallable,sig:'Signature',args:Set[str])->'ValidatorCallable'
pydantic.v1.class_validators._prepare_validator(function:AnyCallable,allow_reuse:bool)->'AnyClassMethod'
pydantic.v1.class_validators.extract_root_validators(namespace:Dict[str,Any])->Tuple[List[AnyCallable], List[Tuple[bool, AnyCallable]]]
pydantic.v1.class_validators.extract_validators(namespace:Dict[str,Any])->Dict[str, List[Validator]]
pydantic.v1.class_validators.gather_all_validators(type_:'ModelOrDc')->Dict[str, 'AnyClassMethod']
pydantic.v1.class_validators.inherit_validators(base_validators:'ValidatorListDict',validators:'ValidatorListDict')->'ValidatorListDict'
pydantic.v1.class_validators.make_generic_validator(validator:AnyCallable)->'ValidatorCallable'
pydantic.v1.class_validators.prep_validators(v_funcs:Iterable[AnyCallable])->'ValidatorsList'
pydantic.v1.class_validators.root_validator(*,pre:bool=False,allow_reuse:bool=False,skip_on_failure:bool=False)->Callable[[AnyCallable], 'AnyClassMethod']
pydantic.v1.class_validators.root_validator(_func:AnyCallable)->'AnyClassMethod'
pydantic.v1.class_validators.root_validator(_func:Optional[AnyCallable]=None,*,pre:bool=False,allow_reuse:bool=False,skip_on_failure:bool=False)->Union['AnyClassMethod', Callable[[AnyCallable], 'AnyClassMethod']]
pydantic.v1.class_validators.validator(*fields:str,pre:bool=False,each_item:bool=False,always:bool=False,check_fields:bool=True,whole:Optional[bool]=None,allow_reuse:bool=False)->Callable[[AnyCallable], 'AnyClassMethod']
pydantic.v1.root_validator(*,pre:bool=False,allow_reuse:bool=False,skip_on_failure:bool=False)->Callable[[AnyCallable], 'AnyClassMethod']
pydantic.v1.root_validator(_func:AnyCallable)->'AnyClassMethod'
pydantic.v1.root_validator(_func:Optional[AnyCallable]=None,*,pre:bool=False,allow_reuse:bool=False,skip_on_failure:bool=False)->Union['AnyClassMethod', Callable[[AnyCallable], 'AnyClassMethod']]
pydantic.v1.validator(*fields:str,pre:bool=False,each_item:bool=False,always:bool=False,check_fields:bool=True,whole:Optional[bool]=None,allow_reuse:bool=False)->Callable[[AnyCallable], 'AnyClassMethod']


----------------------------------------/home/zhang/Packages/pydantic/pydantic2.0b1/v1/validators.py----------------------------------------
A:pydantic.v1.validators.v->v.lower().lower()
A:pydantic.v1.validators.allow_inf_nan->getattr(field.type_, 'allow_inf_nan', None)
A:pydantic.v1.validators.v_len->len(v)
A:pydantic.v1.validators.enum_v->field.type_(v)
A:pydantic.v1.validators.required_version->getattr(field.type_, '_required_version', None)
A:pydantic.v1.validators.permitted_choices->all_literal_values(type_)
A:pydantic.v1.validators.T->TypeVar('T')
A:pydantic.v1.validators.str_value->str_validator(v)
A:pydantic.v1.validators.NamedTupleT->TypeVar('NamedTupleT', bound=NamedTuple)
A:pydantic.v1.validators.NamedTupleModel->create_model_from_namedtuple(namedtuple_cls, __config__=config, __module__=namedtuple_cls.__module__)
A:pydantic.v1.validators.TypedDictModel->create_model_from_typeddict(typeddict_cls, __config__=config, __module__=typeddict_cls.__module__)
A:pydantic.v1.validators.class_->get_class(type_)
pydantic.v1.validators.IfConfig(self,validator:AnyCallable,*config_attr_names:str,ignored_value:Any=False)
pydantic.v1.validators.IfConfig.check(self,config:Type['BaseConfig'])->bool
pydantic.v1.validators.any_class_validator(v:Any)->Type[T]
pydantic.v1.validators.anystr_length_validator(v:'StrBytes',config:'BaseConfig')->'StrBytes'
pydantic.v1.validators.anystr_lower(v:'StrBytes')->'StrBytes'
pydantic.v1.validators.anystr_strip_whitespace(v:'StrBytes')->'StrBytes'
pydantic.v1.validators.anystr_upper(v:'StrBytes')->'StrBytes'
pydantic.v1.validators.bool_validator(v:Any)->bool
pydantic.v1.validators.bytes_validator(v:Any)->Union[bytes]
pydantic.v1.validators.callable_validator(v:Any)->AnyCallable
pydantic.v1.validators.constant_validator(v:'Any',field:'ModelField')->'Any'
pydantic.v1.validators.constr_length_validator(v:'StrBytes',field:'ModelField',config:'BaseConfig')->'StrBytes'
pydantic.v1.validators.constr_lower(v:'StrBytes',field:'ModelField',config:'BaseConfig')->'StrBytes'
pydantic.v1.validators.constr_strip_whitespace(v:'StrBytes',field:'ModelField',config:'BaseConfig')->'StrBytes'
pydantic.v1.validators.constr_upper(v:'StrBytes',field:'ModelField',config:'BaseConfig')->'StrBytes'
pydantic.v1.validators.decimal_validator(v:Any)->Decimal
pydantic.v1.validators.deque_validator(v:Any)->Deque[Any]
pydantic.v1.validators.dict_validator(v:Any)->Dict[Any, Any]
pydantic.v1.validators.enum_member_validator(v:Any,field:'ModelField',config:'BaseConfig')->Enum
pydantic.v1.validators.enum_validator(v:Any)->Enum
pydantic.v1.validators.find_validators(type_:Type[Any],config:Type['BaseConfig'])->Generator[AnyCallable, None, None]
pydantic.v1.validators.float_finite_validator(v:'Number',field:'ModelField',config:'BaseConfig')->'Number'
pydantic.v1.validators.float_validator(v:Any)->float
pydantic.v1.validators.frozenset_validator(v:Any)->FrozenSet[Any]
pydantic.v1.validators.hashable_validator(v:Any)->Hashable
pydantic.v1.validators.int_enum_validator(v:Any)->IntEnum
pydantic.v1.validators.int_validator(v:Any)->int
pydantic.v1.validators.ip_v4_address_validator(v:Any)->IPv4Address
pydantic.v1.validators.ip_v4_interface_validator(v:Any)->IPv4Interface
pydantic.v1.validators.ip_v4_network_validator(v:Any)->IPv4Network
pydantic.v1.validators.ip_v6_address_validator(v:Any)->IPv6Address
pydantic.v1.validators.ip_v6_interface_validator(v:Any)->IPv6Interface
pydantic.v1.validators.ip_v6_network_validator(v:Any)->IPv6Network
pydantic.v1.validators.list_validator(v:Any)->List[Any]
pydantic.v1.validators.make_arbitrary_type_validator(type_:Type[T])->Callable[[T], T]
pydantic.v1.validators.make_class_validator(type_:Type[T])->Callable[[Any], Type[T]]
pydantic.v1.validators.make_literal_validator(type_:Any)->Callable[[Any], Any]
pydantic.v1.validators.make_namedtuple_validator(namedtuple_cls:Type[NamedTupleT],config:Type['BaseConfig'])->Callable[[Tuple[Any, ...]], NamedTupleT]
pydantic.v1.validators.make_typeddict_validator(typeddict_cls:Type['TypedDict'],config:Type['BaseConfig'])->Callable[[Any], Dict[str, Any]]
pydantic.v1.validators.none_validator(v:Any)->'Literal[None]'
pydantic.v1.validators.number_multiple_validator(v:'Number',field:'ModelField')->'Number'
pydantic.v1.validators.number_size_validator(v:'Number',field:'ModelField')->'Number'
pydantic.v1.validators.ordered_dict_validator(v:Any)->'AnyOrderedDict'
pydantic.v1.validators.path_exists_validator(v:Any)->Path
pydantic.v1.validators.path_validator(v:Any)->Path
pydantic.v1.validators.pattern_validator(v:Any)->Pattern[str]
pydantic.v1.validators.set_validator(v:Any)->Set[Any]
pydantic.v1.validators.str_validator(v:Any)->Union[str]
pydantic.v1.validators.strict_bytes_validator(v:Any)->Union[bytes]
pydantic.v1.validators.strict_float_validator(v:Any)->float
pydantic.v1.validators.strict_int_validator(v:Any)->int
pydantic.v1.validators.strict_str_validator(v:Any)->Union[str]
pydantic.v1.validators.tuple_validator(v:Any)->Tuple[Any, ...]
pydantic.v1.validators.uuid_validator(v:Any,field:'ModelField')->UUID
pydantic.v1.validators.validate_json(v:Any,config:'BaseConfig')->Any


----------------------------------------/home/zhang/Packages/pydantic/pydantic2.0b1/v1/utils.py----------------------------------------
A:pydantic.v1.utils.(module_path, class_name)->dotted_path.strip(' ').rsplit('.', 1)
A:pydantic.v1.utils.module->import_module(module_path)
A:pydantic.v1.utils.v->v.__class__.__repr__(v).__class__.__repr__(v)
A:pydantic.v1.utils.KeyType->TypeVar('KeyType')
A:pydantic.v1.utils.updated_mapping->mapping.copy()
A:pydantic.v1.utils.updated_mapping[k]->deep_update(updated_mapping[k], v)
A:pydantic.v1.utils.present_params->signature(init).parameters.values()
A:pydantic.v1.utils.merged_params[param_name]->Parameter(param_name, Parameter.KEYWORD_ONLY, annotation=field.annotation, **kwargs)
A:pydantic.v1.utils.merged_params[var_kw_name]->var_kw.replace(name=var_kw_name)
A:pydantic.v1.utils.pascal_string->to_camel(string)
A:pydantic.v1.utils.T->TypeVar('T')
A:pydantic.v1.utils.v_name->name_factory(v)
A:pydantic.v1.utils.items->dict.fromkeys(items, ...)
A:pydantic.v1.utils.item->self._items.get(e)
A:pydantic.v1.utils.all_items->self._coerce_value(v)
A:pydantic.v1.utils.normalized_items[normalized_i]->self.merge(v, normalized_items.get(normalized_i))
A:pydantic.v1.utils.normalized_item->normalized_items.setdefault(i, {})
A:pydantic.v1.utils.normalized_items[i]->self.merge(all_items, normalized_item)
A:pydantic.v1.utils.override->cls._coerce_value(override)
A:pydantic.v1.utils.base->cls._coerce_value(base)
A:pydantic.v1.utils.merged_item->cls.merge(base.get(k), override.get(k), intersect=intersect)
A:pydantic.v1.utils.class_name->getattr(items, '__class__', '???')
A:pydantic.v1.utils.Obj->TypeVar('Obj')
A:pydantic.v1.utils._EMPTY->object()
A:pydantic.v1.utils.unique_aliases->set(all_aliases)
A:pydantic.v1.utils.is_root_model->getattr(tp, '__custom_root_type__', False)
A:pydantic.v1.utils.(alias, all_values)->_get_union_alias_and_all_values(union_type, discriminator_key)
A:pydantic.v1.utils.(all_aliases, all_values)->zip(*zipped_aliases_values)
pydantic.v1.utils.ClassAttribute(self,name:str,value:Any)
pydantic.v1.utils.ClassAttribute.__get__(self,instance:Any,owner:Type[Any])->None
pydantic.v1.utils.GetterDict(self,obj:Any)
pydantic.v1.utils.GetterDict.__contains__(self,item:Any)->bool
pydantic.v1.utils.GetterDict.__eq__(self,other:Any)->bool
pydantic.v1.utils.GetterDict.__getitem__(self,key:str)->Any
pydantic.v1.utils.GetterDict.__iter__(self)->Iterator[str]
pydantic.v1.utils.GetterDict.__len__(self)->int
pydantic.v1.utils.GetterDict.__repr_args__(self)->'ReprArgs'
pydantic.v1.utils.GetterDict.__repr_name__(self)->str
pydantic.v1.utils.GetterDict.extra_keys(self)->Set[Any]
pydantic.v1.utils.GetterDict.get(self,key:Any,default:Any=None)->Any
pydantic.v1.utils.GetterDict.items(self)->Iterator[Tuple[str, Any]]
pydantic.v1.utils.GetterDict.keys(self)->List[Any]
pydantic.v1.utils.GetterDict.values(self)->List[Any]
pydantic.v1.utils.PyObjectStr(str)
pydantic.v1.utils.PyObjectStr.__repr__(self)->str
pydantic.v1.utils.Representation
pydantic.v1.utils.Representation.__pretty__(self,fmt:Callable[[Any],Any],**kwargs:Any)->Generator[Any, None, None]
pydantic.v1.utils.Representation.__repr__(self)->str
pydantic.v1.utils.Representation.__repr_args__(self)->'ReprArgs'
pydantic.v1.utils.Representation.__repr_name__(self)->str
pydantic.v1.utils.Representation.__repr_str__(self,join_str:str)->str
pydantic.v1.utils.Representation.__rich_repr__(self)->'RichReprResult'
pydantic.v1.utils.Representation.__str__(self)->str
pydantic.v1.utils.ValueItems(self,value:Any,items:Union['AbstractSetIntStr','MappingIntStrAny'])
pydantic.v1.utils.ValueItems.__repr_args__(self)->'ReprArgs'
pydantic.v1.utils.ValueItems._coerce_items(items:Union['AbstractSetIntStr','MappingIntStrAny'])->'MappingIntStrAny'
pydantic.v1.utils.ValueItems._coerce_value(cls,value:Any)->Any
pydantic.v1.utils.ValueItems._normalize_indexes(self,items:'MappingIntStrAny',v_length:int)->'DictIntStrAny'
pydantic.v1.utils.ValueItems.for_element(self,e:'IntStr')->Optional[Union['AbstractSetIntStr', 'MappingIntStrAny']]
pydantic.v1.utils.ValueItems.is_excluded(self,item:Any)->bool
pydantic.v1.utils.ValueItems.is_included(self,item:Any)->bool
pydantic.v1.utils.ValueItems.is_true(v:Any)->bool
pydantic.v1.utils.ValueItems.merge(cls,base:Any,override:Any,intersect:bool=False)->Any
pydantic.v1.utils._get_union_alias_and_all_values(union_type:Type[Any],discriminator_key:str)->Tuple[str, Tuple[Tuple[str, ...], ...]]
pydantic.v1.utils.all_identical(left:Iterable[Any],right:Iterable[Any])->bool
pydantic.v1.utils.almost_equal_floats(value_1:float,value_2:float,*,delta:float=1e-08)->bool
pydantic.v1.utils.assert_never(obj:NoReturn,msg:str)->NoReturn
pydantic.v1.utils.deep_update(mapping:Dict[KeyType,Any],*updating_mappings:Dict[KeyType,Any])->Dict[KeyType, Any]
pydantic.v1.utils.generate_model_signature(init:Callable[...,None],fields:Dict[str,'ModelField'],config:Type['BaseConfig'])->'Signature'
pydantic.v1.utils.get_discriminator_alias_and_values(tp:Any,discriminator_key:str)->Tuple[str, Tuple[str, ...]]
pydantic.v1.utils.get_model(obj:Union[Type['BaseModel'],Type['Dataclass']])->Type['BaseModel']
pydantic.v1.utils.get_unique_discriminator_alias(all_aliases:Collection[str],discriminator_key:str)->str
pydantic.v1.utils.import_string(dotted_path:str)->Any
pydantic.v1.utils.in_ipython()->bool
pydantic.v1.utils.is_valid_field(name:str)->bool
pydantic.v1.utils.is_valid_identifier(identifier:str)->bool
pydantic.v1.utils.is_valid_private_name(name:str)->bool
pydantic.v1.utils.lenient_isinstance(o:Any,class_or_tuple:Union[Type[Any],Tuple[Type[Any],...],None])->bool
pydantic.v1.utils.lenient_issubclass(cls:Any,class_or_tuple:Union[Type[Any],Tuple[Type[Any],...],None])->bool
pydantic.v1.utils.path_type(p:'Path')->str
pydantic.v1.utils.sequence_like(v:Any)->bool
pydantic.v1.utils.smart_deepcopy(obj:Obj)->Obj
pydantic.v1.utils.to_camel(string:str)->str
pydantic.v1.utils.to_lower_camel(string:str)->str
pydantic.v1.utils.truncate(v:Union[str],*,max_len:int=80)->str
pydantic.v1.utils.unique_list(input_list:Union[List[T],Tuple[T,...]],*,name_factory:Callable[[T],str]=str)->List[T]
pydantic.v1.utils.update_not_none(mapping:Dict[Any,Any],**update:Any)->None
pydantic.v1.utils.validate_field_name(bases:List[Type['BaseModel']],field_name:str)->None


----------------------------------------/home/zhang/Packages/pydantic/pydantic2.0b1/v1/decorator.py----------------------------------------
A:pydantic.v1.decorator.AnyCallableT->TypeVar('AnyCallableT', bound=AnyCallable)
A:pydantic.v1.decorator.vd->ValidatedFunction(_func, config)
A:pydantic.v1.decorator.self.positional_only_args->set()
A:pydantic.v1.decorator.type_hints->get_all_type_hints(function)
A:pydantic.v1.decorator.values->self.build_values(args, kwargs)
A:pydantic.v1.decorator.m->self.init_model_instance(*args, **kwargs)
A:pydantic.v1.decorator.arg_iter->enumerate(args)
A:pydantic.v1.decorator.(i, a)->next(arg_iter)
A:pydantic.v1.decorator.arg_name->self.arg_mapping.get(i)
A:pydantic.v1.decorator.var_kwargs->d.pop(self.v_kwargs_name, {})
A:pydantic.v1.decorator.pos_args->len(self.arg_mapping)
A:pydantic.v1.decorator.CustomConfig->type('Config', (), config)
A:pydantic.v1.decorator.keys->', '.join(map(repr, v))
A:pydantic.v1.decorator.extra->getattr(CustomConfig, 'extra', Extra.forbid)
A:pydantic.v1.decorator.self.model->create_model(to_camel(self.raw_function.__name__), __base__=DecoratorBaseModel, **fields)
pydantic.v1.decorator.ValidatedFunction(self,function:'AnyCallableT',config:'ConfigType')
pydantic.v1.decorator.ValidatedFunction.build_values(self,args:Tuple[Any,...],kwargs:Dict[str,Any])->Dict[str, Any]
pydantic.v1.decorator.ValidatedFunction.call(self,*args:Any,**kwargs:Any)->Any
pydantic.v1.decorator.ValidatedFunction.create_model(self,fields:Dict[str,Any],takes_args:bool,takes_kwargs:bool,config:'ConfigType')->None
pydantic.v1.decorator.ValidatedFunction.execute(self,m:BaseModel)->Any
pydantic.v1.decorator.ValidatedFunction.init_model_instance(self,*args:Any,**kwargs:Any)->BaseModel
pydantic.v1.decorator.validate_arguments(func:'AnyCallableT')->'AnyCallableT'
pydantic.v1.decorator.validate_arguments(func:None=None,*,config:'ConfigType'=None)->Callable[['AnyCallableT'], 'AnyCallableT']
pydantic.v1.decorator.validate_arguments(func:Optional['AnyCallableT']=None,*,config:'ConfigType'=None)->Any
pydantic.v1.validate_arguments(func:'AnyCallableT')->'AnyCallableT'
pydantic.v1.validate_arguments(func:None=None,*,config:'ConfigType'=None)->Callable[['AnyCallableT'], 'AnyCallableT']
pydantic.v1.validate_arguments(func:Optional['AnyCallableT']=None,*,config:'ConfigType'=None)->Any


----------------------------------------/home/zhang/Packages/pydantic/pydantic2.0b1/v1/_hypothesis_plugin.py----------------------------------------
A:pydantic.v1._hypothesis_plugin._color_regexes->'|'.join((pydantic.color.r_hex_short, pydantic.color.r_hex_long, pydantic.color.r_rgb, pydantic.color.r_rgba, pydantic.color.r_hsl, pydantic.color.r_hsla)).replace(pydantic.color._r_sl, '(?:(\\d\\d?(?:\\.\\d+)?|100(?:\\.0+)?)%)').replace(pydantic.color._r_alpha, '(?:(0(?:\\.\\d+)?|1(?:\\.0+)?|\\.\\d+|\\d{1,2}%))').replace(pydantic.color._r_255, '(?:((?:\\d|\\d\\d|[01]\\d\\d|2[0-4]\\d|25[0-4])(?:\\.\\d+)?|255(?:\\.0+)?))')
A:pydantic.v1._hypothesis_plugin.finite->hypothesis.strategies.floats(allow_infinity=False, allow_nan=False)
A:pydantic.v1._hypothesis_plugin.inner->hypothesis.strategies.recursive(base=st.one_of(st.none(), st.booleans(), st.integers(), finite, st.text()), extend=lambda x: st.lists(x) | st.dictionaries(st.text(), x))
A:pydantic.v1._hypothesis_plugin.inner_type->getattr(cls, 'inner_type', None)
A:pydantic.v1._hypothesis_plugin.repeats->'{{{},{}}}'.format(min_size - 2 if min_size > 2 else 0, max_size - 2 if (max_size or 0) > 2 else '')
A:pydantic.v1._hypothesis_plugin.s->s.filter(lambda d: cls.gt < d).filter(lambda d: cls.gt < d)
A:pydantic.v1._hypothesis_plugin.min_value->math.ceil(Fraction(min_value) / Fraction(cls.multiple_of))
A:pydantic.v1._hypothesis_plugin.max_value->math.floor(Fraction(max_value) / Fraction(cls.multiple_of))
A:pydantic.v1._hypothesis_plugin.strategy->hypothesis.strategies.from_regex(f'(\\W(.{repeats}\\W)?)?')
pydantic.v1._hypothesis_plugin._registered(typ:Type[pydantic.types.T])->Type[pydantic.types.T]
pydantic.v1._hypothesis_plugin._registered(typ:Union[Type[pydantic.types.T],pydantic.types.ConstrainedNumberMeta])->Union[Type[pydantic.types.T], pydantic.types.ConstrainedNumberMeta]
pydantic.v1._hypothesis_plugin._registered(typ:pydantic.types.ConstrainedNumberMeta)->pydantic.types.ConstrainedNumberMeta
pydantic.v1._hypothesis_plugin.add_luhn_digit(card_number:str)->str
pydantic.v1._hypothesis_plugin.resolve_conbytes(cls)
pydantic.v1._hypothesis_plugin.resolve_condate(cls)
pydantic.v1._hypothesis_plugin.resolve_condecimal(cls)
pydantic.v1._hypothesis_plugin.resolve_confloat(cls)
pydantic.v1._hypothesis_plugin.resolve_conint(cls)
pydantic.v1._hypothesis_plugin.resolve_constr(cls)
pydantic.v1._hypothesis_plugin.resolve_json(cls)
pydantic.v1._hypothesis_plugin.resolves(typ:Union[type,pydantic.types.ConstrainedNumberMeta])->Callable[[Callable[..., st.SearchStrategy]], Callable[..., st.SearchStrategy]]


----------------------------------------/home/zhang/Packages/pydantic/pydantic2.0b1/v1/parse.py----------------------------------------
A:pydantic.v1.parse.b->Path(path).read_bytes()
A:pydantic.v1.parse.path->Path(path)
pydantic.v1.Protocol(str,Enum)
pydantic.v1.parse.Protocol(str,Enum)
pydantic.v1.parse.load_file(path:Union[str,Path],*,content_type:str=None,encoding:str='utf8',proto:Protocol=None,allow_pickle:bool=False,json_loads:Callable[[str],Any]=json.loads)->Any
pydantic.v1.parse.load_str_bytes(b:StrBytes,*,content_type:str=None,encoding:str='utf8',proto:Protocol=None,allow_pickle:bool=False,json_loads:Callable[[str],Any]=json.loads)->Any


----------------------------------------/home/zhang/Packages/pydantic/pydantic2.0b1/v1/env_settings.py----------------------------------------
A:pydantic.v1.env_settings.env_file_sentinel->str(object())
A:pydantic.v1.env_settings.init_settings->InitSettingsSource(init_kwargs=init_kwargs)
A:pydantic.v1.env_settings.env_settings->EnvSettingsSource(env_file=_env_file if _env_file != env_file_sentinel else self.__config__.env_file, env_file_encoding=_env_file_encoding if _env_file_encoding is not None else self.__config__.env_file_encoding, env_nested_delimiter=_env_nested_delimiter if _env_nested_delimiter is not None else self.__config__.env_nested_delimiter, env_prefix_len=len(self.__config__.env_prefix))
A:pydantic.v1.env_settings.file_secret_settings->SecretsSettingsSource(secrets_dir=_secrets_dir or self.__config__.secrets_dir)
A:pydantic.v1.env_settings.sources->self.__config__.customise_sources(init_settings=init_settings, env_settings=env_settings, file_secret_settings=file_secret_settings)
A:pydantic.v1.env_settings.field_info_from_config->cls.get_field_info(field.name)
A:pydantic.v1.env_settings.env_names->env_names.__class__((n.lower() for n in env_names)).__class__((n.lower() for n in env_names))
A:pydantic.v1.env_settings.dotenv_vars->self._read_env_files(settings.__config__.case_sensitive)
A:pydantic.v1.env_settings.env_val->settings.__config__.parse_env_var(field.name, env_val)
A:pydantic.v1.env_settings.(is_complex, allow_parse_failure)->self.field_is_complex(field)
A:pydantic.v1.env_settings.env_val_built->self.explode_env_vars(field, env_vars)
A:pydantic.v1.env_settings.d[field.alias]->deep_update(env_val, self.explode_env_vars(field, env_vars))
A:pydantic.v1.env_settings.env_path->Path(env_file).expanduser()
A:pydantic.v1.env_settings.(_, *keys, last_key)->env_name_without_prefix.split(self.env_nested_delimiter)
A:pydantic.v1.env_settings.env_var->env_var.setdefault(key, {}).setdefault(key, {})
A:pydantic.v1.env_settings.secrets_path->Path(self.secrets_dir).expanduser()
A:pydantic.v1.env_settings.path->find_case_path(secrets_path, env_name, settings.__config__.case_sensitive)
A:pydantic.v1.env_settings.secret_value->settings.__config__.parse_env_var(field.name, secret_value)
pydantic.v1.BaseSettings(__pydantic_self__,_env_file:Optional[DotenvType]=env_file_sentinel,_env_file_encoding:Optional[str]=None,_env_nested_delimiter:Optional[str]=None,_secrets_dir:Optional[StrPath]=None,**values:Any)
pydantic.v1.BaseSettings.Config(BaseConfig)
pydantic.v1.BaseSettings.Config.customise_sources(cls,init_settings:SettingsSourceCallable,env_settings:SettingsSourceCallable,file_secret_settings:SettingsSourceCallable)->Tuple[SettingsSourceCallable, ...]
pydantic.v1.BaseSettings.Config.parse_env_var(cls,field_name:str,raw_val:str)->Any
pydantic.v1.BaseSettings.Config.prepare_field(cls,field:ModelField)->None
pydantic.v1.BaseSettings._build_values(self,init_kwargs:Dict[str,Any],_env_file:Optional[DotenvType]=None,_env_file_encoding:Optional[str]=None,_env_nested_delimiter:Optional[str]=None,_secrets_dir:Optional[StrPath]=None)->Dict[str, Any]
pydantic.v1.env_settings.BaseSettings(__pydantic_self__,_env_file:Optional[DotenvType]=env_file_sentinel,_env_file_encoding:Optional[str]=None,_env_nested_delimiter:Optional[str]=None,_secrets_dir:Optional[StrPath]=None,**values:Any)
pydantic.v1.env_settings.BaseSettings.Config(BaseConfig)
pydantic.v1.env_settings.BaseSettings.Config.customise_sources(cls,init_settings:SettingsSourceCallable,env_settings:SettingsSourceCallable,file_secret_settings:SettingsSourceCallable)->Tuple[SettingsSourceCallable, ...]
pydantic.v1.env_settings.BaseSettings.Config.parse_env_var(cls,field_name:str,raw_val:str)->Any
pydantic.v1.env_settings.BaseSettings.Config.prepare_field(cls,field:ModelField)->None
pydantic.v1.env_settings.BaseSettings._build_values(self,init_kwargs:Dict[str,Any],_env_file:Optional[DotenvType]=None,_env_file_encoding:Optional[str]=None,_env_nested_delimiter:Optional[str]=None,_secrets_dir:Optional[StrPath]=None)->Dict[str, Any]
pydantic.v1.env_settings.EnvSettingsSource(self,env_file:Optional[DotenvType],env_file_encoding:Optional[str],env_nested_delimiter:Optional[str]=None,env_prefix_len:int=0)
pydantic.v1.env_settings.EnvSettingsSource.__repr__(self)->str
pydantic.v1.env_settings.EnvSettingsSource._read_env_files(self,case_sensitive:bool)->Dict[str, Optional[str]]
pydantic.v1.env_settings.EnvSettingsSource.explode_env_vars(self,field:ModelField,env_vars:Mapping[str,Optional[str]])->Dict[str, Any]
pydantic.v1.env_settings.EnvSettingsSource.field_is_complex(self,field:ModelField)->Tuple[bool, bool]
pydantic.v1.env_settings.InitSettingsSource(self,init_kwargs:Dict[str,Any])
pydantic.v1.env_settings.InitSettingsSource.__repr__(self)->str
pydantic.v1.env_settings.SecretsSettingsSource(self,secrets_dir:Optional[StrPath])
pydantic.v1.env_settings.SecretsSettingsSource.__repr__(self)->str
pydantic.v1.env_settings.SettingsError(ValueError)
pydantic.v1.env_settings.find_case_path(dir_path:Path,file_name:str,case_sensitive:bool)->Optional[Path]
pydantic.v1.env_settings.read_env_file(file_path:StrPath,*,encoding:str=None,case_sensitive:bool=False)->Dict[str, Optional[str]]


----------------------------------------/home/zhang/Packages/pydantic/pydantic2.0b1/v1/tools.py----------------------------------------
A:pydantic.v1.tools.type_name->type_name(type_)
A:pydantic.v1.tools.T->TypeVar('T')
A:pydantic.v1.tools.model_type->_get_parsing_type(type_, type_name=type_name)
A:pydantic.v1.tools.obj->load_str_bytes(b, proto=proto, content_type=content_type, encoding=encoding, allow_pickle=allow_pickle, json_loads=json_loads)
pydantic.v1._generate_parsing_type_name(type_:Any)->str
pydantic.v1._get_parsing_type(type_:Any,*,type_name:Optional[NameFactory]=None)->Any
pydantic.v1.parse_file_as(type_:Type[T],path:Union[str,Path],*,content_type:str=None,encoding:str='utf8',proto:Protocol=None,allow_pickle:bool=False,json_loads:Callable[[str],Any]=json.loads,type_name:Optional[NameFactory]=None)->T
pydantic.v1.parse_obj_as(type_:Type[T],obj:Any,*,type_name:Optional[NameFactory]=None)->T
pydantic.v1.parse_raw_as(type_:Type[T],b:StrBytes,*,content_type:str=None,encoding:str='utf8',proto:Protocol=None,allow_pickle:bool=False,json_loads:Callable[[str],Any]=json.loads,type_name:Optional[NameFactory]=None)->T
pydantic.v1.schema_json_of(type_:Any,*,title:Optional[NameFactory]=None,**schema_json_kwargs:Any)->str
pydantic.v1.schema_of(type_:Any,*,title:Optional[NameFactory]=None,**schema_kwargs:Any)->'DictStrAny'
pydantic.v1.tools._generate_parsing_type_name(type_:Any)->str
pydantic.v1.tools._get_parsing_type(type_:Any,*,type_name:Optional[NameFactory]=None)->Any
pydantic.v1.tools.parse_file_as(type_:Type[T],path:Union[str,Path],*,content_type:str=None,encoding:str='utf8',proto:Protocol=None,allow_pickle:bool=False,json_loads:Callable[[str],Any]=json.loads,type_name:Optional[NameFactory]=None)->T
pydantic.v1.tools.parse_obj_as(type_:Type[T],obj:Any,*,type_name:Optional[NameFactory]=None)->T
pydantic.v1.tools.parse_raw_as(type_:Type[T],b:StrBytes,*,content_type:str=None,encoding:str='utf8',proto:Protocol=None,allow_pickle:bool=False,json_loads:Callable[[str],Any]=json.loads,type_name:Optional[NameFactory]=None)->T
pydantic.v1.tools.schema_json_of(type_:Any,*,title:Optional[NameFactory]=None,**schema_json_kwargs:Any)->str
pydantic.v1.tools.schema_of(type_:Any,*,title:Optional[NameFactory]=None,**schema_kwargs:Any)->'DictStrAny'


----------------------------------------/home/zhang/Packages/pydantic/pydantic2.0b1/v1/datetime_parse.py----------------------------------------
A:pydantic.v1.datetime_parse.date_re->re.compile(f'{date_expr}$')
A:pydantic.v1.datetime_parse.time_re->re.compile(time_expr)
A:pydantic.v1.datetime_parse.datetime_re->re.compile(f'{date_expr}[T ]{time_expr}')
A:pydantic.v1.datetime_parse.standard_duration_re->re.compile('^(?:(?P<days>-?\\d+) (days?, )?)?((?:(?P<hours>-?\\d+):)(?=\\d+:\\d+))?(?:(?P<minutes>-?\\d+):)?(?P<seconds>-?\\d+)(?:\\.(?P<microseconds>\\d{1,6})\\d{0,6})?$')
A:pydantic.v1.datetime_parse.iso8601_duration_re->re.compile('^(?P<sign>[-+]?)P(?:(?P<days>\\d+(.\\d+)?)D)?(?:T(?:(?P<hours>\\d+(.\\d+)?)H)?(?:(?P<minutes>\\d+(.\\d+)?)M)?(?:(?P<seconds>\\d+(.\\d+)?)S)?)?$')
A:pydantic.v1.datetime_parse.EPOCH->datetime(1970, 1, 1)
A:pydantic.v1.datetime_parse.MS_WATERSHED->int(20000000000.0)
A:pydantic.v1.datetime_parse.MAX_NUMBER->int(3e+20)
A:pydantic.v1.datetime_parse.number->get_numeric(value, 'datetime')
A:pydantic.v1.datetime_parse.value->value.decode().decode()
A:pydantic.v1.datetime_parse.match->re.compile(f'{date_expr}[T ]{time_expr}').match(value)
A:pydantic.v1.datetime_parse.kw->re.compile(f'{date_expr}[T ]{time_expr}').match(value).groupdict()
A:pydantic.v1.datetime_parse.kw['microsecond']->kw['microsecond'].ljust(6, '0').ljust(6, '0')
A:pydantic.v1.datetime_parse.tzinfo->_parse_timezone(kw.pop('tzinfo'), errors.DateTimeError)
A:pydantic.v1.datetime_parse.kw['microseconds']->kw['microseconds'].ljust(6, '0').ljust(6, '0')
pydantic.v1.datetime_parse._parse_timezone(value:Optional[str],error:Type[Exception])->Union[None, int, timezone]
pydantic.v1.datetime_parse.from_unix_seconds(seconds:Union[int,float])->datetime
pydantic.v1.datetime_parse.get_numeric(value:StrBytesIntFloat,native_expected_type:str)->Union[None, int, float]
pydantic.v1.datetime_parse.parse_date(value:Union[date,StrBytesIntFloat])->date
pydantic.v1.datetime_parse.parse_datetime(value:Union[datetime,StrBytesIntFloat])->datetime
pydantic.v1.datetime_parse.parse_duration(value:StrBytesIntFloat)->timedelta
pydantic.v1.datetime_parse.parse_time(value:Union[time,StrBytesIntFloat])->time


----------------------------------------/home/zhang/Packages/pydantic/pydantic2.0b1/v1/errors.py----------------------------------------
A:pydantic.v1.errors.permitted->', '.join((repr(v.value) for v in self.enum_values))
pydantic.v1.AnyStrMaxLengthError(self,*,limit_value:int)
pydantic.v1.AnyStrMinLengthError(self,*,limit_value:int)
pydantic.v1.ArbitraryTypeError(self,*,expected_arbitrary_type:Type[Any])
pydantic.v1.BoolError(PydanticTypeError)
pydantic.v1.BytesError(PydanticTypeError)
pydantic.v1.CallableError(PydanticTypeError)
pydantic.v1.ClassError(PydanticTypeError)
pydantic.v1.ColorError(PydanticValueError)
pydantic.v1.ConfigError(RuntimeError)
pydantic.v1.DataclassTypeError(PydanticTypeError)
pydantic.v1.DateError(PydanticValueError)
pydantic.v1.DateNotInTheFutureError(PydanticValueError)
pydantic.v1.DateNotInThePastError(PydanticValueError)
pydantic.v1.DateTimeError(PydanticValueError)
pydantic.v1.DecimalError(PydanticTypeError)
pydantic.v1.DecimalIsNotFiniteError(PydanticValueError)
pydantic.v1.DecimalMaxDigitsError(self,*,max_digits:int)
pydantic.v1.DecimalMaxPlacesError(self,*,decimal_places:int)
pydantic.v1.DecimalWholeDigitsError(self,*,whole_digits:int)
pydantic.v1.DequeError(PydanticTypeError)
pydantic.v1.DictError(PydanticTypeError)
pydantic.v1.DurationError(PydanticValueError)
pydantic.v1.EmailError(PydanticValueError)
pydantic.v1.EnumError(PydanticTypeError)
pydantic.v1.EnumMemberError(PydanticTypeError)
pydantic.v1.EnumMemberError.__str__(self)->str
pydantic.v1.ExtraError(PydanticValueError)
pydantic.v1.FloatError(PydanticTypeError)
pydantic.v1.FrozenSetError(PydanticTypeError)
pydantic.v1.FrozenSetMaxLengthError(self,*,limit_value:int)
pydantic.v1.FrozenSetMinLengthError(self,*,limit_value:int)
pydantic.v1.HashableError(PydanticTypeError)
pydantic.v1.IPv4AddressError(PydanticValueError)
pydantic.v1.IPv4InterfaceError(PydanticValueError)
pydantic.v1.IPv4NetworkError(PydanticValueError)
pydantic.v1.IPv6AddressError(PydanticValueError)
pydantic.v1.IPv6InterfaceError(PydanticValueError)
pydantic.v1.IPv6NetworkError(PydanticValueError)
pydantic.v1.IPvAnyAddressError(PydanticValueError)
pydantic.v1.IPvAnyInterfaceError(PydanticValueError)
pydantic.v1.IPvAnyNetworkError(PydanticValueError)
pydantic.v1.IntEnumError(PydanticTypeError)
pydantic.v1.IntegerError(PydanticTypeError)
pydantic.v1.InvalidByteSize(PydanticValueError)
pydantic.v1.InvalidByteSizeUnit(PydanticValueError)
pydantic.v1.InvalidDiscriminator(self,*,discriminator_key:str,discriminator_value:Any,allowed_values:Sequence[Any])
pydantic.v1.InvalidLengthForBrand(PydanticValueError)
pydantic.v1.IterableError(PydanticTypeError)
pydantic.v1.JsonError(PydanticValueError)
pydantic.v1.JsonTypeError(PydanticTypeError)
pydantic.v1.ListError(PydanticTypeError)
pydantic.v1.ListMaxLengthError(self,*,limit_value:int)
pydantic.v1.ListMinLengthError(self,*,limit_value:int)
pydantic.v1.ListUniqueItemsError(PydanticValueError)
pydantic.v1.LuhnValidationError(PydanticValueError)
pydantic.v1.MissingDiscriminator(PydanticValueError)
pydantic.v1.MissingError(PydanticValueError)
pydantic.v1.NoneIsAllowedError(PydanticTypeError)
pydantic.v1.NoneIsNotAllowedError(PydanticTypeError)
pydantic.v1.NotDigitError(PydanticValueError)
pydantic.v1.NotNoneError(PydanticTypeError)
pydantic.v1.NumberNotFiniteError(PydanticValueError)
pydantic.v1.NumberNotGeError(_NumberBoundError)
pydantic.v1.NumberNotGtError(_NumberBoundError)
pydantic.v1.NumberNotLeError(_NumberBoundError)
pydantic.v1.NumberNotLtError(_NumberBoundError)
pydantic.v1.NumberNotMultipleError(self,*,multiple_of:Union[int,float,Decimal])
pydantic.v1.PathError(PydanticTypeError)
pydantic.v1.PathNotADirectoryError(_PathValueError)
pydantic.v1.PathNotAFileError(_PathValueError)
pydantic.v1.PathNotExistsError(_PathValueError)
pydantic.v1.PatternError(PydanticValueError)
pydantic.v1.PyObjectError(PydanticTypeError)
pydantic.v1.PydanticErrorMixin(self,**ctx:Any)
pydantic.v1.PydanticErrorMixin.__reduce__(self)->Tuple[Callable[..., 'PydanticErrorMixin'], Tuple[Type['PydanticErrorMixin'], 'DictStrAny']]
pydantic.v1.PydanticErrorMixin.__str__(self)->str
pydantic.v1.PydanticTypeError(PydanticErrorMixin,TypeError)
pydantic.v1.PydanticValueError(PydanticErrorMixin,ValueError)
pydantic.v1.SequenceError(PydanticTypeError)
pydantic.v1.SetError(PydanticTypeError)
pydantic.v1.SetMaxLengthError(self,*,limit_value:int)
pydantic.v1.SetMinLengthError(self,*,limit_value:int)
pydantic.v1.StrError(PydanticTypeError)
pydantic.v1.StrRegexError(self,*,pattern:str)
pydantic.v1.StrictBoolError(PydanticValueError)
pydantic.v1.SubclassError(self,*,expected_class:Type[Any])
pydantic.v1.TimeError(PydanticValueError)
pydantic.v1.TupleError(PydanticTypeError)
pydantic.v1.TupleLengthError(self,*,actual_length:int,expected_length:int)
pydantic.v1.UUIDError(PydanticTypeError)
pydantic.v1.UUIDVersionError(self,*,required_version:int)
pydantic.v1.UrlError(PydanticValueError)
pydantic.v1.UrlExtraError(UrlError)
pydantic.v1.UrlHostError(UrlError)
pydantic.v1.UrlHostTldError(UrlError)
pydantic.v1.UrlPortError(UrlError)
pydantic.v1.UrlSchemeError(UrlError)
pydantic.v1.UrlSchemePermittedError(self,allowed_schemes:Set[str])
pydantic.v1.UrlUserInfoError(UrlError)
pydantic.v1.WrongConstantError(PydanticValueError)
pydantic.v1.WrongConstantError.__str__(self)->str
pydantic.v1._NumberBoundError(self,*,limit_value:Union[int,float,Decimal])
pydantic.v1._PathValueError(self,*,path:Path)
pydantic.v1.cls_kwargs(cls:Type['PydanticErrorMixin'],ctx:'DictStrAny')->'PydanticErrorMixin'
pydantic.v1.errors.AnyStrMaxLengthError(self,*,limit_value:int)
pydantic.v1.errors.AnyStrMinLengthError(self,*,limit_value:int)
pydantic.v1.errors.ArbitraryTypeError(self,*,expected_arbitrary_type:Type[Any])
pydantic.v1.errors.BoolError(PydanticTypeError)
pydantic.v1.errors.BytesError(PydanticTypeError)
pydantic.v1.errors.CallableError(PydanticTypeError)
pydantic.v1.errors.ClassError(PydanticTypeError)
pydantic.v1.errors.ColorError(PydanticValueError)
pydantic.v1.errors.ConfigError(RuntimeError)
pydantic.v1.errors.DataclassTypeError(PydanticTypeError)
pydantic.v1.errors.DateError(PydanticValueError)
pydantic.v1.errors.DateNotInTheFutureError(PydanticValueError)
pydantic.v1.errors.DateNotInThePastError(PydanticValueError)
pydantic.v1.errors.DateTimeError(PydanticValueError)
pydantic.v1.errors.DecimalError(PydanticTypeError)
pydantic.v1.errors.DecimalIsNotFiniteError(PydanticValueError)
pydantic.v1.errors.DecimalMaxDigitsError(self,*,max_digits:int)
pydantic.v1.errors.DecimalMaxPlacesError(self,*,decimal_places:int)
pydantic.v1.errors.DecimalWholeDigitsError(self,*,whole_digits:int)
pydantic.v1.errors.DequeError(PydanticTypeError)
pydantic.v1.errors.DictError(PydanticTypeError)
pydantic.v1.errors.DurationError(PydanticValueError)
pydantic.v1.errors.EmailError(PydanticValueError)
pydantic.v1.errors.EnumError(PydanticTypeError)
pydantic.v1.errors.EnumMemberError(PydanticTypeError)
pydantic.v1.errors.EnumMemberError.__str__(self)->str
pydantic.v1.errors.ExtraError(PydanticValueError)
pydantic.v1.errors.FloatError(PydanticTypeError)
pydantic.v1.errors.FrozenSetError(PydanticTypeError)
pydantic.v1.errors.FrozenSetMaxLengthError(self,*,limit_value:int)
pydantic.v1.errors.FrozenSetMinLengthError(self,*,limit_value:int)
pydantic.v1.errors.HashableError(PydanticTypeError)
pydantic.v1.errors.IPv4AddressError(PydanticValueError)
pydantic.v1.errors.IPv4InterfaceError(PydanticValueError)
pydantic.v1.errors.IPv4NetworkError(PydanticValueError)
pydantic.v1.errors.IPv6AddressError(PydanticValueError)
pydantic.v1.errors.IPv6InterfaceError(PydanticValueError)
pydantic.v1.errors.IPv6NetworkError(PydanticValueError)
pydantic.v1.errors.IPvAnyAddressError(PydanticValueError)
pydantic.v1.errors.IPvAnyInterfaceError(PydanticValueError)
pydantic.v1.errors.IPvAnyNetworkError(PydanticValueError)
pydantic.v1.errors.IntEnumError(PydanticTypeError)
pydantic.v1.errors.IntegerError(PydanticTypeError)
pydantic.v1.errors.InvalidByteSize(PydanticValueError)
pydantic.v1.errors.InvalidByteSizeUnit(PydanticValueError)
pydantic.v1.errors.InvalidDiscriminator(self,*,discriminator_key:str,discriminator_value:Any,allowed_values:Sequence[Any])
pydantic.v1.errors.InvalidLengthForBrand(PydanticValueError)
pydantic.v1.errors.IterableError(PydanticTypeError)
pydantic.v1.errors.JsonError(PydanticValueError)
pydantic.v1.errors.JsonTypeError(PydanticTypeError)
pydantic.v1.errors.ListError(PydanticTypeError)
pydantic.v1.errors.ListMaxLengthError(self,*,limit_value:int)
pydantic.v1.errors.ListMinLengthError(self,*,limit_value:int)
pydantic.v1.errors.ListUniqueItemsError(PydanticValueError)
pydantic.v1.errors.LuhnValidationError(PydanticValueError)
pydantic.v1.errors.MissingDiscriminator(PydanticValueError)
pydantic.v1.errors.MissingError(PydanticValueError)
pydantic.v1.errors.NoneIsAllowedError(PydanticTypeError)
pydantic.v1.errors.NoneIsNotAllowedError(PydanticTypeError)
pydantic.v1.errors.NotDigitError(PydanticValueError)
pydantic.v1.errors.NotNoneError(PydanticTypeError)
pydantic.v1.errors.NumberNotFiniteError(PydanticValueError)
pydantic.v1.errors.NumberNotGeError(_NumberBoundError)
pydantic.v1.errors.NumberNotGtError(_NumberBoundError)
pydantic.v1.errors.NumberNotLeError(_NumberBoundError)
pydantic.v1.errors.NumberNotLtError(_NumberBoundError)
pydantic.v1.errors.NumberNotMultipleError(self,*,multiple_of:Union[int,float,Decimal])
pydantic.v1.errors.PathError(PydanticTypeError)
pydantic.v1.errors.PathNotADirectoryError(_PathValueError)
pydantic.v1.errors.PathNotAFileError(_PathValueError)
pydantic.v1.errors.PathNotExistsError(_PathValueError)
pydantic.v1.errors.PatternError(PydanticValueError)
pydantic.v1.errors.PyObjectError(PydanticTypeError)
pydantic.v1.errors.PydanticErrorMixin(self,**ctx:Any)
pydantic.v1.errors.PydanticErrorMixin.__reduce__(self)->Tuple[Callable[..., 'PydanticErrorMixin'], Tuple[Type['PydanticErrorMixin'], 'DictStrAny']]
pydantic.v1.errors.PydanticErrorMixin.__str__(self)->str
pydantic.v1.errors.PydanticTypeError(PydanticErrorMixin,TypeError)
pydantic.v1.errors.PydanticValueError(PydanticErrorMixin,ValueError)
pydantic.v1.errors.SequenceError(PydanticTypeError)
pydantic.v1.errors.SetError(PydanticTypeError)
pydantic.v1.errors.SetMaxLengthError(self,*,limit_value:int)
pydantic.v1.errors.SetMinLengthError(self,*,limit_value:int)
pydantic.v1.errors.StrError(PydanticTypeError)
pydantic.v1.errors.StrRegexError(self,*,pattern:str)
pydantic.v1.errors.StrictBoolError(PydanticValueError)
pydantic.v1.errors.SubclassError(self,*,expected_class:Type[Any])
pydantic.v1.errors.TimeError(PydanticValueError)
pydantic.v1.errors.TupleError(PydanticTypeError)
pydantic.v1.errors.TupleLengthError(self,*,actual_length:int,expected_length:int)
pydantic.v1.errors.UUIDError(PydanticTypeError)
pydantic.v1.errors.UUIDVersionError(self,*,required_version:int)
pydantic.v1.errors.UrlError(PydanticValueError)
pydantic.v1.errors.UrlExtraError(UrlError)
pydantic.v1.errors.UrlHostError(UrlError)
pydantic.v1.errors.UrlHostTldError(UrlError)
pydantic.v1.errors.UrlPortError(UrlError)
pydantic.v1.errors.UrlSchemeError(UrlError)
pydantic.v1.errors.UrlSchemePermittedError(self,allowed_schemes:Set[str])
pydantic.v1.errors.UrlUserInfoError(UrlError)
pydantic.v1.errors.WrongConstantError(PydanticValueError)
pydantic.v1.errors.WrongConstantError.__str__(self)->str
pydantic.v1.errors._NumberBoundError(self,*,limit_value:Union[int,float,Decimal])
pydantic.v1.errors._PathValueError(self,*,path:Path)
pydantic.v1.errors.cls_kwargs(cls:Type['PydanticErrorMixin'],ctx:'DictStrAny')->'PydanticErrorMixin'


----------------------------------------/home/zhang/Packages/pydantic/pydantic2.0b1/v1/error_wrappers.py----------------------------------------
A:pydantic.v1.error_wrappers.self._error_cache->list(flatten_errors(self.raw_errors, config))
A:pydantic.v1.error_wrappers.errors->self.errors()
A:pydantic.v1.error_wrappers.no_errors->len(errors)
A:pydantic.v1.error_wrappers.ctx->error.get('ctx')
A:pydantic.v1.error_wrappers.error_loc->error.loc_tuple()
A:pydantic.v1.error_wrappers.type_->get_exc_type(exc.__class__)
A:pydantic.v1.error_wrappers.msg->str(exc)
A:pydantic.v1.error_wrappers.r->_get_exc_type(cls)
pydantic.v1.ValidationError(self,errors:Sequence[ErrorList],model:'ModelOrDc')
pydantic.v1.ValidationError.__repr_args__(self)->'ReprArgs'
pydantic.v1.ValidationError.__str__(self)->str
pydantic.v1.ValidationError.errors(self)->List['ErrorDict']
pydantic.v1.ValidationError.json(self,*,indent:Union[None,int,str]=2)->str
pydantic.v1.error_wrappers.ErrorWrapper(self,exc:Exception,loc:Union[str,'Loc'])
pydantic.v1.error_wrappers.ErrorWrapper.__repr_args__(self)->'ReprArgs'
pydantic.v1.error_wrappers.ErrorWrapper.loc_tuple(self)->'Loc'
pydantic.v1.error_wrappers.ValidationError(self,errors:Sequence[ErrorList],model:'ModelOrDc')
pydantic.v1.error_wrappers.ValidationError.__repr_args__(self)->'ReprArgs'
pydantic.v1.error_wrappers.ValidationError.__str__(self)->str
pydantic.v1.error_wrappers.ValidationError.errors(self)->List['ErrorDict']
pydantic.v1.error_wrappers.ValidationError.json(self,*,indent:Union[None,int,str]=2)->str
pydantic.v1.error_wrappers._display_error_loc(error:'ErrorDict')->str
pydantic.v1.error_wrappers._display_error_type_and_ctx(error:'ErrorDict')->str
pydantic.v1.error_wrappers._get_exc_type(cls:Type[Exception])->str
pydantic.v1.error_wrappers.display_errors(errors:List['ErrorDict'])->str
pydantic.v1.error_wrappers.error_dict(exc:Exception,config:Type['BaseConfig'],loc:'Loc')->'ErrorDict'
pydantic.v1.error_wrappers.flatten_errors(errors:Sequence[Any],config:Type['BaseConfig'],loc:Optional['Loc']=None)->Generator['ErrorDict', None, None]
pydantic.v1.error_wrappers.get_exc_type(cls:Type[Exception])->str


----------------------------------------/home/zhang/Packages/pydantic/pydantic2.0b1/v1/main.py----------------------------------------
A:pydantic.v1.main.Model->TypeVar('Model', bound='BaseModel')
A:pydantic.v1.main._T->TypeVar('_T')
A:pydantic.v1.main.config->inherit_config(config_from_namespace, config, **config_kwargs)
A:pydantic.v1.main.validators->inherit_validators(extract_validators(namespace), validators)
A:pydantic.v1.main.resolve_forward_refs->kwargs.pop('__resolve_forward_refs__', True)
A:pydantic.v1.main.config_from_namespace->namespace.get('Config')
A:pydantic.v1.main.vg->ValidatorGroup(validators)
A:pydantic.v1.main.extra_validators->ValidatorGroup(validators).get_validators(f.name)
A:pydantic.v1.main.annotations->resolve_annotations(namespace.get('__annotations__', {}), namespace.get('__module__', None))
A:pydantic.v1.main.value->field.get_default()
A:pydantic.v1.main.fields[ann_name]->fields.ModelField.infer(name=ann_name, value=value, annotation=ann_type, class_validators=vg.get_validators(ann_name), config=config)
A:pydantic.v1.main.private_attributes[ann_name]->PrivateAttr()
A:pydantic.v1.main.private_attributes[var_name]->PrivateAttr(default=value)
A:pydantic.v1.main.inferred->fields.ModelField.infer(name=var_name, value=value, annotation=annotations.get(var_name, Undefined), class_validators=vg.get_validators(var_name), config=config)
A:pydantic.v1.main.json_encoder->partial(custom_pydantic_encoder, config.json_encoders)
A:pydantic.v1.main.(pre_rv_new, post_rv_new)->extract_root_validators(namespace)
A:pydantic.v1.main.hash_func->generate_hash_function(config.frozen)
A:pydantic.v1.main.cls->super().__new__(mcs, name, bases, new_namespace, **kwargs)
A:pydantic.v1.main.cls.__signature__->ClassAttribute('__signature__', generate_model_signature(cls.__init__, fields, config))
A:pydantic.v1.main.set_name->getattr(obj, '__set_name__', None)
A:pydantic.v1.main.(values, fields_set, validation_error)->validate_model(cls, obj)
A:pydantic.v1.main.new_values->validator(self.__class__, new_values)
A:pydantic.v1.main.known_field->self.__fields__.get(name, None)
A:pydantic.v1.main.(value, error_)->self.__fields__.get(name, None).validate(value, dict_without_original_value, loc=name, cls=self.__class__)
A:pydantic.v1.main.default->private_attr.get_default()
A:pydantic.v1.main.encoder->cast(Callable[[Any], Any], encoder or self.__json_encoder__)
A:pydantic.v1.main.data->dict(self._iter(to_dict=models_as_dict, by_alias=by_alias, include=include, exclude=exclude, exclude_unset=exclude_unset, exclude_defaults=exclude_defaults, exclude_none=exclude_none))
A:pydantic.v1.main.obj->load_file(path, proto=proto, content_type=content_type, encoding=encoding, allow_pickle=allow_pickle, json_loads=cls.__config__.json_loads)
A:pydantic.v1.main.exc->TypeError(f'{cls.__name__} expected dict not {obj.__class__.__name__}')
A:pydantic.v1.main.m->super().__new__(mcs, name, bases, new_namespace, **kwargs).__new__(cls)
A:pydantic.v1.main.fields_values[name]->field.get_default()
A:pydantic.v1.main._fields_set->set(values.keys())
A:pydantic.v1.main.values->validator(cls_, values)
A:pydantic.v1.main.fields_set->set()
A:pydantic.v1.main.cached->super().__new__(mcs, name, bases, new_namespace, **kwargs).__schema_cache__.get((by_alias, ref_template))
A:pydantic.v1.main.s->model_schema(cls, by_alias=by_alias, ref_template=ref_template)
A:pydantic.v1.main.value_as_dict->dict(value)
A:pydantic.v1.main.v_dict->self._get_value(v, to_dict=to_dict, by_alias=by_alias, include=value_include and value_include.for_element(field_key), exclude=value_exclude and value_exclude.for_element(field_key), exclude_unset=exclude_unset, exclude_defaults=exclude_defaults, exclude_none=exclude_none).dict(by_alias=by_alias, exclude_unset=exclude_unset, exclude_defaults=exclude_defaults, include=include, exclude=exclude, exclude_none=exclude_none)
A:pydantic.v1.main.exclude->utils.ValueItems.merge(self.__exclude_fields__, exclude)
A:pydantic.v1.main.include->utils.ValueItems.merge(self.__include_fields__, include, intersect=True)
A:pydantic.v1.main.allowed_keys->self._calculate_keys(include=include, exclude=exclude, exclude_unset=exclude_unset)
A:pydantic.v1.main.model_field->self.__fields__.get(field_key)
A:pydantic.v1.main.v->self._get_value(v, to_dict=to_dict, by_alias=by_alias, include=value_include and value_include.for_element(field_key), exclude=value_exclude and value_exclude.for_element(field_key), exclude_unset=exclude_unset, exclude_defaults=exclude_defaults, exclude_none=exclude_none)
A:pydantic.v1.main.keys->self.__dict__.keys()
A:pydantic.v1.main.namespace['Config']->inherit_config(__config__, BaseConfig)
A:pydantic.v1.main.resolved_bases->resolve_bases(__base__)
A:pydantic.v1.main.(meta, ns, kwds)->prepare_class(__model_name, resolved_bases, kwds=__cls_kwargs__)
A:pydantic.v1.main._missing->object()
A:pydantic.v1.main.names_used->set()
A:pydantic.v1.main.input_data->validator(cls_, input_data)
A:pydantic.v1.main.(v_, errors_)->field.validate(value, values, loc=field.alias, cls=cls_)
pydantic.v1.BaseModel(__pydantic_self__,**data:Any)
pydantic.v1.BaseModel.__eq__(self,other:Any)->bool
pydantic.v1.BaseModel.__get_validators__(cls)->'CallableGenerator'
pydantic.v1.BaseModel.__getstate__(self)->'DictAny'
pydantic.v1.BaseModel.__iter__(self)->'TupleGenerator'
pydantic.v1.BaseModel.__repr_args__(self)->'ReprArgs'
pydantic.v1.BaseModel.__setattr__(self,name,value)
pydantic.v1.BaseModel.__setstate__(self,state:'DictAny')->None
pydantic.v1.BaseModel.__try_update_forward_refs__(cls,**localns:Any)->None
pydantic.v1.BaseModel._calculate_keys(self,include:Optional['MappingIntStrAny'],exclude:Optional['MappingIntStrAny'],exclude_unset:bool,update:Optional['DictStrAny']=None)->Optional[AbstractSet[str]]
pydantic.v1.BaseModel._copy_and_set_values(self:'Model',values:'DictStrAny',fields_set:'SetStr',*,deep:bool)->'Model'
pydantic.v1.BaseModel._decompose_class(cls:Type['Model'],obj:Any)->GetterDict
pydantic.v1.BaseModel._enforce_dict_if_root(cls,obj:Any)->Any
pydantic.v1.BaseModel._get_value(cls,v:Any,to_dict:bool,by_alias:bool,include:Optional[Union['AbstractSetIntStr','MappingIntStrAny']],exclude:Optional[Union['AbstractSetIntStr','MappingIntStrAny']],exclude_unset:bool,exclude_defaults:bool,exclude_none:bool)->Any
pydantic.v1.BaseModel._init_private_attributes(self)->None
pydantic.v1.BaseModel._iter(self,to_dict:bool=False,by_alias:bool=False,include:Optional[Union['AbstractSetIntStr','MappingIntStrAny']]=None,exclude:Optional[Union['AbstractSetIntStr','MappingIntStrAny']]=None,exclude_unset:bool=False,exclude_defaults:bool=False,exclude_none:bool=False)->'TupleGenerator'
pydantic.v1.BaseModel.construct(cls:Type['Model'],_fields_set:Optional['SetStr']=None,**values:Any)->'Model'
pydantic.v1.BaseModel.copy(self:'Model',*,include:Optional[Union['AbstractSetIntStr','MappingIntStrAny']]=None,exclude:Optional[Union['AbstractSetIntStr','MappingIntStrAny']]=None,update:Optional['DictStrAny']=None,deep:bool=False)->'Model'
pydantic.v1.BaseModel.dict(self,*,include:Optional[Union['AbstractSetIntStr','MappingIntStrAny']]=None,exclude:Optional[Union['AbstractSetIntStr','MappingIntStrAny']]=None,by_alias:bool=False,skip_defaults:Optional[bool]=None,exclude_unset:bool=False,exclude_defaults:bool=False,exclude_none:bool=False)->'DictStrAny'
pydantic.v1.BaseModel.from_orm(cls:Type['Model'],obj:Any)->'Model'
pydantic.v1.BaseModel.json(self,*,include:Optional[Union['AbstractSetIntStr','MappingIntStrAny']]=None,exclude:Optional[Union['AbstractSetIntStr','MappingIntStrAny']]=None,by_alias:bool=False,skip_defaults:Optional[bool]=None,exclude_unset:bool=False,exclude_defaults:bool=False,exclude_none:bool=False,encoder:Optional[Callable[[Any],Any]]=None,models_as_dict:bool=True,**dumps_kwargs:Any)->str
pydantic.v1.BaseModel.parse_file(cls:Type['Model'],path:Union[str,Path],*,content_type:str=None,encoding:str='utf8',proto:Protocol=None,allow_pickle:bool=False)->'Model'
pydantic.v1.BaseModel.parse_obj(cls:Type['Model'],obj:Any)->'Model'
pydantic.v1.BaseModel.parse_raw(cls:Type['Model'],b:StrBytes,*,content_type:str=None,encoding:str='utf8',proto:Protocol=None,allow_pickle:bool=False)->'Model'
pydantic.v1.BaseModel.schema(cls,by_alias:bool=True,ref_template:str=default_ref_template)->'DictStrAny'
pydantic.v1.BaseModel.schema_json(cls,*,by_alias:bool=True,ref_template:str=default_ref_template,**dumps_kwargs:Any)->str
pydantic.v1.BaseModel.update_forward_refs(cls,**localns:Any)->None
pydantic.v1.BaseModel.validate(cls:Type['Model'],value:Any)->'Model'
pydantic.v1.ModelMetaclass(mcs,name,bases,namespace,**kwargs)
pydantic.v1.ModelMetaclass.__instancecheck__(self,instance:Any)->bool
pydantic.v1.create_model(__model_name:str,*,__config__:Optional[Type[BaseConfig]]=None,__base__:None=None,__module__:str=__name__,__validators__:Dict[str,'AnyClassMethod']=None,__cls_kwargs__:Dict[str,Any]=None,**field_definitions:Any)->Type['BaseModel']
pydantic.v1.create_model(__model_name:str,*,__config__:Optional[Type[BaseConfig]]=None,__base__:Union[None,Type['Model'],Tuple[Type['Model'],...]]=None,__module__:str=__name__,__validators__:Dict[str,'AnyClassMethod']=None,__cls_kwargs__:Dict[str,Any]=None,__slots__:Optional[Tuple[str,...]]=None,**field_definitions:Any)->Type['Model']
pydantic.v1.create_model(__model_name:str,*,__config__:Optional[Type[BaseConfig]]=None,__base__:Union[Type['Model'],Tuple[Type['Model'],...]],__module__:str=__name__,__validators__:Dict[str,'AnyClassMethod']=None,__cls_kwargs__:Dict[str,Any]=None,**field_definitions:Any)->Type['Model']
pydantic.v1.generate_hash_function(frozen:bool)->Optional[Callable[[Any], int]]
pydantic.v1.main.BaseModel(__pydantic_self__,**data:Any)
pydantic.v1.main.BaseModel.__eq__(self,other:Any)->bool
pydantic.v1.main.BaseModel.__get_validators__(cls)->'CallableGenerator'
pydantic.v1.main.BaseModel.__getstate__(self)->'DictAny'
pydantic.v1.main.BaseModel.__iter__(self)->'TupleGenerator'
pydantic.v1.main.BaseModel.__repr_args__(self)->'ReprArgs'
pydantic.v1.main.BaseModel.__setattr__(self,name,value)
pydantic.v1.main.BaseModel.__setstate__(self,state:'DictAny')->None
pydantic.v1.main.BaseModel.__try_update_forward_refs__(cls,**localns:Any)->None
pydantic.v1.main.BaseModel._calculate_keys(self,include:Optional['MappingIntStrAny'],exclude:Optional['MappingIntStrAny'],exclude_unset:bool,update:Optional['DictStrAny']=None)->Optional[AbstractSet[str]]
pydantic.v1.main.BaseModel._copy_and_set_values(self:'Model',values:'DictStrAny',fields_set:'SetStr',*,deep:bool)->'Model'
pydantic.v1.main.BaseModel._decompose_class(cls:Type['Model'],obj:Any)->GetterDict
pydantic.v1.main.BaseModel._enforce_dict_if_root(cls,obj:Any)->Any
pydantic.v1.main.BaseModel._get_value(cls,v:Any,to_dict:bool,by_alias:bool,include:Optional[Union['AbstractSetIntStr','MappingIntStrAny']],exclude:Optional[Union['AbstractSetIntStr','MappingIntStrAny']],exclude_unset:bool,exclude_defaults:bool,exclude_none:bool)->Any
pydantic.v1.main.BaseModel._init_private_attributes(self)->None
pydantic.v1.main.BaseModel._iter(self,to_dict:bool=False,by_alias:bool=False,include:Optional[Union['AbstractSetIntStr','MappingIntStrAny']]=None,exclude:Optional[Union['AbstractSetIntStr','MappingIntStrAny']]=None,exclude_unset:bool=False,exclude_defaults:bool=False,exclude_none:bool=False)->'TupleGenerator'
pydantic.v1.main.BaseModel.construct(cls:Type['Model'],_fields_set:Optional['SetStr']=None,**values:Any)->'Model'
pydantic.v1.main.BaseModel.copy(self:'Model',*,include:Optional[Union['AbstractSetIntStr','MappingIntStrAny']]=None,exclude:Optional[Union['AbstractSetIntStr','MappingIntStrAny']]=None,update:Optional['DictStrAny']=None,deep:bool=False)->'Model'
pydantic.v1.main.BaseModel.dict(self,*,include:Optional[Union['AbstractSetIntStr','MappingIntStrAny']]=None,exclude:Optional[Union['AbstractSetIntStr','MappingIntStrAny']]=None,by_alias:bool=False,skip_defaults:Optional[bool]=None,exclude_unset:bool=False,exclude_defaults:bool=False,exclude_none:bool=False)->'DictStrAny'
pydantic.v1.main.BaseModel.from_orm(cls:Type['Model'],obj:Any)->'Model'
pydantic.v1.main.BaseModel.json(self,*,include:Optional[Union['AbstractSetIntStr','MappingIntStrAny']]=None,exclude:Optional[Union['AbstractSetIntStr','MappingIntStrAny']]=None,by_alias:bool=False,skip_defaults:Optional[bool]=None,exclude_unset:bool=False,exclude_defaults:bool=False,exclude_none:bool=False,encoder:Optional[Callable[[Any],Any]]=None,models_as_dict:bool=True,**dumps_kwargs:Any)->str
pydantic.v1.main.BaseModel.parse_file(cls:Type['Model'],path:Union[str,Path],*,content_type:str=None,encoding:str='utf8',proto:Protocol=None,allow_pickle:bool=False)->'Model'
pydantic.v1.main.BaseModel.parse_obj(cls:Type['Model'],obj:Any)->'Model'
pydantic.v1.main.BaseModel.parse_raw(cls:Type['Model'],b:StrBytes,*,content_type:str=None,encoding:str='utf8',proto:Protocol=None,allow_pickle:bool=False)->'Model'
pydantic.v1.main.BaseModel.schema(cls,by_alias:bool=True,ref_template:str=default_ref_template)->'DictStrAny'
pydantic.v1.main.BaseModel.schema_json(cls,*,by_alias:bool=True,ref_template:str=default_ref_template,**dumps_kwargs:Any)->str
pydantic.v1.main.BaseModel.update_forward_refs(cls,**localns:Any)->None
pydantic.v1.main.BaseModel.validate(cls:Type['Model'],value:Any)->'Model'
pydantic.v1.main.ModelMetaclass(mcs,name,bases,namespace,**kwargs)
pydantic.v1.main.ModelMetaclass.__instancecheck__(self,instance:Any)->bool
pydantic.v1.main.create_model(__model_name:str,*,__config__:Optional[Type[BaseConfig]]=None,__base__:None=None,__module__:str=__name__,__validators__:Dict[str,'AnyClassMethod']=None,__cls_kwargs__:Dict[str,Any]=None,**field_definitions:Any)->Type['BaseModel']
pydantic.v1.main.create_model(__model_name:str,*,__config__:Optional[Type[BaseConfig]]=None,__base__:Union[None,Type['Model'],Tuple[Type['Model'],...]]=None,__module__:str=__name__,__validators__:Dict[str,'AnyClassMethod']=None,__cls_kwargs__:Dict[str,Any]=None,__slots__:Optional[Tuple[str,...]]=None,**field_definitions:Any)->Type['Model']
pydantic.v1.main.create_model(__model_name:str,*,__config__:Optional[Type[BaseConfig]]=None,__base__:Union[Type['Model'],Tuple[Type['Model'],...]],__module__:str=__name__,__validators__:Dict[str,'AnyClassMethod']=None,__cls_kwargs__:Dict[str,Any]=None,**field_definitions:Any)->Type['Model']
pydantic.v1.main.generate_hash_function(frozen:bool)->Optional[Callable[[Any], int]]
pydantic.v1.main.validate_custom_root_type(fields:Dict[str,ModelField])->None
pydantic.v1.main.validate_model(model:Type[BaseModel],input_data:'DictStrAny',cls:'ModelOrDc'=None)->Tuple['DictStrAny', 'SetStr', Optional[ValidationError]]
pydantic.v1.validate_custom_root_type(fields:Dict[str,ModelField])->None
pydantic.v1.validate_model(model:Type[BaseModel],input_data:'DictStrAny',cls:'ModelOrDc'=None)->Tuple['DictStrAny', 'SetStr', Optional[ValidationError]]


----------------------------------------/home/zhang/Packages/pydantic/pydantic2.0b1/v1/typing.py----------------------------------------
A:pydantic.v1.typing._T->TypeVar('_T')
A:pydantic.v1.typing.origin->get_origin(tp)
A:pydantic.v1.typing.args->get_args(type_)
A:pydantic.v1.typing.converted->tuple((ForwardRef(arg) if isinstance(arg, str) and isinstance(tp, TypingGenericAlias) else convert_generics(arg) for arg in args))
A:pydantic.v1.typing.value->_eval_type(value, base_globals, None)
A:pydantic.v1.typing.values->literal_values(type_)
A:pydantic.v1.typing.test_type->NewType('test_type', str)
A:pydantic.v1.typing.field.type_->evaluate_forwardref(field.type_, globalns, localns or None)
A:pydantic.v1.typing.field.outer_type_->evaluate_forwardref(field.outer_type_, globalns, localns or None)
A:pydantic.v1.typing.globalns->sys.modules[model.__module__].__dict__.copy()
A:pydantic.v1.typing.new_key->evaluate_forwardref(fr, globalns, localns or None)
A:pydantic.v1.typing.json_encoders[new_key]->json_encoders.pop(key)
pydantic.v1.typing._check_classvar(v:Optional[Type[Any]])->bool
pydantic.v1.typing._check_finalvar(v:Optional[Type[Any]])->bool
pydantic.v1.typing._check_typeddict_special(type_:Any)->bool
pydantic.v1.typing.all_literal_values(type_:Type[Any])->Tuple[Any, ...]
pydantic.v1.typing.display_as_type(v:Type[Any])->str
pydantic.v1.typing.get_class(type_:Type[Any])->Union[None, bool, Type[Any]]
pydantic.v1.typing.get_sub_types(tp:Any)->List[Any]
pydantic.v1.typing.is_callable_type(type_:Type[Any])->bool
pydantic.v1.typing.is_classvar(ann_type:Type[Any])->bool
pydantic.v1.typing.is_finalvar(ann_type:Type[Any])->bool
pydantic.v1.typing.is_literal_type(type_:Type[Any])->bool
pydantic.v1.typing.is_namedtuple(type_:Type[Any])->bool
pydantic.v1.typing.is_new_type(type_:Type[Any])->bool
pydantic.v1.typing.is_typeddict(type_:Type[Any])->bool
pydantic.v1.typing.is_typeddict_special(type_:Any)->bool
pydantic.v1.typing.literal_values(type_:Type[Any])->Tuple[Any, ...]
pydantic.v1.typing.new_type_supertype(type_:Type[Any])->Type[Any]
pydantic.v1.typing.resolve_annotations(raw_annotations:Dict[str,Type[Any]],module_name:Optional[str])->Dict[str, Type[Any]]
pydantic.v1.typing.update_field_forward_refs(field:'ModelField',globalns:Any,localns:Any)->None
pydantic.v1.typing.update_model_forward_refs(model:Type[Any],fields:Iterable['ModelField'],json_encoders:Dict[Union[Type[Any],str,ForwardRef],AnyCallable],localns:'DictStrAny',exc_to_suppress:Tuple[Type[BaseException],...]=())->None


----------------------------------------/home/zhang/Packages/pydantic/pydantic2.0b1/v1/config.py----------------------------------------
A:pydantic.v1.config.fields_value->cls.fields.get(name)
A:pydantic.v1.config.alias->cls.alias_generator(name)
A:pydantic.v1.config.config.extra->Extra(config.extra)
pydantic.v1.BaseConfig
pydantic.v1.BaseConfig.get_field_info(cls,name:str)->Dict[str, Any]
pydantic.v1.BaseConfig.prepare_field(cls,field:'ModelField')->None
pydantic.v1.Extra(str,Enum)
pydantic.v1.config.BaseConfig
pydantic.v1.config.BaseConfig.get_field_info(cls,name:str)->Dict[str, Any]
pydantic.v1.config.BaseConfig.prepare_field(cls,field:'ModelField')->None
pydantic.v1.config.Extra(str,Enum)
pydantic.v1.config.get_config(config:Union[ConfigDict,Type[object],None])->Type[BaseConfig]
pydantic.v1.config.inherit_config(self_config:'ConfigType',parent_config:'ConfigType',**namespace:Any)->'ConfigType'
pydantic.v1.config.prepare_config(config:Type[BaseConfig],cls_name:str)->None


----------------------------------------/home/zhang/Packages/pydantic/pydantic2.0b1/v1/networks.py----------------------------------------
A:pydantic.v1.networks._url_regex_cache->re.compile(f'{_scheme_regex}{_user_info_regex}{_host_regex}{_path_regex}{_query_regex}{_fragment_regex}', re.IGNORECASE)
A:pydantic.v1.networks._multi_host_url_regex_cache->re.compile(f'{_scheme_regex}{_user_info_regex}(?P<hosts>([^/]*)){_path_regex}{_query_regex}{_fragment_regex}', re.IGNORECASE)
A:pydantic.v1.networks._ascii_domain_regex_cache->re.compile(f'(?:{ascii_chunk}\\.)*?{ascii_chunk}{ascii_domain_ending}', re.IGNORECASE)
A:pydantic.v1.networks._int_domain_regex_cache->re.compile(f'(?:{int_chunk}\\.)*?{int_chunk}{int_domain_ending}', re.IGNORECASE)
A:pydantic.v1.networks._host_regex_cache->re.compile(_host_regex, re.IGNORECASE)
A:pydantic.v1.networks.parts->email_validator.validate_email(email, check_deliverability=False)
A:pydantic.v1.networks.value->str_validator(value)
A:pydantic.v1.networks.m->re.compile('([\\w ]*?) *<(.*)> *').fullmatch(value)
A:pydantic.v1.networks.original_parts->cast('Parts', m.groupdict())
A:pydantic.v1.networks.(host, tld, host_type, rebuild)->cls.validate_host(d)
A:pydantic.v1.networks.d->int_domain_regex().fullmatch(host)
A:pydantic.v1.networks.tld->tld.encode('idna').decode('ascii').encode('idna').decode('ascii')
A:pydantic.v1.networks.host->host.encode('idna').decode('ascii').encode('idna').decode('ascii')
A:pydantic.v1.networks.extra->', '.join((f'{n}={getattr(self, n)!r}' for n in self.__slots__ if getattr(self, n) is not None))
A:pydantic.v1.networks.host_re->host_regex()
A:pydantic.v1.networks.port->int_domain_regex().fullmatch(host).get('port')
A:pydantic.v1.networks.namespace->dict(strip_whitespace=strip_whitespace, min_length=min_length, max_length=max_length, tld_required=tld_required, host_required=host_required, allowed_schemes=allowed_schemes)
A:pydantic.v1.networks.pretty_email_regex->re.compile('([\\w ]*?) *<(.*)> *')
A:pydantic.v1.networks.(name, value)->re.compile('([\\w ]*?) *<(.*)> *').fullmatch(value).groups()
A:pydantic.v1.networks.email->str_validator(value).strip()
A:pydantic.v1.networks.at_index->str_validator(value).strip().index('@')
A:pydantic.v1.networks.global_part->email[at_index:].lower()
pydantic.v1.AmqpDsn(AnyUrl)
pydantic.v1.AnyHttpUrl(AnyUrl)
pydantic.v1.AnyUrl(self,url:str,*,scheme:str,user:Optional[str]=None,password:Optional[str]=None,host:Optional[str]=None,tld:Optional[str]=None,host_type:str='domain',port:Optional[str]=None,path:Optional[str]=None,query:Optional[str]=None,fragment:Optional[str]=None)
pydantic.v1.AnyUrl.__get_validators__(cls)->'CallableGenerator'
pydantic.v1.AnyUrl.__modify_schema__(cls,field_schema:Dict[str,Any])->None
pydantic.v1.AnyUrl.__repr__(self)->str
pydantic.v1.AnyUrl._build_url(cls,m:Match[str],url:str,parts:'Parts')->'AnyUrl'
pydantic.v1.AnyUrl._match_url(url:str)->Optional[Match[str]]
pydantic.v1.AnyUrl._validate_port(port:Optional[str])->None
pydantic.v1.AnyUrl.apply_default_parts(cls,parts:'Parts')->'Parts'
pydantic.v1.AnyUrl.build(cls,*,scheme:str,user:Optional[str]=None,password:Optional[str]=None,host:str,port:Optional[str]=None,path:Optional[str]=None,query:Optional[str]=None,fragment:Optional[str]=None,**_kwargs:str)->str
pydantic.v1.AnyUrl.get_default_parts(parts:'Parts')->'Parts'
pydantic.v1.AnyUrl.validate(cls,value:Any,field:'ModelField',config:'BaseConfig')->'AnyUrl'
pydantic.v1.AnyUrl.validate_host(cls,parts:'Parts')->Tuple[str, Optional[str], str, bool]
pydantic.v1.AnyUrl.validate_parts(cls,parts:'Parts',validate_port:bool=True)->'Parts'
pydantic.v1.CockroachDsn(AnyUrl)
pydantic.v1.EmailStr(str)
pydantic.v1.EmailStr.__get_validators__(cls)->'CallableGenerator'
pydantic.v1.EmailStr.__modify_schema__(cls,field_schema:Dict[str,Any])->None
pydantic.v1.EmailStr.validate(cls,value:Union[str])->str
pydantic.v1.FileUrl(AnyUrl)
pydantic.v1.HttpUrl(AnyHttpUrl)
pydantic.v1.HttpUrl.get_default_parts(parts:'Parts')->'Parts'
pydantic.v1.IPvAnyAddress(_BaseAddress)
pydantic.v1.IPvAnyAddress.__get_validators__(cls)->'CallableGenerator'
pydantic.v1.IPvAnyAddress.__modify_schema__(cls,field_schema:Dict[str,Any])->None
pydantic.v1.IPvAnyAddress.validate(cls,value:Union[str,bytes,int])->Union[IPv4Address, IPv6Address]
pydantic.v1.IPvAnyInterface(_BaseAddress)
pydantic.v1.IPvAnyInterface.__get_validators__(cls)->'CallableGenerator'
pydantic.v1.IPvAnyInterface.__modify_schema__(cls,field_schema:Dict[str,Any])->None
pydantic.v1.IPvAnyInterface.validate(cls,value:NetworkType)->Union[IPv4Interface, IPv6Interface]
pydantic.v1.IPvAnyNetwork(_BaseNetwork)
pydantic.v1.IPvAnyNetwork.__get_validators__(cls)->'CallableGenerator'
pydantic.v1.IPvAnyNetwork.__modify_schema__(cls,field_schema:Dict[str,Any])->None
pydantic.v1.IPvAnyNetwork.validate(cls,value:NetworkType)->Union[IPv4Network, IPv6Network]
pydantic.v1.KafkaDsn(AnyUrl)
pydantic.v1.KafkaDsn.get_default_parts(parts:'Parts')->'Parts'
pydantic.v1.MongoDsn(AnyUrl)
pydantic.v1.MongoDsn.get_default_parts(parts:'Parts')->'Parts'
pydantic.v1.MultiHostDsn(self,*args:Any,hosts:Optional[List['HostParts']]=None,**kwargs:Any)
pydantic.v1.MultiHostDsn._build_url(cls,m:Match[str],url:str,parts:'Parts')->'MultiHostDsn'
pydantic.v1.MultiHostDsn._match_url(url:str)->Optional[Match[str]]
pydantic.v1.MultiHostDsn.validate_parts(cls,parts:'Parts',validate_port:bool=True)->'Parts'
pydantic.v1.NameEmail(self,name:str,email:str)
pydantic.v1.NameEmail.__eq__(self,other:Any)->bool
pydantic.v1.NameEmail.__get_validators__(cls)->'CallableGenerator'
pydantic.v1.NameEmail.__modify_schema__(cls,field_schema:Dict[str,Any])->None
pydantic.v1.NameEmail.__str__(self)->str
pydantic.v1.NameEmail.validate(cls,value:Any)->'NameEmail'
pydantic.v1.PostgresDsn(MultiHostDsn)
pydantic.v1.RedisDsn(AnyUrl)
pydantic.v1.RedisDsn.get_default_parts(parts:'Parts')->'Parts'
pydantic.v1.ascii_domain_regex()->Pattern[str]
pydantic.v1.host_regex()->Pattern[str]
pydantic.v1.import_email_validator()->None
pydantic.v1.int_domain_regex()->Pattern[str]
pydantic.v1.multi_host_url_regex()->Pattern[str]
pydantic.v1.networks.AmqpDsn(AnyUrl)
pydantic.v1.networks.AnyHttpUrl(AnyUrl)
pydantic.v1.networks.AnyUrl(self,url:str,*,scheme:str,user:Optional[str]=None,password:Optional[str]=None,host:Optional[str]=None,tld:Optional[str]=None,host_type:str='domain',port:Optional[str]=None,path:Optional[str]=None,query:Optional[str]=None,fragment:Optional[str]=None)
pydantic.v1.networks.AnyUrl.__get_validators__(cls)->'CallableGenerator'
pydantic.v1.networks.AnyUrl.__modify_schema__(cls,field_schema:Dict[str,Any])->None
pydantic.v1.networks.AnyUrl.__repr__(self)->str
pydantic.v1.networks.AnyUrl._build_url(cls,m:Match[str],url:str,parts:'Parts')->'AnyUrl'
pydantic.v1.networks.AnyUrl._match_url(url:str)->Optional[Match[str]]
pydantic.v1.networks.AnyUrl._validate_port(port:Optional[str])->None
pydantic.v1.networks.AnyUrl.apply_default_parts(cls,parts:'Parts')->'Parts'
pydantic.v1.networks.AnyUrl.build(cls,*,scheme:str,user:Optional[str]=None,password:Optional[str]=None,host:str,port:Optional[str]=None,path:Optional[str]=None,query:Optional[str]=None,fragment:Optional[str]=None,**_kwargs:str)->str
pydantic.v1.networks.AnyUrl.get_default_parts(parts:'Parts')->'Parts'
pydantic.v1.networks.AnyUrl.validate(cls,value:Any,field:'ModelField',config:'BaseConfig')->'AnyUrl'
pydantic.v1.networks.AnyUrl.validate_host(cls,parts:'Parts')->Tuple[str, Optional[str], str, bool]
pydantic.v1.networks.AnyUrl.validate_parts(cls,parts:'Parts',validate_port:bool=True)->'Parts'
pydantic.v1.networks.CockroachDsn(AnyUrl)
pydantic.v1.networks.EmailStr(str)
pydantic.v1.networks.EmailStr.__get_validators__(cls)->'CallableGenerator'
pydantic.v1.networks.EmailStr.__modify_schema__(cls,field_schema:Dict[str,Any])->None
pydantic.v1.networks.EmailStr.validate(cls,value:Union[str])->str
pydantic.v1.networks.FileUrl(AnyUrl)
pydantic.v1.networks.HttpUrl(AnyHttpUrl)
pydantic.v1.networks.HttpUrl.get_default_parts(parts:'Parts')->'Parts'
pydantic.v1.networks.IPvAnyAddress(_BaseAddress)
pydantic.v1.networks.IPvAnyAddress.__get_validators__(cls)->'CallableGenerator'
pydantic.v1.networks.IPvAnyAddress.__modify_schema__(cls,field_schema:Dict[str,Any])->None
pydantic.v1.networks.IPvAnyAddress.validate(cls,value:Union[str,bytes,int])->Union[IPv4Address, IPv6Address]
pydantic.v1.networks.IPvAnyInterface(_BaseAddress)
pydantic.v1.networks.IPvAnyInterface.__get_validators__(cls)->'CallableGenerator'
pydantic.v1.networks.IPvAnyInterface.__modify_schema__(cls,field_schema:Dict[str,Any])->None
pydantic.v1.networks.IPvAnyInterface.validate(cls,value:NetworkType)->Union[IPv4Interface, IPv6Interface]
pydantic.v1.networks.IPvAnyNetwork(_BaseNetwork)
pydantic.v1.networks.IPvAnyNetwork.__get_validators__(cls)->'CallableGenerator'
pydantic.v1.networks.IPvAnyNetwork.__modify_schema__(cls,field_schema:Dict[str,Any])->None
pydantic.v1.networks.IPvAnyNetwork.validate(cls,value:NetworkType)->Union[IPv4Network, IPv6Network]
pydantic.v1.networks.KafkaDsn(AnyUrl)
pydantic.v1.networks.KafkaDsn.get_default_parts(parts:'Parts')->'Parts'
pydantic.v1.networks.MongoDsn(AnyUrl)
pydantic.v1.networks.MongoDsn.get_default_parts(parts:'Parts')->'Parts'
pydantic.v1.networks.MultiHostDsn(self,*args:Any,hosts:Optional[List['HostParts']]=None,**kwargs:Any)
pydantic.v1.networks.MultiHostDsn._build_url(cls,m:Match[str],url:str,parts:'Parts')->'MultiHostDsn'
pydantic.v1.networks.MultiHostDsn._match_url(url:str)->Optional[Match[str]]
pydantic.v1.networks.MultiHostDsn.validate_parts(cls,parts:'Parts',validate_port:bool=True)->'Parts'
pydantic.v1.networks.NameEmail(self,name:str,email:str)
pydantic.v1.networks.NameEmail.__eq__(self,other:Any)->bool
pydantic.v1.networks.NameEmail.__get_validators__(cls)->'CallableGenerator'
pydantic.v1.networks.NameEmail.__modify_schema__(cls,field_schema:Dict[str,Any])->None
pydantic.v1.networks.NameEmail.__str__(self)->str
pydantic.v1.networks.NameEmail.validate(cls,value:Any)->'NameEmail'
pydantic.v1.networks.PostgresDsn(MultiHostDsn)
pydantic.v1.networks.RedisDsn(AnyUrl)
pydantic.v1.networks.RedisDsn.get_default_parts(parts:'Parts')->'Parts'
pydantic.v1.networks.ascii_domain_regex()->Pattern[str]
pydantic.v1.networks.host_regex()->Pattern[str]
pydantic.v1.networks.import_email_validator()->None
pydantic.v1.networks.int_domain_regex()->Pattern[str]
pydantic.v1.networks.multi_host_url_regex()->Pattern[str]
pydantic.v1.networks.stricturl(*,strip_whitespace:bool=True,min_length:int=1,max_length:int=2**16,tld_required:bool=True,host_required:bool=True,allowed_schemes:Optional[Collection[str]]=None)->Type[AnyUrl]
pydantic.v1.networks.url_regex()->Pattern[str]
pydantic.v1.networks.validate_email(value:Union[str])->Tuple[str, str]
pydantic.v1.stricturl(*,strip_whitespace:bool=True,min_length:int=1,max_length:int=2**16,tld_required:bool=True,host_required:bool=True,allowed_schemes:Optional[Collection[str]]=None)->Type[AnyUrl]
pydantic.v1.url_regex()->Pattern[str]
pydantic.v1.validate_email(value:Union[str])->Tuple[str, str]


----------------------------------------/home/zhang/Packages/pydantic/pydantic2.0b1/v1/generics.py----------------------------------------
A:pydantic.v1.generics.GenericModelT->TypeVar('GenericModelT', bound='GenericModel')
A:pydantic.v1.generics._generic_types_cache->GenericTypesCache()
A:pydantic.v1.generics._assigned_parameters->AssignedParameters()
A:pydantic.v1.generics.args->get_args(v)
A:pydantic.v1.generics.cached->GenericTypesCache().get(_cache_key(params))
A:pydantic.v1.generics.model_name->cls.__concrete_name__(params)
A:pydantic.v1.generics.validators->gather_all_validators(cls)
A:pydantic.v1.generics.type_hints->get_all_type_hints(cls).items()
A:pydantic.v1.generics.(model_module, called_globally)->get_caller_frame_info()
A:pydantic.v1.generics.created_model->cast(Type[GenericModel], create_model(model_name, __module__=model_module or cls.__module__, __base__=(cls,) + tuple(cls.__parameterized_bases__(typevars_map)), __config__=None, __validators__=validators, __cls_kwargs__=None, **fields))
A:pydantic.v1.generics.object_by_reference->reference_module_globals.setdefault(reference_name, created_model)
A:pydantic.v1.generics.new_params->tuple({param: None for param in iter_contained_typevars(typevars_map.values())})
A:pydantic.v1.generics.params_component->', '.join(param_names)
A:pydantic.v1.generics.base_parameters->tuple((mapped_types[param] for param in base_model.__parameters__))
A:pydantic.v1.generics.parameterized_base->base_model.__class_getitem__(base_parameters)
A:pydantic.v1.generics.type_args->get_args(type_)
A:pydantic.v1.generics.origin_type->getattr(typing, type_._name)
A:pydantic.v1.generics.resolved_type_args->tuple((replace_types(t, type_map) for t in type_args))
A:pydantic.v1.generics.resolved_list->list((replace_types(element, type_map) for element in type_))
A:pydantic.v1.generics.type_.inner_type->replace_types(type_.inner_type, type_map)
A:pydantic.v1.generics.actual->len(parameters)
A:pydantic.v1.generics.expected->len(cls.__parameters__)
A:pydantic.v1.generics.previous_caller_frame->sys._getframe(2)
A:pydantic.v1.generics.concrete_type->replace_types(field_type_hint, typevars_map)
pydantic.v1.generics.GenericModel(BaseModel)
pydantic.v1.generics.GenericModel.__class_getitem__(cls:Type[GenericModelT],params:Union[Type[Any],Tuple[Type[Any],...]])->Type[Any]
pydantic.v1.generics.GenericModel.__concrete_name__(cls:Type[Any],params:Tuple[Type[Any],...])->str
pydantic.v1.generics.GenericModel.__parameterized_bases__(cls,typevars_map:Parametrization)->Iterator[Type[Any]]
pydantic.v1.generics._prepare_model_fields(created_model:Type[GenericModel],fields:Mapping[str,Any],instance_type_hints:Mapping[str,type],typevars_map:Mapping[Any,type])->None
pydantic.v1.generics.check_parameters_count(cls:Type[GenericModel],parameters:Tuple[Any,...])->None
pydantic.v1.generics.get_caller_frame_info()->Tuple[Optional[str], bool]
pydantic.v1.generics.iter_contained_typevars(v:Any)->Iterator[TypeVarType]
pydantic.v1.generics.replace_types(type_:Any,type_map:Mapping[Any,Any])->Any


----------------------------------------/home/zhang/Packages/pydantic/pydantic2.0b1/v1/schema.py----------------------------------------
A:pydantic.v1.schema.sig->signature(modify_schema)
A:pydantic.v1.schema.args->get_args(field_type)
A:pydantic.v1.schema.flat_models->get_flat_models_from_model(model)
A:pydantic.v1.schema.model_name_map->get_model_name_map(flat_models)
A:pydantic.v1.schema.(m_schema, m_definitions, m_nested_models)->model_process_schema(model, by_alias=by_alias, model_name_map=model_name_map, ref_prefix=ref_prefix, ref_template=ref_template)
A:pydantic.v1.schema.model->cast(Type['BaseModel'], model)
A:pydantic.v1.schema.(m_schema, m_definitions, nested_models)->model_type_schema(model, by_alias=by_alias, model_name_map=model_name_map, ref_prefix=ref_prefix, ref_template=ref_template, known_models=known_models)
A:pydantic.v1.schema.m_schema->get_schema_ref(model_name, ref_prefix, ref_template, False)
A:pydantic.v1.schema.schema_['default']->encode_default(field.default)
A:pydantic.v1.schema.(s, schema_overrides)->get_field_info_schema(field)
A:pydantic.v1.schema.validation_schema->get_field_schema_validations(field)
A:pydantic.v1.schema.(f_schema, f_definitions, f_nested_models)->field_schema(f, by_alias=by_alias, model_name_map=model_name_map, ref_prefix=ref_prefix, ref_template=ref_template, known_models=known_models)
A:pydantic.v1.schema.attr->getattr(field.field_info, attr_name, None)
A:pydantic.v1.schema.modify_schema->getattr(field_type, '__modify_schema__', None)
A:pydantic.v1.schema.model_name->get_long_model_name(model)
A:pydantic.v1.schema.conflicting_model->name_model_map.pop(model_name)
A:pydantic.v1.schema.fields->cast(Sequence[ModelField], model.__fields__.values())
A:pydantic.v1.schema.(items_schema, f_definitions, f_nested_models)->field_singleton_schema(field, by_alias=by_alias, model_name_map=model_name_map, ref_prefix=ref_prefix, ref_template=ref_template, known_models=known_models)
A:pydantic.v1.schema.key_field->cast(ModelField, field.key_field)
A:pydantic.v1.schema.regex->getattr(key_field.type_, 'regex', None)
A:pydantic.v1.schema.sub_fields->cast(List[ModelField], field.sub_fields)
A:pydantic.v1.schema.(sf_schema, sf_definitions, sf_nested_models)->field_type_schema(sf, by_alias=by_alias, model_name_map=model_name_map, ref_prefix=ref_prefix, ref_template=ref_template, known_models=known_models)
A:pydantic.v1.schema.sub_fields_len->len(sub_fields)
A:pydantic.v1.schema.s->enum_process_schema(model, field=field)
A:pydantic.v1.schema.doc->getdoc(model)
A:pydantic.v1.schema.discriminator_value->str(discriminator_value.value)
A:pydantic.v1.schema.sub_models->get_sub_types(sub_field.type_)
A:pydantic.v1.schema.discriminator_model_ref->get_schema_ref(discriminator_model_name, ref_prefix, ref_template, False)
A:pydantic.v1.schema.(sub_schema, sub_definitions, sub_nested_models)->model_process_schema(field_type, by_alias=by_alias, model_name_map=model_name_map, ref_prefix=ref_prefix, ref_template=ref_template, known_models=known_models, field=field)
A:pydantic.v1.schema.values->tuple((x.value if isinstance(x, Enum) else x for x in all_literal_values(field_type)))
A:pydantic.v1.schema.f_schema['enum']->list(values)
A:pydantic.v1.schema.(f_schema, schema_overrides)->get_field_info_schema(field, schema_overrides)
A:pydantic.v1.schema.definitions[enum_name]->enum_process_schema(field_type, field=field)
A:pydantic.v1.schema.(sub_schema, *_)->model_process_schema(field_type.__pydantic_model__, by_alias=by_alias, model_name_map=model_name_map, ref_prefix=ref_prefix, ref_template=ref_template, known_models=known_models, field=field)
A:pydantic.v1.schema.items_schemas->list(sub_schema['properties'].values())
A:pydantic.v1.schema.schema_ref->get_schema_ref(model_name, ref_prefix, ref_template, schema_overrides)
A:pydantic.v1.schema.literal_distinct_types->defaultdict(list)
A:pydantic.v1.schema.dft->cast('dict[str, Any]', pydantic_encoder(dft))
A:pydantic.v1.schema.constraints->field_info.get_constraints()
A:pydantic.v1.schema.(annotation, used_constraints)->get_annotation_with_constraints(annotation, field_info)
A:pydantic.v1.schema.origin->get_origin(type_)
A:pydantic.v1.schema.numeric_type->next((t for t in numeric_types if issubclass(type_, t)))
A:pydantic.v1.schema.constraint_func->cast(Callable[..., type], constraint_func)
pydantic.v1.schema.SkipField(self,message:str)
pydantic.v1.schema._apply_modify_schema(modify_schema:Callable[...,None],field:Optional[ModelField],field_schema:Dict[str,Any])->None
pydantic.v1.schema.add_field_type_to_schema(field_type:Any,schema_:Dict[str,Any])->None
pydantic.v1.schema.encode_default(dft:Any)->Any
pydantic.v1.schema.enum_process_schema(enum:Type[Enum],*,field:Optional[ModelField]=None)->Dict[str, Any]
pydantic.v1.schema.field_schema(field:ModelField,*,by_alias:bool=True,model_name_map:Dict[TypeModelOrEnum,str],ref_prefix:Optional[str]=None,ref_template:str=default_ref_template,known_models:Optional[TypeModelSet]=None)->Tuple[Dict[str, Any], Dict[str, Any], Set[str]]
pydantic.v1.schema.field_singleton_schema(field:ModelField,*,by_alias:bool,model_name_map:Dict[TypeModelOrEnum,str],ref_template:str,schema_overrides:bool=False,ref_prefix:Optional[str]=None,known_models:TypeModelSet)->Tuple[Dict[str, Any], Dict[str, Any], Set[str]]
pydantic.v1.schema.field_singleton_sub_fields_schema(field:ModelField,*,by_alias:bool,model_name_map:Dict[TypeModelOrEnum,str],ref_template:str,schema_overrides:bool=False,ref_prefix:Optional[str]=None,known_models:TypeModelSet)->Tuple[Dict[str, Any], Dict[str, Any], Set[str]]
pydantic.v1.schema.field_type_schema(field:ModelField,*,by_alias:bool,model_name_map:Dict[TypeModelOrEnum,str],ref_template:str,schema_overrides:bool=False,ref_prefix:Optional[str]=None,known_models:TypeModelSet)->Tuple[Dict[str, Any], Dict[str, Any], Set[str]]
pydantic.v1.schema.get_annotation_from_field_info(annotation:Any,field_info:FieldInfo,field_name:str,validate_assignment:bool=False)->Type[Any]
pydantic.v1.schema.get_annotation_with_constraints(annotation:Any,field_info:FieldInfo)->Tuple[Type[Any], Set[str]]
pydantic.v1.schema.get_field_info_schema(field:ModelField,schema_overrides:bool=False)->Tuple[Dict[str, Any], bool]
pydantic.v1.schema.get_field_schema_validations(field:ModelField)->Dict[str, Any]
pydantic.v1.schema.get_flat_models_from_field(field:ModelField,known_models:TypeModelSet)->TypeModelSet
pydantic.v1.schema.get_flat_models_from_fields(fields:Sequence[ModelField],known_models:TypeModelSet)->TypeModelSet
pydantic.v1.schema.get_flat_models_from_model(model:Type['BaseModel'],known_models:Optional[TypeModelSet]=None)->TypeModelSet
pydantic.v1.schema.get_flat_models_from_models(models:Sequence[Type['BaseModel']])->TypeModelSet
pydantic.v1.schema.get_long_model_name(model:TypeModelOrEnum)->str
pydantic.v1.schema.get_model_name_map(unique_models:TypeModelSet)->Dict[TypeModelOrEnum, str]
pydantic.v1.schema.get_schema_ref(name:str,ref_prefix:Optional[str],ref_template:str,schema_overrides:bool)->Dict[str, Any]
pydantic.v1.schema.model_process_schema(model:TypeModelOrEnum,*,by_alias:bool=True,model_name_map:Dict[TypeModelOrEnum,str],ref_prefix:Optional[str]=None,ref_template:str=default_ref_template,known_models:Optional[TypeModelSet]=None,field:Optional[ModelField]=None)->Tuple[Dict[str, Any], Dict[str, Any], Set[str]]
pydantic.v1.schema.model_schema(model:Union[Type['BaseModel'],Type['Dataclass']],by_alias:bool=True,ref_prefix:Optional[str]=None,ref_template:str=default_ref_template)->Dict[str, Any]
pydantic.v1.schema.model_type_schema(model:Type['BaseModel'],*,by_alias:bool,model_name_map:Dict[TypeModelOrEnum,str],ref_template:str,ref_prefix:Optional[str]=None,known_models:TypeModelSet)->Tuple[Dict[str, Any], Dict[str, Any], Set[str]]
pydantic.v1.schema.multitypes_literal_field_for_schema(values:Tuple[Any,...],field:ModelField)->ModelField
pydantic.v1.schema.normalize_name(name:str)->str
pydantic.v1.schema.schema(models:Sequence[Union[Type['BaseModel'],Type['Dataclass']]],*,by_alias:bool=True,title:Optional[str]=None,description:Optional[str]=None,ref_prefix:Optional[str]=None,ref_template:str=default_ref_template)->Dict[str, Any]


----------------------------------------/home/zhang/Packages/pydantic/pydantic2.0b1/v1/version.py----------------------------------------
pydantic.v1.version.version_info()->str


----------------------------------------/home/zhang/Packages/pydantic/pydantic2.0b1/v1/json.py----------------------------------------
A:pydantic.v1.json.(minutes, seconds)->divmod(td.seconds, 60)
A:pydantic.v1.json.(hours, minutes)->divmod(minutes, 60)
pydantic.v1.json.custom_pydantic_encoder(type_encoders:Dict[Any,Callable[[Type[Any]],Any]],obj:Any)->Any
pydantic.v1.json.decimal_encoder(dec_value:Decimal)->Union[int, float]
pydantic.v1.json.isoformat(o:Union[datetime.date,datetime.time])->str
pydantic.v1.json.pydantic_encoder(obj:Any)->Any
pydantic.v1.json.timedelta_isoformat(td:datetime.timedelta)->str


----------------------------------------/home/zhang/Packages/pydantic/pydantic2.0b1/v1/__init__.py----------------------------------------


----------------------------------------/home/zhang/Packages/pydantic/pydantic2.0b1/v1/mypy.py----------------------------------------
A:pydantic.v1.m.MYPY_VERSION_TUPLE->parse_mypy_version(mypy_version)
A:pydantic.v1.m.self.plugin_config->PydanticPluginConfig(options)
A:pydantic.v1.m.self._plugin_data->self.plugin_config.to_data()
A:pydantic.v1.m.sym->SymbolTableNode(MDEF, func)
A:pydantic.v1.m.transformer->PydanticModelTransformer(ctx, self.plugin_config)
A:pydantic.v1.m.args->getattr(ret_type, 'args', None)
A:pydantic.v1.m.ret_type.args->tuple((default_any_type for _ in args))
A:pydantic.v1.m.toml_config->parse_toml(options.config_file)
A:pydantic.v1.m.config->ModelConfigData()
A:pydantic.v1.m.setting->ConfigParser().getboolean(CONFIGFILE_KEY, key, fallback=False)
A:pydantic.v1.m.plugin_config->ConfigParser()
A:pydantic.v1.m.pydantic_metadata->model_type.type.metadata.get(METADATA_KEY)
A:pydantic.v1.m.orm_mode->model_type.type.metadata.get(METADATA_KEY).get('config', {}).get('orm_mode')
A:pydantic.v1.m.fields->self.collect_fields(config)
A:pydantic.v1.m.is_settings->any((get_fullname(base) == BASESETTINGS_FULLNAME for base in info.mro[:-1]))
A:pydantic.v1.m.known_fields->set()
A:pydantic.v1.m.is_required->self.get_is_required(cls, stmt, lhs)
A:pydantic.v1.m.(alias, has_dynamic_alias)->self.get_alias_info(stmt)
A:pydantic.v1.m.all_fields->self.collect_fields(config).copy()
A:pydantic.v1.m.field->PydanticModelField.deserialize(info, data)
A:pydantic.v1.m.init_arguments->self.get_field_arguments(fields, typed=typed, force_all_optional=force_all_optional, use_alias=use_alias)
A:pydantic.v1.m.var->PydanticModelField.deserialize(info, data).to_var(info, use_alias=False)
A:pydantic.v1.m.set_str->ctx.api.named_type(f'{BUILTINS_NAME}.set', [ctx.api.named_type(f'{BUILTINS_NAME}.str')])
A:pydantic.v1.m.optional_set_str->UnionType([set_str, NoneType()])
A:pydantic.v1.m.fields_set_argument->Argument(Var('_fields_set', optional_set_str), optional_set_str, None, ARG_OPT)
A:pydantic.v1.m.construct_arguments->self.get_field_arguments(fields, typed=True, force_all_optional=False, use_alias=False)
A:pydantic.v1.m.obj_type->ctx.api.named_type(f'{BUILTINS_NAME}.object')
A:pydantic.v1.m.tvd->TypeVarDef(self_tvar_name, tvar_fullname, -1, [], obj_type)
A:pydantic.v1.m.self_tvar_expr->TypeVarExpr(self_tvar_name, tvar_fullname, [], obj_type)
A:pydantic.v1.m.ctx.cls.info.names[self_tvar_name]->SymbolTableNode(MDEF, self_tvar_expr)
A:pydantic.v1.m.self_type->TypeVarType(tvd)
A:pydantic.v1.m.sym_node->info.names.get(field.name)
A:pydantic.v1.m.var_str->repr(var)
A:pydantic.v1.m.info.names[get_name(var)]->SymbolTableNode(MDEF, var)
A:pydantic.v1.m.value_type->get_proper_type(cls.info[lhs.name].type)
A:pydantic.v1.m.type_annotation->AnyType(TypeOfAny.explicit)
A:pydantic.v1.m.ERROR_ORM->ErrorCode('pydantic-orm', 'Invalid from_orm call', 'Pydantic')
A:pydantic.v1.m.ERROR_CONFIG->ErrorCode('pydantic-config', 'Invalid config value', 'Pydantic')
A:pydantic.v1.m.ERROR_ALIAS->ErrorCode('pydantic-alias', 'Dynamic alias disallowed', 'Pydantic')
A:pydantic.v1.m.ERROR_UNEXPECTED->ErrorCode('pydantic-unexpected', 'Unexpected behavior', 'Pydantic')
A:pydantic.v1.m.ERROR_UNTYPED->ErrorCode('pydantic-field', 'Untyped field disallowed', 'Pydantic')
A:pydantic.v1.m.ERROR_FIELD_DEFAULTS->ErrorCode('pydantic-field', 'Invalid Field defaults', 'Pydantic')
A:pydantic.v1.m.function_type->ctx.api.named_type(f'{BUILTINS_NAME}.function')
A:pydantic.v1.m.signature->CallableType(arg_types, arg_kinds, arg_names, return_type, function_type)
A:pydantic.v1.m.func->FuncDef(name, args, Block([PassStmt()]))
A:pydantic.v1.m.func.type->set_callable_name(signature, func)
A:pydantic.v1.m.r_name->get_unique_redefinition_name(name, info.names)
A:pydantic.v1.m.v->Var(name, func.type)
A:pydantic.v1.m.dec->Decorator(func, [NameExpr('classmethod')], v)
pydantic.v1.m.ModelConfigData(self,forbid_extra:Optional[bool]=None,allow_mutation:Optional[bool]=None,frozen:Optional[bool]=None,orm_mode:Optional[bool]=None,allow_population_by_field_name:Optional[bool]=None,has_alias_generator:Optional[bool]=None)
pydantic.v1.m.ModelConfigData.set_values_dict(self)->Dict[str, Any]
pydantic.v1.m.ModelConfigData.setdefault(self,key:str,value:Any)->None
pydantic.v1.m.ModelConfigData.update(self,config:Optional['ModelConfigData'])->None
pydantic.v1.m.PydanticModelField(self,name:str,is_required:bool,alias:Optional[str],has_dynamic_alias:bool,line:int,column:int)
pydantic.v1.m.PydanticModelField.deserialize(cls,info:TypeInfo,data:JsonDict)->'PydanticModelField'
pydantic.v1.m.PydanticModelField.serialize(self)->JsonDict
pydantic.v1.m.PydanticModelField.to_argument(self,info:TypeInfo,typed:bool,force_optional:bool,use_alias:bool)->Argument
pydantic.v1.m.PydanticModelField.to_var(self,info:TypeInfo,use_alias:bool)->Var
pydantic.v1.m.PydanticModelTransformer(self,ctx:ClassDefContext,plugin_config:PydanticPluginConfig)
pydantic.v1.m.PydanticModelTransformer.add_construct_method(self,fields:List['PydanticModelField'])->None
pydantic.v1.m.PydanticModelTransformer.add_initializer(self,fields:List['PydanticModelField'],config:'ModelConfigData',is_settings:bool)->None
pydantic.v1.m.PydanticModelTransformer.adjust_validator_signatures(self)->None
pydantic.v1.m.PydanticModelTransformer.collect_config(self)->'ModelConfigData'
pydantic.v1.m.PydanticModelTransformer.collect_fields(self,model_config:'ModelConfigData')->List['PydanticModelField']
pydantic.v1.m.PydanticModelTransformer.get_alias_info(stmt:AssignmentStmt)->Tuple[Optional[str], bool]
pydantic.v1.m.PydanticModelTransformer.get_config_update(self,substmt:AssignmentStmt)->Optional['ModelConfigData']
pydantic.v1.m.PydanticModelTransformer.get_field_arguments(self,fields:List['PydanticModelField'],typed:bool,force_all_optional:bool,use_alias:bool)->List[Argument]
pydantic.v1.m.PydanticModelTransformer.get_is_required(cls:ClassDef,stmt:AssignmentStmt,lhs:NameExpr)->bool
pydantic.v1.m.PydanticModelTransformer.is_dynamic_alias_present(fields:List['PydanticModelField'],has_alias_generator:bool)->bool
pydantic.v1.m.PydanticModelTransformer.set_frozen(self,fields:List['PydanticModelField'],frozen:bool)->None
pydantic.v1.m.PydanticModelTransformer.should_init_forbid_extra(self,fields:List['PydanticModelField'],config:'ModelConfigData')->bool
pydantic.v1.m.PydanticModelTransformer.transform(self)->None
pydantic.v1.m.PydanticModelTransformer.type_has_implicit_default(type_:Optional[ProperType])->bool
pydantic.v1.m.PydanticPlugin(self,options:Options)
pydantic.v1.m.PydanticPlugin._pydantic_field_callback(self,ctx:FunctionContext)->'Type'
pydantic.v1.m.PydanticPlugin._pydantic_model_class_maker_callback(self,ctx:ClassDefContext)->None
pydantic.v1.m.PydanticPlugin._pydantic_model_metaclass_marker_callback(self,ctx:ClassDefContext)->None
pydantic.v1.m.PydanticPlugin.get_base_class_hook(self,fullname:str)->'Optional[Callable[[ClassDefContext], None]]'
pydantic.v1.m.PydanticPlugin.get_class_decorator_hook(self,fullname:str)->Optional[Callable[[ClassDefContext], None]]
pydantic.v1.m.PydanticPlugin.get_function_hook(self,fullname:str)->'Optional[Callable[[FunctionContext], Type]]'
pydantic.v1.m.PydanticPlugin.get_metaclass_hook(self,fullname:str)->Optional[Callable[[ClassDefContext], None]]
pydantic.v1.m.PydanticPlugin.get_method_hook(self,fullname:str)->Optional[Callable[[MethodContext], Type]]
pydantic.v1.m.PydanticPlugin.report_config_data(self,ctx:ReportConfigContext)->Dict[str, Any]
pydantic.v1.m.PydanticPluginConfig(self,options:Options)
pydantic.v1.m.PydanticPluginConfig.to_data(self)->Dict[str, Any]
pydantic.v1.m.add_method(ctx:ClassDefContext,name:str,args:List[Argument],return_type:Type,self_type:Optional[Type]=None,tvar_def:Optional[TypeVarDef]=None,is_classmethod:bool=False,is_new:bool=False)->None
pydantic.v1.m.error_default_and_default_factory_specified(api:CheckerPluginInterface,context:Context)->None
pydantic.v1.m.error_from_orm(model_name:str,api:CheckerPluginInterface,context:Context)->None
pydantic.v1.m.error_invalid_config_value(name:str,api:SemanticAnalyzerPluginInterface,context:Context)->None
pydantic.v1.m.error_required_dynamic_aliases(api:SemanticAnalyzerPluginInterface,context:Context)->None
pydantic.v1.m.error_unexpected_behavior(detail:str,api:Union[CheckerPluginInterface,SemanticAnalyzerPluginInterface],context:Context)->None
pydantic.v1.m.error_untyped_fields(api:SemanticAnalyzerPluginInterface,context:Context)->None
pydantic.v1.m.from_orm_callback(ctx:MethodContext)->Type
pydantic.v1.m.get_fullname(x:Union[FuncBase,SymbolNode])->str
pydantic.v1.m.get_name(x:Union[FuncBase,SymbolNode])->str
pydantic.v1.m.parse_mypy_version(version:str)->Tuple[int, ...]
pydantic.v1.m.parse_toml(config_file:str)->Optional[Dict[str, Any]]
pydantic.v1.m.plugin(version:str)->'TypingType[Plugin]'


----------------------------------------/home/zhang/Packages/pydantic/pydantic2.0b1/v1/fields.py----------------------------------------
A:pydantic.v1.fields.T->TypeVar('T')
A:pydantic.v1.fields.Undefined->UndefinedType()
A:pydantic.v1.fields.self.default_factory->kwargs.pop('default_factory', None)
A:pydantic.v1.fields.self.alias->kwargs.pop('alias', None)
A:pydantic.v1.fields.self.alias_priority->kwargs.pop('alias_priority', 2 if self.alias is not None else None)
A:pydantic.v1.fields.self.title->kwargs.pop('title', None)
A:pydantic.v1.fields.self.description->kwargs.pop('description', None)
A:pydantic.v1.fields.self.exclude->utils.ValueItems.merge(value, current_value)
A:pydantic.v1.fields.self.include->utils.ValueItems.merge(value, current_value, intersect=True)
A:pydantic.v1.fields.self.const->kwargs.pop('const', None)
A:pydantic.v1.fields.self.gt->kwargs.pop('gt', None)
A:pydantic.v1.fields.self.ge->kwargs.pop('ge', None)
A:pydantic.v1.fields.self.lt->kwargs.pop('lt', None)
A:pydantic.v1.fields.self.le->kwargs.pop('le', None)
A:pydantic.v1.fields.self.multiple_of->kwargs.pop('multiple_of', None)
A:pydantic.v1.fields.self.allow_inf_nan->kwargs.pop('allow_inf_nan', None)
A:pydantic.v1.fields.self.max_digits->kwargs.pop('max_digits', None)
A:pydantic.v1.fields.self.decimal_places->kwargs.pop('decimal_places', None)
A:pydantic.v1.fields.self.min_items->kwargs.pop('min_items', None)
A:pydantic.v1.fields.self.max_items->kwargs.pop('max_items', None)
A:pydantic.v1.fields.self.unique_items->kwargs.pop('unique_items', None)
A:pydantic.v1.fields.self.min_length->kwargs.pop('min_length', None)
A:pydantic.v1.fields.self.max_length->kwargs.pop('max_length', None)
A:pydantic.v1.fields.self.allow_mutation->kwargs.pop('allow_mutation', True)
A:pydantic.v1.fields.self.regex->kwargs.pop('regex', None)
A:pydantic.v1.fields.self.discriminator->kwargs.pop('discriminator', None)
A:pydantic.v1.fields.self.repr->kwargs.pop('repr', True)
A:pydantic.v1.fields.current_value->getattr(self, attr_name)
A:pydantic.v1.fields.field_info->FieldInfo(value, **field_info_from_config)
A:pydantic.v1.fields.field_info_from_config->config.get_field_info(field_name)
A:pydantic.v1.fields.(field_info, value)->cls._get_field_info(name, annotation, value, config)
A:pydantic.v1.fields.annotation->get_annotation_from_field_info(annotation, field_info, name, config.validate_assignment)
A:pydantic.v1.fields.info_from_config->config.get_field_info(self.name)
A:pydantic.v1.fields.new_alias->config.get_field_info(self.name).get('alias')
A:pydantic.v1.fields.new_exclude->config.get_field_info(self.name).get('exclude')
A:pydantic.v1.fields.self.field_info.exclude->utils.ValueItems.merge(self.field_info.exclude, new_exclude)
A:pydantic.v1.fields.new_include->config.get_field_info(self.name).get('include')
A:pydantic.v1.fields.self.field_info.include->utils.ValueItems.merge(self.field_info.include, new_include, intersect=True)
A:pydantic.v1.fields.default_value->self.get_default()
A:pydantic.v1.fields.self.type_->new_type_supertype(self.type_)
A:pydantic.v1.fields.origin->get_origin(self.type_)
A:pydantic.v1.fields.args->get_args(self.type_)
A:pydantic.v1.fields.get_validators->getattr(self.type_, '__get_validators__', None)
A:pydantic.v1.fields.self.key_field->self._create_sub_type(get_args(self.type_)[0], 'key_' + self.name, for_keys=True)
A:pydantic.v1.fields.(alias, discriminator_values)->get_discriminator_alias_and_values(t, self.discriminator_key)
A:pydantic.v1.fields.self.discriminator_alias->get_unique_discriminator_alias(all_aliases, self.discriminator_key)
A:pydantic.v1.fields.(field_info, _)->self._get_field_info(name, type_, None, self.model_config)
A:pydantic.v1.fields.class_validators_->self.class_validators.values()
A:pydantic.v1.fields.self.validators->prep_validators(v_funcs)
A:pydantic.v1.fields.(v, errors)->self._apply_validators(v, values, loc, cls, self.post_validators)
A:pydantic.v1.fields.e->errors_.TupleLengthError(actual_length=actual_length, expected_length=expected_length)
A:pydantic.v1.fields.(r, ee)->field.validate(v_, values, loc=v_loc, cls=cls)
A:pydantic.v1.fields.converted->deque(result)
A:pydantic.v1.fields.iterable->iter(v)
A:pydantic.v1.fields.v_iter->dict_validator(v)
A:pydantic.v1.fields.(key_result, key_errors)->self.key_field.validate(k, values, loc=v_loc, cls=cls)
A:pydantic.v1.fields.(value_result, value_errors)->self._validate_singleton(v_, values, v_loc, cls)
A:pydantic.v1.fields.(value, error)->field.validate(v, values, loc=loc, cls=cls)
A:pydantic.v1.fields.discriminator_value->getattr(v, self.discriminator_key)
A:pydantic.v1.fields.v->validator(cls, v, values, self, self.model_config)
A:pydantic.v1.fields.t->SHAPE_NAME_LOOKUP[self.shape].format(t)
pydantic.v1.Field(default:Any=Undefined,*,default_factory:Optional[NoArgAnyCallable]=None,alias:Optional[str]=None,title:Optional[str]=None,description:Optional[str]=None,exclude:Optional[Union['AbstractSetIntStr','MappingIntStrAny',Any]]=None,include:Optional[Union['AbstractSetIntStr','MappingIntStrAny',Any]]=None,const:Optional[bool]=None,gt:Optional[float]=None,ge:Optional[float]=None,lt:Optional[float]=None,le:Optional[float]=None,multiple_of:Optional[float]=None,allow_inf_nan:Optional[bool]=None,max_digits:Optional[int]=None,decimal_places:Optional[int]=None,min_items:Optional[int]=None,max_items:Optional[int]=None,unique_items:Optional[bool]=None,min_length:Optional[int]=None,max_length:Optional[int]=None,allow_mutation:bool=True,regex:Optional[str]=None,discriminator:Optional[str]=None,repr:bool=True,**extra:Any)->Any
pydantic.v1.FieldInfo(self,default:Any=Undefined,**kwargs:Any)
pydantic.v1.FieldInfo.__repr_args__(self)->'ReprArgs'
pydantic.v1.FieldInfo._validate(self)->None
pydantic.v1.FieldInfo.get_constraints(self)->Set[str]
pydantic.v1.FieldInfo.update_from_config(self,from_config:Dict[str,Any])->None
pydantic.v1.PrivateAttr(default:Any=Undefined,*,default_factory:Optional[NoArgAnyCallable]=None)->Any
pydantic.v1.fields.DeferredType
pydantic.v1.fields.Field(default:Any=Undefined,*,default_factory:Optional[NoArgAnyCallable]=None,alias:Optional[str]=None,title:Optional[str]=None,description:Optional[str]=None,exclude:Optional[Union['AbstractSetIntStr','MappingIntStrAny',Any]]=None,include:Optional[Union['AbstractSetIntStr','MappingIntStrAny',Any]]=None,const:Optional[bool]=None,gt:Optional[float]=None,ge:Optional[float]=None,lt:Optional[float]=None,le:Optional[float]=None,multiple_of:Optional[float]=None,allow_inf_nan:Optional[bool]=None,max_digits:Optional[int]=None,decimal_places:Optional[int]=None,min_items:Optional[int]=None,max_items:Optional[int]=None,unique_items:Optional[bool]=None,min_length:Optional[int]=None,max_length:Optional[int]=None,allow_mutation:bool=True,regex:Optional[str]=None,discriminator:Optional[str]=None,repr:bool=True,**extra:Any)->Any
pydantic.v1.fields.FieldInfo(self,default:Any=Undefined,**kwargs:Any)
pydantic.v1.fields.FieldInfo.__repr_args__(self)->'ReprArgs'
pydantic.v1.fields.FieldInfo._validate(self)->None
pydantic.v1.fields.FieldInfo.get_constraints(self)->Set[str]
pydantic.v1.fields.FieldInfo.update_from_config(self,from_config:Dict[str,Any])->None
pydantic.v1.fields.ModelField(self,*,name:str,type_:Type[Any],class_validators:Optional[Dict[str,Validator]],model_config:Type['BaseConfig'],default:Any=None,default_factory:Optional[NoArgAnyCallable]=None,required:'BoolUndefined'=Undefined,final:bool=False,alias:Optional[str]=None,field_info:Optional[FieldInfo]=None)
pydantic.v1.fields.ModelField.__repr_args__(self)->'ReprArgs'
pydantic.v1.fields.ModelField._apply_validators(self,v:Any,values:Dict[str,Any],loc:'LocStr',cls:Optional['ModelOrDc'],validators:'ValidatorsList')->'ValidateReturn'
pydantic.v1.fields.ModelField._create_sub_type(self,type_:Type[Any],name:str,*,for_keys:bool=False)->'ModelField'
pydantic.v1.fields.ModelField._get_field_info(field_name:str,annotation:Any,value:Any,config:Type['BaseConfig'])->Tuple[FieldInfo, Any]
pydantic.v1.fields.ModelField._get_mapping_value(self,original:T,converted:Dict[Any,Any])->Union[T, Dict[Any, Any]]
pydantic.v1.fields.ModelField._set_default_and_type(self)->None
pydantic.v1.fields.ModelField._type_analysis(self)->None
pydantic.v1.fields.ModelField._type_display(self)->PyObjectStr
pydantic.v1.fields.ModelField._validate_discriminated_union(self,v:Any,values:Dict[str,Any],loc:'LocStr',cls:Optional['ModelOrDc'])->'ValidateReturn'
pydantic.v1.fields.ModelField._validate_iterable(self,v:Any,values:Dict[str,Any],loc:'LocStr',cls:Optional['ModelOrDc'])->'ValidateReturn'
pydantic.v1.fields.ModelField._validate_mapping_like(self,v:Any,values:Dict[str,Any],loc:'LocStr',cls:Optional['ModelOrDc'])->'ValidateReturn'
pydantic.v1.fields.ModelField._validate_sequence_like(self,v:Any,values:Dict[str,Any],loc:'LocStr',cls:Optional['ModelOrDc'])->'ValidateReturn'
pydantic.v1.fields.ModelField._validate_singleton(self,v:Any,values:Dict[str,Any],loc:'LocStr',cls:Optional['ModelOrDc'])->'ValidateReturn'
pydantic.v1.fields.ModelField._validate_tuple(self,v:Any,values:Dict[str,Any],loc:'LocStr',cls:Optional['ModelOrDc'])->'ValidateReturn'
pydantic.v1.fields.ModelField.alt_alias(self)->bool
pydantic.v1.fields.ModelField.get_default(self)->Any
pydantic.v1.fields.ModelField.infer(cls,*,name:str,value:Any,annotation:Any,class_validators:Optional[Dict[str,Validator]],config:Type['BaseConfig'])->'ModelField'
pydantic.v1.fields.ModelField.is_complex(self)->bool
pydantic.v1.fields.ModelField.populate_validators(self)->None
pydantic.v1.fields.ModelField.prepare(self)->None
pydantic.v1.fields.ModelField.prepare_discriminated_union_sub_fields(self)->None
pydantic.v1.fields.ModelField.set_config(self,config:Type['BaseConfig'])->None
pydantic.v1.fields.ModelField.validate(self,v:Any,values:Dict[str,Any],*,loc:'LocStr',cls:Optional['ModelOrDc']=None)->'ValidateReturn'
pydantic.v1.fields.ModelPrivateAttr(self,default:Any=Undefined,*,default_factory:Optional[NoArgAnyCallable]=None)
pydantic.v1.fields.ModelPrivateAttr.__eq__(self,other:Any)->bool
pydantic.v1.fields.ModelPrivateAttr.get_default(self)->Any
pydantic.v1.fields.PrivateAttr(default:Any=Undefined,*,default_factory:Optional[NoArgAnyCallable]=None)->Any
pydantic.v1.fields.UndefinedType
pydantic.v1.fields.UndefinedType.__copy__(self:T)->T
pydantic.v1.fields.UndefinedType.__deepcopy__(self:T,_:Any)->T
pydantic.v1.fields.UndefinedType.__reduce__(self)->str
pydantic.v1.fields.UndefinedType.__repr__(self)->str
pydantic.v1.fields.is_finalvar_with_default_val(type_:Type[Any],val:Any)->bool

