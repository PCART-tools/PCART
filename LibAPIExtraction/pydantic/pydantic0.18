
----------------------------------------/dataset/nuaa/anaconda3/envs/pydantic0.18/lib/python3.6/site-packages/pydantic/env_settings.py----------------------------------------
A:pydantic.env_settings.env_val->json.loads(env_val)
pydantic.BaseSettings(self,**values)
pydantic.BaseSettings.Config
pydantic.BaseSettings._build_environ(self)
pydantic.BaseSettings._build_values(self,init_kwargs)
pydantic.env_settings.BaseSettings(self,**values)
pydantic.env_settings.BaseSettings.Config
pydantic.env_settings.BaseSettings.__init__(self,**values)
pydantic.env_settings.BaseSettings._build_environ(self)
pydantic.env_settings.BaseSettings._build_values(self,init_kwargs)
pydantic.env_settings.SettingsError(ValueError)


----------------------------------------/dataset/nuaa/anaconda3/envs/pydantic0.18/lib/python3.6/site-packages/pydantic/dataclasses.py----------------------------------------
A:pydantic.dataclasses.d->dict(self.__dict__)
A:pydantic.dataclasses.(value, error_)->self.__pydantic_model__.__fields__[name].validate(value, d, loc=name)
A:pydantic.dataclasses.post_init_original->getattr(_cls, '__post_init__', None)
A:pydantic.dataclasses.cls->dataclasses._process_class(_cls, init, repr, eq, order, unsafe_hash, frozen)
A:pydantic.dataclasses.cls.__pydantic_model__->create_model(cls.__name__, __config__=config, **fields)
A:pydantic.dataclasses.cls.__validate__->classmethod(_validate_dataclass)
A:pydantic.dataclasses.cls.__get_validators__->classmethod(_get_validators)
pydantic.dataclasses._get_validators(cls)
pydantic.dataclasses._process_class(_cls,init,repr,eq,order,unsafe_hash,frozen,config)
pydantic.dataclasses._pydantic_post_init(self)
pydantic.dataclasses._validate_dataclass(cls,v)
pydantic.dataclasses.dataclass(_cls=None,*,init=True,repr=True,eq=True,order=False,unsafe_hash=False,frozen=False,config=None)
pydantic.dataclasses.setattr_validate_assignment(self,name,value)


----------------------------------------/dataset/nuaa/anaconda3/envs/pydantic0.18/lib/python3.6/site-packages/pydantic/__init__.py----------------------------------------


----------------------------------------/dataset/nuaa/anaconda3/envs/pydantic0.18/lib/python3.6/site-packages/pydantic/parse.py----------------------------------------
A:pydantic.parse.b->Path(path).read_bytes()
A:pydantic.parse.path->Path(path)
pydantic.Protocol(str,Enum)
pydantic.parse.Protocol(str,Enum)
pydantic.parse.load_file(path:Union[str,Path],*,content_type:str=None,encoding:str='utf8',proto:Protocol=None,allow_pickle:bool=False)->Any
pydantic.parse.load_str_bytes(b:StrBytes,*,content_type:str=None,encoding:str='utf8',proto:Protocol=None,allow_pickle:bool=False)->Any


----------------------------------------/dataset/nuaa/anaconda3/envs/pydantic0.18/lib/python3.6/site-packages/pydantic/validators.py----------------------------------------
A:pydantic.validators.NoneType->type(None)
A:pydantic.validators.v->Decimal(v)
A:pydantic.validators.v_len->len(v)
A:pydantic.validators.min_length->getattr(field.type_, 'min_length', config.min_anystr_length)
A:pydantic.validators.max_length->getattr(field.type_, 'max_length', config.max_anystr_length)
A:pydantic.validators.strip_whitespace->getattr(field.type_, 'strip_whitespace', config.anystr_strip_whitespace)
A:pydantic.validators.enum_v->field.type_(v)
A:pydantic.validators.required_version->getattr(field.type_, '_required_version', None)
A:pydantic.validators.supertype->_find_supertype(supertype)
pydantic.validators._find_supertype(type_)
pydantic.validators._is_new_type(type_)
pydantic.validators.anystr_length_validator(v,field,config,**kwargs)
pydantic.validators.anystr_strip_whitespace(v,field,config,**kwargs)
pydantic.validators.bool_validator(v)->bool
pydantic.validators.bytes_validator(v)->bytes
pydantic.validators.decimal_validator(v)->Decimal
pydantic.validators.dict_validator(v)->dict
pydantic.validators.enum_validator(v,field,config,**kwargs)->Enum
pydantic.validators.find_validators(type_,arbitrary_types_allowed=False)
pydantic.validators.float_validator(v)->float
pydantic.validators.int_validator(v)->int
pydantic.validators.is_none_validator(v)
pydantic.validators.list_validator(v)->list
pydantic.validators.make_arbitrary_type_validator(type_)
pydantic.validators.not_none_validator(v)
pydantic.validators.number_size_validator(v,field,config,**kwargs)
pydantic.validators.ordered_dict_validator(v)->OrderedDict
pydantic.validators.path_exists_validator(v)->Path
pydantic.validators.path_validator(v)->Path
pydantic.validators.pattern_validator(v)->Pattern
pydantic.validators.set_validator(v)->set
pydantic.validators.str_validator(v)->str
pydantic.validators.tuple_validator(v)->tuple
pydantic.validators.uuid_validator(v,field,config,**kwargs)->UUID


----------------------------------------/dataset/nuaa/anaconda3/envs/pydantic0.18/lib/python3.6/site-packages/pydantic/datetime_parse.py----------------------------------------
A:pydantic.datetime_parse.date_re->re.compile('(?P<year>\\d{4})-(?P<month>\\d{1,2})-(?P<day>\\d{1,2})$')
A:pydantic.datetime_parse.time_re->re.compile('(?P<hour>\\d{1,2}):(?P<minute>\\d{1,2})(?::(?P<second>\\d{1,2})(?:\\.(?P<microsecond>\\d{1,6})\\d{0,6})?)?')
A:pydantic.datetime_parse.datetime_re->re.compile('(?P<year>\\d{4})-(?P<month>\\d{1,2})-(?P<day>\\d{1,2})[T ](?P<hour>\\d{1,2}):(?P<minute>\\d{1,2})(?::(?P<second>\\d{1,2})(?:\\.(?P<microsecond>\\d{1,6})\\d{0,6})?)?(?P<tzinfo>Z|[+-]\\d{2}(?::?\\d{2})?)?$')
A:pydantic.datetime_parse.standard_duration_re->re.compile('^(?:(?P<days>-?\\d+) (days?, )?)?((?:(?P<hours>-?\\d+):)(?=\\d+:\\d+))?(?:(?P<minutes>-?\\d+):)?(?P<seconds>-?\\d+)(?:\\.(?P<microseconds>\\d{1,6})\\d{0,6})?$')
A:pydantic.datetime_parse.iso8601_duration_re->re.compile('^(?P<sign>[-+]?)P(?:(?P<days>\\d+(.\\d+)?)D)?(?:T(?:(?P<hours>\\d+(.\\d+)?)H)?(?:(?P<minutes>\\d+(.\\d+)?)M)?(?:(?P<seconds>\\d+(.\\d+)?)S)?)?$')
A:pydantic.datetime_parse.EPOCH->datetime(1970, 1, 1)
A:pydantic.datetime_parse.MS_WATERSHED->int(100000000000.0)
A:pydantic.datetime_parse.number->get_numeric(value)
A:pydantic.datetime_parse.match->re.compile('(?P<year>\\d{4})-(?P<month>\\d{1,2})-(?P<day>\\d{1,2})[T ](?P<hour>\\d{1,2}):(?P<minute>\\d{1,2})(?::(?P<second>\\d{1,2})(?:\\.(?P<microsecond>\\d{1,6})\\d{0,6})?)?(?P<tzinfo>Z|[+-]\\d{2}(?::?\\d{2})?)?$').match(value)
A:pydantic.datetime_parse.kw->re.compile('(?P<year>\\d{4})-(?P<month>\\d{1,2})-(?P<day>\\d{1,2})[T ](?P<hour>\\d{1,2}):(?P<minute>\\d{1,2})(?::(?P<second>\\d{1,2})(?:\\.(?P<microsecond>\\d{1,6})\\d{0,6})?)?(?P<tzinfo>Z|[+-]\\d{2}(?::?\\d{2})?)?$').match(value).groupdict()
A:pydantic.datetime_parse.kw['microsecond']->kw['microsecond'].ljust(6, '0').ljust(6, '0')
A:pydantic.datetime_parse.tzinfo->timezone(timedelta(minutes=offset))
A:pydantic.datetime_parse.value->str(value)
A:pydantic.datetime_parse.kw['microseconds']->kw['microseconds'].ljust(6, '0').ljust(6, '0')
pydantic.datetime_parse.from_unix_seconds(seconds:int)->datetime
pydantic.datetime_parse.get_numeric(value:StrIntFloat)
pydantic.datetime_parse.parse_date(value:Union[date,StrIntFloat])->date
pydantic.datetime_parse.parse_datetime(value:Union[datetime,StrIntFloat])->datetime
pydantic.datetime_parse.parse_duration(value:StrIntFloat)->timedelta
pydantic.datetime_parse.parse_time(value:Union[time,str])->time


----------------------------------------/dataset/nuaa/anaconda3/envs/pydantic0.18/lib/python3.6/site-packages/pydantic/utils.py----------------------------------------
A:pydantic.utils.PRETTY_REGEX->re.compile('([\\w ]*?) *<(.*)> *')
A:pydantic.utils.m->re.compile('([\\w ]*?) *<(.*)> *').fullmatch(value)
A:pydantic.utils.(name, value)->re.compile('([\\w ]*?) *<(.*)> *').fullmatch(value).groups()
A:pydantic.utils.email->_eval_type(value, base_globals, None).strip()
A:pydantic.utils.keys->list(query)
A:pydantic.utils.(module_path, class_name)->dotted_path.strip(' ').rsplit('.', 1)
A:pydantic.utils.module->import_module(module_path)
A:pydantic.utils.v->type(v)
A:pydantic.utils.value->_eval_type(value, base_globals, None)
pydantic.utils._rfc_1738_quote(text)
pydantic.utils.change_exception(raise_exc,*except_types)
pydantic.utils.clean_docstring(d)
pydantic.utils.display_as_type(v)
pydantic.utils.import_string(dotted_path)
pydantic.utils.in_ipython()
pydantic.utils.lenient_issubclass(cls,class_or_tuple)
pydantic.utils.list_like(v)
pydantic.utils.make_dsn(*,driver:str,user:str=None,password:str=None,host:str=None,port:str=None,name:str=None,query:str=None)
pydantic.utils.resolve_annotations(raw_annotations,module)
pydantic.utils.truncate(v,*,max_len=80)
pydantic.utils.url_regex_generator(*,relative:bool,require_tld:bool)->Pattern
pydantic.utils.validate_email(value)->Tuple[str, str]
pydantic.utils.validate_field_name(bases:List[Type['BaseModel']],field_name:str)->None


----------------------------------------/dataset/nuaa/anaconda3/envs/pydantic0.18/lib/python3.6/site-packages/pydantic/schema.py----------------------------------------
A:pydantic.schema.flat_models->set()
A:pydantic.schema.model_name_map->get_model_name_map(flat_models)
A:pydantic.schema.(m_schema, m_definitions)->model_type_schema(model, by_alias=by_alias, model_name_map=model_name_map, ref_prefix=ref_prefix)
A:pydantic.schema.s->dict(title=field.schema.title or field.alias.title())
A:pydantic.schema.s['default']->encode_default(field.default)
A:pydantic.schema.validation_schema->get_field_schema_validations(field)
A:pydantic.schema.(f_schema, f_definitions)->field_schema(f, by_alias=by_alias, model_name_map=model_name_map, ref_prefix=ref_prefix)
A:pydantic.schema.attr->getattr(field.schema, attr_name, None)
A:pydantic.schema.conflicting_names->set()
A:pydantic.schema.model_name->get_long_model_name(model)
A:pydantic.schema.conflicting_model->name_model_map.pop(model_name)
A:pydantic.schema.regex->getattr(field.key_field.type_, 'regex', None)
A:pydantic.schema.(sf_schema, sf_definitions)->field_type_schema(sf, by_alias=by_alias, model_name_map=model_name_map, ref_prefix=ref_prefix)
A:pydantic.schema.s['description']->clean_docstring(model.__doc__)
A:pydantic.schema.(sub_schema, sub_definitions)->model_process_schema(field.type_, by_alias=by_alias, model_name_map=model_name_map, ref_prefix=ref_prefix)
A:pydantic.schema.field_value->getattr(field.type_, field_name, None)
A:pydantic.schema.t->type(dft)
A:pydantic.schema.numeric_type->next((t for t in numeric_types if issubclass(annotation, t)))
pydantic.Schema(self,default,*,alias:str=None,title:str=None,description:str=None,gt:float=None,ge:float=None,lt:float=None,le:float=None,min_length:int=None,max_length:int=None,regex:str=None,**extra)
pydantic.Schema.__repr__(self)
pydantic.schema.Schema(self,default,*,alias:str=None,title:str=None,description:str=None,gt:float=None,ge:float=None,lt:float=None,le:float=None,min_length:int=None,max_length:int=None,regex:str=None,**extra)
pydantic.schema.Schema.__init__(self,default,*,alias:str=None,title:str=None,description:str=None,gt:float=None,ge:float=None,lt:float=None,le:float=None,min_length:int=None,max_length:int=None,regex:str=None,**extra)
pydantic.schema.Schema.__repr__(self)
pydantic.schema.encode_default(dft)
pydantic.schema.field_schema(field:Field,*,by_alias=True,model_name_map:Dict[Type['main.BaseModel'],str],ref_prefix=None)->Tuple[Dict[str, Any], Dict[str, Any]]
pydantic.schema.field_singleton_schema(field:Field,*,by_alias:bool,model_name_map:Dict[Type['main.BaseModel'],str],schema_overrides=False,ref_prefix=None)->Tuple[Dict[str, Any], Dict[str, Any]]
pydantic.schema.field_singleton_sub_fields_schema(sub_fields:Sequence[Field],*,by_alias:bool,model_name_map:Dict[Type['main.BaseModel'],str],schema_overrides=False,ref_prefix=None)->Tuple[Dict[str, Any], Dict[str, Any]]
pydantic.schema.field_type_schema(field:Field,*,by_alias:bool,model_name_map:Dict[Type['main.BaseModel'],str],schema_overrides=False,ref_prefix=None)->Tuple[Dict[str, Any], Dict[str, Any]]
pydantic.schema.get_annotation_from_schema(annotation,schema)
pydantic.schema.get_field_schema_validations(field)
pydantic.schema.get_flat_models_from_field(field:Field)->Set[Type['main.BaseModel']]
pydantic.schema.get_flat_models_from_fields(fields)->Set[Type['main.BaseModel']]
pydantic.schema.get_flat_models_from_model(model:Type['main.BaseModel'])->Set[Type['main.BaseModel']]
pydantic.schema.get_flat_models_from_models(models:Sequence[Type['main.BaseModel']])->Set[Type['main.BaseModel']]
pydantic.schema.get_long_model_name(model:Type['main.BaseModel'])
pydantic.schema.get_model_name_map(unique_models:Set[Type['main.BaseModel']])->Dict[Type['main.BaseModel'], str]
pydantic.schema.model_process_schema(model:Type['main.BaseModel'],*,by_alias=True,model_name_map:Dict[Type['main.BaseModel'],str],ref_prefix=None)->Tuple[Dict[str, Any], Dict[str, Any]]
pydantic.schema.model_schema(model:Type['main.BaseModel'],by_alias=True,ref_prefix=None)->Dict[str, Any]
pydantic.schema.model_type_schema(model:Type['main.BaseModel'],*,by_alias:bool,model_name_map:Dict[Type['main.BaseModel'],str],ref_prefix=None)
pydantic.schema.schema(models:Sequence[Type['main.BaseModel']],*,by_alias=True,title=None,description=None,ref_prefix=None)->Dict


----------------------------------------/dataset/nuaa/anaconda3/envs/pydantic0.18/lib/python3.6/site-packages/pydantic/version.py----------------------------------------
A:pydantic.version.VERSION->StrictVersion('0.18')


----------------------------------------/dataset/nuaa/anaconda3/envs/pydantic0.18/lib/python3.6/site-packages/pydantic/class_validators.py----------------------------------------
A:pydantic.class_validators._FUNCS->set()
A:pydantic.class_validators.f_cls->classmethod(f)
A:pydantic.class_validators.specific_validators->self.validators.get(name)
A:pydantic.class_validators.wildcard_validators->self.validators.get('*')
A:pydantic.class_validators.unused_validators->set(chain(*[(v.func.__name__ for v in self.validators[f] if v.check_fields) for f in self.validators.keys() - self.used_validators]))
A:pydantic.class_validators.fn->', '.join(unused_validators)
A:pydantic.class_validators.validator_config->getattr(value, '__validator_config', None)
A:pydantic.class_validators.signature->inspect.signature(validator)
pydantic.class_validators.Validator
pydantic.class_validators.ValidatorGroup(self,validators)
pydantic.class_validators.ValidatorGroup.__init__(self,validators)
pydantic.class_validators.ValidatorGroup.check_for_unused(self)
pydantic.class_validators.ValidatorGroup.get_validators(self,name)
pydantic.class_validators.ValidatorSignature(IntEnum)
pydantic.class_validators.extract_validators(namespace)
pydantic.class_validators.get_validator_signature(validator)
pydantic.class_validators.inherit_validators(base_validators,validators)
pydantic.class_validators.validator(*fields,pre:bool=False,whole:bool=False,always:bool=False,check_fields:bool=True)
pydantic.validator(*fields,pre:bool=False,whole:bool=False,always:bool=False,check_fields:bool=True)


----------------------------------------/dataset/nuaa/anaconda3/envs/pydantic0.18/lib/python3.6/site-packages/pydantic/errors.py----------------------------------------
pydantic.AnyStrMaxLengthError(self,*,limit_value:int)
pydantic.AnyStrMinLengthError(self,*,limit_value:int)
pydantic.ArbitraryTypeError(self,*,expected_arbitrary_type)
pydantic.BytesError(PydanticTypeError)
pydantic.ConfigError(RuntimeError)
pydantic.DSNDriverIsEmptyError(PydanticValueError)
pydantic.DataclassTypeError(PydanticTypeError)
pydantic.DateError(PydanticTypeError)
pydantic.DateTimeError(PydanticTypeError)
pydantic.DecimalError(PydanticTypeError)
pydantic.DecimalIsNotFiniteError(PydanticValueError)
pydantic.DecimalMaxDigitsError(self,*,max_digits:int)
pydantic.DecimalMaxPlacesError(self,*,decimal_places:int)
pydantic.DecimalWholeDigitsError(self,*,whole_digits:int)
pydantic.DictError(PydanticTypeError)
pydantic.DurationError(PydanticTypeError)
pydantic.EmailError(PydanticValueError)
pydantic.EnumError(PydanticTypeError)
pydantic.ExtraError(PydanticValueError)
pydantic.FloatError(PydanticTypeError)
pydantic.IntegerError(PydanticTypeError)
pydantic.JsonError(PydanticValueError)
pydantic.JsonTypeError(PydanticTypeError)
pydantic.ListError(PydanticTypeError)
pydantic.MissingError(PydanticValueError)
pydantic.NoneIsAllowedError(PydanticTypeError)
pydantic.NoneIsNotAllowedError(PydanticTypeError)
pydantic.NumberNotGeError(_NumberBoundError)
pydantic.NumberNotGtError(_NumberBoundError)
pydantic.NumberNotLeError(_NumberBoundError)
pydantic.NumberNotLtError(_NumberBoundError)
pydantic.PathError(PydanticTypeError)
pydantic.PathNotADirectoryError(_PathValueError)
pydantic.PathNotAFileError(_PathValueError)
pydantic.PathNotExistsError(_PathValueError)
pydantic.PatternError(PydanticValueError)
pydantic.PyObjectError(PydanticTypeError)
pydantic.PydanticErrorMixin(self,**ctx)
pydantic.PydanticErrorMixin.__str__(self)->str
pydantic.PydanticTypeError(PydanticErrorMixin,TypeError)
pydantic.PydanticValueError(PydanticErrorMixin,ValueError)
pydantic.SetError(PydanticTypeError)
pydantic.StrError(PydanticTypeError)
pydantic.StrRegexError(self,*,pattern:str)
pydantic.TimeError(PydanticTypeError)
pydantic.TupleError(PydanticTypeError)
pydantic.TupleLengthError(self,*,actual_length:int,expected_length:int)
pydantic.UUIDError(PydanticTypeError)
pydantic.UUIDVersionError(self,*,required_version:int)
pydantic.UrlRegexError(PydanticValueError)
pydantic.UrlSchemeError(self,*,scheme:str)
pydantic._NumberBoundError(self,*,limit_value:Union[int,float,Decimal])
pydantic._PathValueError(self,*,path:Path)
pydantic.errors.AnyStrMaxLengthError(self,*,limit_value:int)
pydantic.errors.AnyStrMaxLengthError.__init__(self,*,limit_value:int)
pydantic.errors.AnyStrMinLengthError(self,*,limit_value:int)
pydantic.errors.AnyStrMinLengthError.__init__(self,*,limit_value:int)
pydantic.errors.ArbitraryTypeError(self,*,expected_arbitrary_type)
pydantic.errors.ArbitraryTypeError.__init__(self,*,expected_arbitrary_type)
pydantic.errors.BytesError(PydanticTypeError)
pydantic.errors.ConfigError(RuntimeError)
pydantic.errors.DSNDriverIsEmptyError(PydanticValueError)
pydantic.errors.DataclassTypeError(PydanticTypeError)
pydantic.errors.DateError(PydanticTypeError)
pydantic.errors.DateTimeError(PydanticTypeError)
pydantic.errors.DecimalError(PydanticTypeError)
pydantic.errors.DecimalIsNotFiniteError(PydanticValueError)
pydantic.errors.DecimalMaxDigitsError(self,*,max_digits:int)
pydantic.errors.DecimalMaxDigitsError.__init__(self,*,max_digits:int)
pydantic.errors.DecimalMaxPlacesError(self,*,decimal_places:int)
pydantic.errors.DecimalMaxPlacesError.__init__(self,*,decimal_places:int)
pydantic.errors.DecimalWholeDigitsError(self,*,whole_digits:int)
pydantic.errors.DecimalWholeDigitsError.__init__(self,*,whole_digits:int)
pydantic.errors.DictError(PydanticTypeError)
pydantic.errors.DurationError(PydanticTypeError)
pydantic.errors.EmailError(PydanticValueError)
pydantic.errors.EnumError(PydanticTypeError)
pydantic.errors.ExtraError(PydanticValueError)
pydantic.errors.FloatError(PydanticTypeError)
pydantic.errors.IntegerError(PydanticTypeError)
pydantic.errors.JsonError(PydanticValueError)
pydantic.errors.JsonTypeError(PydanticTypeError)
pydantic.errors.ListError(PydanticTypeError)
pydantic.errors.MissingError(PydanticValueError)
pydantic.errors.NoneIsAllowedError(PydanticTypeError)
pydantic.errors.NoneIsNotAllowedError(PydanticTypeError)
pydantic.errors.NumberNotGeError(_NumberBoundError)
pydantic.errors.NumberNotGtError(_NumberBoundError)
pydantic.errors.NumberNotLeError(_NumberBoundError)
pydantic.errors.NumberNotLtError(_NumberBoundError)
pydantic.errors.PathError(PydanticTypeError)
pydantic.errors.PathNotADirectoryError(_PathValueError)
pydantic.errors.PathNotAFileError(_PathValueError)
pydantic.errors.PathNotExistsError(_PathValueError)
pydantic.errors.PatternError(PydanticValueError)
pydantic.errors.PyObjectError(PydanticTypeError)
pydantic.errors.PydanticErrorMixin(self,**ctx)
pydantic.errors.PydanticErrorMixin.__init__(self,**ctx)
pydantic.errors.PydanticErrorMixin.__str__(self)->str
pydantic.errors.PydanticTypeError(PydanticErrorMixin,TypeError)
pydantic.errors.PydanticValueError(PydanticErrorMixin,ValueError)
pydantic.errors.SetError(PydanticTypeError)
pydantic.errors.StrError(PydanticTypeError)
pydantic.errors.StrRegexError(self,*,pattern:str)
pydantic.errors.StrRegexError.__init__(self,*,pattern:str)
pydantic.errors.TimeError(PydanticTypeError)
pydantic.errors.TupleError(PydanticTypeError)
pydantic.errors.TupleLengthError(self,*,actual_length:int,expected_length:int)
pydantic.errors.TupleLengthError.__init__(self,*,actual_length:int,expected_length:int)
pydantic.errors.UUIDError(PydanticTypeError)
pydantic.errors.UUIDVersionError(self,*,required_version:int)
pydantic.errors.UUIDVersionError.__init__(self,*,required_version:int)
pydantic.errors.UrlRegexError(PydanticValueError)
pydantic.errors.UrlSchemeError(self,*,scheme:str)
pydantic.errors.UrlSchemeError.__init__(self,*,scheme:str)
pydantic.errors._NumberBoundError(self,*,limit_value:Union[int,float,Decimal])
pydantic.errors._NumberBoundError.__init__(self,*,limit_value:Union[int,float,Decimal])
pydantic.errors._PathValueError(self,*,path:Path)
pydantic.errors._PathValueError.__init__(self,*,path:Path)


----------------------------------------/dataset/nuaa/anaconda3/envs/pydantic0.18/lib/python3.6/site-packages/pydantic/types.py----------------------------------------
A:pydantic.types.namespace->dict(gt=gt, ge=ge, lt=lt, le=le, max_digits=max_digits, decimal_places=decimal_places)
A:pydantic.types.scheme->value.split('://')[0].lower()
A:pydantic.types.regex->url_regex_generator(relative=cls.relative, require_tld=cls.require_tld)
A:pydantic.types.new_cls->type.__new__(cls, name, bases, dct)
A:pydantic.types.digitsdecimals->abs(exponent)
A:pydantic.types.digits->len(digit_tuple)
A:pydantic.types.decimals->abs(exponent)
pydantic.ConstrainedDecimal(Decimal,metaclass=ConstrainedNumberMeta)
pydantic.ConstrainedDecimal.__get_validators__(cls)
pydantic.ConstrainedDecimal.validate(cls,value:Decimal)->Decimal
pydantic.ConstrainedFloat(float,metaclass=ConstrainedNumberMeta)
pydantic.ConstrainedFloat.__get_validators__(cls)
pydantic.ConstrainedInt(int,metaclass=ConstrainedNumberMeta)
pydantic.ConstrainedInt.__get_validators__(cls)
pydantic.ConstrainedNumberMeta(cls,name,bases,dct)
pydantic.ConstrainedStr(str)
pydantic.ConstrainedStr.__get_validators__(cls)
pydantic.ConstrainedStr.validate(cls,value:str)->str
pydantic.DSN(str)
pydantic.DSN.__get_validators__(cls)
pydantic.DSN.validate(cls,value,values,**kwarg)
pydantic.DirectoryPath(Path)
pydantic.DirectoryPath.__get_validators__(cls)
pydantic.DirectoryPath.validate(cls,value:Path)->Path
pydantic.EmailStr(str)
pydantic.EmailStr.__get_validators__(cls)
pydantic.EmailStr.validate(cls,value)
pydantic.FilePath(Path)
pydantic.FilePath.__get_validators__(cls)
pydantic.FilePath.validate(cls,value:Path)->Path
pydantic.Json(metaclass=JsonMeta)
pydantic.Json.__get_validators__(cls)
pydantic.Json.validate(cls,v:str)
pydantic.JsonMeta(type)
pydantic.JsonMeta.__getitem__(self,t)
pydantic.JsonWrapper
pydantic.NameEmail(self,name,email)
pydantic.NameEmail.__get_validators__(cls)
pydantic.NameEmail.__repr__(self)
pydantic.NameEmail.__str__(self)
pydantic.NameEmail.validate(cls,value)
pydantic.NegativeFloat(ConstrainedFloat)
pydantic.NegativeInt(ConstrainedInt)
pydantic.PositiveFloat(ConstrainedFloat)
pydantic.PositiveInt(ConstrainedInt)
pydantic.PyObject
pydantic.PyObject.__get_validators__(cls)
pydantic.PyObject.validate(cls,value)
pydantic.StrictStr(str)
pydantic.StrictStr.__get_validators__(cls)
pydantic.StrictStr.validate(cls,v)
pydantic.UUID1(UUID)
pydantic.UUID3(UUID)
pydantic.UUID4(UUID)
pydantic.UUID5(UUID)
pydantic.UrlStr(str)
pydantic.UrlStr.__get_validators__(cls)
pydantic.UrlStr.validate(cls,value:str)->str
pydantic.condecimal(*,gt=None,ge=None,lt=None,le=None,max_digits=None,decimal_places=None)->Type[Decimal]
pydantic.confloat(*,gt=None,ge=None,lt=None,le=None)->Type[float]
pydantic.conint(*,gt=None,ge=None,lt=None,le=None)->Type[int]
pydantic.constr(*,strip_whitespace=False,min_length=None,max_length=None,curtail_length=None,regex=None)->Type[str]
pydantic.types.ConstrainedDecimal(Decimal,metaclass=ConstrainedNumberMeta)
pydantic.types.ConstrainedDecimal.__get_validators__(cls)
pydantic.types.ConstrainedDecimal.validate(cls,value:Decimal)->Decimal
pydantic.types.ConstrainedFloat(float,metaclass=ConstrainedNumberMeta)
pydantic.types.ConstrainedFloat.__get_validators__(cls)
pydantic.types.ConstrainedInt(int,metaclass=ConstrainedNumberMeta)
pydantic.types.ConstrainedInt.__get_validators__(cls)
pydantic.types.ConstrainedNumberMeta(cls,name,bases,dct)
pydantic.types.ConstrainedNumberMeta.__new__(cls,name,bases,dct)
pydantic.types.ConstrainedStr(str)
pydantic.types.ConstrainedStr.__get_validators__(cls)
pydantic.types.ConstrainedStr.validate(cls,value:str)->str
pydantic.types.DSN(str)
pydantic.types.DSN.__get_validators__(cls)
pydantic.types.DSN.validate(cls,value,values,**kwarg)
pydantic.types.DirectoryPath(Path)
pydantic.types.DirectoryPath.__get_validators__(cls)
pydantic.types.DirectoryPath.validate(cls,value:Path)->Path
pydantic.types.EmailStr(str)
pydantic.types.EmailStr.__get_validators__(cls)
pydantic.types.EmailStr.validate(cls,value)
pydantic.types.FilePath(Path)
pydantic.types.FilePath.__get_validators__(cls)
pydantic.types.FilePath.validate(cls,value:Path)->Path
pydantic.types.Json(metaclass=JsonMeta)
pydantic.types.Json.__get_validators__(cls)
pydantic.types.Json.validate(cls,v:str)
pydantic.types.JsonMeta(type)
pydantic.types.JsonMeta.__getitem__(self,t)
pydantic.types.JsonWrapper
pydantic.types.NameEmail(self,name,email)
pydantic.types.NameEmail.__get_validators__(cls)
pydantic.types.NameEmail.__init__(self,name,email)
pydantic.types.NameEmail.__repr__(self)
pydantic.types.NameEmail.__str__(self)
pydantic.types.NameEmail.validate(cls,value)
pydantic.types.NegativeFloat(ConstrainedFloat)
pydantic.types.NegativeInt(ConstrainedInt)
pydantic.types.PositiveFloat(ConstrainedFloat)
pydantic.types.PositiveInt(ConstrainedInt)
pydantic.types.PyObject
pydantic.types.PyObject.__get_validators__(cls)
pydantic.types.PyObject.validate(cls,value)
pydantic.types.StrictStr(str)
pydantic.types.StrictStr.__get_validators__(cls)
pydantic.types.StrictStr.validate(cls,v)
pydantic.types.UUID1(UUID)
pydantic.types.UUID3(UUID)
pydantic.types.UUID4(UUID)
pydantic.types.UUID5(UUID)
pydantic.types.UrlStr(str)
pydantic.types.UrlStr.__get_validators__(cls)
pydantic.types.UrlStr.validate(cls,value:str)->str
pydantic.types.condecimal(*,gt=None,ge=None,lt=None,le=None,max_digits=None,decimal_places=None)->Type[Decimal]
pydantic.types.confloat(*,gt=None,ge=None,lt=None,le=None)->Type[float]
pydantic.types.conint(*,gt=None,ge=None,lt=None,le=None)->Type[int]
pydantic.types.constr(*,strip_whitespace=False,min_length=None,max_length=None,curtail_length=None,regex=None)->Type[str]
pydantic.types.urlstr(*,strip_whitespace=True,min_length=1,max_length=2**16,relative=False,require_tld=True,schemes:Optional[Set[str]]=None)->Type[str]
pydantic.urlstr(*,strip_whitespace=True,min_length=1,max_length=2**16,relative=False,require_tld=True,schemes:Optional[Set[str]]=None)->Type[str]


----------------------------------------/dataset/nuaa/anaconda3/envs/pydantic0.18/lib/python3.6/site-packages/pydantic/json.py----------------------------------------
A:pydantic.json.encoder->type_encoders.get(type(obj))
A:pydantic.json.(minutes, seconds)->divmod(td.seconds, 60)
A:pydantic.json.(hours, minutes)->divmod(minutes, 60)
pydantic.json.custom_pydantic_encoder(type_encoders,obj)
pydantic.json.isoformat(o)
pydantic.json.pydantic_encoder(obj)
pydantic.json.timedelta_isoformat(td:datetime.timedelta)->str


----------------------------------------/dataset/nuaa/anaconda3/envs/pydantic0.18/lib/python3.6/site-packages/pydantic/fields.py----------------------------------------
A:pydantic.fields.schema_from_config->config.get_field_schema(self.name)
A:pydantic.fields.schema->Schema(value, **schema_from_config)
A:pydantic.fields.annotation->get_annotation_from_schema(annotation, schema)
A:pydantic.fields.self.type_->type(self.default)
A:pydantic.fields.origin->getattr(self.type_, '__origin__', None)
A:pydantic.fields.self.key_field->self._create_sub_type(self.type_.__args__[0], 'key_' + self.name, for_keys=True)
A:pydantic.fields.class_validators_->self.class_validators.values()
A:pydantic.fields.get_validators->getattr(self.type_, 'get_validators', None)
A:pydantic.fields.self.validators->self._prep_vals(v_funcs)
A:pydantic.fields.self.whole_pre_validators->self._prep_vals((v.func for v in class_validators_ if v.whole and v.pre))
A:pydantic.fields.self.whole_post_validators->self._prep_vals((v.func for v in class_validators_ if v.whole and (not v.pre)))
A:pydantic.fields.(v, error)->self._validate_json(v, loc)
A:pydantic.fields.(v, errors)->self._apply_validators(v, values, loc, cls, self.whole_post_validators)
A:pydantic.fields.v->validator(cls, v, values=values, config=self.model_config, field=self)
A:pydantic.fields.(r, e)->field.validate(v_, values, loc=v_loc, cls=cls)
A:pydantic.fields.e->errors_.TupleLengthError(actual_length=actual_length, expected_length=expected_length)
A:pydantic.fields.v_iter->dict_validator(v)
A:pydantic.fields.(key_result, key_errors)->self.key_field.validate(k, values, loc=v_loc, cls=cls)
A:pydantic.fields.(value_result, value_errors)->self._validate_singleton(v_, values, v_loc, cls)
A:pydantic.fields.(value, error)->field.validate(v, values, loc=loc, cls=cls)
pydantic.fields.Field(self,*,name:str,type_:Type,class_validators:Optional[Dict[str,Validator]],model_config:Any,default:Any=None,required:bool=True,alias:str=None,schema=None)
pydantic.fields.Field.__init__(self,*,name:str,type_:Type,class_validators:Optional[Dict[str,Validator]],model_config:Any,default:Any=None,required:bool=True,alias:str=None,schema=None)
pydantic.fields.Field.__repr__(self)
pydantic.fields.Field.__str__(self)
pydantic.fields.Field._apply_validators(self,v,values,loc,cls,validators)
pydantic.fields.Field._create_sub_type(self,type_,name,*,for_keys=False)
pydantic.fields.Field._populate_sub_fields(self)
pydantic.fields.Field._populate_validators(self)
pydantic.fields.Field._prep_vals(v_funcs)
pydantic.fields.Field._validate_json(self,v,loc)
pydantic.fields.Field._validate_list_set(self,v,values,loc,cls)
pydantic.fields.Field._validate_mapping(self,v,values,loc,cls)
pydantic.fields.Field._validate_singleton(self,v,values,loc,cls)
pydantic.fields.Field._validate_tuple(self,v,values,loc,cls)
pydantic.fields.Field.alt_alias(self)
pydantic.fields.Field.include_in_schema(self)->bool
pydantic.fields.Field.infer(cls,*,name,value,annotation,class_validators,config)
pydantic.fields.Field.is_complex(self)
pydantic.fields.Field.prepare(self)
pydantic.fields.Field.set_config(self,config)
pydantic.fields.Field.validate(self,v,values,*,loc,cls=None)
pydantic.fields.Shape(IntEnum)


----------------------------------------/dataset/nuaa/anaconda3/envs/pydantic0.18/lib/python3.6/site-packages/pydantic/error_wrappers.py----------------------------------------
A:pydantic.error_wrappers.default_msg_template->getattr(self.exc, 'msg_template', None)
A:pydantic.error_wrappers.errors->self.errors()
A:pydantic.error_wrappers.no_errors->len(errors)
A:pydantic.error_wrappers.ctx->error.get('ctx')
A:pydantic.error_wrappers.cls->type(exc)
pydantic.ValidationError(self,errors)
pydantic.ValidationError.__str__(self)
pydantic.ValidationError.errors(self)
pydantic.ValidationError.json(self,*,indent=2)
pydantic.error_wrappers.ErrorWrapper(self,exc,*,loc,config=None)
pydantic.error_wrappers.ErrorWrapper.__init__(self,exc,*,loc,config=None)
pydantic.error_wrappers.ErrorWrapper.ctx(self)
pydantic.error_wrappers.ErrorWrapper.dict(self,*,loc_prefix=None)
pydantic.error_wrappers.ErrorWrapper.msg(self)
pydantic.error_wrappers.ErrorWrapper.type_(self)
pydantic.error_wrappers.ValidationError(self,errors)
pydantic.error_wrappers.ValidationError.__init__(self,errors)
pydantic.error_wrappers.ValidationError.__str__(self)
pydantic.error_wrappers.ValidationError.errors(self)
pydantic.error_wrappers.ValidationError.json(self,*,indent=2)
pydantic.error_wrappers._display_error_loc(error)
pydantic.error_wrappers._display_error_type_and_ctx(error)
pydantic.error_wrappers.display_errors(errors)
pydantic.error_wrappers.flatten_errors(errors,*,loc=None)
pydantic.error_wrappers.get_exc_type(exc:Exception)->str


----------------------------------------/dataset/nuaa/anaconda3/envs/pydantic0.18/lib/python3.6/site-packages/pydantic/main.py----------------------------------------
A:pydantic.main.config->inherit_config(namespace.get('Config'), config)
A:pydantic.main.validators->inherit_validators(extract_validators(namespace), validators)
A:pydantic.main.vg->ValidatorGroup(validators)
A:pydantic.main.extra_validators->ValidatorGroup(validators).get_validators(f.name)
A:pydantic.main.annotations->resolve_annotations(annotations, namespace.get('__module__', None))
A:pydantic.main.class_vars->set()
A:pydantic.main.fields[ann_name]->fields.Field.infer(name=ann_name, value=..., annotation=ann_type, class_validators=vg.get_validators(ann_name), config=config)
A:pydantic.main.fields[var_name]->fields.Field.infer(name=var_name, value=value, annotation=annotations.get(var_name), class_validators=vg.get_validators(var_name), config=config)
A:pydantic.main.json_encoder->partial(custom_pydantic_encoder, config.json_encoders)
A:pydantic.main._missing->object()
A:pydantic.main.(value_, error_)->self.fields[name].validate(value, self.dict(exclude={name}), loc=name)
A:pydantic.main.get_key->partial(get_key, self.fields)
A:pydantic.main.exc->TypeError(f'{cls.__name__} expected dict not {type(obj).__name__}')
A:pydantic.main.obj->load_file(path, proto=proto, content_type=content_type, encoding=encoding, allow_pickle=allow_pickle)
A:pydantic.main.m->cls.__new__(cls)
A:pydantic.main.v->deepcopy(v)
A:pydantic.main.cached->cls._schema_cache.get(by_alias)
A:pydantic.main.s->model_schema(cls, by_alias=by_alias)
A:pydantic.main.f.type_->f.type_._evaluate(globalns, localns or None)
A:pydantic.main.namespace['Config']->inherit_config(__config__, BaseConfig)
A:pydantic.main.names_used->set()
A:pydantic.main.value->deepcopy(field.default)
A:pydantic.main.values[name]->deepcopy(field.default)
A:pydantic.main.(v_, errors_)->field.validate(value, values, loc=field.alias, cls=model.__class__)
pydantic.BaseConfig
pydantic.BaseConfig.get_field_schema(cls,name)
pydantic.BaseModel(self,**data)
pydantic.BaseModel.__eq__(self,other)
pydantic.BaseModel.__get_validators__(cls)
pydantic.BaseModel.__getattr__(self,name)
pydantic.BaseModel.__getstate__(self)
pydantic.BaseModel.__iter__(self)
pydantic.BaseModel.__repr__(self)
pydantic.BaseModel.__setattr__(self,name,value)
pydantic.BaseModel.__setstate__(self,state)
pydantic.BaseModel.__str__(self)
pydantic.BaseModel._get_key_factory(self,by_alias:bool)->Callable
pydantic.BaseModel._get_value(cls,v,by_alias=False)
pydantic.BaseModel._iter(self,by_alias=False)
pydantic.BaseModel._process_values(self,input_data:dict)->Dict[str, Any]
pydantic.BaseModel.construct(cls,**values)
pydantic.BaseModel.copy(self,*,include:Set[str]=None,exclude:Set[str]=None,update:Dict[str,Any]=None,deep:bool=False)
pydantic.BaseModel.dict(self,*,include:Set[str]=None,exclude:Set[str]=set(),by_alias:bool=False)->Dict[str, Any]
pydantic.BaseModel.fields(self)
pydantic.BaseModel.json(self,*,include:Set[str]=None,exclude:Set[str]=set(),by_alias:bool=False,encoder=None,**dumps_kwargs)->str
pydantic.BaseModel.parse_file(cls,path:Union[str,Path],*,content_type:str=None,encoding:str='utf8',proto:Protocol=None,allow_pickle:bool=False)
pydantic.BaseModel.parse_obj(cls,obj)
pydantic.BaseModel.parse_raw(cls,b:StrBytes,*,content_type:str=None,encoding:str='utf8',proto:Protocol=None,allow_pickle:bool=False)
pydantic.BaseModel.schema(cls,by_alias=True)->Dict[str, Any]
pydantic.BaseModel.schema_json(cls,*,by_alias=True,**dumps_kwargs)->str
pydantic.BaseModel.to_string(self,pretty=False)
pydantic.BaseModel.update_forward_refs(cls,**localns)
pydantic.BaseModel.validate(cls,value)
pydantic.create_model(model_name:str,*,__config__:Type=None,__base__:Type[BaseModel]=None,**field_definitions)
pydantic.main.BaseConfig
pydantic.main.BaseConfig.get_field_schema(cls,name)
pydantic.main.BaseModel(self,**data)
pydantic.main.BaseModel.__eq__(self,other)
pydantic.main.BaseModel.__get_validators__(cls)
pydantic.main.BaseModel.__getattr__(self,name)
pydantic.main.BaseModel.__getstate__(self)
pydantic.main.BaseModel.__init__(self,**data)
pydantic.main.BaseModel.__iter__(self)
pydantic.main.BaseModel.__repr__(self)
pydantic.main.BaseModel.__setattr__(self,name,value)
pydantic.main.BaseModel.__setstate__(self,state)
pydantic.main.BaseModel.__str__(self)
pydantic.main.BaseModel._get_key_factory(self,by_alias:bool)->Callable
pydantic.main.BaseModel._get_value(cls,v,by_alias=False)
pydantic.main.BaseModel._iter(self,by_alias=False)
pydantic.main.BaseModel._process_values(self,input_data:dict)->Dict[str, Any]
pydantic.main.BaseModel.construct(cls,**values)
pydantic.main.BaseModel.copy(self,*,include:Set[str]=None,exclude:Set[str]=None,update:Dict[str,Any]=None,deep:bool=False)
pydantic.main.BaseModel.dict(self,*,include:Set[str]=None,exclude:Set[str]=set(),by_alias:bool=False)->Dict[str, Any]
pydantic.main.BaseModel.fields(self)
pydantic.main.BaseModel.json(self,*,include:Set[str]=None,exclude:Set[str]=set(),by_alias:bool=False,encoder=None,**dumps_kwargs)->str
pydantic.main.BaseModel.parse_file(cls,path:Union[str,Path],*,content_type:str=None,encoding:str='utf8',proto:Protocol=None,allow_pickle:bool=False)
pydantic.main.BaseModel.parse_obj(cls,obj)
pydantic.main.BaseModel.parse_raw(cls,b:StrBytes,*,content_type:str=None,encoding:str='utf8',proto:Protocol=None,allow_pickle:bool=False)
pydantic.main.BaseModel.schema(cls,by_alias=True)->Dict[str, Any]
pydantic.main.BaseModel.schema_json(cls,*,by_alias=True,**dumps_kwargs)->str
pydantic.main.BaseModel.to_string(self,pretty=False)
pydantic.main.BaseModel.update_forward_refs(cls,**localns)
pydantic.main.BaseModel.validate(cls,value)
pydantic.main.MetaModel(mcs,name,bases,namespace)
pydantic.main.MetaModel.__new__(mcs,name,bases,namespace)
pydantic.main.create_model(model_name:str,*,__config__:Type=None,__base__:Type[BaseModel]=None,**field_definitions)
pydantic.main.inherit_config(self_config:Type,parent_config:Type[BaseConfig])->Type[BaseConfig]
pydantic.main.validate_model(model:BaseModel,input_data:dict,raise_exc=True)
pydantic.validate_model(model:BaseModel,input_data:dict,raise_exc=True)

