
----------------------------------------/dataset/nuaa/anaconda3/envs/pydantic2.10.6/lib/python3.9/site-packages/pydantic/env_settings.py----------------------------------------
A:pydantic.env_settings.__getattr__->getattr_migration(__name__)


----------------------------------------/dataset/nuaa/anaconda3/envs/pydantic2.10.6/lib/python3.9/site-packages/pydantic/_migration.py----------------------------------------
pydantic._migration.getattr_migration(module:str)->Callable[[str], Any]
pydantic.getattr_migration(module:str)->Callable[[str], Any]


----------------------------------------/dataset/nuaa/anaconda3/envs/pydantic2.10.6/lib/python3.9/site-packages/pydantic/dataclasses.py----------------------------------------
A:pydantic.dataclasses._T->TypeVar('_T')
A:pydantic.dataclasses.annotations->getattr(annotation_cls, '__annotations__', [])
A:pydantic.dataclasses.field_value->getattr(cls, field_name, None)
A:pydantic.dataclasses.has_dataclass_base->any((dataclasses.is_dataclass(base) for base in cls.__bases__))
A:pydantic.dataclasses.config_wrapper->_internal._config.ConfigWrapper(config_dict)
A:pydantic.dataclasses.decorators->_internal._decorators.DecoratorInfos.build(cls)
A:pydantic.dataclasses.cls->dataclasses.dataclass(cls, init=True, repr=repr, eq=eq, order=order, unsafe_hash=unsafe_hash, frozen=frozen_, **kwargs)
A:pydantic.dataclasses.__getattr__->getattr_migration(__name__)
A:pydantic.dataclasses.ns_resolver->_internal._namespace_utils.NsResolver(parent_namespace=rebuild_ns)
pydantic.dataclasses.dataclass(_cls:type[_T]|None=None,*,init:Literal[False]=False,repr:bool=True,eq:bool=True,order:bool=False,unsafe_hash:bool=False,frozen:bool|None=None,config:ConfigDict|type[object]|None=None,validate_on_init:bool|None=None,kw_only:bool=False,slots:bool=False)->Callable[[type[_T]], type[PydanticDataclass]] | type[PydanticDataclass]
pydantic.dataclasses.is_pydantic_dataclass(class_:type[Any],/)->TypeGuard[type[PydanticDataclass]]
pydantic.dataclasses.rebuild_dataclass(cls:type[PydanticDataclass],*,force:bool=False,raise_errors:bool=True,_parent_namespace_depth:int=2,_types_namespace:MappingNamespace|None=None)->bool | None


----------------------------------------/dataset/nuaa/anaconda3/envs/pydantic2.10.6/lib/python3.9/site-packages/pydantic/__init__.py----------------------------------------
A:pydantic.__init__._getattr_migration->getattr_migration(__name__)
A:pydantic.__init__.dynamic_attr->_dynamic_imports.get(attr_name)
A:pydantic.__init__.result->getattr(module, attr_name)
A:pydantic.__init__.module->import_module(module_name, package=package)
A:pydantic.__init__.g->globals()
A:pydantic.__init__.g[k]->getattr(module, k)
pydantic.__init__.__dir__()->'list[str]'
pydantic.__init__.__getattr__(attr_name:str)->object


----------------------------------------/dataset/nuaa/anaconda3/envs/pydantic2.10.6/lib/python3.9/site-packages/pydantic/decorator.py----------------------------------------
A:pydantic.decorator.__getattr__->getattr_migration(__name__)


----------------------------------------/dataset/nuaa/anaconda3/envs/pydantic2.10.6/lib/python3.9/site-packages/pydantic/parse.py----------------------------------------
A:pydantic.parse.__getattr__->getattr_migration(__name__)


----------------------------------------/dataset/nuaa/anaconda3/envs/pydantic2.10.6/lib/python3.9/site-packages/pydantic/functional_serializers.py----------------------------------------
A:pydantic.functional_serializers.schema->handler(source_type)
A:pydantic.functional_serializers.return_type->_internal._decorators.get_function_return_type(self.func, self.return_type, localns=handler._get_types_namespace().locals)
A:pydantic.functional_serializers.schema['serialization']->pydantic_core.core_schema.wrap_serializer_function_ser_schema(function=self.func, info_arg=_decorators.inspect_annotated_serializer(self.func, 'wrap'), return_schema=return_schema, when_used=self.when_used)
A:pydantic.functional_serializers.(globalns, localns)->handler._get_types_namespace()
A:pydantic.functional_serializers._FieldPlainSerializerT->TypeVar('_FieldPlainSerializerT', bound=FieldPlainSerializer)
A:pydantic.functional_serializers._FieldWrapSerializerT->TypeVar('_FieldWrapSerializerT', bound=FieldWrapSerializer)
A:pydantic.functional_serializers.dec_info->_internal._decorators.ModelSerializerDecoratorInfo(mode=mode, return_type=return_type, when_used=when_used)
A:pydantic.functional_serializers._ModelPlainSerializerT->TypeVar('_ModelPlainSerializerT', bound=ModelPlainSerializer)
A:pydantic.functional_serializers._ModelWrapSerializerT->TypeVar('_ModelWrapSerializerT', bound=ModelWrapSerializer)
A:pydantic.functional_serializers.AnyType->TypeVar('AnyType')
A:pydantic.functional_serializers.schema_to_update->schema_to_update.copy().copy()
A:pydantic.functional_serializers.schema_to_update['serialization']->pydantic_core.core_schema.wrap_serializer_function_ser_schema(lambda x, h: h(x), schema=core_schema.any_schema())
pydantic.PlainSerializer
pydantic.PlainSerializer.__get_pydantic_core_schema__(self,source_type:Any,handler:GetCoreSchemaHandler)->core_schema.CoreSchema
pydantic.WrapSerializer
pydantic.WrapSerializer.__get_pydantic_core_schema__(self,source_type:Any,handler:GetCoreSchemaHandler)->core_schema.CoreSchema
pydantic.field_serializer(*fields:str,mode:Literal['plain','wrap']='plain',return_type:Any=PydanticUndefined,when_used:WhenUsed='always',check_fields:bool|None=None)->Callable[[_FieldWrapSerializerT], _FieldWrapSerializerT] | Callable[[_FieldPlainSerializerT], _FieldPlainSerializerT]
pydantic.functional_serializers.PlainSerializer
pydantic.functional_serializers.PlainSerializer.__get_pydantic_core_schema__(self,source_type:Any,handler:GetCoreSchemaHandler)->core_schema.CoreSchema
pydantic.functional_serializers.WrapSerializer
pydantic.functional_serializers.WrapSerializer.__get_pydantic_core_schema__(self,source_type:Any,handler:GetCoreSchemaHandler)->core_schema.CoreSchema
pydantic.functional_serializers.field_serializer(*fields:str,mode:Literal['plain','wrap']='plain',return_type:Any=PydanticUndefined,when_used:WhenUsed='always',check_fields:bool|None=None)->Callable[[_FieldWrapSerializerT], _FieldWrapSerializerT] | Callable[[_FieldPlainSerializerT], _FieldPlainSerializerT]
pydantic.functional_serializers.model_serializer(f:_ModelPlainSerializerT|_ModelWrapSerializerT|None=None,/,*,mode:Literal['plain','wrap']='plain',when_used:WhenUsed='always',return_type:Any=PydanticUndefined)->_ModelPlainSerializerT | Callable[[_ModelWrapSerializerT], _ModelWrapSerializerT] | Callable[[_ModelPlainSerializerT], _ModelPlainSerializerT]
pydantic.model_serializer(f:_ModelPlainSerializerT|_ModelWrapSerializerT|None=None,/,*,mode:Literal['plain','wrap']='plain',when_used:WhenUsed='always',return_type:Any=PydanticUndefined)->_ModelPlainSerializerT | Callable[[_ModelWrapSerializerT], _ModelWrapSerializerT] | Callable[[_ModelPlainSerializerT], _ModelPlainSerializerT]


----------------------------------------/dataset/nuaa/anaconda3/envs/pydantic2.10.6/lib/python3.9/site-packages/pydantic/validators.py----------------------------------------
A:pydantic.validators.__getattr__->getattr_migration(__name__)


----------------------------------------/dataset/nuaa/anaconda3/envs/pydantic2.10.6/lib/python3.9/site-packages/pydantic/annotated_handlers.py----------------------------------------
pydantic.GetCoreSchemaHandler(self,source_type:Any,/)
pydantic.GetCoreSchemaHandler._get_types_namespace(self)->NamespacesTuple
pydantic.GetCoreSchemaHandler.field_name(self)->str | None
pydantic.GetCoreSchemaHandler.generate_schema(self,source_type:Any,/)->core_schema.CoreSchema
pydantic.GetCoreSchemaHandler.resolve_ref_schema(self,maybe_ref_schema:core_schema.CoreSchema,/)->core_schema.CoreSchema
pydantic.GetJsonSchemaHandler(self,core_schema:CoreSchemaOrField,/)
pydantic.GetJsonSchemaHandler.resolve_ref_schema(self,maybe_ref_json_schema:JsonSchemaValue,/)->JsonSchemaValue
pydantic.annotated_handlers.GetCoreSchemaHandler(self,source_type:Any,/)
pydantic.annotated_handlers.GetCoreSchemaHandler.__call__(self,source_type:Any,/)
pydantic.annotated_handlers.GetCoreSchemaHandler._get_types_namespace(self)->NamespacesTuple
pydantic.annotated_handlers.GetCoreSchemaHandler.field_name(self)->str | None
pydantic.annotated_handlers.GetCoreSchemaHandler.generate_schema(self,source_type:Any,/)->core_schema.CoreSchema
pydantic.annotated_handlers.GetCoreSchemaHandler.resolve_ref_schema(self,maybe_ref_schema:core_schema.CoreSchema,/)->core_schema.CoreSchema
pydantic.annotated_handlers.GetJsonSchemaHandler(self,core_schema:CoreSchemaOrField,/)
pydantic.annotated_handlers.GetJsonSchemaHandler.__call__(self,core_schema:CoreSchemaOrField,/)
pydantic.annotated_handlers.GetJsonSchemaHandler.resolve_ref_schema(self,maybe_ref_json_schema:JsonSchemaValue,/)->JsonSchemaValue


----------------------------------------/dataset/nuaa/anaconda3/envs/pydantic2.10.6/lib/python3.9/site-packages/pydantic/json_schema.py----------------------------------------
A:pydantic.json_schema.CoreRef->NewType('CoreRef', str)
A:pydantic.json_schema.DefsRef->NewType('DefsRef', str)
A:pydantic.json_schema.JsonRef->NewType('JsonRef', str)
A:pydantic.json_schema.JsonSchemaKeyT->TypeVar('JsonSchemaKeyT', bound=Hashable)
A:pydantic.json_schema.copied_definitions->deepcopy(definitions)
A:pydantic.json_schema.schemas_for_alternatives[defs_ref]->_deduplicate_schemas(schemas_for_alternatives[defs_ref])
A:pydantic.json_schema.remapped_defs_ref->next((x for x in alternatives if len(schemas_for_alternatives[x]) == 1))
A:pydantic.json_schema.remapping->_DefinitionsRemapping(defs_remapping, json_remapping)
A:pydantic.json_schema.new_definitions_schema->_DefinitionsRemapping(defs_remapping, json_remapping).remap_json_schema({'$defs': copied_definitions})
A:pydantic.json_schema.schema['$ref']->self.remap_json_ref(JsonRef(value))
A:pydantic.json_schema.schema[key]->self.remap_json_schema(value)
A:pydantic.json_schema.self._config_wrapper_stack->_internal._config.ConfigWrapperStack(_config.ConfigWrapper({}))
A:pydantic.json_schema.self._schema_type_to_method->self.build_schema_type_to_method()
A:pydantic.json_schema.mapping[key]->getattr(self, method_name)
A:pydantic.json_schema.definitions_remapping->self._build_definitions_remapping()
A:pydantic.json_schema.json_schema->handler(core_schema)
A:pydantic.json_schema.json_schemas_map[key, mode]->self._build_definitions_remapping().remap_json_schema(json_schema)
A:pydantic.json_schema.json_ref_counts->self.get_json_ref_counts(json_schema)
A:pydantic.json_schema.ref->handler(core_schema).pop('$ref', None)
A:pydantic.json_schema.ref_json_schema->self.get_schema_from_definitions(ref)
A:pydantic.json_schema.core_ref->CoreRef(schema['schema_ref'])
A:pydantic.json_schema.(defs_ref, ref_json_schema)->self.get_cache_defs_ref_schema(core_ref)
A:pydantic.json_schema.json_ref->JsonRef(self.ref_template.format(model=defs_ref))
A:pydantic.json_schema.current_handler->_internal._schema_generation_shared.GenerateJsonSchemaHandler(self, new_handler_func)
A:pydantic.json_schema.metadata->cast(_core_metadata.CoreMetadata, schema.get('metadata', {}))
A:pydantic.json_schema.original_schema->_internal._schema_generation_shared.GenerateJsonSchemaHandler(self, new_handler_func).resolve_ref_schema(json_schema)
A:pydantic.json_schema.keys->sorted(keys)
A:pydantic.json_schema.sorted_dict[key]->self._sort_recursive(value[key], parent_key=key)
A:pydantic.json_schema.multiple_of->schema.get('multiple_of')
A:pydantic.json_schema.le->schema.get('le')
A:pydantic.json_schema.ge->schema.get('ge')
A:pydantic.json_schema.lt->schema.get('lt')
A:pydantic.json_schema.gt->schema.get('gt')
A:pydantic.json_schema.json_schema['items']->self.generate_inner(schema['items_schema'][variadic_item_index])
A:pydantic.json_schema.json_schema['minItems']->len(prefixItems)
A:pydantic.json_schema.json_schema['maxItems']->len(prefix_items)
A:pydantic.json_schema.keys_pattern->keys_schema.pop('pattern', None)
A:pydantic.json_schema.default->ser_func(default)
A:pydantic.json_schema.encoded_default->self.encode_default(default)
A:pydantic.json_schema.inner_json_schema->self.generate_inner(schema['schema'])
A:pydantic.json_schema.generated[str(k)]->self.generate_inner(v).copy()
A:pydantic.json_schema.one_of_choices->_deduplicate_schemas(generated.values())
A:pydantic.json_schema.openapi_discriminator->self._extract_discriminator(schema, one_of_choices)
A:pydantic.json_schema.choice->self.resolve_ref_schema(choice)
A:pydantic.json_schema.properties->self.resolve_ref_schema(choice).get('properties', {})
A:pydantic.json_schema.use_strict->schema.get('strict', False)
A:pydantic.json_schema.total->schema.get('total', True)
A:pydantic.json_schema.cls->cast('type[BaseModel]', schema['cls'])
A:pydantic.json_schema.config->_get_typed_dict_config(cls)
A:pydantic.json_schema.extra->_get_typed_dict_config(cls).get('extra')
A:pydantic.json_schema.name->DefsRef(self.normalize_name(short_ref))
A:pydantic.json_schema.field_json_schema->self.handle_ref_overrides(field_json_schema)
A:pydantic.json_schema.title->model_title_generator(cls)
A:pydantic.json_schema.alias->argument.get('alias')
A:pydantic.json_schema.json_schema_extra->json_schema_extra.__get__(cls).__get__(cls)
A:pydantic.json_schema.schema_to_update->self.resolve_ref_schema(json_schema)
A:pydantic.json_schema.extras_schema->schema.get('extras_schema', None)
A:pydantic.json_schema.schema_to_update['additionalProperties']->self.generate_inner(extras_schema)
A:pydantic.json_schema.prefer_positional->schema.get('metadata', {}).get('pydantic_js_prefer_positional_arguments')
A:pydantic.json_schema.var_args_schema->schema.get('var_args_schema')
A:pydantic.json_schema.var_kwargs_schema->schema.get('var_kwargs_schema')
A:pydantic.json_schema.argument_schema->self.generate_inner(argument['schema']).copy()
A:pydantic.json_schema.argument_schema['title']->self.get_title_from_name(name)
A:pydantic.json_schema.additional_properties_schema->self.generate_inner(var_kwargs_schema)
A:pydantic.json_schema.items_schema->self.generate_inner(var_args_schema)
A:pydantic.json_schema.content_json_schema->self.generate_inner(content_core_schema)
A:pydantic.json_schema.(_, ref_json_schema)->self.get_cache_defs_ref_schema(core_ref)
A:pydantic.json_schema.return_schema->schema.get('return_schema')
A:pydantic.json_schema.components->re.split('([\\][,])', core_ref)
A:pydantic.json_schema.core_ref_no_id->''.join(components)
A:pydantic.json_schema.short_ref->''.join(components)
A:pydantic.json_schema.name_mode->DefsRef(self.normalize_name(short_ref) + f'-{mode_title}')
A:pydantic.json_schema.module_qualname->DefsRef(self.normalize_name(core_ref_no_id))
A:pydantic.json_schema.module_qualname_mode->DefsRef(f'{module_qualname}-{mode_title}')
A:pydantic.json_schema.module_qualname_id->DefsRef(self.normalize_name(core_ref))
A:pydantic.json_schema.occurrence_index->self._collision_index.get(module_qualname_id)
A:pydantic.json_schema.module_qualname_occurrence->DefsRef(f'{module_qualname}__{occurrence_index}')
A:pydantic.json_schema.module_qualname_occurrence_mode->DefsRef(f'{module_qualname_mode}__{occurrence_index}')
A:pydantic.json_schema.maybe_defs_ref->self.core_to_defs_refs.get(core_mode_ref)
A:pydantic.json_schema.defs_ref->self.get_defs_ref(core_mode_ref)
A:pydantic.json_schema.referenced_json_schema->self.get_schema_from_definitions(JsonRef(json_schema['$ref']))
A:pydantic.json_schema.members->_deduplicate_schemas(members)
A:pydantic.json_schema.message->self.render_warning_message(kind, detail)
A:pydantic.json_schema.unvisited_json_refs->_get_all_json_refs(schema)
A:pydantic.json_schema.next_json_ref->_get_all_json_refs(schema).pop()
A:pydantic.json_schema.schema_generator_instance->schema_generator(by_alias=by_alias, ref_template=ref_template)
A:pydantic.json_schema.instance->schema_generator(by_alias=by_alias, ref_template=ref_template)
A:pydantic.json_schema.(json_schemas_map, definitions)->schema_generator(by_alias=by_alias, ref_template=ref_template).generate_definitions(inputs)
A:pydantic.json_schema.examples->handler(core_schema).get('examples')
A:pydantic.json_schema.json_schema['examples']->to_jsonable_python(examples + [ex for value in self.examples.values() for ex in value])
A:pydantic.json_schema.current->stack.pop()
A:pydantic.json_schema.AnyType->TypeVar('AnyType')
pydantic.WithJsonSchema
pydantic.WithJsonSchema.__get_pydantic_json_schema__(self,core_schema:core_schema.CoreSchema,handler:GetJsonSchemaHandler)->JsonSchemaValue
pydantic.WithJsonSchema.__hash__(self)->int
pydantic.json_schema.Examples(self,examples:dict[str,Any]|list[Any],mode:Literal['validation','serialization']|None=None)
pydantic.json_schema.Examples.__get_pydantic_json_schema__(self,core_schema:core_schema.CoreSchema,handler:GetJsonSchemaHandler)->JsonSchemaValue
pydantic.json_schema.Examples.__hash__(self)->int
pydantic.json_schema.Examples.__init__(self,examples:dict[str,Any]|list[Any],mode:Literal['validation','serialization']|None=None)
pydantic.json_schema.GenerateJsonSchema(self,by_alias:bool=True,ref_template:str=DEFAULT_REF_TEMPLATE)
pydantic.json_schema.GenerateJsonSchema.ValidationsMapping
pydantic.json_schema.GenerateJsonSchema.__init__(self,by_alias:bool=True,ref_template:str=DEFAULT_REF_TEMPLATE)
pydantic.json_schema.GenerateJsonSchema._build_definitions_remapping(self)->_DefinitionsRemapping
pydantic.json_schema.GenerateJsonSchema._common_set_schema(self,schema:core_schema.SetSchema|core_schema.FrozenSetSchema)->JsonSchemaValue
pydantic.json_schema.GenerateJsonSchema._config(self)->_config.ConfigWrapper
pydantic.json_schema.GenerateJsonSchema._extract_discriminator(self,schema:core_schema.TaggedUnionSchema,one_of_choices:list[JsonDict])->str | None
pydantic.json_schema.GenerateJsonSchema._garbage_collect_definitions(self,schema:JsonSchemaValue)->None
pydantic.json_schema.GenerateJsonSchema._get_alias_name(self,field:CoreSchemaField,name:str)->str
pydantic.json_schema.GenerateJsonSchema._name_required_computed_fields(computed_fields:list[ComputedField])->list[tuple[str, bool, core_schema.ComputedField]]
pydantic.json_schema.GenerateJsonSchema._named_required_fields_schema(self,named_required_fields:Sequence[tuple[str,bool,CoreSchemaField]])->JsonSchemaValue
pydantic.json_schema.GenerateJsonSchema._sort_recursive(self,value:Any,parent_key:str|None=None)->Any
pydantic.json_schema.GenerateJsonSchema._update_class_schema(self,json_schema:JsonSchemaValue,cls:type[Any],config:ConfigDict)->None
pydantic.json_schema.GenerateJsonSchema.any_schema(self,schema:core_schema.AnySchema)->JsonSchemaValue
pydantic.json_schema.GenerateJsonSchema.arguments_schema(self,schema:core_schema.ArgumentsSchema)->JsonSchemaValue
pydantic.json_schema.GenerateJsonSchema.bool_schema(self,schema:core_schema.BoolSchema)->JsonSchemaValue
pydantic.json_schema.GenerateJsonSchema.build_schema_type_to_method(self)->dict[CoreSchemaOrFieldType, Callable[[CoreSchemaOrField], JsonSchemaValue]]
pydantic.json_schema.GenerateJsonSchema.bytes_schema(self,schema:core_schema.BytesSchema)->JsonSchemaValue
pydantic.json_schema.GenerateJsonSchema.call_schema(self,schema:core_schema.CallSchema)->JsonSchemaValue
pydantic.json_schema.GenerateJsonSchema.callable_schema(self,schema:core_schema.CallableSchema)->JsonSchemaValue
pydantic.json_schema.GenerateJsonSchema.chain_schema(self,schema:core_schema.ChainSchema)->JsonSchemaValue
pydantic.json_schema.GenerateJsonSchema.complex_schema(self,schema:core_schema.ComplexSchema)->JsonSchemaValue
pydantic.json_schema.GenerateJsonSchema.computed_field_schema(self,schema:core_schema.ComputedField)->JsonSchemaValue
pydantic.json_schema.GenerateJsonSchema.custom_error_schema(self,schema:core_schema.CustomErrorSchema)->JsonSchemaValue
pydantic.json_schema.GenerateJsonSchema.dataclass_args_schema(self,schema:core_schema.DataclassArgsSchema)->JsonSchemaValue
pydantic.json_schema.GenerateJsonSchema.dataclass_field_schema(self,schema:core_schema.DataclassField)->JsonSchemaValue
pydantic.json_schema.GenerateJsonSchema.dataclass_schema(self,schema:core_schema.DataclassSchema)->JsonSchemaValue
pydantic.json_schema.GenerateJsonSchema.date_schema(self,schema:core_schema.DateSchema)->JsonSchemaValue
pydantic.json_schema.GenerateJsonSchema.datetime_schema(self,schema:core_schema.DatetimeSchema)->JsonSchemaValue
pydantic.json_schema.GenerateJsonSchema.decimal_schema(self,schema:core_schema.DecimalSchema)->JsonSchemaValue
pydantic.json_schema.GenerateJsonSchema.default_schema(self,schema:core_schema.WithDefaultSchema)->JsonSchemaValue
pydantic.json_schema.GenerateJsonSchema.definition_ref_schema(self,schema:core_schema.DefinitionReferenceSchema)->JsonSchemaValue
pydantic.json_schema.GenerateJsonSchema.definitions_schema(self,schema:core_schema.DefinitionsSchema)->JsonSchemaValue
pydantic.json_schema.GenerateJsonSchema.dict_schema(self,schema:core_schema.DictSchema)->JsonSchemaValue
pydantic.json_schema.GenerateJsonSchema.emit_warning(self,kind:JsonSchemaWarningKind,detail:str)->None
pydantic.json_schema.GenerateJsonSchema.encode_default(self,dft:Any)->Any
pydantic.json_schema.GenerateJsonSchema.enum_schema(self,schema:core_schema.EnumSchema)->JsonSchemaValue
pydantic.json_schema.GenerateJsonSchema.field_is_present(self,field:CoreSchemaField)->bool
pydantic.json_schema.GenerateJsonSchema.field_is_required(self,field:core_schema.ModelField|core_schema.DataclassField|core_schema.TypedDictField,total:bool)->bool
pydantic.json_schema.GenerateJsonSchema.field_title_should_be_set(self,schema:CoreSchemaOrField)->bool
pydantic.json_schema.GenerateJsonSchema.float_schema(self,schema:core_schema.FloatSchema)->JsonSchemaValue
pydantic.json_schema.GenerateJsonSchema.frozenset_schema(self,schema:core_schema.FrozenSetSchema)->JsonSchemaValue
pydantic.json_schema.GenerateJsonSchema.function_after_schema(self,schema:core_schema.AfterValidatorFunctionSchema)->JsonSchemaValue
pydantic.json_schema.GenerateJsonSchema.function_before_schema(self,schema:core_schema.BeforeValidatorFunctionSchema)->JsonSchemaValue
pydantic.json_schema.GenerateJsonSchema.function_plain_schema(self,schema:core_schema.PlainValidatorFunctionSchema)->JsonSchemaValue
pydantic.json_schema.GenerateJsonSchema.function_wrap_schema(self,schema:core_schema.WrapValidatorFunctionSchema)->JsonSchemaValue
pydantic.json_schema.GenerateJsonSchema.generate(self,schema:CoreSchema,mode:JsonSchemaMode='validation')->JsonSchemaValue
pydantic.json_schema.GenerateJsonSchema.generate_definitions(self,inputs:Sequence[tuple[JsonSchemaKeyT,JsonSchemaMode,core_schema.CoreSchema]])->tuple[dict[tuple[JsonSchemaKeyT, JsonSchemaMode], JsonSchemaValue], dict[DefsRef, JsonSchemaValue]]
pydantic.json_schema.GenerateJsonSchema.generate_inner(self,schema:CoreSchemaOrField)->JsonSchemaValue
pydantic.json_schema.GenerateJsonSchema.generator_schema(self,schema:core_schema.GeneratorSchema)->JsonSchemaValue
pydantic.json_schema.GenerateJsonSchema.get_argument_name(self,argument:core_schema.ArgumentsParameter)->str
pydantic.json_schema.GenerateJsonSchema.get_cache_defs_ref_schema(self,core_ref:CoreRef)->tuple[DefsRef, JsonSchemaValue]
pydantic.json_schema.GenerateJsonSchema.get_defs_ref(self,core_mode_ref:CoreModeRef)->DefsRef
pydantic.json_schema.GenerateJsonSchema.get_flattened_anyof(self,schemas:list[JsonSchemaValue])->JsonSchemaValue
pydantic.json_schema.GenerateJsonSchema.get_json_ref_counts(self,json_schema:JsonSchemaValue)->dict[JsonRef, int]
pydantic.json_schema.GenerateJsonSchema.get_schema_from_definitions(self,json_ref:JsonRef)->JsonSchemaValue | None
pydantic.json_schema.GenerateJsonSchema.get_title_from_name(self,name:str)->str
pydantic.json_schema.GenerateJsonSchema.handle_invalid_for_json_schema(self,schema:CoreSchemaOrField,error_info:str)->JsonSchemaValue
pydantic.json_schema.GenerateJsonSchema.handle_ref_overrides(self,json_schema:JsonSchemaValue)->JsonSchemaValue
pydantic.json_schema.GenerateJsonSchema.int_schema(self,schema:core_schema.IntSchema)->JsonSchemaValue
pydantic.json_schema.GenerateJsonSchema.invalid_schema(self,schema:core_schema.InvalidSchema)->JsonSchemaValue
pydantic.json_schema.GenerateJsonSchema.is_instance_schema(self,schema:core_schema.IsInstanceSchema)->JsonSchemaValue
pydantic.json_schema.GenerateJsonSchema.is_subclass_schema(self,schema:core_schema.IsSubclassSchema)->JsonSchemaValue
pydantic.json_schema.GenerateJsonSchema.json_or_python_schema(self,schema:core_schema.JsonOrPythonSchema)->JsonSchemaValue
pydantic.json_schema.GenerateJsonSchema.json_schema(self,schema:core_schema.JsonSchema)->JsonSchemaValue
pydantic.json_schema.GenerateJsonSchema.kw_arguments_schema(self,arguments:list[core_schema.ArgumentsParameter],var_kwargs_schema:CoreSchema|None)->JsonSchemaValue
pydantic.json_schema.GenerateJsonSchema.lax_or_strict_schema(self,schema:core_schema.LaxOrStrictSchema)->JsonSchemaValue
pydantic.json_schema.GenerateJsonSchema.list_schema(self,schema:core_schema.ListSchema)->JsonSchemaValue
pydantic.json_schema.GenerateJsonSchema.literal_schema(self,schema:core_schema.LiteralSchema)->JsonSchemaValue
pydantic.json_schema.GenerateJsonSchema.mode(self)->JsonSchemaMode
pydantic.json_schema.GenerateJsonSchema.model_field_schema(self,schema:core_schema.ModelField)->JsonSchemaValue
pydantic.json_schema.GenerateJsonSchema.model_fields_schema(self,schema:core_schema.ModelFieldsSchema)->JsonSchemaValue
pydantic.json_schema.GenerateJsonSchema.model_schema(self,schema:core_schema.ModelSchema)->JsonSchemaValue
pydantic.json_schema.GenerateJsonSchema.multi_host_url_schema(self,schema:core_schema.MultiHostUrlSchema)->JsonSchemaValue
pydantic.json_schema.GenerateJsonSchema.none_schema(self,schema:core_schema.NoneSchema)->JsonSchemaValue
pydantic.json_schema.GenerateJsonSchema.normalize_name(self,name:str)->str
pydantic.json_schema.GenerateJsonSchema.nullable_schema(self,schema:core_schema.NullableSchema)->JsonSchemaValue
pydantic.json_schema.GenerateJsonSchema.p_arguments_schema(self,arguments:list[core_schema.ArgumentsParameter],var_args_schema:CoreSchema|None)->JsonSchemaValue
pydantic.json_schema.GenerateJsonSchema.render_warning_message(self,kind:JsonSchemaWarningKind,detail:str)->str | None
pydantic.json_schema.GenerateJsonSchema.resolve_ref_schema(self,json_schema:JsonSchemaValue)->JsonSchemaValue
pydantic.json_schema.GenerateJsonSchema.ser_schema(self,schema:core_schema.SerSchema|core_schema.IncExSeqSerSchema|core_schema.IncExDictSerSchema)->JsonSchemaValue | None
pydantic.json_schema.GenerateJsonSchema.set_schema(self,schema:core_schema.SetSchema)->JsonSchemaValue
pydantic.json_schema.GenerateJsonSchema.sort(self,value:JsonSchemaValue,parent_key:str|None=None)->JsonSchemaValue
pydantic.json_schema.GenerateJsonSchema.str_schema(self,schema:core_schema.StringSchema)->JsonSchemaValue
pydantic.json_schema.GenerateJsonSchema.tagged_union_schema(self,schema:core_schema.TaggedUnionSchema)->JsonSchemaValue
pydantic.json_schema.GenerateJsonSchema.time_schema(self,schema:core_schema.TimeSchema)->JsonSchemaValue
pydantic.json_schema.GenerateJsonSchema.timedelta_schema(self,schema:core_schema.TimedeltaSchema)->JsonSchemaValue
pydantic.json_schema.GenerateJsonSchema.tuple_positional_schema(self,schema:core_schema.TupleSchema)->JsonSchemaValue
pydantic.json_schema.GenerateJsonSchema.tuple_schema(self,schema:core_schema.TupleSchema)->JsonSchemaValue
pydantic.json_schema.GenerateJsonSchema.tuple_variable_schema(self,schema:core_schema.TupleSchema)->JsonSchemaValue
pydantic.json_schema.GenerateJsonSchema.typed_dict_field_schema(self,schema:core_schema.TypedDictField)->JsonSchemaValue
pydantic.json_schema.GenerateJsonSchema.typed_dict_schema(self,schema:core_schema.TypedDictSchema)->JsonSchemaValue
pydantic.json_schema.GenerateJsonSchema.union_schema(self,schema:core_schema.UnionSchema)->JsonSchemaValue
pydantic.json_schema.GenerateJsonSchema.update_with_validations(self,json_schema:JsonSchemaValue,core_schema:CoreSchema,mapping:dict[str,str])->None
pydantic.json_schema.GenerateJsonSchema.url_schema(self,schema:core_schema.UrlSchema)->JsonSchemaValue
pydantic.json_schema.GenerateJsonSchema.uuid_schema(self,schema:core_schema.UuidSchema)->JsonSchemaValue
pydantic.json_schema.PydanticJsonSchemaWarning(UserWarning)
pydantic.json_schema.WithJsonSchema
pydantic.json_schema.WithJsonSchema.__get_pydantic_json_schema__(self,core_schema:core_schema.CoreSchema,handler:GetJsonSchemaHandler)->JsonSchemaValue
pydantic.json_schema.WithJsonSchema.__hash__(self)->int
pydantic.json_schema._DefinitionsRemapping
pydantic.json_schema._DefinitionsRemapping.from_prioritized_choices(prioritized_choices:dict[DefsRef,list[DefsRef]],defs_to_json:dict[DefsRef,JsonRef],definitions:dict[DefsRef,JsonSchemaValue])->_DefinitionsRemapping
pydantic.json_schema._DefinitionsRemapping.remap_defs_ref(self,ref:DefsRef)->DefsRef
pydantic.json_schema._DefinitionsRemapping.remap_json_ref(self,ref:JsonRef)->JsonRef
pydantic.json_schema._DefinitionsRemapping.remap_json_schema(self,schema:Any)->Any
pydantic.json_schema._deduplicate_schemas(schemas:Iterable[JsonDict])->list[JsonDict]
pydantic.json_schema._get_all_json_refs(item:Any)->set[JsonRef]
pydantic.json_schema._get_typed_dict_config(cls:type[Any]|None)->ConfigDict
pydantic.json_schema._make_json_hashable(value:JsonValue)->_HashableJsonValue
pydantic.json_schema.model_json_schema(cls:type[BaseModel]|type[PydanticDataclass],by_alias:bool=True,ref_template:str=DEFAULT_REF_TEMPLATE,schema_generator:type[GenerateJsonSchema]=GenerateJsonSchema,mode:JsonSchemaMode='validation')->dict[str, Any]
pydantic.json_schema.models_json_schema(models:Sequence[tuple[type[BaseModel]|type[PydanticDataclass],JsonSchemaMode]],*,by_alias:bool=True,title:str|None=None,description:str|None=None,ref_template:str=DEFAULT_REF_TEMPLATE,schema_generator:type[GenerateJsonSchema]=GenerateJsonSchema)->tuple[dict[tuple[type[BaseModel] | type[PydanticDataclass], JsonSchemaMode], JsonSchemaValue], JsonSchemaValue]


----------------------------------------/dataset/nuaa/anaconda3/envs/pydantic2.10.6/lib/python3.9/site-packages/pydantic/root_model.py----------------------------------------
A:pydantic.root_model.RootModelRootType->typing.TypeVar('RootModelRootType')
A:pydantic.root_model.extra->type(self).model_config.get('extra')
A:pydantic.root_model.cls->type(self)
A:pydantic.root_model.m->type(self).__new__(cls)
pydantic.RootModel(self,/,root:RootModelRootType=PydanticUndefined,**data)
pydantic.RootModel.__copy__(self)->Self
pydantic.RootModel.__deepcopy__(self,memo:dict[int,Any]|None=None)->Self
pydantic.RootModel.__eq__(self,other:Any)->bool
pydantic.RootModel.__getstate__(self)->dict[Any, Any]
pydantic.RootModel.__init_subclass__(cls,**kwargs)
pydantic.RootModel.__repr_args__(self)->_repr.ReprArgs
pydantic.RootModel.__setstate__(self,state:dict[Any,Any])->None
pydantic.RootModel.model_construct(cls,root:RootModelRootType,_fields_set:set[str]|None=None)->Self
pydantic.root_model.RootModel(self,/,root:RootModelRootType=PydanticUndefined,**data)
pydantic.root_model.RootModel.__copy__(self)->Self
pydantic.root_model.RootModel.__deepcopy__(self,memo:dict[int,Any]|None=None)->Self
pydantic.root_model.RootModel.__eq__(self,other:Any)->bool
pydantic.root_model.RootModel.__getstate__(self)->dict[Any, Any]
pydantic.root_model.RootModel.__init__(self,/,root:RootModelRootType=PydanticUndefined,**data)
pydantic.root_model.RootModel.__init_subclass__(cls,**kwargs)
pydantic.root_model.RootModel.__repr_args__(self)->_repr.ReprArgs
pydantic.root_model.RootModel.__setstate__(self,state:dict[Any,Any])->None
pydantic.root_model.RootModel.model_construct(cls,root:RootModelRootType,_fields_set:set[str]|None=None)->Self


----------------------------------------/dataset/nuaa/anaconda3/envs/pydantic2.10.6/lib/python3.9/site-packages/pydantic/networks.py----------------------------------------
A:pydantic.networks.schema->handler(source)
A:pydantic.networks.v->str(v)
A:pydantic.networks.core_url->h(v)
A:pydantic.networks.instance->source.__new__(source)
A:pydantic.networks.__pydantic_serializer__->SchemaSerializer(core_schema.any_schema(serialization=core_schema.to_string_ser_schema()))
A:pydantic.networks._constraints->UrlConstraints(allowed_schemes=['snowflake'], host_required=True)
A:pydantic.networks.field_schema->handler(core_schema)
A:pydantic.networks.(name, email)->validate_email(input_value)
A:pydantic.networks.pretty_email_regex->_build_pretty_email_regex()
A:pydantic.networks.m->_build_pretty_email_regex().fullmatch(value)
A:pydantic.networks.(unquoted_name, quoted_name, value)->_build_pretty_email_regex().fullmatch(value).groups()
A:pydantic.networks.email->value.strip()
A:pydantic.networks.parts->email_validator.validate_email(email, check_deliverability=False)
A:pydantic.networks.__getattr__->getattr_migration(__name__)
pydantic.AmqpDsn(AnyUrl)
pydantic.AnyHttpUrl(AnyUrl)
pydantic.AnyUrl(_BaseUrl)
pydantic.AnyWebsocketUrl(AnyUrl)
pydantic.ClickHouseDsn(AnyUrl)
pydantic.CockroachDsn(AnyUrl)
pydantic.CockroachDsn.host(self)->str
pydantic.FileUrl(AnyUrl)
pydantic.FtpUrl(AnyUrl)
pydantic.HttpUrl(AnyUrl)
pydantic.KafkaDsn(AnyUrl)
pydantic.MariaDBDsn(AnyUrl)
pydantic.MongoDsn(_BaseMultiHostUrl)
pydantic.MySQLDsn(AnyUrl)
pydantic.NameEmail(self,name:str,email:str)
pydantic.NameEmail.__eq__(self,other:Any)->bool
pydantic.NameEmail.__get_pydantic_core_schema__(cls,_source:type[Any],_handler:GetCoreSchemaHandler)->core_schema.CoreSchema
pydantic.NameEmail.__get_pydantic_json_schema__(cls,core_schema:core_schema.CoreSchema,handler:_schema_generation_shared.GetJsonSchemaHandler)->JsonSchemaValue
pydantic.NameEmail.__str__(self)->str
pydantic.NameEmail._validate(cls,input_value:Self|str,/)->Self
pydantic.NatsDsn(_BaseMultiHostUrl)
pydantic.PostgresDsn(_BaseMultiHostUrl)
pydantic.PostgresDsn.host(self)->str
pydantic.RedisDsn(AnyUrl)
pydantic.RedisDsn.host(self)->str
pydantic.SnowflakeDsn(AnyUrl)
pydantic.SnowflakeDsn.host(self)->str
pydantic.UrlConstraints
pydantic.UrlConstraints.__get_pydantic_core_schema__(self,source:Any,handler:GetCoreSchemaHandler)->core_schema.CoreSchema
pydantic.UrlConstraints.__hash__(self)->int
pydantic.UrlConstraints.defined_constraints(self)->dict[str, Any]
pydantic.WebsocketUrl(AnyUrl)
pydantic._BaseMultiHostUrl(self,url:str|_CoreMultiHostUrl|_BaseMultiHostUrl)
pydantic._BaseMultiHostUrl.__deepcopy__(self,memo:dict)->Self
pydantic._BaseMultiHostUrl.__eq__(self,other:Any)->bool
pydantic._BaseMultiHostUrl.__get_pydantic_core_schema__(cls,source:type[_BaseMultiHostUrl],handler:GetCoreSchemaHandler)->core_schema.CoreSchema
pydantic._BaseMultiHostUrl.__get_pydantic_json_schema__(cls,core_schema:core_schema.CoreSchema,handler:_schema_generation_shared.GetJsonSchemaHandler)->JsonSchemaValue
pydantic._BaseMultiHostUrl.__hash__(self)->int
pydantic._BaseMultiHostUrl.__len__(self)->int
pydantic._BaseMultiHostUrl.__repr__(self)->str
pydantic._BaseMultiHostUrl.__str__(self)->str
pydantic._BaseMultiHostUrl.build(cls,*,scheme:str,hosts:list[MultiHostHost]|None=None,username:str|None=None,password:str|None=None,host:str|None=None,port:int|None=None,path:str|None=None,query:str|None=None,fragment:str|None=None)->Self
pydantic._BaseMultiHostUrl.fragment(self)->str | None
pydantic._BaseMultiHostUrl.hosts(self)->list[MultiHostHost]
pydantic._BaseMultiHostUrl.path(self)->str | None
pydantic._BaseMultiHostUrl.query(self)->str | None
pydantic._BaseMultiHostUrl.query_params(self)->list[tuple[str, str]]
pydantic._BaseMultiHostUrl.scheme(self)->str
pydantic._BaseMultiHostUrl.serialize_url(cls,url:Any,info:core_schema.SerializationInfo)->str | Self
pydantic._BaseMultiHostUrl.unicode_string(self)->str
pydantic._BaseUrl(self,url:str|_CoreUrl|_BaseUrl)
pydantic._BaseUrl.__deepcopy__(self,memo:dict)->Self
pydantic._BaseUrl.__eq__(self,other:Any)->bool
pydantic._BaseUrl.__ge__(self,other:Any)->bool
pydantic._BaseUrl.__get_pydantic_core_schema__(cls,source:type[_BaseUrl],handler:GetCoreSchemaHandler)->core_schema.CoreSchema
pydantic._BaseUrl.__get_pydantic_json_schema__(cls,core_schema:core_schema.CoreSchema,handler:_schema_generation_shared.GetJsonSchemaHandler)->JsonSchemaValue
pydantic._BaseUrl.__gt__(self,other:Any)->bool
pydantic._BaseUrl.__hash__(self)->int
pydantic._BaseUrl.__le__(self,other:Any)->bool
pydantic._BaseUrl.__len__(self)->int
pydantic._BaseUrl.__lt__(self,other:Any)->bool
pydantic._BaseUrl.__repr__(self)->str
pydantic._BaseUrl.__str__(self)->str
pydantic._BaseUrl.build(cls,*,scheme:str,username:str|None=None,password:str|None=None,host:str,port:int|None=None,path:str|None=None,query:str|None=None,fragment:str|None=None)->Self
pydantic._BaseUrl.fragment(self)->str | None
pydantic._BaseUrl.host(self)->str | None
pydantic._BaseUrl.password(self)->str | None
pydantic._BaseUrl.path(self)->str | None
pydantic._BaseUrl.port(self)->int | None
pydantic._BaseUrl.query(self)->str | None
pydantic._BaseUrl.query_params(self)->list[tuple[str, str]]
pydantic._BaseUrl.scheme(self)->str
pydantic._BaseUrl.serialize_url(cls,url:Any,info:core_schema.SerializationInfo)->str | Self
pydantic._BaseUrl.unicode_host(self)->str | None
pydantic._BaseUrl.unicode_string(self)->str
pydantic._BaseUrl.username(self)->str | None
pydantic._build_pretty_email_regex()->re.Pattern[str]
pydantic._build_type_adapter(cls:type[_BaseUrl|_BaseMultiHostUrl])->TypeAdapter
pydantic.import_email_validator()->None
pydantic.networks.AmqpDsn(AnyUrl)
pydantic.networks.AnyHttpUrl(AnyUrl)
pydantic.networks.AnyUrl(_BaseUrl)
pydantic.networks.AnyWebsocketUrl(AnyUrl)
pydantic.networks.ClickHouseDsn(AnyUrl)
pydantic.networks.CockroachDsn(AnyUrl)
pydantic.networks.CockroachDsn.host(self)->str
pydantic.networks.FileUrl(AnyUrl)
pydantic.networks.FtpUrl(AnyUrl)
pydantic.networks.HttpUrl(AnyUrl)
pydantic.networks.KafkaDsn(AnyUrl)
pydantic.networks.MariaDBDsn(AnyUrl)
pydantic.networks.MongoDsn(_BaseMultiHostUrl)
pydantic.networks.MySQLDsn(AnyUrl)
pydantic.networks.NameEmail(self,name:str,email:str)
pydantic.networks.NameEmail.__eq__(self,other:Any)->bool
pydantic.networks.NameEmail.__get_pydantic_core_schema__(cls,_source:type[Any],_handler:GetCoreSchemaHandler)->core_schema.CoreSchema
pydantic.networks.NameEmail.__get_pydantic_json_schema__(cls,core_schema:core_schema.CoreSchema,handler:_schema_generation_shared.GetJsonSchemaHandler)->JsonSchemaValue
pydantic.networks.NameEmail.__init__(self,name:str,email:str)
pydantic.networks.NameEmail.__str__(self)->str
pydantic.networks.NameEmail._validate(cls,input_value:Self|str,/)->Self
pydantic.networks.NatsDsn(_BaseMultiHostUrl)
pydantic.networks.PostgresDsn(_BaseMultiHostUrl)
pydantic.networks.PostgresDsn.host(self)->str
pydantic.networks.RedisDsn(AnyUrl)
pydantic.networks.RedisDsn.host(self)->str
pydantic.networks.SnowflakeDsn(AnyUrl)
pydantic.networks.SnowflakeDsn.host(self)->str
pydantic.networks.UrlConstraints
pydantic.networks.UrlConstraints.__get_pydantic_core_schema__(self,source:Any,handler:GetCoreSchemaHandler)->core_schema.CoreSchema
pydantic.networks.UrlConstraints.__hash__(self)->int
pydantic.networks.UrlConstraints.defined_constraints(self)->dict[str, Any]
pydantic.networks.WebsocketUrl(AnyUrl)
pydantic.networks._BaseMultiHostUrl(self,url:str|_CoreMultiHostUrl|_BaseMultiHostUrl)
pydantic.networks._BaseMultiHostUrl.__deepcopy__(self,memo:dict)->Self
pydantic.networks._BaseMultiHostUrl.__eq__(self,other:Any)->bool
pydantic.networks._BaseMultiHostUrl.__get_pydantic_core_schema__(cls,source:type[_BaseMultiHostUrl],handler:GetCoreSchemaHandler)->core_schema.CoreSchema
pydantic.networks._BaseMultiHostUrl.__get_pydantic_json_schema__(cls,core_schema:core_schema.CoreSchema,handler:_schema_generation_shared.GetJsonSchemaHandler)->JsonSchemaValue
pydantic.networks._BaseMultiHostUrl.__hash__(self)->int
pydantic.networks._BaseMultiHostUrl.__init__(self,url:str|_CoreMultiHostUrl|_BaseMultiHostUrl)
pydantic.networks._BaseMultiHostUrl.__len__(self)->int
pydantic.networks._BaseMultiHostUrl.__repr__(self)->str
pydantic.networks._BaseMultiHostUrl.__str__(self)->str
pydantic.networks._BaseMultiHostUrl.build(cls,*,scheme:str,hosts:list[MultiHostHost]|None=None,username:str|None=None,password:str|None=None,host:str|None=None,port:int|None=None,path:str|None=None,query:str|None=None,fragment:str|None=None)->Self
pydantic.networks._BaseMultiHostUrl.fragment(self)->str | None
pydantic.networks._BaseMultiHostUrl.hosts(self)->list[MultiHostHost]
pydantic.networks._BaseMultiHostUrl.path(self)->str | None
pydantic.networks._BaseMultiHostUrl.query(self)->str | None
pydantic.networks._BaseMultiHostUrl.query_params(self)->list[tuple[str, str]]
pydantic.networks._BaseMultiHostUrl.scheme(self)->str
pydantic.networks._BaseMultiHostUrl.serialize_url(cls,url:Any,info:core_schema.SerializationInfo)->str | Self
pydantic.networks._BaseMultiHostUrl.unicode_string(self)->str
pydantic.networks._BaseUrl(self,url:str|_CoreUrl|_BaseUrl)
pydantic.networks._BaseUrl.__deepcopy__(self,memo:dict)->Self
pydantic.networks._BaseUrl.__eq__(self,other:Any)->bool
pydantic.networks._BaseUrl.__ge__(self,other:Any)->bool
pydantic.networks._BaseUrl.__get_pydantic_core_schema__(cls,source:type[_BaseUrl],handler:GetCoreSchemaHandler)->core_schema.CoreSchema
pydantic.networks._BaseUrl.__get_pydantic_json_schema__(cls,core_schema:core_schema.CoreSchema,handler:_schema_generation_shared.GetJsonSchemaHandler)->JsonSchemaValue
pydantic.networks._BaseUrl.__gt__(self,other:Any)->bool
pydantic.networks._BaseUrl.__hash__(self)->int
pydantic.networks._BaseUrl.__init__(self,url:str|_CoreUrl|_BaseUrl)
pydantic.networks._BaseUrl.__le__(self,other:Any)->bool
pydantic.networks._BaseUrl.__len__(self)->int
pydantic.networks._BaseUrl.__lt__(self,other:Any)->bool
pydantic.networks._BaseUrl.__repr__(self)->str
pydantic.networks._BaseUrl.__str__(self)->str
pydantic.networks._BaseUrl.build(cls,*,scheme:str,username:str|None=None,password:str|None=None,host:str,port:int|None=None,path:str|None=None,query:str|None=None,fragment:str|None=None)->Self
pydantic.networks._BaseUrl.fragment(self)->str | None
pydantic.networks._BaseUrl.host(self)->str | None
pydantic.networks._BaseUrl.password(self)->str | None
pydantic.networks._BaseUrl.path(self)->str | None
pydantic.networks._BaseUrl.port(self)->int | None
pydantic.networks._BaseUrl.query(self)->str | None
pydantic.networks._BaseUrl.query_params(self)->list[tuple[str, str]]
pydantic.networks._BaseUrl.scheme(self)->str
pydantic.networks._BaseUrl.serialize_url(cls,url:Any,info:core_schema.SerializationInfo)->str | Self
pydantic.networks._BaseUrl.unicode_host(self)->str | None
pydantic.networks._BaseUrl.unicode_string(self)->str
pydantic.networks._BaseUrl.username(self)->str | None
pydantic.networks._build_pretty_email_regex()->re.Pattern[str]
pydantic.networks._build_type_adapter(cls:type[_BaseUrl|_BaseMultiHostUrl])->TypeAdapter
pydantic.networks.import_email_validator()->None
pydantic.networks.validate_email(value:str)->tuple[str, str]
pydantic.validate_email(value:str)->tuple[str, str]


----------------------------------------/dataset/nuaa/anaconda3/envs/pydantic2.10.6/lib/python3.9/site-packages/pydantic/datetime_parse.py----------------------------------------
A:pydantic.datetime_parse.__getattr__->getattr_migration(__name__)


----------------------------------------/dataset/nuaa/anaconda3/envs/pydantic2.10.6/lib/python3.9/site-packages/pydantic/alias_generators.py----------------------------------------
A:pydantic.alias_generators.camel->to_pascal(snake)
A:pydantic.alias_generators.snake->snake.replace('-', '_').replace('-', '_')
pydantic.alias_generators.to_camel(snake:str)->str
pydantic.alias_generators.to_pascal(snake:str)->str
pydantic.alias_generators.to_snake(camel:str)->str


----------------------------------------/dataset/nuaa/anaconda3/envs/pydantic2.10.6/lib/python3.9/site-packages/pydantic/utils.py----------------------------------------
A:pydantic.utils.__getattr__->getattr_migration(__name__)


----------------------------------------/dataset/nuaa/anaconda3/envs/pydantic2.10.6/lib/python3.9/site-packages/pydantic/type_adapter.py----------------------------------------
A:pydantic.type_adapter.T->TypeVar('T')
A:pydantic.type_adapter.R->TypeVar('R')
A:pydantic.type_adapter.P->ParamSpec('P')
A:pydantic.type_adapter.TypeAdapterT->TypeVar('TypeAdapterT', bound='TypeAdapter')
A:pydantic.type_adapter.slots->getattr(obj, '__slots__', None)
A:pydantic.type_adapter.parent_frame->self._fetch_parent_frame()
A:pydantic.type_adapter.frame->sys._getframe(self._parent_depth)
A:pydantic.type_adapter.self.core_schema->_internal._generate_schema.GenerateSchema(config_wrapper, ns_resolver=ns_resolver).clean_schema(core_schema)
A:pydantic.type_adapter.self.validator->create_schema_validator(schema=self.core_schema, schema_type=self._type, schema_type_module=self._module_name, schema_type_name=str(self._type), schema_kind='TypeAdapter', config=core_config, plugin_settings=config_wrapper.plugin_settings)
A:pydantic.type_adapter.self.serializer->SchemaSerializer(self.core_schema, core_config)
A:pydantic.type_adapter.config_wrapper->_internal._config.ConfigWrapper(self._config)
A:pydantic.type_adapter.schema_generator->_internal._generate_schema.GenerateSchema(config_wrapper, ns_resolver=ns_resolver)
A:pydantic.type_adapter.core_schema->_internal._generate_schema.GenerateSchema(config_wrapper, ns_resolver=ns_resolver).generate_schema(self._type)
A:pydantic.type_adapter.core_config->_internal._config.ConfigWrapper(self._config).core_config(None)
A:pydantic.type_adapter.ns_resolver->_internal._namespace_utils.NsResolver(namespaces_tuple=_namespace_utils.NamespacesTuple(locals=rebuild_ns, globals=globalns), parent_namespace=rebuild_ns)
A:pydantic.type_adapter.schema_generator_instance->schema_generator(by_alias=by_alias, ref_template=ref_template)
A:pydantic.type_adapter.(json_schemas_map, definitions)->schema_generator(by_alias=by_alias, ref_template=ref_template).generate_definitions(inputs_)
pydantic.TypeAdapter(self,type:Any,*,config:ConfigDict|None=None,_parent_depth:int=2,module:str|None=None)
pydantic.TypeAdapter.__repr__(self)->str
pydantic.TypeAdapter._defer_build(self)->bool
pydantic.TypeAdapter._fetch_parent_frame(self)->FrameType | None
pydantic.TypeAdapter._init_core_attrs(self,ns_resolver:_namespace_utils.NsResolver,force:bool,raise_errors:bool=False)->bool
pydantic.TypeAdapter._model_config(self)->ConfigDict | None
pydantic.TypeAdapter.dump_json(self,instance:T,/,*,indent:int|None=None,include:IncEx|None=None,exclude:IncEx|None=None,by_alias:bool=False,exclude_unset:bool=False,exclude_defaults:bool=False,exclude_none:bool=False,round_trip:bool=False,warnings:bool|Literal['none','warn','error']=True,serialize_as_any:bool=False,context:dict[str,Any]|None=None)->bytes
pydantic.TypeAdapter.dump_python(self,instance:T,/,*,mode:Literal['json','python']='python',include:IncEx|None=None,exclude:IncEx|None=None,by_alias:bool=False,exclude_unset:bool=False,exclude_defaults:bool=False,exclude_none:bool=False,round_trip:bool=False,warnings:bool|Literal['none','warn','error']=True,serialize_as_any:bool=False,context:dict[str,Any]|None=None)->Any
pydantic.TypeAdapter.get_default_value(self,*,strict:bool|None=None,context:dict[str,Any]|None=None)->Some[T] | None
pydantic.TypeAdapter.json_schema(self,*,by_alias:bool=True,ref_template:str=DEFAULT_REF_TEMPLATE,schema_generator:type[GenerateJsonSchema]=GenerateJsonSchema,mode:JsonSchemaMode='validation')->dict[str, Any]
pydantic.TypeAdapter.json_schemas(inputs:Iterable[tuple[JsonSchemaKeyT,JsonSchemaMode,TypeAdapter[Any]]],/,*,by_alias:bool=True,title:str|None=None,description:str|None=None,ref_template:str=DEFAULT_REF_TEMPLATE,schema_generator:type[GenerateJsonSchema]=GenerateJsonSchema)->tuple[dict[tuple[JsonSchemaKeyT, JsonSchemaMode], JsonSchemaValue], JsonSchemaValue]
pydantic.TypeAdapter.rebuild(self,*,force:bool=False,raise_errors:bool=True,_parent_namespace_depth:int=2,_types_namespace:_namespace_utils.MappingNamespace|None=None)->bool | None
pydantic.TypeAdapter.validate_json(self,data:str|bytes|bytearray,/,*,strict:bool|None=None,context:dict[str,Any]|None=None,experimental_allow_partial:bool|Literal['off','on','trailing-strings']=False)->T
pydantic.TypeAdapter.validate_python(self,object:Any,/,*,strict:bool|None=None,from_attributes:bool|None=None,context:dict[str,Any]|None=None,experimental_allow_partial:bool|Literal['off','on','trailing-strings']=False)->T
pydantic.TypeAdapter.validate_strings(self,obj:Any,/,*,strict:bool|None=None,context:dict[str,Any]|None=None,experimental_allow_partial:bool|Literal['off','on','trailing-strings']=False)->T
pydantic.type_adapter.TypeAdapter(self,type:Any,*,config:ConfigDict|None=None,_parent_depth:int=2,module:str|None=None)
pydantic.type_adapter.TypeAdapter.__init__(self,type:Any,*,config:ConfigDict|None=None,_parent_depth:int=2,module:str|None=None)
pydantic.type_adapter.TypeAdapter.__repr__(self)->str
pydantic.type_adapter.TypeAdapter._defer_build(self)->bool
pydantic.type_adapter.TypeAdapter._fetch_parent_frame(self)->FrameType | None
pydantic.type_adapter.TypeAdapter._init_core_attrs(self,ns_resolver:_namespace_utils.NsResolver,force:bool,raise_errors:bool=False)->bool
pydantic.type_adapter.TypeAdapter._model_config(self)->ConfigDict | None
pydantic.type_adapter.TypeAdapter.dump_json(self,instance:T,/,*,indent:int|None=None,include:IncEx|None=None,exclude:IncEx|None=None,by_alias:bool=False,exclude_unset:bool=False,exclude_defaults:bool=False,exclude_none:bool=False,round_trip:bool=False,warnings:bool|Literal['none','warn','error']=True,serialize_as_any:bool=False,context:dict[str,Any]|None=None)->bytes
pydantic.type_adapter.TypeAdapter.dump_python(self,instance:T,/,*,mode:Literal['json','python']='python',include:IncEx|None=None,exclude:IncEx|None=None,by_alias:bool=False,exclude_unset:bool=False,exclude_defaults:bool=False,exclude_none:bool=False,round_trip:bool=False,warnings:bool|Literal['none','warn','error']=True,serialize_as_any:bool=False,context:dict[str,Any]|None=None)->Any
pydantic.type_adapter.TypeAdapter.get_default_value(self,*,strict:bool|None=None,context:dict[str,Any]|None=None)->Some[T] | None
pydantic.type_adapter.TypeAdapter.json_schema(self,*,by_alias:bool=True,ref_template:str=DEFAULT_REF_TEMPLATE,schema_generator:type[GenerateJsonSchema]=GenerateJsonSchema,mode:JsonSchemaMode='validation')->dict[str, Any]
pydantic.type_adapter.TypeAdapter.json_schemas(inputs:Iterable[tuple[JsonSchemaKeyT,JsonSchemaMode,TypeAdapter[Any]]],/,*,by_alias:bool=True,title:str|None=None,description:str|None=None,ref_template:str=DEFAULT_REF_TEMPLATE,schema_generator:type[GenerateJsonSchema]=GenerateJsonSchema)->tuple[dict[tuple[JsonSchemaKeyT, JsonSchemaMode], JsonSchemaValue], JsonSchemaValue]
pydantic.type_adapter.TypeAdapter.rebuild(self,*,force:bool=False,raise_errors:bool=True,_parent_namespace_depth:int=2,_types_namespace:_namespace_utils.MappingNamespace|None=None)->bool | None
pydantic.type_adapter.TypeAdapter.validate_json(self,data:str|bytes|bytearray,/,*,strict:bool|None=None,context:dict[str,Any]|None=None,experimental_allow_partial:bool|Literal['off','on','trailing-strings']=False)->T
pydantic.type_adapter.TypeAdapter.validate_python(self,object:Any,/,*,strict:bool|None=None,from_attributes:bool|None=None,context:dict[str,Any]|None=None,experimental_allow_partial:bool|Literal['off','on','trailing-strings']=False)->T
pydantic.type_adapter.TypeAdapter.validate_strings(self,obj:Any,/,*,strict:bool|None=None,context:dict[str,Any]|None=None,experimental_allow_partial:bool|Literal['off','on','trailing-strings']=False)->T
pydantic.type_adapter._getattr_no_parents(obj:Any,attribute:str)->Any
pydantic.type_adapter._type_has_config(type_:Any)->bool


----------------------------------------/dataset/nuaa/anaconda3/envs/pydantic2.10.6/lib/python3.9/site-packages/pydantic/color.py----------------------------------------
A:pydantic.color.self._rgba->parse_str(value)
A:pydantic.color.rgb->cast(Tuple[int, int, int], self.as_rgb_tuple())
A:pydantic.color.as_hex->''.join((as_hex[c] for c in range(0, len(as_hex), 2)))
A:pydantic.color.(h, s, li)->self.as_hsl_tuple(alpha=False)
A:pydantic.color.(h, s, li, a)->self.as_hsl_tuple(alpha=True)
A:pydantic.color.(h, l, s)->rgb_to_hls(self._rgba.r, self._rgba.g, self._rgba.b)
A:pydantic.color.value_lower->value.lower()
A:pydantic.color.m->re.fullmatch(r_hex_long, value_lower)
A:pydantic.color.(*rgb, a)->re.fullmatch(r_hex_long, value_lower).groups()
A:pydantic.color.color->float(value)
A:pydantic.color.alpha->float(value)
A:pydantic.color.h_value->float(h)
A:pydantic.color.(r, g, b)->hls_to_rgb(h_value, l_value, s_value)
pydantic.color.Color(self,value:ColorType)
pydantic.color.Color.__eq__(self,other:Any)->bool
pydantic.color.Color.__get_pydantic_core_schema__(cls,source:Type[Any],handler:Callable[[Any],CoreSchema])->core_schema.CoreSchema
pydantic.color.Color.__get_pydantic_json_schema__(cls,core_schema:core_schema.CoreSchema,handler:_GetJsonSchemaHandler)->JsonSchemaValue
pydantic.color.Color.__hash__(self)->int
pydantic.color.Color.__init__(self,value:ColorType)
pydantic.color.Color.__repr_args__(self)->'_repr.ReprArgs'
pydantic.color.Color.__str__(self)->str
pydantic.color.Color._alpha_float(self)->float
pydantic.color.Color._validate(cls,__input_value:Any,_:Any)->'Color'
pydantic.color.Color.as_hex(self)->str
pydantic.color.Color.as_hsl(self)->str
pydantic.color.Color.as_hsl_tuple(self,*,alpha:Optional[bool]=None)->HslColorTuple
pydantic.color.Color.as_named(self,*,fallback:bool=False)->str
pydantic.color.Color.as_rgb(self)->str
pydantic.color.Color.as_rgb_tuple(self,*,alpha:Optional[bool]=None)->ColorTuple
pydantic.color.Color.original(self)->ColorType
pydantic.color.RGBA(self,r:float,g:float,b:float,alpha:Optional[float])
pydantic.color.RGBA.__getitem__(self,item:Any)->Any
pydantic.color.RGBA.__init__(self,r:float,g:float,b:float,alpha:Optional[float])
pydantic.color.float_to_255(c:float)->int
pydantic.color.ints_to_rgba(r:Union[int,str],g:Union[int,str],b:Union[int,str],alpha:Optional[float]=None)->RGBA
pydantic.color.parse_color_value(value:Union[int,str],max_val:int=255)->float
pydantic.color.parse_float_alpha(value:Union[None,str,float,int])->Optional[float]
pydantic.color.parse_hsl(h:str,h_units:str,sat:str,light:str,alpha:Optional[float]=None)->RGBA
pydantic.color.parse_str(value:str)->RGBA
pydantic.color.parse_tuple(value:Tuple[Any,...])->RGBA


----------------------------------------/dataset/nuaa/anaconda3/envs/pydantic2.10.6/lib/python3.9/site-packages/pydantic/schema.py----------------------------------------
A:pydantic.schema.__getattr__->getattr_migration(__name__)


----------------------------------------/dataset/nuaa/anaconda3/envs/pydantic2.10.6/lib/python3.9/site-packages/pydantic/functional_validators.py----------------------------------------
A:pydantic.functional_validators.schema->handler(source_type)
A:pydantic.functional_validators.info_arg->_inspect_validator(self.func, 'wrap')
A:pydantic.functional_validators.func->cast(core_schema.NoInfoWrapValidatorFunction, self.func)
A:pydantic.functional_validators.serialization->handler(source_type).get('serialization', core_schema.wrap_serializer_function_ser_schema(function=lambda v, h: h(v), schema=schema, return_schema=handler.generate_schema(source_type)))
A:pydantic.functional_validators.input_schema->handler.generate_schema(self.json_schema_input_type)
A:pydantic.functional_validators._V2BeforeAfterOrPlainValidatorType->TypeVar('_V2BeforeAfterOrPlainValidatorType', bound=Union[_V2Validator, _PartialClsOrStaticMethod])
A:pydantic.functional_validators._V2WrapValidatorType->TypeVar('_V2WrapValidatorType', bound=Union[_V2WrapValidator, _PartialClsOrStaticMethod])
A:pydantic.functional_validators.f->_internal._decorators.ensure_classmethod_based_on_signature(f)
A:pydantic.functional_validators.dec_info->_internal._decorators.ModelValidatorDecoratorInfo(mode=mode)
A:pydantic.functional_validators._ModelType->TypeVar('_ModelType')
A:pydantic.functional_validators._ModelTypeCo->TypeVar('_ModelTypeCo', covariant=True)
A:pydantic.functional_validators.AnyType->TypeVar('AnyType')
A:pydantic.functional_validators.instance_of_schema->pydantic_core.core_schema.is_instance_schema(_generics.get_origin(source) or source)
A:pydantic.functional_validators.original_schema->handler(source)
A:pydantic.functional_validators.instance_of_schema['serialization']->pydantic_core.core_schema.wrap_serializer_function_ser_schema(function=lambda v, h: h(v), schema=original_schema)
pydantic.AfterValidator
pydantic.AfterValidator.__get_pydantic_core_schema__(self,source_type:Any,handler:GetCoreSchemaHandler)->core_schema.CoreSchema
pydantic.AfterValidator._from_decorator(cls,decorator:_decorators.Decorator[_decorators.FieldValidatorDecoratorInfo])->Self
pydantic.BeforeValidator
pydantic.BeforeValidator.__get_pydantic_core_schema__(self,source_type:Any,handler:GetCoreSchemaHandler)->core_schema.CoreSchema
pydantic.BeforeValidator._from_decorator(cls,decorator:_decorators.Decorator[_decorators.FieldValidatorDecoratorInfo])->Self
pydantic.ModelWrapValidatorHandler(self,value:Any,outer_location:str|int|None=None,/)
pydantic.PlainValidator
pydantic.PlainValidator.__get_pydantic_core_schema__(self,source_type:Any,handler:GetCoreSchemaHandler)->core_schema.CoreSchema
pydantic.PlainValidator._from_decorator(cls,decorator:_decorators.Decorator[_decorators.FieldValidatorDecoratorInfo])->Self
pydantic.WrapValidator
pydantic.WrapValidator.__get_pydantic_core_schema__(self,source_type:Any,handler:GetCoreSchemaHandler)->core_schema.CoreSchema
pydantic.WrapValidator._from_decorator(cls,decorator:_decorators.Decorator[_decorators.FieldValidatorDecoratorInfo])->Self
pydantic.field_validator(field:str,/,*fields:str,mode:FieldValidatorModes='after',check_fields:bool|None=None,json_schema_input_type:Any=PydanticUndefined)->Callable[[Any], Any]
pydantic.functional_validators.AfterValidator
pydantic.functional_validators.AfterValidator.__get_pydantic_core_schema__(self,source_type:Any,handler:GetCoreSchemaHandler)->core_schema.CoreSchema
pydantic.functional_validators.AfterValidator._from_decorator(cls,decorator:_decorators.Decorator[_decorators.FieldValidatorDecoratorInfo])->Self
pydantic.functional_validators.BeforeValidator
pydantic.functional_validators.BeforeValidator.__get_pydantic_core_schema__(self,source_type:Any,handler:GetCoreSchemaHandler)->core_schema.CoreSchema
pydantic.functional_validators.BeforeValidator._from_decorator(cls,decorator:_decorators.Decorator[_decorators.FieldValidatorDecoratorInfo])->Self
pydantic.functional_validators.FreeModelBeforeValidator(self,value:Any,info:_core_schema.ValidationInfo,/)
pydantic.functional_validators.FreeModelBeforeValidator.__call__(self,value:Any,info:_core_schema.ValidationInfo,/)
pydantic.functional_validators.FreeModelBeforeValidatorWithoutInfo(self,value:Any,/)
pydantic.functional_validators.FreeModelBeforeValidatorWithoutInfo.__call__(self,value:Any,/)
pydantic.functional_validators.ModelBeforeValidator(self,cls:Any,value:Any,info:_core_schema.ValidationInfo,/)
pydantic.functional_validators.ModelBeforeValidator.__call__(self,cls:Any,value:Any,info:_core_schema.ValidationInfo,/)
pydantic.functional_validators.ModelBeforeValidatorWithoutInfo(self,cls:Any,value:Any,/)
pydantic.functional_validators.ModelBeforeValidatorWithoutInfo.__call__(self,cls:Any,value:Any,/)
pydantic.functional_validators.ModelWrapValidator(self,cls:type[_ModelType],value:Any,handler:ModelWrapValidatorHandler[_ModelType],info:_core_schema.ValidationInfo,/)
pydantic.functional_validators.ModelWrapValidator.__call__(self,cls:type[_ModelType],value:Any,handler:ModelWrapValidatorHandler[_ModelType],info:_core_schema.ValidationInfo,/)
pydantic.functional_validators.ModelWrapValidatorHandler(self,value:Any,outer_location:str|int|None=None,/)
pydantic.functional_validators.ModelWrapValidatorHandler.__call__(self,value:Any,outer_location:str|int|None=None,/)
pydantic.functional_validators.ModelWrapValidatorWithoutInfo(self,cls:type[_ModelType],value:Any,handler:ModelWrapValidatorHandler[_ModelType],/)
pydantic.functional_validators.ModelWrapValidatorWithoutInfo.__call__(self,cls:type[_ModelType],value:Any,handler:ModelWrapValidatorHandler[_ModelType],/)
pydantic.functional_validators.PlainValidator
pydantic.functional_validators.PlainValidator.__get_pydantic_core_schema__(self,source_type:Any,handler:GetCoreSchemaHandler)->core_schema.CoreSchema
pydantic.functional_validators.PlainValidator._from_decorator(cls,decorator:_decorators.Decorator[_decorators.FieldValidatorDecoratorInfo])->Self
pydantic.functional_validators.WrapValidator
pydantic.functional_validators.WrapValidator.__get_pydantic_core_schema__(self,source_type:Any,handler:GetCoreSchemaHandler)->core_schema.CoreSchema
pydantic.functional_validators.WrapValidator._from_decorator(cls,decorator:_decorators.Decorator[_decorators.FieldValidatorDecoratorInfo])->Self
pydantic.functional_validators.field_validator(field:str,/,*fields:str,mode:FieldValidatorModes='after',check_fields:bool|None=None,json_schema_input_type:Any=PydanticUndefined)->Callable[[Any], Any]
pydantic.functional_validators.model_validator(*,mode:Literal['wrap','before','after'])->Any
pydantic.model_validator(*,mode:Literal['wrap','before','after'])->Any


----------------------------------------/dataset/nuaa/anaconda3/envs/pydantic2.10.6/lib/python3.9/site-packages/pydantic/version.py----------------------------------------
A:pydantic.version.pydantic_dir->os.path.abspath(os.path.dirname(os.path.dirname(__file__)))
pydantic.version.parse_mypy_version(version:str)->tuple[int, int, int]
pydantic.version.version_info()->str
pydantic.version.version_short()->str


----------------------------------------/dataset/nuaa/anaconda3/envs/pydantic2.10.6/lib/python3.9/site-packages/pydantic/aliases.py----------------------------------------
A:pydantic.aliases.alias->self._generate_alias('alias', (str,), field_name)
A:pydantic.aliases.validation_alias->self._generate_alias('validation_alias', (str, AliasChoices, AliasPath), field_name)
A:pydantic.aliases.serialization_alias->self._generate_alias('serialization_alias', (str,), field_name)
pydantic.AliasChoices(self,first_choice:str|AliasPath,*choices:str|AliasPath)
pydantic.AliasChoices.convert_to_aliases(self)->list[list[str | int]]
pydantic.AliasGenerator
pydantic.AliasGenerator._generate_alias(self,alias_kind:Literal['alias','validation_alias','serialization_alias'],allowed_types:tuple[type[str]|type[AliasPath]|type[AliasChoices],...],field_name:str)->str | AliasPath | AliasChoices | None
pydantic.AliasGenerator.generate_aliases(self,field_name:str)->tuple[str | None, str | AliasPath | AliasChoices | None, str | None]
pydantic.AliasPath(self,first_arg:str,*args:str|int)
pydantic.AliasPath.convert_to_aliases(self)->list[str | int]
pydantic.AliasPath.search_dict_for_path(self,d:dict)->Any
pydantic.aliases.AliasChoices(self,first_choice:str|AliasPath,*choices:str|AliasPath)
pydantic.aliases.AliasChoices.__init__(self,first_choice:str|AliasPath,*choices:str|AliasPath)
pydantic.aliases.AliasChoices.convert_to_aliases(self)->list[list[str | int]]
pydantic.aliases.AliasGenerator
pydantic.aliases.AliasGenerator._generate_alias(self,alias_kind:Literal['alias','validation_alias','serialization_alias'],allowed_types:tuple[type[str]|type[AliasPath]|type[AliasChoices],...],field_name:str)->str | AliasPath | AliasChoices | None
pydantic.aliases.AliasGenerator.generate_aliases(self,field_name:str)->tuple[str | None, str | AliasPath | AliasChoices | None, str | None]
pydantic.aliases.AliasPath(self,first_arg:str,*args:str|int)
pydantic.aliases.AliasPath.__init__(self,first_arg:str,*args:str|int)
pydantic.aliases.AliasPath.convert_to_aliases(self)->list[str | int]
pydantic.aliases.AliasPath.search_dict_for_path(self,d:dict)->Any


----------------------------------------/dataset/nuaa/anaconda3/envs/pydantic2.10.6/lib/python3.9/site-packages/pydantic/class_validators.py----------------------------------------
A:pydantic.class_validators.__getattr__->getattr_migration(__name__)


----------------------------------------/dataset/nuaa/anaconda3/envs/pydantic2.10.6/lib/python3.9/site-packages/pydantic/config.py----------------------------------------
A:pydantic.config._TypeT->TypeVar('_TypeT', bound=type)
A:pydantic.config.__getattr__->getattr_migration(__name__)
pydantic.ConfigDict(TypedDict,total=False)
pydantic.config.ConfigDict(TypedDict,total=False)
pydantic.config.with_config(config:ConfigDict)->Callable[[_TypeT], _TypeT]
pydantic.with_config(config:ConfigDict)->Callable[[_TypeT], _TypeT]


----------------------------------------/dataset/nuaa/anaconda3/envs/pydantic2.10.6/lib/python3.9/site-packages/pydantic/validate_call_decorator.py----------------------------------------
A:pydantic.validate_call_decorator.AnyCallableT->TypeVar('AnyCallableT', bound=Callable[..., Any])
A:pydantic.validate_call_decorator.parent_namespace->_internal._typing_extra.parent_frame_namespace()
A:pydantic.validate_call_decorator.validate_call_wrapper->_internal._validate_call.ValidateCallWrapper(cast(_generate_schema.ValidateCallSupportedTypes, function), config, validate_return, parent_namespace)
pydantic.validate_call(func:AnyCallableT|None=None,/,*,config:ConfigDict|None=None,validate_return:bool=False)->AnyCallableT | Callable[[AnyCallableT], AnyCallableT]
pydantic.validate_call_decorator._check_function_type(function:object)->None
pydantic.validate_call_decorator.validate_call(func:AnyCallableT|None=None,/,*,config:ConfigDict|None=None,validate_return:bool=False)->AnyCallableT | Callable[[AnyCallableT], AnyCallableT]


----------------------------------------/dataset/nuaa/anaconda3/envs/pydantic2.10.6/lib/python3.9/site-packages/pydantic/generics.py----------------------------------------
A:pydantic.generics.__getattr__->getattr_migration(__name__)


----------------------------------------/dataset/nuaa/anaconda3/envs/pydantic2.10.6/lib/python3.9/site-packages/pydantic/errors.py----------------------------------------
A:pydantic.errors.name->re.search(".*'(.+?)'", str(name_error)).group(1)
A:pydantic.errors.__getattr__->getattr_migration(__name__)
pydantic.PydanticErrorMixin(self,message:str,*,code:PydanticErrorCodes|None)
pydantic.PydanticErrorMixin.__str__(self)->str
pydantic.PydanticImportError(self,message:str)
pydantic.PydanticInvalidForJsonSchema(self,message:str)
pydantic.PydanticSchemaGenerationError(self,message:str)
pydantic.PydanticUndefinedAnnotation(self,name:str,message:str)
pydantic.PydanticUndefinedAnnotation.from_name_error(cls,name_error:NameError)->Self
pydantic.PydanticUserError(PydanticErrorMixin,TypeError)
pydantic.errors.PydanticErrorMixin(self,message:str,*,code:PydanticErrorCodes|None)
pydantic.errors.PydanticErrorMixin.__init__(self,message:str,*,code:PydanticErrorCodes|None)
pydantic.errors.PydanticErrorMixin.__str__(self)->str
pydantic.errors.PydanticImportError(self,message:str)
pydantic.errors.PydanticImportError.__init__(self,message:str)
pydantic.errors.PydanticInvalidForJsonSchema(self,message:str)
pydantic.errors.PydanticInvalidForJsonSchema.__init__(self,message:str)
pydantic.errors.PydanticSchemaGenerationError(self,message:str)
pydantic.errors.PydanticSchemaGenerationError.__init__(self,message:str)
pydantic.errors.PydanticUndefinedAnnotation(self,name:str,message:str)
pydantic.errors.PydanticUndefinedAnnotation.__init__(self,name:str,message:str)
pydantic.errors.PydanticUndefinedAnnotation.from_name_error(cls,name_error:NameError)->Self
pydantic.errors.PydanticUserError(PydanticErrorMixin,TypeError)


----------------------------------------/dataset/nuaa/anaconda3/envs/pydantic2.10.6/lib/python3.9/site-packages/pydantic/types.py----------------------------------------
A:pydantic.types.T->TypeVar('T')
A:pydantic.types.HashableItemType->TypeVar('HashableItemType', bound=Hashable)
A:pydantic.types.AnyItemType->TypeVar('AnyItemType')
A:pydantic.types.AnyType->TypeVar('AnyType')
A:pydantic.types.serializer->pydantic_core.core_schema.plain_serializer_function_ser_schema(cls._serialize, when_used='json')
A:pydantic.types.field_schema->handler(core_schema)
A:pydantic.types.schema->handler(source_type)
A:pydantic.types.SecretType->TypeVar('SecretType')
A:pydantic.types.origin_type->get_origin(source)
A:pydantic.types.bases->getattr(cls, '__orig_bases__', getattr(cls, '__bases__', []))
A:pydantic.types.inner_schema->handler.generate_schema(inner_type)
A:pydantic.types.value->value.get_secret_value().get_secret_value()
A:pydantic.types.validated_inner->handler(value)
A:pydantic.types.__pydantic_serializer__->SchemaSerializer(core_schema.any_schema(serialization=core_schema.plain_serializer_function_ser_schema(_serialize_secret_field, info_arg=True, when_used='always')))
A:pydantic.types.json_schema->pydantic_core.core_schema.no_info_after_validator_function(source, cls._inner_schema)
A:pydantic.types.card_number->self.validate_luhn_check_digit(card_number)
A:pydantic.types.self.brand->self.validate_brand(card_number)
A:pydantic.types.sum_->int(card_number[-1])
A:pydantic.types.length->len(card_number)
A:pydantic.types.digit->int(card_number[i])
A:pydantic.types.byte_string_re->re.compile(byte_string_pattern, re.IGNORECASE)
A:pydantic.types.str_match->cls.byte_string_re.match(str(input_value))
A:pydantic.types.(scalar, unit)->cls.byte_string_re.match(str(input_value)).groups()
A:pydantic.types.num->float(self)
A:pydantic.types.__getattr__->getattr_migration(__name__)
A:pydantic.types.metadata->choice.get('metadata')
A:pydantic.types.origin->_internal._typing_extra.get_origin(source_type)
A:pydantic.types.original_schema->pydantic_core.core_schema.union_schema([original_schema])
A:pydantic.types.metadata_tag->choice.get('metadata').get(_core_utils.TAGGED_UNION_TAG_KEY)
A:pydantic.types.custom_error_type->pydantic_core.core_schema.union_schema([original_schema]).get('custom_error_type')
A:pydantic.types.custom_error_message->pydantic_core.core_schema.union_schema([original_schema]).get('custom_error_message')
A:pydantic.types.custom_error_context->pydantic_core.core_schema.union_schema([original_schema]).get('custom_error_context')
A:pydantic.types.type_->type(x)
A:pydantic.types.python_schema->handler(source_type)
A:pydantic.types.JsonValue->TypeAliasType('JsonValue', Annotated[Union[Annotated[List['JsonValue'], Tag('list')], Annotated[Dict[str, 'JsonValue'], Tag('dict')], Annotated[str, Tag('str')], Annotated[bool, Tag('bool')], Annotated[int, Tag('int')], Annotated[float, Tag('float')], Annotated[None, Tag('NoneType')]], Discriminator(_get_type_name, custom_error_type='invalid-json-value', custom_error_message='input was not a valid JSON value'), _AllowAnyJson])
pydantic.AllowInfNan(_fields.PydanticMetadata)
pydantic.AllowInfNan.__hash__(self)->int
pydantic.Base64Encoder(EncoderProtocol)
pydantic.Base64Encoder.decode(cls,data:bytes)->bytes
pydantic.Base64Encoder.encode(cls,value:bytes)->bytes
pydantic.Base64Encoder.get_json_format(cls)->Literal['base64']
pydantic.Base64UrlEncoder(EncoderProtocol)
pydantic.Base64UrlEncoder.decode(cls,data:bytes)->bytes
pydantic.Base64UrlEncoder.encode(cls,value:bytes)->bytes
pydantic.Base64UrlEncoder.get_json_format(cls)->Literal['base64url']
pydantic.ByteSize(int)
pydantic.ByteSize.__get_pydantic_core_schema__(cls,source:type[Any],handler:GetCoreSchemaHandler)->core_schema.CoreSchema
pydantic.ByteSize._validate(cls,input_value:Any,/,_:core_schema.ValidationInfo)->ByteSize
pydantic.ByteSize.human_readable(self,decimal:bool=False,separator:str='')->str
pydantic.ByteSize.to(self,unit:str)->float
pydantic.Discriminator
pydantic.Discriminator.__get_pydantic_core_schema__(self,source_type:Any,handler:GetCoreSchemaHandler)->CoreSchema
pydantic.Discriminator._convert_schema(self,original_schema:core_schema.CoreSchema)->core_schema.TaggedUnionSchema
pydantic.EncodedBytes
pydantic.EncodedBytes.__get_pydantic_core_schema__(self,source:type[Any],handler:GetCoreSchemaHandler)->core_schema.CoreSchema
pydantic.EncodedBytes.__get_pydantic_json_schema__(self,core_schema:core_schema.CoreSchema,handler:GetJsonSchemaHandler)->JsonSchemaValue
pydantic.EncodedBytes.__hash__(self)->int
pydantic.EncodedBytes.decode(self,data:bytes,_:core_schema.ValidationInfo)->bytes
pydantic.EncodedBytes.encode(self,value:bytes)->bytes
pydantic.EncodedStr
pydantic.EncodedStr.__get_pydantic_core_schema__(self,source:type[Any],handler:GetCoreSchemaHandler)->core_schema.CoreSchema
pydantic.EncodedStr.__get_pydantic_json_schema__(self,core_schema:core_schema.CoreSchema,handler:GetJsonSchemaHandler)->JsonSchemaValue
pydantic.EncodedStr.__hash__(self)->int
pydantic.EncodedStr.decode_str(self,data:str,_:core_schema.ValidationInfo)->str
pydantic.EncodedStr.encode_str(self,value:str)->str
pydantic.EncoderProtocol(Protocol)
pydantic.EncoderProtocol.decode(cls,data:bytes)->bytes
pydantic.EncoderProtocol.encode(cls,value:bytes)->bytes
pydantic.EncoderProtocol.get_json_format(cls)->str
pydantic.FailFast(_fields.PydanticMetadata,BaseMetadata)
pydantic.GetPydanticSchema
pydantic.PathType
pydantic.PathType.__get_pydantic_core_schema__(self,source:Any,handler:GetCoreSchemaHandler)->core_schema.CoreSchema
pydantic.PathType.__get_pydantic_json_schema__(self,core_schema:core_schema.CoreSchema,handler:GetJsonSchemaHandler)->JsonSchemaValue
pydantic.PathType.__hash__(self)->int
pydantic.PathType.validate_directory(path:Path,_:core_schema.ValidationInfo)->Path
pydantic.PathType.validate_file(path:Path,_:core_schema.ValidationInfo)->Path
pydantic.PathType.validate_new(path:Path,_:core_schema.ValidationInfo)->Path
pydantic.PathType.validate_socket(path:Path,_:core_schema.ValidationInfo)->Path
pydantic.PaymentCardBrand(str,Enum)
pydantic.PaymentCardBrand.__str__(self)->str
pydantic.PaymentCardNumber(self,card_number:str)
pydantic.PaymentCardNumber.__get_pydantic_core_schema__(cls,source:type[Any],handler:GetCoreSchemaHandler)->core_schema.CoreSchema
pydantic.PaymentCardNumber.masked(self)->str
pydantic.PaymentCardNumber.validate(cls,input_value:str,/,_:core_schema.ValidationInfo)->PaymentCardNumber
pydantic.PaymentCardNumber.validate_brand(card_number:str)->PaymentCardBrand
pydantic.PaymentCardNumber.validate_digits(cls,card_number:str)->None
pydantic.PaymentCardNumber.validate_luhn_check_digit(cls,card_number:str)->str
pydantic.Secret(_SecretBase[SecretType])
pydantic.Secret.__get_pydantic_core_schema__(cls,source:type[Any],handler:GetCoreSchemaHandler)->core_schema.CoreSchema
pydantic.Secret._display(self)->str | bytes
pydantic.SecretBytes(_SecretField[bytes])
pydantic.SecretBytes.__len__(self)->int
pydantic.SecretBytes._display(self)->bytes
pydantic.SecretStr(_SecretField[str])
pydantic.SecretStr.__len__(self)->int
pydantic.SecretStr._display(self)->str
pydantic.Strict(_fields.PydanticMetadata,BaseMetadata)
pydantic.Strict.__hash__(self)->int
pydantic.StringConstraints(annotated_types.GroupedMetadata)
pydantic.StringConstraints.__iter__(self)->Iterator[BaseMetadata]
pydantic.Tag
pydantic.Tag.__get_pydantic_core_schema__(self,source_type:Any,handler:GetCoreSchemaHandler)->CoreSchema
pydantic.UuidVersion
pydantic.UuidVersion.__get_pydantic_core_schema__(self,source:Any,handler:GetCoreSchemaHandler)->core_schema.CoreSchema
pydantic.UuidVersion.__get_pydantic_json_schema__(self,core_schema:core_schema.CoreSchema,handler:GetJsonSchemaHandler)->JsonSchemaValue
pydantic.UuidVersion.__hash__(self)->int
pydantic._AllowAnyJson
pydantic._AllowAnyJson.__get_pydantic_core_schema__(cls,source_type:Any,handler:GetCoreSchemaHandler)->CoreSchema
pydantic._OnErrorOmit
pydantic._OnErrorOmit.__get_pydantic_core_schema__(cls,source_type:Any,handler:GetCoreSchemaHandler)->CoreSchema
pydantic._SecretBase(self,secret_value:SecretType)
pydantic._SecretBase.__eq__(self,other:Any)->bool
pydantic._SecretBase.__hash__(self)->int
pydantic._SecretBase.__repr__(self)->str
pydantic._SecretBase.__str__(self)->str
pydantic._SecretBase._display(self)->str | bytes
pydantic._SecretBase.get_secret_value(self)->SecretType
pydantic._SecretField(_SecretBase[SecretType])
pydantic._SecretField.__get_pydantic_core_schema__(cls,source:type[Any],handler:GetCoreSchemaHandler)->core_schema.CoreSchema
pydantic._check_annotated_type(annotated_type:str,expected_type:str,annotation:str)->None
pydantic._get_type_name(x:Any)->str
pydantic._secret_display(value:SecretType)->str
pydantic._serialize_secret(value:Secret[SecretType],info:core_schema.SerializationInfo)->str | Secret[SecretType]
pydantic._serialize_secret_field(value:_SecretField[SecretType],info:core_schema.SerializationInfo)->str | _SecretField[SecretType]
pydantic.conbytes(*,min_length:int|None=None,max_length:int|None=None,strict:bool|None=None)->type[bytes]
pydantic.condate(*,strict:bool|None=None,gt:date|None=None,ge:date|None=None,lt:date|None=None,le:date|None=None)->type[date]
pydantic.condecimal(*,strict:bool|None=None,gt:int|Decimal|None=None,ge:int|Decimal|None=None,lt:int|Decimal|None=None,le:int|Decimal|None=None,multiple_of:int|Decimal|None=None,max_digits:int|None=None,decimal_places:int|None=None,allow_inf_nan:bool|None=None)->type[Decimal]
pydantic.confloat(*,strict:bool|None=None,gt:float|None=None,ge:float|None=None,lt:float|None=None,le:float|None=None,multiple_of:float|None=None,allow_inf_nan:bool|None=None)->type[float]
pydantic.confrozenset(item_type:type[HashableItemType],*,min_length:int|None=None,max_length:int|None=None)->type[frozenset[HashableItemType]]
pydantic.conint(*,strict:bool|None=None,gt:int|None=None,ge:int|None=None,lt:int|None=None,le:int|None=None,multiple_of:int|None=None)->type[int]
pydantic.conlist(item_type:type[AnyItemType],*,min_length:int|None=None,max_length:int|None=None,unique_items:bool|None=None)->type[list[AnyItemType]]
pydantic.conset(item_type:type[HashableItemType],*,min_length:int|None=None,max_length:int|None=None)->type[set[HashableItemType]]
pydantic.constr(*,strip_whitespace:bool|None=None,to_upper:bool|None=None,to_lower:bool|None=None,strict:bool|None=None,min_length:int|None=None,max_length:int|None=None,pattern:str|Pattern[str]|None=None)->type[str]
pydantic.types.AllowInfNan(_fields.PydanticMetadata)
pydantic.types.AllowInfNan.__hash__(self)->int
pydantic.types.Base64Encoder(EncoderProtocol)
pydantic.types.Base64Encoder.decode(cls,data:bytes)->bytes
pydantic.types.Base64Encoder.encode(cls,value:bytes)->bytes
pydantic.types.Base64Encoder.get_json_format(cls)->Literal['base64']
pydantic.types.Base64UrlEncoder(EncoderProtocol)
pydantic.types.Base64UrlEncoder.decode(cls,data:bytes)->bytes
pydantic.types.Base64UrlEncoder.encode(cls,value:bytes)->bytes
pydantic.types.Base64UrlEncoder.get_json_format(cls)->Literal['base64url']
pydantic.types.ByteSize(int)
pydantic.types.ByteSize.__get_pydantic_core_schema__(cls,source:type[Any],handler:GetCoreSchemaHandler)->core_schema.CoreSchema
pydantic.types.ByteSize._validate(cls,input_value:Any,/,_:core_schema.ValidationInfo)->ByteSize
pydantic.types.ByteSize.human_readable(self,decimal:bool=False,separator:str='')->str
pydantic.types.ByteSize.to(self,unit:str)->float
pydantic.types.Discriminator
pydantic.types.Discriminator.__get_pydantic_core_schema__(self,source_type:Any,handler:GetCoreSchemaHandler)->CoreSchema
pydantic.types.Discriminator._convert_schema(self,original_schema:core_schema.CoreSchema)->core_schema.TaggedUnionSchema
pydantic.types.EncodedBytes
pydantic.types.EncodedBytes.__get_pydantic_core_schema__(self,source:type[Any],handler:GetCoreSchemaHandler)->core_schema.CoreSchema
pydantic.types.EncodedBytes.__get_pydantic_json_schema__(self,core_schema:core_schema.CoreSchema,handler:GetJsonSchemaHandler)->JsonSchemaValue
pydantic.types.EncodedBytes.__hash__(self)->int
pydantic.types.EncodedBytes.decode(self,data:bytes,_:core_schema.ValidationInfo)->bytes
pydantic.types.EncodedBytes.encode(self,value:bytes)->bytes
pydantic.types.EncodedStr
pydantic.types.EncodedStr.__get_pydantic_core_schema__(self,source:type[Any],handler:GetCoreSchemaHandler)->core_schema.CoreSchema
pydantic.types.EncodedStr.__get_pydantic_json_schema__(self,core_schema:core_schema.CoreSchema,handler:GetJsonSchemaHandler)->JsonSchemaValue
pydantic.types.EncodedStr.__hash__(self)->int
pydantic.types.EncodedStr.decode_str(self,data:str,_:core_schema.ValidationInfo)->str
pydantic.types.EncodedStr.encode_str(self,value:str)->str
pydantic.types.EncoderProtocol(Protocol)
pydantic.types.EncoderProtocol.decode(cls,data:bytes)->bytes
pydantic.types.EncoderProtocol.encode(cls,value:bytes)->bytes
pydantic.types.EncoderProtocol.get_json_format(cls)->str
pydantic.types.FailFast(_fields.PydanticMetadata,BaseMetadata)
pydantic.types.GetPydanticSchema
pydantic.types.PathType
pydantic.types.PathType.__get_pydantic_core_schema__(self,source:Any,handler:GetCoreSchemaHandler)->core_schema.CoreSchema
pydantic.types.PathType.__get_pydantic_json_schema__(self,core_schema:core_schema.CoreSchema,handler:GetJsonSchemaHandler)->JsonSchemaValue
pydantic.types.PathType.__hash__(self)->int
pydantic.types.PathType.validate_directory(path:Path,_:core_schema.ValidationInfo)->Path
pydantic.types.PathType.validate_file(path:Path,_:core_schema.ValidationInfo)->Path
pydantic.types.PathType.validate_new(path:Path,_:core_schema.ValidationInfo)->Path
pydantic.types.PathType.validate_socket(path:Path,_:core_schema.ValidationInfo)->Path
pydantic.types.PaymentCardBrand(str,Enum)
pydantic.types.PaymentCardBrand.__str__(self)->str
pydantic.types.PaymentCardNumber(self,card_number:str)
pydantic.types.PaymentCardNumber.__get_pydantic_core_schema__(cls,source:type[Any],handler:GetCoreSchemaHandler)->core_schema.CoreSchema
pydantic.types.PaymentCardNumber.__init__(self,card_number:str)
pydantic.types.PaymentCardNumber.masked(self)->str
pydantic.types.PaymentCardNumber.validate(cls,input_value:str,/,_:core_schema.ValidationInfo)->PaymentCardNumber
pydantic.types.PaymentCardNumber.validate_brand(card_number:str)->PaymentCardBrand
pydantic.types.PaymentCardNumber.validate_digits(cls,card_number:str)->None
pydantic.types.PaymentCardNumber.validate_luhn_check_digit(cls,card_number:str)->str
pydantic.types.Secret(_SecretBase[SecretType])
pydantic.types.Secret.__get_pydantic_core_schema__(cls,source:type[Any],handler:GetCoreSchemaHandler)->core_schema.CoreSchema
pydantic.types.Secret._display(self)->str | bytes
pydantic.types.SecretBytes(_SecretField[bytes])
pydantic.types.SecretBytes.__len__(self)->int
pydantic.types.SecretBytes._display(self)->bytes
pydantic.types.SecretStr(_SecretField[str])
pydantic.types.SecretStr.__len__(self)->int
pydantic.types.SecretStr._display(self)->str
pydantic.types.Strict(_fields.PydanticMetadata,BaseMetadata)
pydantic.types.Strict.__hash__(self)->int
pydantic.types.StringConstraints(annotated_types.GroupedMetadata)
pydantic.types.StringConstraints.__iter__(self)->Iterator[BaseMetadata]
pydantic.types.Tag
pydantic.types.Tag.__get_pydantic_core_schema__(self,source_type:Any,handler:GetCoreSchemaHandler)->CoreSchema
pydantic.types.UuidVersion
pydantic.types.UuidVersion.__get_pydantic_core_schema__(self,source:Any,handler:GetCoreSchemaHandler)->core_schema.CoreSchema
pydantic.types.UuidVersion.__get_pydantic_json_schema__(self,core_schema:core_schema.CoreSchema,handler:GetJsonSchemaHandler)->JsonSchemaValue
pydantic.types.UuidVersion.__hash__(self)->int
pydantic.types._AllowAnyJson
pydantic.types._AllowAnyJson.__get_pydantic_core_schema__(cls,source_type:Any,handler:GetCoreSchemaHandler)->CoreSchema
pydantic.types._OnErrorOmit
pydantic.types._OnErrorOmit.__get_pydantic_core_schema__(cls,source_type:Any,handler:GetCoreSchemaHandler)->CoreSchema
pydantic.types._SecretBase(self,secret_value:SecretType)
pydantic.types._SecretBase.__eq__(self,other:Any)->bool
pydantic.types._SecretBase.__hash__(self)->int
pydantic.types._SecretBase.__init__(self,secret_value:SecretType)
pydantic.types._SecretBase.__repr__(self)->str
pydantic.types._SecretBase.__str__(self)->str
pydantic.types._SecretBase._display(self)->str | bytes
pydantic.types._SecretBase.get_secret_value(self)->SecretType
pydantic.types._SecretField(_SecretBase[SecretType])
pydantic.types._SecretField.__get_pydantic_core_schema__(cls,source:type[Any],handler:GetCoreSchemaHandler)->core_schema.CoreSchema
pydantic.types._check_annotated_type(annotated_type:str,expected_type:str,annotation:str)->None
pydantic.types._get_type_name(x:Any)->str
pydantic.types._secret_display(value:SecretType)->str
pydantic.types._serialize_secret(value:Secret[SecretType],info:core_schema.SerializationInfo)->str | Secret[SecretType]
pydantic.types._serialize_secret_field(value:_SecretField[SecretType],info:core_schema.SerializationInfo)->str | _SecretField[SecretType]
pydantic.types.conbytes(*,min_length:int|None=None,max_length:int|None=None,strict:bool|None=None)->type[bytes]
pydantic.types.condate(*,strict:bool|None=None,gt:date|None=None,ge:date|None=None,lt:date|None=None,le:date|None=None)->type[date]
pydantic.types.condecimal(*,strict:bool|None=None,gt:int|Decimal|None=None,ge:int|Decimal|None=None,lt:int|Decimal|None=None,le:int|Decimal|None=None,multiple_of:int|Decimal|None=None,max_digits:int|None=None,decimal_places:int|None=None,allow_inf_nan:bool|None=None)->type[Decimal]
pydantic.types.confloat(*,strict:bool|None=None,gt:float|None=None,ge:float|None=None,lt:float|None=None,le:float|None=None,multiple_of:float|None=None,allow_inf_nan:bool|None=None)->type[float]
pydantic.types.confrozenset(item_type:type[HashableItemType],*,min_length:int|None=None,max_length:int|None=None)->type[frozenset[HashableItemType]]
pydantic.types.conint(*,strict:bool|None=None,gt:int|None=None,ge:int|None=None,lt:int|None=None,le:int|None=None,multiple_of:int|None=None)->type[int]
pydantic.types.conlist(item_type:type[AnyItemType],*,min_length:int|None=None,max_length:int|None=None,unique_items:bool|None=None)->type[list[AnyItemType]]
pydantic.types.conset(item_type:type[HashableItemType],*,min_length:int|None=None,max_length:int|None=None)->type[set[HashableItemType]]
pydantic.types.constr(*,strip_whitespace:bool|None=None,to_upper:bool|None=None,to_lower:bool|None=None,strict:bool|None=None,min_length:int|None=None,max_length:int|None=None,pattern:str|Pattern[str]|None=None)->type[str]


----------------------------------------/dataset/nuaa/anaconda3/envs/pydantic2.10.6/lib/python3.9/site-packages/pydantic/tools.py----------------------------------------
A:pydantic.tools.__getattr__->getattr_migration(__name__)


----------------------------------------/dataset/nuaa/anaconda3/envs/pydantic2.10.6/lib/python3.9/site-packages/pydantic/json.py----------------------------------------
A:pydantic.json.__getattr__->getattr_migration(__name__)


----------------------------------------/dataset/nuaa/anaconda3/envs/pydantic2.10.6/lib/python3.9/site-packages/pydantic/warnings.py----------------------------------------
A:pydantic.warnings.self.message->message.rstrip('.')
pydantic.PydanticDeprecatedSince20(self,message:str,*args:object)
pydantic.PydanticDeprecatedSince26(self,message:str,*args:object)
pydantic.PydanticDeprecatedSince29(self,message:str,*args:object)
pydantic.PydanticDeprecationWarning(self,message:str,*args:object,since:tuple[int,int],expected_removal:tuple[int,int]|None=None)
pydantic.PydanticDeprecationWarning.__str__(self)->str
pydantic.PydanticExperimentalWarning(Warning)
pydantic.warnings.GenericBeforeBaseModelWarning(Warning)
pydantic.warnings.PydanticDeprecatedSince20(self,message:str,*args:object)
pydantic.warnings.PydanticDeprecatedSince20.__init__(self,message:str,*args:object)
pydantic.warnings.PydanticDeprecatedSince210(self,message:str,*args:object)
pydantic.warnings.PydanticDeprecatedSince210.__init__(self,message:str,*args:object)
pydantic.warnings.PydanticDeprecatedSince26(self,message:str,*args:object)
pydantic.warnings.PydanticDeprecatedSince26.__init__(self,message:str,*args:object)
pydantic.warnings.PydanticDeprecatedSince29(self,message:str,*args:object)
pydantic.warnings.PydanticDeprecatedSince29.__init__(self,message:str,*args:object)
pydantic.warnings.PydanticDeprecationWarning(self,message:str,*args:object,since:tuple[int,int],expected_removal:tuple[int,int]|None=None)
pydantic.warnings.PydanticDeprecationWarning.__init__(self,message:str,*args:object,since:tuple[int,int],expected_removal:tuple[int,int]|None=None)
pydantic.warnings.PydanticDeprecationWarning.__str__(self)->str
pydantic.warnings.PydanticExperimentalWarning(Warning)


----------------------------------------/dataset/nuaa/anaconda3/envs/pydantic2.10.6/lib/python3.9/site-packages/pydantic/fields.py----------------------------------------
A:pydantic.fields.(self.annotation, annotation_metadata)->self._extract_metadata(kwargs.get('annotation'))
A:pydantic.fields.default->default.merge_field_infos(*[x for x in annotation_metadata if isinstance(x, FieldInfo)], default, annotation=default.annotation).merge_field_infos(*[x for x in annotation_metadata if isinstance(x, FieldInfo)], default, annotation=default.annotation)
A:pydantic.fields.self.default_factory->kwargs.pop('default_factory', None)
A:pydantic.fields.self.alias->kwargs.pop('alias', None)
A:pydantic.fields.self.validation_alias->kwargs.pop('validation_alias', None)
A:pydantic.fields.self.serialization_alias->kwargs.pop('serialization_alias', None)
A:pydantic.fields.alias_is_set->any((alias is not None for alias in (self.alias, self.validation_alias, self.serialization_alias)))
A:pydantic.fields.self.title->kwargs.pop('title', None)
A:pydantic.fields.self.field_title_generator->kwargs.pop('field_title_generator', None)
A:pydantic.fields.self.description->kwargs.pop('description', None)
A:pydantic.fields.self.examples->kwargs.pop('examples', None)
A:pydantic.fields.self.exclude->kwargs.pop('exclude', None)
A:pydantic.fields.self.discriminator->kwargs.pop('discriminator', None)
A:pydantic.fields.self.deprecated->kwargs.pop('deprecated', getattr(self, 'deprecated', None))
A:pydantic.fields.self.repr->kwargs.pop('repr', True)
A:pydantic.fields.self.json_schema_extra->kwargs.pop('json_schema_extra', None)
A:pydantic.fields.self.validate_default->kwargs.pop('validate_default', None)
A:pydantic.fields.self.frozen->kwargs.pop('frozen', None)
A:pydantic.fields.self.init->kwargs.pop('init', None)
A:pydantic.fields.self.init_var->kwargs.pop('init_var', None)
A:pydantic.fields.self.kw_only->kwargs.pop('kw_only', None)
A:pydantic.fields.(first_arg, *extra_args)->typing_extensions.get_args(annotation)
A:pydantic.fields.field_info->FieldInfo(**merged_field_info_kwargs)
A:pydantic.fields.new_field_info->copy(field_info)
A:pydantic.fields.final->_internal._typing_extra.is_finalvar(annotation)
A:pydantic.fields.(default.annotation, annotation_metadata)->FieldInfo._extract_metadata(annotation)
A:pydantic.fields.annotation->typing.cast(Any, Any)
A:pydantic.fields.pydantic_field->pydantic_field.merge_field_infos(*[x for x in annotation_metadata if isinstance(x, FieldInfo)], pydantic_field, annotation=pydantic_field.annotation).merge_field_infos(*[x for x in annotation_metadata if isinstance(x, FieldInfo)], pydantic_field, annotation=pydantic_field.annotation)
A:pydantic.fields.(pydantic_field.annotation, annotation_metadata)->FieldInfo._extract_metadata(annotation)
A:pydantic.fields.pydantic_field.init->getattr(default, 'init', None)
A:pydantic.fields.pydantic_field.kw_only->getattr(default, 'kw_only', None)
A:pydantic.fields.default_override->overrides.pop('default', PydanticUndefined)
A:pydantic.fields.attributes_set->FieldInfo(**merged_field_info_kwargs)._attributes_set.copy()
A:pydantic.fields.json_schema_extra->FieldInfo(**merged_field_info_kwargs)._attributes_set.copy().pop('json_schema_extra')
A:pydantic.fields.existing_json_schema_extra->merged_field_info_kwargs.get('json_schema_extra')
A:pydantic.fields.field_info.metadata->list(metadata.values())
A:pydantic.fields.fac->cast('Callable[[], Any]', self.default_factory)
A:pydantic.fields.(annotation, _)->_internal._typing_extra.try_eval_type(self.annotation, globalns, localns)
A:pydantic.fields.self.annotation->_internal._generics.replace_types(annotation, typevars_map)
A:pydantic.fields.value->getattr(self, s)
A:pydantic.fields._T->TypeVar('_T')
A:pydantic.fields.const->extra.pop('const', None)
A:pydantic.fields.min_items->extra.pop('min_items', None)
A:pydantic.fields.max_items->extra.pop('max_items', None)
A:pydantic.fields.unique_items->extra.pop('unique_items', None)
A:pydantic.fields.allow_mutation->extra.pop('allow_mutation', None)
A:pydantic.fields.regex->extra.pop('regex', None)
A:pydantic.fields.include->extra.pop('include', None)
A:pydantic.fields._FIELD_ARG_NAMES->set(inspect.signature(Field).parameters)
A:pydantic.fields.set_name->getattr(default, '__set_name__', None)
A:pydantic.fields.wrapped_name->getattr(property_.func, '__name__', '')
A:pydantic.fields.PropertyT->typing.TypeVar('PropertyT')
A:pydantic.fields.unwrapped->_internal._decorators.unwrap_wrapped_function(f)
A:pydantic.fields.description->inspect.cleandoc(unwrapped.__doc__)
A:pydantic.fields.f->_internal._decorators.ensure_property(f)
A:pydantic.fields.dec_info->ComputedFieldInfo(f, return_type, alias, alias_priority, title, field_title_generator, description, deprecated, examples, json_schema_extra, repr_)
pydantic.Field(default:Any=PydanticUndefined,*,default_factory:Callable[[],Any]|Callable[[dict[str,Any]],Any]|None=_Unset,alias:str|None=_Unset,alias_priority:int|None=_Unset,validation_alias:str|AliasPath|AliasChoices|None=_Unset,serialization_alias:str|None=_Unset,title:str|None=_Unset,field_title_generator:Callable[[str,FieldInfo],str]|None=_Unset,description:str|None=_Unset,examples:list[Any]|None=_Unset,exclude:bool|None=_Unset,discriminator:str|types.Discriminator|None=_Unset,deprecated:Deprecated|str|bool|None=_Unset,json_schema_extra:JsonDict|Callable[[JsonDict],None]|None=_Unset,frozen:bool|None=_Unset,validate_default:bool|None=_Unset,repr:bool=_Unset,init:bool|None=_Unset,init_var:bool|None=_Unset,kw_only:bool|None=_Unset,pattern:str|typing.Pattern[str]|None=_Unset,strict:bool|None=_Unset,coerce_numbers_to_str:bool|None=_Unset,gt:annotated_types.SupportsGt|None=_Unset,ge:annotated_types.SupportsGe|None=_Unset,lt:annotated_types.SupportsLt|None=_Unset,le:annotated_types.SupportsLe|None=_Unset,multiple_of:float|None=_Unset,allow_inf_nan:bool|None=_Unset,max_digits:int|None=_Unset,decimal_places:int|None=_Unset,min_length:int|None=_Unset,max_length:int|None=_Unset,union_mode:Literal['smart','left_to_right']=_Unset,fail_fast:bool|None=_Unset,**extra:Unpack[_EmptyKwargs])->Any
pydantic.FieldInfo(self,**kwargs:Unpack[_FieldInfoInputs])
pydantic.FieldInfo.__repr_args__(self)->ReprArgs
pydantic.FieldInfo._collect_metadata(kwargs:dict[str,Any])->list[Any]
pydantic.FieldInfo._extract_metadata(annotation:type[Any]|None)->tuple[type[Any] | None, list[Any]]
pydantic.FieldInfo._from_dataclass_field(dc_field:DataclassField[Any])->FieldInfo
pydantic.FieldInfo.apply_typevars_map(self,typevars_map:dict[Any,Any]|None,globalns:GlobalsNamespace|None=None,localns:MappingNamespace|None=None)->None
pydantic.FieldInfo.default_factory_takes_validated_data(self)->bool | None
pydantic.FieldInfo.deprecation_message(self)->str | None
pydantic.FieldInfo.from_annotated_attribute(annotation:type[Any],default:Any)->FieldInfo
pydantic.FieldInfo.from_annotation(annotation:type[Any])->FieldInfo
pydantic.FieldInfo.from_field(default:Any=PydanticUndefined,**kwargs:Unpack[_FromFieldInfoInputs])->FieldInfo
pydantic.FieldInfo.get_default(self,*,call_default_factory:bool=False,validated_data:dict[str,Any]|None=None)->Any
pydantic.FieldInfo.is_required(self)->bool
pydantic.FieldInfo.merge_field_infos(*field_infos:FieldInfo,**overrides:Any)->FieldInfo
pydantic.FieldInfo.rebuild_annotation(self)->Any
pydantic.PrivateAttr(default:Any=PydanticUndefined,*,default_factory:Callable[[],Any]|None=None,init:Literal[False]=False)->Any
pydantic.computed_field(func:PropertyT|None=None,/,*,alias:str|None=None,alias_priority:int|None=None,title:str|None=None,field_title_generator:typing.Callable[[str,ComputedFieldInfo],str]|None=None,description:str|None=None,deprecated:Deprecated|str|bool|None=None,examples:list[Any]|None=None,json_schema_extra:JsonDict|typing.Callable[[JsonDict],None]|None=None,repr:bool|None=None,return_type:Any=PydanticUndefined)->PropertyT | typing.Callable[[PropertyT], PropertyT]
pydantic.fields.ComputedFieldInfo
pydantic.fields.ComputedFieldInfo.deprecation_message(self)->str | None
pydantic.fields.Field(default:Any=PydanticUndefined,*,default_factory:Callable[[],Any]|Callable[[dict[str,Any]],Any]|None=_Unset,alias:str|None=_Unset,alias_priority:int|None=_Unset,validation_alias:str|AliasPath|AliasChoices|None=_Unset,serialization_alias:str|None=_Unset,title:str|None=_Unset,field_title_generator:Callable[[str,FieldInfo],str]|None=_Unset,description:str|None=_Unset,examples:list[Any]|None=_Unset,exclude:bool|None=_Unset,discriminator:str|types.Discriminator|None=_Unset,deprecated:Deprecated|str|bool|None=_Unset,json_schema_extra:JsonDict|Callable[[JsonDict],None]|None=_Unset,frozen:bool|None=_Unset,validate_default:bool|None=_Unset,repr:bool=_Unset,init:bool|None=_Unset,init_var:bool|None=_Unset,kw_only:bool|None=_Unset,pattern:str|typing.Pattern[str]|None=_Unset,strict:bool|None=_Unset,coerce_numbers_to_str:bool|None=_Unset,gt:annotated_types.SupportsGt|None=_Unset,ge:annotated_types.SupportsGe|None=_Unset,lt:annotated_types.SupportsLt|None=_Unset,le:annotated_types.SupportsLe|None=_Unset,multiple_of:float|None=_Unset,allow_inf_nan:bool|None=_Unset,max_digits:int|None=_Unset,decimal_places:int|None=_Unset,min_length:int|None=_Unset,max_length:int|None=_Unset,union_mode:Literal['smart','left_to_right']=_Unset,fail_fast:bool|None=_Unset,**extra:Unpack[_EmptyKwargs])->Any
pydantic.fields.FieldInfo(self,**kwargs:Unpack[_FieldInfoInputs])
pydantic.fields.FieldInfo.__init__(self,**kwargs:Unpack[_FieldInfoInputs])
pydantic.fields.FieldInfo.__repr_args__(self)->ReprArgs
pydantic.fields.FieldInfo._collect_metadata(kwargs:dict[str,Any])->list[Any]
pydantic.fields.FieldInfo._extract_metadata(annotation:type[Any]|None)->tuple[type[Any] | None, list[Any]]
pydantic.fields.FieldInfo._from_dataclass_field(dc_field:DataclassField[Any])->FieldInfo
pydantic.fields.FieldInfo.apply_typevars_map(self,typevars_map:dict[Any,Any]|None,globalns:GlobalsNamespace|None=None,localns:MappingNamespace|None=None)->None
pydantic.fields.FieldInfo.default_factory_takes_validated_data(self)->bool | None
pydantic.fields.FieldInfo.deprecation_message(self)->str | None
pydantic.fields.FieldInfo.from_annotated_attribute(annotation:type[Any],default:Any)->FieldInfo
pydantic.fields.FieldInfo.from_annotation(annotation:type[Any])->FieldInfo
pydantic.fields.FieldInfo.from_field(default:Any=PydanticUndefined,**kwargs:Unpack[_FromFieldInfoInputs])->FieldInfo
pydantic.fields.FieldInfo.get_default(self,*,call_default_factory:bool=False,validated_data:dict[str,Any]|None=None)->Any
pydantic.fields.FieldInfo.is_required(self)->bool
pydantic.fields.FieldInfo.merge_field_infos(*field_infos:FieldInfo,**overrides:Any)->FieldInfo
pydantic.fields.FieldInfo.rebuild_annotation(self)->Any
pydantic.fields.ModelPrivateAttr(self,default:Any=PydanticUndefined,*,default_factory:typing.Callable[[],Any]|None=None)
pydantic.fields.ModelPrivateAttr.__eq__(self,other:Any)->bool
pydantic.fields.ModelPrivateAttr.__init__(self,default:Any=PydanticUndefined,*,default_factory:typing.Callable[[],Any]|None=None)
pydantic.fields.ModelPrivateAttr.__set_name__(self,cls:type[Any],name:str)->None
pydantic.fields.ModelPrivateAttr.get_default(self)->Any
pydantic.fields.PrivateAttr(default:Any=PydanticUndefined,*,default_factory:Callable[[],Any]|None=None,init:Literal[False]=False)->Any
pydantic.fields._EmptyKwargs(typing_extensions.TypedDict)
pydantic.fields._FieldInfoInputs(_FromFieldInfoInputs,total=False)
pydantic.fields._FromFieldInfoInputs(typing_extensions.TypedDict,total=False)
pydantic.fields._wrapped_property_is_private(property_:cached_property|property)->bool
pydantic.fields.computed_field(func:PropertyT|None=None,/,*,alias:str|None=None,alias_priority:int|None=None,title:str|None=None,field_title_generator:typing.Callable[[str,ComputedFieldInfo],str]|None=None,description:str|None=None,deprecated:Deprecated|str|bool|None=None,examples:list[Any]|None=None,json_schema_extra:JsonDict|typing.Callable[[JsonDict],None]|None=None,repr:bool|None=None,return_type:Any=PydanticUndefined)->PropertyT | typing.Callable[[PropertyT], PropertyT]


----------------------------------------/dataset/nuaa/anaconda3/envs/pydantic2.10.6/lib/python3.9/site-packages/pydantic/error_wrappers.py----------------------------------------
A:pydantic.error_wrappers.__getattr__->getattr_migration(__name__)


----------------------------------------/dataset/nuaa/anaconda3/envs/pydantic2.10.6/lib/python3.9/site-packages/pydantic/mypy.py----------------------------------------
A:pydantic.mypy.MYPY_VERSION_TUPLE->parse_mypy_version(mypy_version)
A:pydantic.mypy.self.plugin_config->PydanticPluginConfig(options)
A:pydantic.mypy.self._plugin_data->self.plugin_config.to_data()
A:pydantic.mypy.sym->SymbolTableNode(MDEF, func)
A:pydantic.mypy.transformer->PydanticModelTransformer(ctx.cls, ctx.reason, ctx.api, self.plugin_config)
A:pydantic.mypy.toml_config->parse_toml(options.config_file)
A:pydantic.mypy.config->ModelConfigData()
A:pydantic.mypy.setting->ConfigParser().getboolean(CONFIGFILE_KEY, key, fallback=False)
A:pydantic.mypy.plugin_config->ConfigParser()
A:pydantic.mypy.pydantic_metadata->model_type.type.metadata.get(METADATA_KEY)
A:pydantic.mypy.from_attributes->model_type.type.metadata.get(METADATA_KEY).get('config', {}).get('from_attributes')
A:pydantic.mypy.variable->Var(arg_name, analyzed_variable_type)
A:pydantic.mypy.type_annotation->AnyType(TypeOfAny.explicit)
A:pydantic.mypy.modified_type->self.type.copy_modified()
A:pydantic.mypy.filled_with_typevars->fill_typevars(current_info)
A:pydantic.mypy.data->data.copy().copy()
A:pydantic.mypy.typ->self._api.analyze_simple_literal_type(stmt.rvalue, is_final=True)
A:pydantic.mypy.self.type->map_type_from_supertype(self.type, sub_type, self.info)
A:pydantic.mypy.is_root_model->any((ROOT_MODEL_FULLNAME in base.fullname for base in info.mro[:-1]))
A:pydantic.mypy.(fields, class_vars)->self.collect_fields_and_class_vars(config, is_root_model)
A:pydantic.mypy.is_settings->any((base.fullname == BASESETTINGS_FULLNAME for base in info.mro[:-1]))
A:pydantic.mypy.config_data->self.get_config_update(name, expr)
A:pydantic.mypy.field->PydanticModelField.deserialize(info, data, self._api)
A:pydantic.mypy.sym_node->info.names.get(field.name)
A:pydantic.mypy.found_class_vars[name]->PydanticModelClassVar.deserialize(data)
A:pydantic.mypy.maybe_field->self.collect_field_or_class_var_from_stmt(stmt, model_config, found_class_vars)
A:pydantic.mypy.node_type->get_proper_type(node.type)
A:pydantic.mypy.has_default->self.get_has_default(stmt)
A:pydantic.mypy.strict->self.get_strict(stmt)
A:pydantic.mypy.node.type->AnyType(TypeOfAny.from_error)
A:pydantic.mypy.(alias, has_dynamic_alias)->self.get_alias_info(stmt)
A:pydantic.mypy.is_frozen->self.is_field_frozen(stmt)
A:pydantic.mypy.init_type->self._infer_dataclass_attr_init_type(sym, lhs.name, stmt)
A:pydantic.mypy.t->get_proper_type(sym.type)
A:pydantic.mypy.setter->get_proper_type(sym.type).type.get('__set__')
A:pydantic.mypy.super_info->get_proper_type(sym.type).type.get_containing_type_info('__set__')
A:pydantic.mypy.setter_type->get_proper_type(map_type_from_supertype(setter.type, t.type, super_info))
A:pydantic.mypy.model_strict->bool(config.strict)
A:pydantic.mypy.requires_dynamic_aliases->bool(config.has_alias_generator and (not config.populate_by_name))
A:pydantic.mypy.args->self.get_field_arguments(fields, typed=True, model_strict=bool(config.strict), requires_dynamic_aliases=False, use_alias=False, is_settings=is_settings, is_root_model=is_root_model)
A:pydantic.mypy.analyzed_variable_type->self._api.anal_type(func_type.arg_types[arg_idx])
A:pydantic.mypy.var->PydanticModelField.deserialize(info, data, self._api).to_var(info, api, use_alias=False)
A:pydantic.mypy.set_str->self._api.named_type(f'{BUILTINS_NAME}.set', [self._api.named_type(f'{BUILTINS_NAME}.str')])
A:pydantic.mypy.optional_set_str->UnionType([set_str, NoneType()])
A:pydantic.mypy.fields_set_argument->Argument(Var('_fields_set', optional_set_str), optional_set_str, None, ARG_OPT)
A:pydantic.mypy.var_str->repr(var)
A:pydantic.mypy.info.names[var.name]->SymbolTableNode(MDEF, var)
A:pydantic.mypy.ERROR_ORM->ErrorCode('pydantic-orm', 'Invalid from_attributes call', 'Pydantic')
A:pydantic.mypy.ERROR_CONFIG->ErrorCode('pydantic-config', 'Invalid config value', 'Pydantic')
A:pydantic.mypy.ERROR_ALIAS->ErrorCode('pydantic-alias', 'Dynamic alias disallowed', 'Pydantic')
A:pydantic.mypy.ERROR_UNEXPECTED->ErrorCode('pydantic-unexpected', 'Unexpected behavior', 'Pydantic')
A:pydantic.mypy.ERROR_UNTYPED->ErrorCode('pydantic-field', 'Untyped field disallowed', 'Pydantic')
A:pydantic.mypy.ERROR_FIELD_DEFAULTS->ErrorCode('pydantic-field', 'Invalid Field defaults', 'Pydantic')
A:pydantic.mypy.ERROR_EXTRA_FIELD_ROOT_MODEL->ErrorCode('pydantic-field', 'Extra field on RootModel subclass', 'Pydantic')
A:pydantic.mypy.function_type->api.named_generic_type('builtins.function', [])
A:pydantic.mypy.signature->CallableType(arg_types, arg_kinds, arg_names, return_type, function_type)
A:pydantic.mypy.func->FuncDef(name, args, Block([PassStmt()]))
A:pydantic.mypy.func.type->set_callable_name(signature, func)
A:pydantic.mypy.r_name->get_unique_redefinition_name(name, info.names)
A:pydantic.mypy.v->Var(name, func.type)
A:pydantic.mypy.dec->Decorator(func, [NameExpr('classmethod')], v)
pydantic.mypy.ModelConfigData(self,forbid_extra:bool|None=None,frozen:bool|None=None,from_attributes:bool|None=None,populate_by_name:bool|None=None,has_alias_generator:bool|None=None,strict:bool|None=None)
pydantic.mypy.ModelConfigData.__init__(self,forbid_extra:bool|None=None,frozen:bool|None=None,from_attributes:bool|None=None,populate_by_name:bool|None=None,has_alias_generator:bool|None=None,strict:bool|None=None)
pydantic.mypy.ModelConfigData.get_values_dict(self)->dict[str, Any]
pydantic.mypy.ModelConfigData.setdefault(self,key:str,value:Any)->None
pydantic.mypy.ModelConfigData.update(self,config:ModelConfigData|None)->None
pydantic.mypy.PydanticModelClassVar(self,name)
pydantic.mypy.PydanticModelClassVar.__init__(self,name)
pydantic.mypy.PydanticModelClassVar.deserialize(cls,data:JsonDict)->PydanticModelClassVar
pydantic.mypy.PydanticModelClassVar.serialize(self)->JsonDict
pydantic.mypy.PydanticModelField(self,name:str,alias:str|None,is_frozen:bool,has_dynamic_alias:bool,has_default:bool,strict:bool|None,line:int,column:int,type:Type|None,info:TypeInfo)
pydantic.mypy.PydanticModelField.__init__(self,name:str,alias:str|None,is_frozen:bool,has_dynamic_alias:bool,has_default:bool,strict:bool|None,line:int,column:int,type:Type|None,info:TypeInfo)
pydantic.mypy.PydanticModelField.deserialize(cls,info:TypeInfo,data:JsonDict,api:SemanticAnalyzerPluginInterface)->PydanticModelField
pydantic.mypy.PydanticModelField.expand_type(self,current_info:TypeInfo,api:SemanticAnalyzerPluginInterface,force_typevars_invariant:bool=False)->Type | None
pydantic.mypy.PydanticModelField.expand_typevar_from_subtype(self,sub_type:TypeInfo,api:SemanticAnalyzerPluginInterface)->None
pydantic.mypy.PydanticModelField.serialize(self)->JsonDict
pydantic.mypy.PydanticModelField.to_argument(self,current_info:TypeInfo,typed:bool,model_strict:bool,force_optional:bool,use_alias:bool,api:SemanticAnalyzerPluginInterface,force_typevars_invariant:bool,is_root_model_root:bool)->Argument
pydantic.mypy.PydanticModelField.to_var(self,current_info:TypeInfo,api:SemanticAnalyzerPluginInterface,use_alias:bool,force_typevars_invariant:bool=False)->Var
pydantic.mypy.PydanticModelTransformer(self,cls:ClassDef,reason:Expression|Statement,api:SemanticAnalyzerPluginInterface,plugin_config:PydanticPluginConfig)
pydantic.mypy.PydanticModelTransformer.__init__(self,cls:ClassDef,reason:Expression|Statement,api:SemanticAnalyzerPluginInterface,plugin_config:PydanticPluginConfig)
pydantic.mypy.PydanticModelTransformer._get_assignment_statements_from_block(self,block:Block)->Iterator[AssignmentStmt]
pydantic.mypy.PydanticModelTransformer._get_assignment_statements_from_if_statement(self,stmt:IfStmt)->Iterator[AssignmentStmt]
pydantic.mypy.PydanticModelTransformer._infer_dataclass_attr_init_type(self,sym:SymbolTableNode,name:str,context:Context)->Type | None
pydantic.mypy.PydanticModelTransformer.add_initializer(self,fields:list[PydanticModelField],config:ModelConfigData,is_settings:bool,is_root_model:bool)->None
pydantic.mypy.PydanticModelTransformer.add_model_construct_method(self,fields:list[PydanticModelField],config:ModelConfigData,is_settings:bool,is_root_model:bool)->None
pydantic.mypy.PydanticModelTransformer.adjust_decorator_signatures(self)->None
pydantic.mypy.PydanticModelTransformer.collect_config(self)->ModelConfigData
pydantic.mypy.PydanticModelTransformer.collect_field_or_class_var_from_stmt(self,stmt:AssignmentStmt,model_config:ModelConfigData,class_vars:dict[str,PydanticModelClassVar])->PydanticModelField | PydanticModelClassVar | None
pydantic.mypy.PydanticModelTransformer.collect_fields_and_class_vars(self,model_config:ModelConfigData,is_root_model:bool)->tuple[list[PydanticModelField] | None, list[PydanticModelClassVar] | None]
pydantic.mypy.PydanticModelTransformer.get_alias_info(stmt:AssignmentStmt)->tuple[str | None, bool]
pydantic.mypy.PydanticModelTransformer.get_config_update(self,name:str,arg:Expression,lax_extra:bool=False)->ModelConfigData | None
pydantic.mypy.PydanticModelTransformer.get_field_arguments(self,fields:list[PydanticModelField],typed:bool,model_strict:bool,use_alias:bool,requires_dynamic_aliases:bool,is_settings:bool,is_root_model:bool,force_typevars_invariant:bool=False)->list[Argument]
pydantic.mypy.PydanticModelTransformer.get_has_default(stmt:AssignmentStmt)->bool
pydantic.mypy.PydanticModelTransformer.get_strict(stmt:AssignmentStmt)->bool | None
pydantic.mypy.PydanticModelTransformer.is_dynamic_alias_present(fields:list[PydanticModelField],has_alias_generator:bool)->bool
pydantic.mypy.PydanticModelTransformer.is_field_frozen(stmt:AssignmentStmt)->bool
pydantic.mypy.PydanticModelTransformer.set_frozen(self,fields:list[PydanticModelField],api:SemanticAnalyzerPluginInterface,frozen:bool)->None
pydantic.mypy.PydanticModelTransformer.should_init_forbid_extra(self,fields:list[PydanticModelField],config:ModelConfigData)->bool
pydantic.mypy.PydanticModelTransformer.transform(self)->bool
pydantic.mypy.PydanticPlugin(self,options:Options)
pydantic.mypy.PydanticPlugin.__init__(self,options:Options)
pydantic.mypy.PydanticPlugin._pydantic_model_class_maker_callback(self,ctx:ClassDefContext)->None
pydantic.mypy.PydanticPlugin._pydantic_model_metaclass_marker_callback(self,ctx:ClassDefContext)->None
pydantic.mypy.PydanticPlugin.get_base_class_hook(self,fullname:str)->Callable[[ClassDefContext], None] | None
pydantic.mypy.PydanticPlugin.get_metaclass_hook(self,fullname:str)->Callable[[ClassDefContext], None] | None
pydantic.mypy.PydanticPlugin.get_method_hook(self,fullname:str)->Callable[[MethodContext], Type] | None
pydantic.mypy.PydanticPlugin.report_config_data(self,ctx:ReportConfigContext)->dict[str, Any]
pydantic.mypy.PydanticPluginConfig(self,options:Options)
pydantic.mypy.PydanticPluginConfig.__init__(self,options:Options)
pydantic.mypy.PydanticPluginConfig.to_data(self)->dict[str, Any]
pydantic.mypy.add_method(api:SemanticAnalyzerPluginInterface|CheckerPluginInterface,cls:ClassDef,name:str,args:list[Argument],return_type:Type,self_type:Type|None=None,tvar_def:TypeVarType|None=None,is_classmethod:bool=False)->None
pydantic.mypy.error_extra_fields_on_root_model(api:CheckerPluginInterface,context:Context)->None
pydantic.mypy.error_from_attributes(model_name:str,api:CheckerPluginInterface,context:Context)->None
pydantic.mypy.error_invalid_config_value(name:str,api:SemanticAnalyzerPluginInterface,context:Context)->None
pydantic.mypy.error_required_dynamic_aliases(api:SemanticAnalyzerPluginInterface,context:Context)->None
pydantic.mypy.error_unexpected_behavior(detail:str,api:CheckerPluginInterface|SemanticAnalyzerPluginInterface,context:Context)->None
pydantic.mypy.error_untyped_fields(api:SemanticAnalyzerPluginInterface,context:Context)->None
pydantic.mypy.from_attributes_callback(ctx:MethodContext)->Type
pydantic.mypy.parse_toml(config_file:str)->dict[str, Any] | None
pydantic.mypy.plugin(version:str)->type[Plugin]


----------------------------------------/dataset/nuaa/anaconda3/envs/pydantic2.10.6/lib/python3.9/site-packages/pydantic/typing.py----------------------------------------
A:pydantic.typing.__getattr__->getattr_migration(__name__)


----------------------------------------/dataset/nuaa/anaconda3/envs/pydantic2.10.6/lib/python3.9/site-packages/pydantic/main.py----------------------------------------
A:pydantic.main.__pydantic_core_schema__->_internal._mock_val_ser.MockCoreSchema('Pydantic models should inherit from BaseModel, BaseModel cannot be instantiated directly', code='base-model-instantiated')
A:pydantic.main.__pydantic_validator__->_internal._mock_val_ser.MockValSer('Pydantic models should inherit from BaseModel, BaseModel cannot be instantiated directly', val_or_ser='validator', code='base-model-instantiated')
A:pydantic.main.__pydantic_serializer__->_internal._mock_val_ser.MockValSer('Pydantic models should inherit from BaseModel, BaseModel cannot be instantiated directly', val_or_ser='serializer', code='base-model-instantiated')
A:pydantic.main.validated_self->self.__pydantic_validator__.validate_python(data, self_instance=self)
A:pydantic.main.m->type(self).__new__(cls)
A:pydantic.main.fields_set->set(self.__pydantic_fields_set__)
A:pydantic.main.fields_values[name]->self.__pydantic_fields__.get(k).get_default(call_default_factory=True, validated_data=fields_values)
A:pydantic.main.value->alias.search_dict_for_path(values)
A:pydantic.main.params_component->', '.join(param_names)
A:pydantic.main.ns_resolver->_internal._namespace_utils.NsResolver(parent_namespace={**rebuild_ns, **parent_ns})
A:pydantic.main.schema->type(self).__dict__.get('__pydantic_core_schema__')
A:pydantic.main.cached->_internal._generics.get_cached_generic_type_late(cls, typevar_values, origin, args)
A:pydantic.main.args->tuple((_generics.replace_types(arg, typevars_map) for arg in parent_args))
A:pydantic.main.model_name->origin.model_parametrized_name(args)
A:pydantic.main.params->tuple({param: None for param in _generics.iter_contained_typevars(typevars_map.values())})
A:pydantic.main.submodel->_internal._generics.create_generic_submodel(model_name, origin, args, params)
A:pydantic.main.cls->type(self)
A:pydantic.main.private_attributes->object.__getattribute__(self, '__private_attributes__')
A:pydantic.main.pydantic_extra->object.__getattribute__(self, '__pydantic_extra__')
A:pydantic.main.attr->getattr(self.__class__, name, None)
A:pydantic.main.model_fields->type(self).__pydantic_fields__.keys()
A:pydantic.main.self_fields_proxy->_internal._utils.SafeGetItemProxy(self.__dict__)
A:pydantic.main.other_fields_proxy->_internal._utils.SafeGetItemProxy(other.__dict__)
A:pydantic.main.field->self.__pydantic_fields__.get(k)
A:pydantic.main.obj->deprecated.parse.load_file(path, proto=proto, content_type=content_type, encoding=encoding, allow_pickle=allow_pickle)
A:pydantic.main.values->dict(copy_internals._iter(self, to_dict=False, by_alias=False, include=include, exclude=exclude, exclude_unset=False), **update or {})
A:pydantic.main.extra->self.__pydantic_extra__.copy()
A:pydantic.main.extra[k]->dict(copy_internals._iter(self, to_dict=False, by_alias=False, include=include, exclude=exclude, exclude_unset=False), **update or {}).pop(k)
A:pydantic.main.ModelT->TypeVar('ModelT', bound=BaseModel)
A:pydantic.main.f_def->cast('tuple[str, Any]', f_def)
A:pydantic.main.(f_annotation, f_value, *_)->typing_extensions.get_args(f_def)
A:pydantic.main.FieldInfo->_internal._import_utils.import_cached_field_info()
A:pydantic.main.f->sys._getframe(1)
A:pydantic.main.resolved_bases->types.resolve_bases(__base__)
A:pydantic.main.(meta, ns, kwds)->types.prepare_class(model_name, resolved_bases, kwds=__cls_kwargs__)
A:pydantic.main.__getattr__->getattr_migration(__name__)
pydantic.BaseModel(self,/,**data:Any)
pydantic.BaseModel.__class_getitem__(cls,typevar_values:type[Any]|tuple[type[Any],...])->type[BaseModel] | _forward_ref.PydanticRecursiveRef
pydantic.BaseModel.__copy__(self)->Self
pydantic.BaseModel.__deepcopy__(self,memo:dict[int,Any]|None=None)->Self
pydantic.BaseModel.__fields__(self)->dict[str, FieldInfo]
pydantic.BaseModel.__fields_set__(self)->set[str]
pydantic.BaseModel.__get_pydantic_core_schema__(cls,source:type[BaseModel],handler:GetCoreSchemaHandler,/)->CoreSchema
pydantic.BaseModel.__get_pydantic_json_schema__(cls,core_schema:CoreSchema,handler:GetJsonSchemaHandler,/)->JsonSchemaValue
pydantic.BaseModel.__getstate__(self)->dict[Any, Any]
pydantic.BaseModel.__iter__(self)->TupleGenerator
pydantic.BaseModel.__pydantic_init_subclass__(cls,**kwargs:Any)->None
pydantic.BaseModel.__repr__(self)->str
pydantic.BaseModel.__repr_args__(self)->_repr.ReprArgs
pydantic.BaseModel.__setstate__(self,state:dict[Any,Any])->None
pydantic.BaseModel.__str__(self)->str
pydantic.BaseModel._calculate_keys(self,*args:Any,**kwargs:Any)->Any
pydantic.BaseModel._check_frozen(self,name:str,value:Any)->None
pydantic.BaseModel._copy_and_set_values(self,*args:Any,**kwargs:Any)->Any
pydantic.BaseModel._get_value(cls,*args:Any,**kwargs:Any)->Any
pydantic.BaseModel._iter(self,*args:Any,**kwargs:Any)->Any
pydantic.BaseModel.construct(cls,_fields_set:set[str]|None=None,**values:Any)->Self
pydantic.BaseModel.copy(self,*,include:AbstractSetIntStr|MappingIntStrAny|None=None,exclude:AbstractSetIntStr|MappingIntStrAny|None=None,update:Dict[str,Any]|None=None,deep:bool=False)->Self
pydantic.BaseModel.dict(self,*,include:IncEx|None=None,exclude:IncEx|None=None,by_alias:bool=False,exclude_unset:bool=False,exclude_defaults:bool=False,exclude_none:bool=False)->Dict[str, Any]
pydantic.BaseModel.from_orm(cls,obj:Any)->Self
pydantic.BaseModel.json(self,*,include:IncEx|None=None,exclude:IncEx|None=None,by_alias:bool=False,exclude_unset:bool=False,exclude_defaults:bool=False,exclude_none:bool=False,encoder:Callable[[Any],Any]|None=PydanticUndefined,models_as_dict:bool=PydanticUndefined,**dumps_kwargs:Any)->str
pydantic.BaseModel.model_construct(cls,_fields_set:set[str]|None=None,**values:Any)->Self
pydantic.BaseModel.model_copy(self,*,update:Mapping[str,Any]|None=None,deep:bool=False)->Self
pydantic.BaseModel.model_dump(self,*,mode:Literal['json','python']|str='python',include:IncEx|None=None,exclude:IncEx|None=None,context:Any|None=None,by_alias:bool=False,exclude_unset:bool=False,exclude_defaults:bool=False,exclude_none:bool=False,round_trip:bool=False,warnings:bool|Literal['none','warn','error']=True,serialize_as_any:bool=False)->dict[str, Any]
pydantic.BaseModel.model_dump_json(self,*,indent:int|None=None,include:IncEx|None=None,exclude:IncEx|None=None,context:Any|None=None,by_alias:bool=False,exclude_unset:bool=False,exclude_defaults:bool=False,exclude_none:bool=False,round_trip:bool=False,warnings:bool|Literal['none','warn','error']=True,serialize_as_any:bool=False)->str
pydantic.BaseModel.model_extra(self)->dict[str, Any] | None
pydantic.BaseModel.model_fields_set(self)->set[str]
pydantic.BaseModel.model_json_schema(cls,by_alias:bool=True,ref_template:str=DEFAULT_REF_TEMPLATE,schema_generator:type[GenerateJsonSchema]=GenerateJsonSchema,mode:JsonSchemaMode='validation')->dict[str, Any]
pydantic.BaseModel.model_parametrized_name(cls,params:tuple[type[Any],...])->str
pydantic.BaseModel.model_post_init(self,__context:Any)->None
pydantic.BaseModel.model_rebuild(cls,*,force:bool=False,raise_errors:bool=True,_parent_namespace_depth:int=2,_types_namespace:MappingNamespace|None=None)->bool | None
pydantic.BaseModel.model_validate(cls,obj:Any,*,strict:bool|None=None,from_attributes:bool|None=None,context:Any|None=None)->Self
pydantic.BaseModel.model_validate_json(cls,json_data:str|bytes|bytearray,*,strict:bool|None=None,context:Any|None=None)->Self
pydantic.BaseModel.model_validate_strings(cls,obj:Any,*,strict:bool|None=None,context:Any|None=None)->Self
pydantic.BaseModel.parse_file(cls,path:str|Path,*,content_type:str|None=None,encoding:str='utf8',proto:DeprecatedParseProtocol|None=None,allow_pickle:bool=False)->Self
pydantic.BaseModel.parse_obj(cls,obj:Any)->Self
pydantic.BaseModel.parse_raw(cls,b:str|bytes,*,content_type:str|None=None,encoding:str='utf8',proto:DeprecatedParseProtocol|None=None,allow_pickle:bool=False)->Self
pydantic.BaseModel.schema(cls,by_alias:bool=True,ref_template:str=DEFAULT_REF_TEMPLATE)->Dict[str, Any]
pydantic.BaseModel.schema_json(cls,*,by_alias:bool=True,ref_template:str=DEFAULT_REF_TEMPLATE,**dumps_kwargs:Any)->str
pydantic.BaseModel.update_forward_refs(cls,**localns:Any)->None
pydantic.BaseModel.validate(cls,value:Any)->Self
pydantic.create_model(model_name:str,/,*,__config__:ConfigDict|None=None,__doc__:str|None=None,__base__:type[ModelT]|tuple[type[ModelT],...]|None=None,__module__:str|None=None,__validators__:dict[str,Callable[...,Any]]|None=None,__cls_kwargs__:dict[str,Any]|None=None,__slots__:tuple[str,...]|None=None,**field_definitions:Any)->type[ModelT]
pydantic.main.BaseModel(self,/,**data:Any)
pydantic.main.BaseModel.__class_getitem__(cls,typevar_values:type[Any]|tuple[type[Any],...])->type[BaseModel] | _forward_ref.PydanticRecursiveRef
pydantic.main.BaseModel.__copy__(self)->Self
pydantic.main.BaseModel.__deepcopy__(self,memo:dict[int,Any]|None=None)->Self
pydantic.main.BaseModel.__fields__(self)->dict[str, FieldInfo]
pydantic.main.BaseModel.__fields_set__(self)->set[str]
pydantic.main.BaseModel.__get_pydantic_core_schema__(cls,source:type[BaseModel],handler:GetCoreSchemaHandler,/)->CoreSchema
pydantic.main.BaseModel.__get_pydantic_json_schema__(cls,core_schema:CoreSchema,handler:GetJsonSchemaHandler,/)->JsonSchemaValue
pydantic.main.BaseModel.__getstate__(self)->dict[Any, Any]
pydantic.main.BaseModel.__init__(self,/,**data:Any)
pydantic.main.BaseModel.__iter__(self)->TupleGenerator
pydantic.main.BaseModel.__pydantic_init_subclass__(cls,**kwargs:Any)->None
pydantic.main.BaseModel.__repr__(self)->str
pydantic.main.BaseModel.__repr_args__(self)->_repr.ReprArgs
pydantic.main.BaseModel.__setstate__(self,state:dict[Any,Any])->None
pydantic.main.BaseModel.__str__(self)->str
pydantic.main.BaseModel._calculate_keys(self,*args:Any,**kwargs:Any)->Any
pydantic.main.BaseModel._check_frozen(self,name:str,value:Any)->None
pydantic.main.BaseModel._copy_and_set_values(self,*args:Any,**kwargs:Any)->Any
pydantic.main.BaseModel._get_value(cls,*args:Any,**kwargs:Any)->Any
pydantic.main.BaseModel._iter(self,*args:Any,**kwargs:Any)->Any
pydantic.main.BaseModel.construct(cls,_fields_set:set[str]|None=None,**values:Any)->Self
pydantic.main.BaseModel.copy(self,*,include:AbstractSetIntStr|MappingIntStrAny|None=None,exclude:AbstractSetIntStr|MappingIntStrAny|None=None,update:Dict[str,Any]|None=None,deep:bool=False)->Self
pydantic.main.BaseModel.dict(self,*,include:IncEx|None=None,exclude:IncEx|None=None,by_alias:bool=False,exclude_unset:bool=False,exclude_defaults:bool=False,exclude_none:bool=False)->Dict[str, Any]
pydantic.main.BaseModel.from_orm(cls,obj:Any)->Self
pydantic.main.BaseModel.json(self,*,include:IncEx|None=None,exclude:IncEx|None=None,by_alias:bool=False,exclude_unset:bool=False,exclude_defaults:bool=False,exclude_none:bool=False,encoder:Callable[[Any],Any]|None=PydanticUndefined,models_as_dict:bool=PydanticUndefined,**dumps_kwargs:Any)->str
pydantic.main.BaseModel.model_construct(cls,_fields_set:set[str]|None=None,**values:Any)->Self
pydantic.main.BaseModel.model_copy(self,*,update:Mapping[str,Any]|None=None,deep:bool=False)->Self
pydantic.main.BaseModel.model_dump(self,*,mode:Literal['json','python']|str='python',include:IncEx|None=None,exclude:IncEx|None=None,context:Any|None=None,by_alias:bool=False,exclude_unset:bool=False,exclude_defaults:bool=False,exclude_none:bool=False,round_trip:bool=False,warnings:bool|Literal['none','warn','error']=True,serialize_as_any:bool=False)->dict[str, Any]
pydantic.main.BaseModel.model_dump_json(self,*,indent:int|None=None,include:IncEx|None=None,exclude:IncEx|None=None,context:Any|None=None,by_alias:bool=False,exclude_unset:bool=False,exclude_defaults:bool=False,exclude_none:bool=False,round_trip:bool=False,warnings:bool|Literal['none','warn','error']=True,serialize_as_any:bool=False)->str
pydantic.main.BaseModel.model_extra(self)->dict[str, Any] | None
pydantic.main.BaseModel.model_fields_set(self)->set[str]
pydantic.main.BaseModel.model_json_schema(cls,by_alias:bool=True,ref_template:str=DEFAULT_REF_TEMPLATE,schema_generator:type[GenerateJsonSchema]=GenerateJsonSchema,mode:JsonSchemaMode='validation')->dict[str, Any]
pydantic.main.BaseModel.model_parametrized_name(cls,params:tuple[type[Any],...])->str
pydantic.main.BaseModel.model_post_init(self,__context:Any)->None
pydantic.main.BaseModel.model_rebuild(cls,*,force:bool=False,raise_errors:bool=True,_parent_namespace_depth:int=2,_types_namespace:MappingNamespace|None=None)->bool | None
pydantic.main.BaseModel.model_validate(cls,obj:Any,*,strict:bool|None=None,from_attributes:bool|None=None,context:Any|None=None)->Self
pydantic.main.BaseModel.model_validate_json(cls,json_data:str|bytes|bytearray,*,strict:bool|None=None,context:Any|None=None)->Self
pydantic.main.BaseModel.model_validate_strings(cls,obj:Any,*,strict:bool|None=None,context:Any|None=None)->Self
pydantic.main.BaseModel.parse_file(cls,path:str|Path,*,content_type:str|None=None,encoding:str='utf8',proto:DeprecatedParseProtocol|None=None,allow_pickle:bool=False)->Self
pydantic.main.BaseModel.parse_obj(cls,obj:Any)->Self
pydantic.main.BaseModel.parse_raw(cls,b:str|bytes,*,content_type:str|None=None,encoding:str='utf8',proto:DeprecatedParseProtocol|None=None,allow_pickle:bool=False)->Self
pydantic.main.BaseModel.schema(cls,by_alias:bool=True,ref_template:str=DEFAULT_REF_TEMPLATE)->Dict[str, Any]
pydantic.main.BaseModel.schema_json(cls,*,by_alias:bool=True,ref_template:str=DEFAULT_REF_TEMPLATE,**dumps_kwargs:Any)->str
pydantic.main.BaseModel.update_forward_refs(cls,**localns:Any)->None
pydantic.main.BaseModel.validate(cls,value:Any)->Self
pydantic.main.create_model(model_name:str,/,*,__config__:ConfigDict|None=None,__doc__:str|None=None,__base__:type[ModelT]|tuple[type[ModelT],...]|None=None,__module__:str|None=None,__validators__:dict[str,Callable[...,Any]]|None=None,__cls_kwargs__:dict[str,Any]|None=None,__slots__:tuple[str,...]|None=None,**field_definitions:Any)->type[ModelT]


----------------------------------------/dataset/nuaa/anaconda3/envs/pydantic2.10.6/lib/python3.9/site-packages/pydantic/experimental/__init__.py----------------------------------------


----------------------------------------/dataset/nuaa/anaconda3/envs/pydantic2.10.6/lib/python3.9/site-packages/pydantic/experimental/pipeline.py----------------------------------------
A:pydantic.experimental.pipeline.EllipsisType->type(Ellipsis)
A:pydantic.experimental.pipeline._InT->TypeVar('_InT')
A:pydantic.experimental.pipeline._OutT->TypeVar('_OutT')
A:pydantic.experimental.pipeline._NewOutT->TypeVar('_NewOutT')
A:pydantic.experimental.pipeline.queue->deque(self._steps)
A:pydantic.experimental.pipeline.step->deque(self._steps).popleft()
A:pydantic.experimental.pipeline.s->_check_func(check_pattern, f'~ {constraint.pattern}', s)
A:pydantic.experimental.pipeline.source->inspect.getsource(func).strip()
A:pydantic.experimental.pipeline._NewOutGt->TypeVar('_NewOutGt', bound=annotated_types.SupportsGt)
A:pydantic.experimental.pipeline._NewOutGe->TypeVar('_NewOutGe', bound=annotated_types.SupportsGe)
A:pydantic.experimental.pipeline._NewOutLt->TypeVar('_NewOutLt', bound=annotated_types.SupportsLt)
A:pydantic.experimental.pipeline._NewOutLe->TypeVar('_NewOutLe', bound=annotated_types.SupportsLe)
A:pydantic.experimental.pipeline._NewOutLen->TypeVar('_NewOutLen', bound=_SupportsLen)
A:pydantic.experimental.pipeline._NewOutDiv->TypeVar('_NewOutDiv', bound=annotated_types.SupportsDiv)
A:pydantic.experimental.pipeline._NewOutMod->TypeVar('_NewOutMod', bound=annotated_types.SupportsMod)
A:pydantic.experimental.pipeline._NewOutDatetime->TypeVar('_NewOutDatetime', bound=datetime.datetime)
A:pydantic.experimental.pipeline._NewOutInterval->TypeVar('_NewOutInterval', bound=_SupportsRange)
A:pydantic.experimental.pipeline._OtherIn->TypeVar('_OtherIn')
A:pydantic.experimental.pipeline._OtherOut->TypeVar('_OtherOut')
pydantic.experimental.pipeline._Constraint
pydantic.experimental.pipeline._Eq
pydantic.experimental.pipeline._FieldTypeMarker
pydantic.experimental.pipeline._In
pydantic.experimental.pipeline._NotEq
pydantic.experimental.pipeline._NotIn
pydantic.experimental.pipeline._Pipeline(Generic[_InT,_OutT])
pydantic.experimental.pipeline._Pipeline.__get_pydantic_core_schema__(self,source_type:Any,handler:GetCoreSchemaHandler)->cs.CoreSchema
pydantic.experimental.pipeline._Pipeline.__supports_type__(self,_:_OutT)->bool
pydantic.experimental.pipeline._Pipeline.constrain(self,constraint:_ConstraintAnnotation)->Any
pydantic.experimental.pipeline._Pipeline.datetime_tz(self:_Pipeline[_InT,datetime.datetime],tz:datetime.tzinfo)->_Pipeline[_InT, datetime.datetime]
pydantic.experimental.pipeline._Pipeline.datetime_tz_aware(self:_Pipeline[_InT,datetime.datetime])->_Pipeline[_InT, datetime.datetime]
pydantic.experimental.pipeline._Pipeline.datetime_tz_naive(self:_Pipeline[_InT,datetime.datetime])->_Pipeline[_InT, datetime.datetime]
pydantic.experimental.pipeline._Pipeline.datetime_with_tz(self:_Pipeline[_InT,datetime.datetime],tz:datetime.tzinfo|None)->_Pipeline[_InT, datetime.datetime]
pydantic.experimental.pipeline._Pipeline.eq(self:_Pipeline[_InT,_OutT],value:_OutT)->_Pipeline[_InT, _OutT]
pydantic.experimental.pipeline._Pipeline.ge(self:_Pipeline[_InT,_NewOutGe],ge:_NewOutGe)->_Pipeline[_InT, _NewOutGe]
pydantic.experimental.pipeline._Pipeline.gt(self:_Pipeline[_InT,_NewOutGt],gt:_NewOutGt)->_Pipeline[_InT, _NewOutGt]
pydantic.experimental.pipeline._Pipeline.in_(self:_Pipeline[_InT,_OutT],values:Container[_OutT])->_Pipeline[_InT, _OutT]
pydantic.experimental.pipeline._Pipeline.le(self:_Pipeline[_InT,_NewOutLe],le:_NewOutLe)->_Pipeline[_InT, _NewOutLe]
pydantic.experimental.pipeline._Pipeline.len(self:_Pipeline[_InT,_NewOutLen],min_len:int,max_len:int|None=None)->_Pipeline[_InT, _NewOutLen]
pydantic.experimental.pipeline._Pipeline.lt(self:_Pipeline[_InT,_NewOutLt],lt:_NewOutLt)->_Pipeline[_InT, _NewOutLt]
pydantic.experimental.pipeline._Pipeline.multiple_of(self:_Pipeline[_InT,Any],multiple_of:Any)->_Pipeline[_InT, Any]
pydantic.experimental.pipeline._Pipeline.not_eq(self:_Pipeline[_InT,_OutT],value:_OutT)->_Pipeline[_InT, _OutT]
pydantic.experimental.pipeline._Pipeline.not_in(self:_Pipeline[_InT,_OutT],values:Container[_OutT])->_Pipeline[_InT, _OutT]
pydantic.experimental.pipeline._Pipeline.otherwise(self,other:_Pipeline[_OtherIn,_OtherOut])->_Pipeline[_InT | _OtherIn, _OutT | _OtherOut]
pydantic.experimental.pipeline._Pipeline.predicate(self:_Pipeline[_InT,_NewOutT],func:Callable[[_NewOutT],bool])->_Pipeline[_InT, _NewOutT]
pydantic.experimental.pipeline._Pipeline.str_contains(self:_Pipeline[_InT,str],substring:str)->_Pipeline[_InT, str]
pydantic.experimental.pipeline._Pipeline.str_ends_with(self:_Pipeline[_InT,str],suffix:str)->_Pipeline[_InT, str]
pydantic.experimental.pipeline._Pipeline.str_lower(self:_Pipeline[_InT,str])->_Pipeline[_InT, str]
pydantic.experimental.pipeline._Pipeline.str_pattern(self:_Pipeline[_InT,str],pattern:str)->_Pipeline[_InT, str]
pydantic.experimental.pipeline._Pipeline.str_starts_with(self:_Pipeline[_InT,str],prefix:str)->_Pipeline[_InT, str]
pydantic.experimental.pipeline._Pipeline.str_strip(self:_Pipeline[_InT,str])->_Pipeline[_InT, str]
pydantic.experimental.pipeline._Pipeline.str_title(self:_Pipeline[_InT,str])->_Pipeline[_InT, str]
pydantic.experimental.pipeline._Pipeline.str_upper(self:_Pipeline[_InT,str])->_Pipeline[_InT, str]
pydantic.experimental.pipeline._Pipeline.then(self,other:_Pipeline[_OutT,_OtherOut])->_Pipeline[_InT, _OtherOut]
pydantic.experimental.pipeline._Pipeline.transform(self,func:Callable[[_OutT],_NewOutT])->_Pipeline[_InT, _NewOutT]
pydantic.experimental.pipeline._Pipeline.validate_as(self,tp:type[_NewOutT]|EllipsisType,*,strict:bool=False)->_Pipeline[_InT, Any]
pydantic.experimental.pipeline._Pipeline.validate_as_deferred(self,func:Callable[[],type[_NewOutT]])->_Pipeline[_InT, _NewOutT]
pydantic.experimental.pipeline._PipelineAnd
pydantic.experimental.pipeline._PipelineOr
pydantic.experimental.pipeline._SupportsLen(Protocol)
pydantic.experimental.pipeline._SupportsLen.__len__(self)->int
pydantic.experimental.pipeline._SupportsRange(annotated_types.SupportsLe,annotated_types.SupportsGe,Protocol)
pydantic.experimental.pipeline._Transform
pydantic.experimental.pipeline._ValidateAs
pydantic.experimental.pipeline._ValidateAsDefer
pydantic.experimental.pipeline._ValidateAsDefer.tp(self)->type[Any]
pydantic.experimental.pipeline._apply_constraint(s:cs.CoreSchema|None,constraint:_ConstraintAnnotation)->cs.CoreSchema
pydantic.experimental.pipeline._apply_parse(s:cs.CoreSchema|None,tp:type[Any],strict:bool,handler:GetCoreSchemaHandler,source_type:Any)->cs.CoreSchema
pydantic.experimental.pipeline._apply_step(step:_Step,s:cs.CoreSchema|None,handler:GetCoreSchemaHandler,source_type:Any)->cs.CoreSchema
pydantic.experimental.pipeline._apply_transform(s:cs.CoreSchema|None,func:Callable[[Any],Any],handler:GetCoreSchemaHandler)->cs.CoreSchema
pydantic.experimental.pipeline._check_func(func:Callable[[Any],bool],predicate_err:str|Callable[[],str],s:cs.CoreSchema|None)->cs.CoreSchema


----------------------------------------/dataset/nuaa/anaconda3/envs/pydantic2.10.6/lib/python3.9/site-packages/pydantic/plugin/_loader.py----------------------------------------
A:pydantic.plugin._loader.disabled_plugins->os.getenv('PYDANTIC_DISABLE_PLUGINS')
A:pydantic.plugin._loader._plugins[entry_point.value]->entry_point.load()
pydantic.plugin._loader.get_plugins()->Iterable[PydanticPluginProtocol]


----------------------------------------/dataset/nuaa/anaconda3/envs/pydantic2.10.6/lib/python3.9/site-packages/pydantic/plugin/__init__.py----------------------------------------
pydantic.plugin.__init__.BaseValidateHandlerProtocol(Protocol)
pydantic.plugin.__init__.BaseValidateHandlerProtocol.on_error(self,error:ValidationError)->None
pydantic.plugin.__init__.BaseValidateHandlerProtocol.on_exception(self,exception:Exception)->None
pydantic.plugin.__init__.BaseValidateHandlerProtocol.on_success(self,result:Any)->None
pydantic.plugin.__init__.PydanticPluginProtocol(Protocol)
pydantic.plugin.__init__.PydanticPluginProtocol.new_schema_validator(self,schema:CoreSchema,schema_type:Any,schema_type_path:SchemaTypePath,schema_kind:SchemaKind,config:CoreConfig|None,plugin_settings:dict[str,object])->tuple[ValidatePythonHandlerProtocol | None, ValidateJsonHandlerProtocol | None, ValidateStringsHandlerProtocol | None]
pydantic.plugin.__init__.SchemaTypePath(NamedTuple)
pydantic.plugin.__init__.ValidateJsonHandlerProtocol(BaseValidateHandlerProtocol,Protocol)
pydantic.plugin.__init__.ValidateJsonHandlerProtocol.on_enter(self,input:str|bytes|bytearray,*,strict:bool|None=None,context:dict[str,Any]|None=None,self_instance:Any|None=None)->None
pydantic.plugin.__init__.ValidatePythonHandlerProtocol(BaseValidateHandlerProtocol,Protocol)
pydantic.plugin.__init__.ValidatePythonHandlerProtocol.on_enter(self,input:Any,*,strict:bool|None=None,from_attributes:bool|None=None,context:dict[str,Any]|None=None,self_instance:Any|None=None)->None
pydantic.plugin.__init__.ValidateStringsHandlerProtocol(BaseValidateHandlerProtocol,Protocol)
pydantic.plugin.__init__.ValidateStringsHandlerProtocol.on_enter(self,input:StringInput,*,strict:bool|None=None,context:dict[str,Any]|None=None)->None


----------------------------------------/dataset/nuaa/anaconda3/envs/pydantic2.10.6/lib/python3.9/site-packages/pydantic/plugin/_schema_validator.py----------------------------------------
A:pydantic.plugin._schema_validator.P->ParamSpec('P')
A:pydantic.plugin._schema_validator.R->TypeVar('R')
A:pydantic.plugin._schema_validator.plugins->get_plugins()
A:pydantic.plugin._schema_validator.self._schema_validator->SchemaValidator(schema, config)
A:pydantic.plugin._schema_validator.(p, j, s)->plugin.new_schema_validator(schema, schema_type, schema_type_path, schema_kind, config, plugin_settings)
A:pydantic.plugin._schema_validator.self.validate_python->build_wrapper(self._schema_validator.validate_python, python_event_handlers)
A:pydantic.plugin._schema_validator.self.validate_json->build_wrapper(self._schema_validator.validate_json, json_event_handlers)
A:pydantic.plugin._schema_validator.self.validate_strings->build_wrapper(self._schema_validator.validate_strings, strings_event_handlers)
A:pydantic.plugin._schema_validator.on_enters->tuple((h.on_enter for h in event_handlers if filter_handlers(h, 'on_enter')))
A:pydantic.plugin._schema_validator.on_successes->tuple((h.on_success for h in event_handlers if filter_handlers(h, 'on_success')))
A:pydantic.plugin._schema_validator.on_errors->tuple((h.on_error for h in event_handlers if filter_handlers(h, 'on_error')))
A:pydantic.plugin._schema_validator.on_exceptions->tuple((h.on_exception for h in event_handlers if filter_handlers(h, 'on_exception')))
A:pydantic.plugin._schema_validator.result->func(*args, **kwargs)
A:pydantic.plugin._schema_validator.handler->getattr(handler_cls, method_name, None)
pydantic.plugin._schema_validator.PluggableSchemaValidator(self,schema:CoreSchema,schema_type:Any,schema_type_path:SchemaTypePath,schema_kind:SchemaKind,config:CoreConfig|None,plugins:Iterable[PydanticPluginProtocol],plugin_settings:dict[str,Any])
pydantic.plugin._schema_validator.PluggableSchemaValidator.__getattr__(self,name:str)->Any
pydantic.plugin._schema_validator.PluggableSchemaValidator.__init__(self,schema:CoreSchema,schema_type:Any,schema_type_path:SchemaTypePath,schema_kind:SchemaKind,config:CoreConfig|None,plugins:Iterable[PydanticPluginProtocol],plugin_settings:dict[str,Any])
pydantic.plugin._schema_validator.build_wrapper(func:Callable[P,R],event_handlers:list[BaseValidateHandlerProtocol])->Callable[P, R]
pydantic.plugin._schema_validator.create_schema_validator(schema:CoreSchema,schema_type:Any,schema_type_module:str,schema_type_name:str,schema_kind:SchemaKind,config:CoreConfig|None=None,plugin_settings:dict[str,Any]|None=None)->SchemaValidator | PluggableSchemaValidator
pydantic.plugin._schema_validator.filter_handlers(handler_cls:BaseValidateHandlerProtocol,method_name:str)->bool


----------------------------------------/dataset/nuaa/anaconda3/envs/pydantic2.10.6/lib/python3.9/site-packages/pydantic/deprecated/__init__.py----------------------------------------


----------------------------------------/dataset/nuaa/anaconda3/envs/pydantic2.10.6/lib/python3.9/site-packages/pydantic/deprecated/decorator.py----------------------------------------
A:pydantic.deprecated.decorator.AnyCallableT->TypeVar('AnyCallableT', bound=AnyCallable)
A:pydantic.deprecated.decorator.vd->ValidatedFunction(_func, config)
A:pydantic.deprecated.decorator.type_hints->_internal._typing_extra.get_type_hints(function, include_extras=True)
A:pydantic.deprecated.decorator.values->self.build_values(args, kwargs)
A:pydantic.deprecated.decorator.m->self.init_model_instance(*args, **kwargs)
A:pydantic.deprecated.decorator.arg_iter->enumerate(args)
A:pydantic.deprecated.decorator.(i, a)->next(arg_iter)
A:pydantic.deprecated.decorator.arg_name->self.arg_mapping.get(i)
A:pydantic.deprecated.decorator.var_kwargs->d.pop(self.v_kwargs_name, {})
A:pydantic.deprecated.decorator.pos_args->len(self.arg_mapping)
A:pydantic.deprecated.decorator.config_wrapper->_internal._config.ConfigWrapper(config)
A:pydantic.deprecated.decorator.keys->', '.join(map(repr, v))
A:pydantic.deprecated.decorator.self.model->create_model(to_pascal(self.raw_function.__name__), __base__=DecoratorBaseModel, **fields)
pydantic.deprecated.decorator.ValidatedFunction(self,function:'AnyCallable',config:'ConfigType')
pydantic.deprecated.decorator.ValidatedFunction.__init__(self,function:'AnyCallable',config:'ConfigType')
pydantic.deprecated.decorator.ValidatedFunction.build_values(self,args:Tuple[Any,...],kwargs:Dict[str,Any])->Dict[str, Any]
pydantic.deprecated.decorator.ValidatedFunction.call(self,*args:Any,**kwargs:Any)->Any
pydantic.deprecated.decorator.ValidatedFunction.create_model(self,fields:Dict[str,Any],takes_args:bool,takes_kwargs:bool,config:'ConfigType')->None
pydantic.deprecated.decorator.ValidatedFunction.execute(self,m:BaseModel)->Any
pydantic.deprecated.decorator.ValidatedFunction.init_model_instance(self,*args:Any,**kwargs:Any)->BaseModel
pydantic.deprecated.decorator.validate_arguments(func:Optional['AnyCallableT']=None,*,config:'ConfigType'=None)->Any


----------------------------------------/dataset/nuaa/anaconda3/envs/pydantic2.10.6/lib/python3.9/site-packages/pydantic/deprecated/parse.py----------------------------------------
A:pydantic.deprecated.parse.b->Path(path).read_bytes()
A:pydantic.deprecated.parse.path->Path(path)
pydantic.deprecated.parse.Protocol(str,Enum)
pydantic.deprecated.parse.load_file(path:str|Path,*,content_type:str|None=None,encoding:str='utf8',proto:Protocol|None=None,allow_pickle:bool=False,json_loads:Callable[[str],Any]=json.loads)->Any
pydantic.deprecated.parse.load_str_bytes(b:str|bytes,*,content_type:str|None=None,encoding:str='utf8',proto:Protocol|None=None,allow_pickle:bool=False,json_loads:Callable[[str],Any]=json.loads)->Any


----------------------------------------/dataset/nuaa/anaconda3/envs/pydantic2.10.6/lib/python3.9/site-packages/pydantic/deprecated/class_validators.py----------------------------------------
A:pydantic.deprecated.class_validators._V1ValidatorType->TypeVar('_V1ValidatorType', V1Validator, _PartialClsOrStaticMethod)
A:pydantic.deprecated.class_validators._V1RootValidatorFunctionType->TypeVar('_V1RootValidatorFunctionType', _decorators_v1.V1RootValidatorFunction, _V1RootValidatorClsMethod, _PartialClsOrStaticMethod)
A:pydantic.deprecated.class_validators.f->_internal._decorators.ensure_classmethod_based_on_signature(f)
A:pydantic.deprecated.class_validators.validator_wrapper_info->_internal._decorators.ValidatorDecoratorInfo(fields=fields, mode=mode, each_item=each_item, always=always, check_fields=check_fields)
A:pydantic.deprecated.class_validators.wrap->partial(_decorators_v1.make_v1_generic_root_validator, pre=pre)
A:pydantic.deprecated.class_validators.res->_internal._decorators.ensure_classmethod_based_on_signature(f)
A:pydantic.deprecated.class_validators.dec_info->_internal._decorators.RootValidatorDecoratorInfo(mode=mode)
pydantic.deprecated.class_validators.root_validator(*__args,pre:bool=False,skip_on_failure:bool=False,allow_reuse:bool=False)->Any
pydantic.deprecated.class_validators.validator(__field:str,*fields:str,pre:bool=False,each_item:bool=False,always:bool=False,check_fields:bool|None=None,allow_reuse:bool=False)->Callable[[_V1ValidatorType], _V1ValidatorType]
pydantic.root_validator(*__args,pre:bool=False,skip_on_failure:bool=False,allow_reuse:bool=False)->Any
pydantic.validator(__field:str,*fields:str,pre:bool=False,each_item:bool=False,always:bool=False,check_fields:bool|None=None,allow_reuse:bool=False)->Callable[[_V1ValidatorType], _V1ValidatorType]


----------------------------------------/dataset/nuaa/anaconda3/envs/pydantic2.10.6/lib/python3.9/site-packages/pydantic/deprecated/config.py----------------------------------------
A:pydantic.deprecated.config.obj->super().__getattribute__(item)
pydantic.BaseConfig(metaclass=_ConfigMetaclass)
pydantic.BaseConfig.__getattr__(self,item:str)->Any
pydantic.BaseConfig.__init_subclass__(cls,**kwargs:Any)->None
pydantic.Extra(metaclass=_ExtraMeta)
pydantic.deprecated.config.BaseConfig(metaclass=_ConfigMetaclass)
pydantic.deprecated.config.BaseConfig.__getattr__(self,item:str)->Any
pydantic.deprecated.config.BaseConfig.__init_subclass__(cls,**kwargs:Any)->None
pydantic.deprecated.config.Extra(metaclass=_ExtraMeta)
pydantic.deprecated.config._ConfigMetaclass(type)
pydantic.deprecated.config._ConfigMetaclass.__getattr__(self,item:str)->Any
pydantic.deprecated.config._ExtraMeta(type)
pydantic.deprecated.config._ExtraMeta.__getattribute__(self,__name:str)->Any


----------------------------------------/dataset/nuaa/anaconda3/envs/pydantic2.10.6/lib/python3.9/site-packages/pydantic/deprecated/tools.py----------------------------------------
A:pydantic.deprecated.tools.T->TypeVar('T')
A:pydantic.deprecated.tools.res->TypeAdapter(type_).json_schema(by_alias=by_alias, schema_generator=schema_generator, ref_template=ref_template)
A:pydantic.deprecated.tools.res['title']->title(type_)
pydantic.deprecated.tools.parse_obj_as(type_:type[T],obj:Any,type_name:NameFactory|None=None)->T
pydantic.deprecated.tools.schema_json_of(type_:Any,*,title:NameFactory|None=None,by_alias:bool=True,ref_template:str=DEFAULT_REF_TEMPLATE,schema_generator:type[GenerateJsonSchema]=GenerateJsonSchema,**dumps_kwargs:Any)->str
pydantic.deprecated.tools.schema_of(type_:Any,*,title:NameFactory|None=None,by_alias:bool=True,ref_template:str=DEFAULT_REF_TEMPLATE,schema_generator:type[GenerateJsonSchema]=GenerateJsonSchema)->dict[str, Any]
pydantic.parse_obj_as(type_:type[T],obj:Any,type_name:NameFactory|None=None)->T
pydantic.schema_json_of(type_:Any,*,title:NameFactory|None=None,by_alias:bool=True,ref_template:str=DEFAULT_REF_TEMPLATE,schema_generator:type[GenerateJsonSchema]=GenerateJsonSchema,**dumps_kwargs:Any)->str
pydantic.schema_of(type_:Any,*,title:NameFactory|None=None,by_alias:bool=True,ref_template:str=DEFAULT_REF_TEMPLATE,schema_generator:type[GenerateJsonSchema]=GenerateJsonSchema)->dict[str, Any]


----------------------------------------/dataset/nuaa/anaconda3/envs/pydantic2.10.6/lib/python3.9/site-packages/pydantic/deprecated/copy_internals.py----------------------------------------
A:pydantic.deprecated.copy_internals.Model->typing.TypeVar('Model', bound='BaseModel')
A:pydantic.deprecated.copy_internals.exclude->_internal._utils.ValueItems.merge({k: v.exclude for (k, v) in self.__pydantic_fields__.items() if v.exclude is not None}, exclude)
A:pydantic.deprecated.copy_internals.include->_internal._utils.ValueItems.merge({k: True for k in self.__pydantic_fields__}, include, intersect=True)
A:pydantic.deprecated.copy_internals.allowed_keys->_calculate_keys(self, include=include, exclude=exclude, exclude_unset=exclude_unset)
A:pydantic.deprecated.copy_internals.items->self.__dict__.items()
A:pydantic.deprecated.copy_internals.v->_get_value(type(self), v, to_dict=to_dict, by_alias=by_alias, include=value_include and value_include.for_element(field_key), exclude=value_exclude and value_exclude.for_element(field_key), exclude_unset=exclude_unset, exclude_defaults=exclude_defaults, exclude_none=exclude_none)
A:pydantic.deprecated.copy_internals.values->deepcopy(values)
A:pydantic.deprecated.copy_internals.extra->deepcopy(extra)
A:pydantic.deprecated.copy_internals.private->deepcopy(private)
A:pydantic.deprecated.copy_internals.m->cls.__new__(cls)
A:pydantic.deprecated.copy_internals.keys->set(self.__dict__.keys())
pydantic.deprecated.copy_internals._calculate_keys(self:BaseModel,include:MappingIntStrAny|None,exclude:MappingIntStrAny|None,exclude_unset:bool,update:typing.Dict[str,Any]|None=None)->typing.AbstractSet[str] | None
pydantic.deprecated.copy_internals._copy_and_set_values(self:Model,values:dict[str,Any],fields_set:set[str],extra:dict[str,Any]|None=None,private:dict[str,Any]|None=None,*,deep:bool)->Model
pydantic.deprecated.copy_internals._get_value(cls:type[BaseModel],v:Any,to_dict:bool,by_alias:bool,include:AbstractSetIntStr|MappingIntStrAny|None,exclude:AbstractSetIntStr|MappingIntStrAny|None,exclude_unset:bool,exclude_defaults:bool,exclude_none:bool)->Any
pydantic.deprecated.copy_internals._iter(self:BaseModel,to_dict:bool=False,by_alias:bool=False,include:AbstractSetIntStr|MappingIntStrAny|None=None,exclude:AbstractSetIntStr|MappingIntStrAny|None=None,exclude_unset:bool=False,exclude_defaults:bool=False,exclude_none:bool=False)->TupleGenerator


----------------------------------------/dataset/nuaa/anaconda3/envs/pydantic2.10.6/lib/python3.9/site-packages/pydantic/deprecated/json.py----------------------------------------
A:pydantic.deprecated.json.BaseModel->import_cached_base_model()
A:pydantic.deprecated.json.(minutes, seconds)->divmod(td.seconds, 60)
A:pydantic.deprecated.json.(hours, minutes)->divmod(minutes, 60)
pydantic.deprecated.json.custom_pydantic_encoder(type_encoders:Dict[Any,Callable[[Type[Any]],Any]],obj:Any)->Any
pydantic.deprecated.json.decimal_encoder(dec_value:Decimal)->Union[int, float]
pydantic.deprecated.json.isoformat(o:Union[datetime.date,datetime.time])->str
pydantic.deprecated.json.pydantic_encoder(obj:Any)->Any
pydantic.deprecated.json.timedelta_isoformat(td:datetime.timedelta)->str


----------------------------------------/dataset/nuaa/anaconda3/envs/pydantic2.10.6/lib/python3.9/site-packages/pydantic/_internal/__init__.py----------------------------------------


----------------------------------------/dataset/nuaa/anaconda3/envs/pydantic2.10.6/lib/python3.9/site-packages/pydantic/_internal/_decorators_v1.py----------------------------------------
A:pydantic._internal._decorators_v1.sig->signature(validator)
A:pydantic._internal._decorators_v1.val1->cast(V1ValidatorWithValues, validator)
A:pydantic._internal._decorators_v1.val2->cast(V1OnlyValueValidator, validator)
A:pydantic._internal._decorators_v1.values->validator(values)
A:pydantic._internal._decorators_v1.fields->set(model_dict.keys())
A:pydantic._internal._decorators_v1.model_dict_new->validator(model_dict)
A:pydantic._internal._decorators_v1.model_extra[k]->validator(model_dict).pop(k)
pydantic._internal._decorators_v1.V1OnlyValueValidator(self,__value:Any)
pydantic._internal._decorators_v1.V1OnlyValueValidator.__call__(self,__value:Any)
pydantic._internal._decorators_v1.V1RootValidatorFunction(self,__values:RootValidatorValues)
pydantic._internal._decorators_v1.V1RootValidatorFunction.__call__(self,__values:RootValidatorValues)
pydantic._internal._decorators_v1.V1ValidatorWithKwargs(self,__value:Any,**kwargs:Any)
pydantic._internal._decorators_v1.V1ValidatorWithKwargs.__call__(self,__value:Any,**kwargs:Any)
pydantic._internal._decorators_v1.V1ValidatorWithValues(self,__value:Any,values:dict[str,Any])
pydantic._internal._decorators_v1.V1ValidatorWithValues.__call__(self,__value:Any,values:dict[str,Any])
pydantic._internal._decorators_v1.V1ValidatorWithValuesAndKwargs(self,__value:Any,values:dict[str,Any],**kwargs:Any)
pydantic._internal._decorators_v1.V1ValidatorWithValuesAndKwargs.__call__(self,__value:Any,values:dict[str,Any],**kwargs:Any)
pydantic._internal._decorators_v1.V1ValidatorWithValuesKwOnly(self,__value:Any,*,values:dict[str,Any])
pydantic._internal._decorators_v1.V1ValidatorWithValuesKwOnly.__call__(self,__value:Any,*,values:dict[str,Any])
pydantic._internal._decorators_v1.V2CoreAfterRootValidator(self,__fields_tuple:RootValidatorFieldsTuple,__info:core_schema.ValidationInfo)
pydantic._internal._decorators_v1.V2CoreAfterRootValidator.__call__(self,__fields_tuple:RootValidatorFieldsTuple,__info:core_schema.ValidationInfo)
pydantic._internal._decorators_v1.V2CoreBeforeRootValidator(self,__values:RootValidatorValues,__info:core_schema.ValidationInfo)
pydantic._internal._decorators_v1.V2CoreBeforeRootValidator.__call__(self,__values:RootValidatorValues,__info:core_schema.ValidationInfo)
pydantic._internal._decorators_v1.can_be_keyword(param:Parameter)->bool
pydantic._internal._decorators_v1.make_generic_v1_field_validator(validator:V1Validator)->core_schema.WithInfoValidatorFunction
pydantic._internal._decorators_v1.make_v1_generic_root_validator(validator:V1RootValidatorFunction,pre:bool)->V2CoreBeforeRootValidator | V2CoreAfterRootValidator


----------------------------------------/dataset/nuaa/anaconda3/envs/pydantic2.10.6/lib/python3.9/site-packages/pydantic/_internal/_fields.py----------------------------------------
A:pydantic._internal._fields.fields_docs->extract_docstrings_from_cls(cls)
A:pydantic._internal._fields.BaseModel->import_cached_base_model()
A:pydantic._internal._fields.FieldInfo_->import_cached_field_info()
A:pydantic._internal._fields.type_hints->_typing_extra.get_model_type_hints(cls, ns_resolver=ns_resolver)
A:pydantic._internal._fields.annotations->cls.__dict__.get('__annotations__', {})
A:pydantic._internal._fields.ns_violation->ann_name.startswith(protected_namespace)
A:pydantic._internal._fields.generic_origin->getattr(cls, '__pydantic_generic_metadata__', {}).get('origin')
A:pydantic._internal._fields.default->getattr(cls, ann_name, PydanticUndefined)
A:pydantic._internal._fields.field_info->import_cached_field_info().from_annotated_attribute(ann_type, dataclass_field)
A:pydantic._internal._fields.default.default->getattr(cls, ann_name, PydanticUndefined).default.__get__(None, cls)
A:pydantic._internal._fields.FieldInfo->import_cached_field_info()
A:pydantic._internal._fields.args->getattr(ann_type, '__args__', None)
A:pydantic._internal._fields.(ann_type, _)->_typing_extra.try_eval_type(dataclass_field.type, globalns, localns)
A:pydantic._internal._fields.sig->signature(default_factory)
A:pydantic._internal._fields.parameters->list(sig.parameters.values())
pydantic._internal._fields.PydanticMetadata(Representation)
pydantic._internal._fields._general_metadata_cls()->type[BaseMetadata]
pydantic._internal._fields._is_finalvar_with_default_val(type_:type[Any],val:Any)->bool
pydantic._internal._fields._update_fields_from_docstrings(cls:type[Any],fields:dict[str,FieldInfo],config_wrapper:ConfigWrapper)->None
pydantic._internal._fields._warn_on_nested_alias_in_annotation(ann_type:type[Any],ann_name:str)->None
pydantic._internal._fields.collect_dataclass_fields(cls:type[StandardDataclass],*,ns_resolver:NsResolver|None=None,typevars_map:dict[Any,Any]|None=None,config_wrapper:ConfigWrapper|None=None)->dict[str, FieldInfo]
pydantic._internal._fields.collect_model_fields(cls:type[BaseModel],bases:tuple[type[Any],...],config_wrapper:ConfigWrapper,ns_resolver:NsResolver|None,*,typevars_map:dict[Any,Any]|None=None)->tuple[dict[str, FieldInfo], set[str]]
pydantic._internal._fields.is_valid_field_name(name:str)->bool
pydantic._internal._fields.is_valid_privateattr_name(name:str)->bool
pydantic._internal._fields.pydantic_general_metadata(**metadata:Any)->BaseMetadata
pydantic._internal._fields.takes_validated_data_argument(default_factory:Callable[[],Any]|Callable[[dict[str,Any]],Any])->TypeIs[Callable[[dict[str, Any]], Any]]


----------------------------------------/dataset/nuaa/anaconda3/envs/pydantic2.10.6/lib/python3.9/site-packages/pydantic/_internal/_decorators.py----------------------------------------
A:pydantic._internal._decorators.ReturnType->TypeVar('ReturnType')
A:pydantic._internal._decorators.f->partial(self._call_wrapped_attr, name=attr)
A:pydantic._internal._decorators.self.wrapped->getattr(self.wrapped, name)(func)
A:pydantic._internal._decorators.DecoratorInfoType->TypeVar('DecoratorInfoType', bound=DecoratorInfo)
A:pydantic._internal._decorators.func->unwrap_wrapped_function(attribute.wrapped)
A:pydantic._internal._decorators.attribute->base.__dict__.get(name, _sentinel)
A:pydantic._internal._decorators.bases->get_bases(tp)
A:pydantic._internal._decorators._sentinel->object()
A:pydantic._internal._decorators.attribute_get->getattr(attribute, '__get__', None)
A:pydantic._internal._decorators.res->DecoratorInfos()
A:pydantic._internal._decorators.existing->DecoratorInfos.build(base)
A:pydantic._internal._decorators.res.validators[var_name]->Decorator.build(model_dc, cls_var_name=var_name, shim=var_value.shim, info=info)
A:pydantic._internal._decorators.res.field_validators[var_name]->Decorator.build(model_dc, cls_var_name=var_name, shim=var_value.shim, info=info)
A:pydantic._internal._decorators.res.root_validators[var_name]->Decorator.build(model_dc, cls_var_name=var_name, shim=var_value.shim, info=info)
A:pydantic._internal._decorators.res.field_serializers[var_name]->Decorator.build(model_dc, cls_var_name=var_name, shim=var_value.shim, info=info)
A:pydantic._internal._decorators.res.model_validators[var_name]->Decorator.build(model_dc, cls_var_name=var_name, shim=var_value.shim, info=info)
A:pydantic._internal._decorators.res.model_serializers[var_name]->Decorator.build(model_dc, cls_var_name=var_name, shim=var_value.shim, info=info)
A:pydantic._internal._decorators.res.computed_fields[var_name]->Decorator.build(model_dc, cls_var_name=var_name, shim=None, info=info)
A:pydantic._internal._decorators.sig->signature(unwrap_wrapped_function(function))
A:pydantic._internal._decorators.n_positional->count_positional_required_params(sig)
A:pydantic._internal._decorators.first->next(iter(sig.parameters.values()), None)
A:pydantic._internal._decorators.info_arg->_serializer_info_arg(mode, count_positional_required_params(sig))
A:pydantic._internal._decorators.hints->get_function_type_hints(unwrap_wrapped_function(func), include_keys={'return'}, globalns=globalns, localns=localns)
A:pydantic._internal._decorators.parameters->list(sig.parameters.values())
pydantic._internal._decorators.Decorator(Generic[DecoratorInfoType])
pydantic._internal._decorators.Decorator.bind_to_cls(self,cls:Any)->Decorator[DecoratorInfoType]
pydantic._internal._decorators.Decorator.build(cls_:Any,*,cls_var_name:str,shim:Callable[[Any],Any]|None,info:DecoratorInfoType)->Decorator[DecoratorInfoType]
pydantic._internal._decorators.DecoratorInfos
pydantic._internal._decorators.DecoratorInfos.build(model_dc:type[Any])->DecoratorInfos
pydantic._internal._decorators.FieldSerializerDecoratorInfo
pydantic._internal._decorators.FieldValidatorDecoratorInfo
pydantic._internal._decorators.ModelSerializerDecoratorInfo
pydantic._internal._decorators.ModelValidatorDecoratorInfo
pydantic._internal._decorators.PydanticDescriptorProxy(Generic[ReturnType])
pydantic._internal._decorators.PydanticDescriptorProxy.__get__(self,obj:object|None,obj_type:type[object]|None=None)->PydanticDescriptorProxy[ReturnType]
pydantic._internal._decorators.PydanticDescriptorProxy.__getattr__(self,__name:str)->Any
pydantic._internal._decorators.PydanticDescriptorProxy.__post_init__(self)
pydantic._internal._decorators.PydanticDescriptorProxy.__set_name__(self,instance:Any,name:str)->None
pydantic._internal._decorators.PydanticDescriptorProxy._call_wrapped_attr(self,func:Callable[[Any],None],*,name:str)->PydanticDescriptorProxy[ReturnType]
pydantic._internal._decorators.RootValidatorDecoratorInfo
pydantic._internal._decorators.ValidatorDecoratorInfo
pydantic._internal._decorators._is_classmethod_from_sig(function:AnyDecoratorCallable)->bool
pydantic._internal._decorators._serializer_info_arg(mode:Literal['plain','wrap'],n_positional:int)->bool | None
pydantic._internal._decorators.count_positional_required_params(sig:Signature)->int
pydantic._internal._decorators.ensure_classmethod_based_on_signature(function:AnyDecoratorCallable)->Any
pydantic._internal._decorators.ensure_property(f:Any)->Any
pydantic._internal._decorators.get_attribute_from_base_dicts(tp:type[Any],name:str)->Any
pydantic._internal._decorators.get_attribute_from_bases(tp:type[Any]|tuple[type[Any],...],name:str)->Any
pydantic._internal._decorators.get_bases(tp:type[Any])->tuple[type[Any], ...]
pydantic._internal._decorators.get_function_return_type(func:Any,explicit_return_type:Any,globalns:GlobalsNamespace|None=None,localns:MappingNamespace|None=None)->Any
pydantic._internal._decorators.inspect_annotated_serializer(serializer:Callable[...,Any],mode:Literal['plain','wrap'])->bool
pydantic._internal._decorators.inspect_field_serializer(serializer:Callable[...,Any],mode:Literal['plain','wrap'])->tuple[bool, bool]
pydantic._internal._decorators.inspect_model_serializer(serializer:Callable[...,Any],mode:Literal['plain','wrap'])->bool
pydantic._internal._decorators.inspect_validator(validator:Callable[...,Any],mode:FieldValidatorModes)->bool
pydantic._internal._decorators.is_instance_method_from_sig(function:AnyDecoratorCallable)->bool
pydantic._internal._decorators.mro(tp:type[Any])->tuple[type[Any], ...]
pydantic._internal._decorators.mro_for_bases(bases:tuple[type[Any],...])->tuple[type[Any], ...]
pydantic._internal._decorators.unwrap_wrapped_function(func:Any,*,unwrap_partial:bool=True,unwrap_class_static_method:bool=True)->Any


----------------------------------------/dataset/nuaa/anaconda3/envs/pydantic2.10.6/lib/python3.9/site-packages/pydantic/_internal/_known_annotated_metadata.py----------------------------------------
A:pydantic._internal._known_annotated_metadata.FieldInfo->import_cached_field_info()
A:pydantic._internal._known_annotated_metadata.annotation->copy(annotation)
A:pydantic._internal._known_annotated_metadata.schema->pydantic_core.core_schema.no_info_after_validator_function(val_func, schema)
A:pydantic._internal._known_annotated_metadata.(schema_update, other_metadata)->collect_known_metadata([annotation])
A:pydantic._internal._known_annotated_metadata.schema['schema']->apply_known_metadata(annotation, schema['schema'])
A:pydantic._internal._known_annotated_metadata.x->handler(value)
A:pydantic._internal._known_annotated_metadata.metadata->pydantic_core.core_schema.no_info_after_validator_function(val_func, schema).get('metadata', {})
A:pydantic._internal._known_annotated_metadata.validator->_validators.NUMERIC_VALIDATOR_LOOKUP.get(constraint)
A:pydantic._internal._known_annotated_metadata.predicate_satisfied->copy(annotation).func(v)
A:pydantic._internal._known_annotated_metadata.annotations->expand_grouped_metadata(annotations)
A:pydantic._internal._known_annotated_metadata.res[constraint]->getattr(annotation, constraint)
pydantic._internal._known_annotated_metadata._get_at_to_constraint_map()->dict[type, str]
pydantic._internal._known_annotated_metadata.apply_known_metadata(annotation:Any,schema:CoreSchema)->CoreSchema | None
pydantic._internal._known_annotated_metadata.as_jsonable_value(v:Any)->Any
pydantic._internal._known_annotated_metadata.check_metadata(metadata:dict[str,Any],allowed:Iterable[str],source_type:Any)->None
pydantic._internal._known_annotated_metadata.collect_known_metadata(annotations:Iterable[Any])->tuple[dict[str, Any], list[Any]]
pydantic._internal._known_annotated_metadata.expand_grouped_metadata(annotations:Iterable[Any])->Iterable[Any]


----------------------------------------/dataset/nuaa/anaconda3/envs/pydantic2.10.6/lib/python3.9/site-packages/pydantic/_internal/_utils.py----------------------------------------
A:pydantic._internal._utils.BaseModel->import_cached_base_model()
A:pydantic._internal._utils.KeyType->TypeVar('KeyType')
A:pydantic._internal._utils.updated_mapping->mapping.copy()
A:pydantic._internal._utils.updated_mapping[k]->deep_update(updated_mapping[k], v)
A:pydantic._internal._utils.T->TypeVar('T')
A:pydantic._internal._utils.v_name->name_factory(v)
A:pydantic._internal._utils.items->dict.fromkeys(items, ...)
A:pydantic._internal._utils.item->self._items.get(e)
A:pydantic._internal._utils.all_items->self._coerce_value(v)
A:pydantic._internal._utils.normalized_items[normalized_i]->self.merge(v, normalized_items.get(normalized_i))
A:pydantic._internal._utils.normalized_item->normalized_items.setdefault(i, {})
A:pydantic._internal._utils.normalized_items[i]->self.merge(all_items, normalized_item)
A:pydantic._internal._utils.override->cls._coerce_value(override)
A:pydantic._internal._utils.base->cls._coerce_value(base)
A:pydantic._internal._utils.merged_item->cls.merge(base.get(k), override.get(k), intersect=intersect)
A:pydantic._internal._utils.class_name->getattr(items, '__class__', '???')
A:pydantic._internal._utils.Obj->TypeVar('Obj')
A:pydantic._internal._utils._SENTINEL->object()
pydantic._internal._utils.SafeGetItemProxy
pydantic._internal._utils.SafeGetItemProxy.__getitem__(self,key:str,/)->Any
pydantic._internal._utils.ValueItems(self,value:Any,items:AbstractSetIntStr|MappingIntStrAny)
pydantic._internal._utils.ValueItems.__init__(self,value:Any,items:AbstractSetIntStr|MappingIntStrAny)
pydantic._internal._utils.ValueItems.__repr_args__(self)->_repr.ReprArgs
pydantic._internal._utils.ValueItems._coerce_items(items:AbstractSetIntStr|MappingIntStrAny)->MappingIntStrAny
pydantic._internal._utils.ValueItems._coerce_value(cls,value:Any)->Any
pydantic._internal._utils.ValueItems._normalize_indexes(self,items:MappingIntStrAny,v_length:int)->dict[int | str, Any]
pydantic._internal._utils.ValueItems.for_element(self,e:int|str)->AbstractSetIntStr | MappingIntStrAny | None
pydantic._internal._utils.ValueItems.is_excluded(self,item:Any)->bool
pydantic._internal._utils.ValueItems.is_included(self,item:Any)->bool
pydantic._internal._utils.ValueItems.is_true(v:Any)->bool
pydantic._internal._utils.ValueItems.merge(cls,base:Any,override:Any,intersect:bool=False)->Any
pydantic._internal._utils.all_identical(left:typing.Iterable[Any],right:typing.Iterable[Any])->bool
pydantic._internal._utils.can_be_positional(param:Parameter)->bool
pydantic._internal._utils.deep_update(mapping:dict[KeyType,Any],*updating_mappings:dict[KeyType,Any])->dict[KeyType, Any]
pydantic._internal._utils.is_model_class(cls:Any)->TypeGuard[type[BaseModel]]
pydantic._internal._utils.is_valid_identifier(identifier:str)->bool
pydantic._internal._utils.lenient_isinstance(o:Any,class_or_tuple:type[Any]|tuple[type[Any],...]|None)->bool
pydantic._internal._utils.lenient_issubclass(cls:Any,class_or_tuple:Any)->bool
pydantic._internal._utils.sequence_like(v:Any)->bool
pydantic._internal._utils.smart_deepcopy(obj:Obj)->Obj
pydantic._internal._utils.unique_list(input_list:list[T]|tuple[T,...],*,name_factory:typing.Callable[[T],str]=str)->list[T]
pydantic._internal._utils.update_not_none(mapping:dict[Any,Any],**update:Any)->None


----------------------------------------/dataset/nuaa/anaconda3/envs/pydantic2.10.6/lib/python3.9/site-packages/pydantic/_internal/_namespace_utils.py----------------------------------------
A:pydantic._internal._namespace_utils.module_name->getattr(obj, '__module__', None)
A:pydantic._internal._namespace_utils.globalns->get_module_ns_of(typ)
pydantic._internal._namespace_utils.LazyLocalNamespace(self,*namespaces:MappingNamespace)
pydantic._internal._namespace_utils.LazyLocalNamespace.__contains__(self,key:object)->bool
pydantic._internal._namespace_utils.LazyLocalNamespace.__getitem__(self,key:str)->Any
pydantic._internal._namespace_utils.LazyLocalNamespace.__init__(self,*namespaces:MappingNamespace)
pydantic._internal._namespace_utils.LazyLocalNamespace.__iter__(self)->Iterator[str]
pydantic._internal._namespace_utils.LazyLocalNamespace.__len__(self)->int
pydantic._internal._namespace_utils.LazyLocalNamespace.data(self)->dict[str, Any]
pydantic._internal._namespace_utils.NamespacesTuple(NamedTuple)
pydantic._internal._namespace_utils.NsResolver(self,namespaces_tuple:NamespacesTuple|None=None,parent_namespace:MappingNamespace|None=None)
pydantic._internal._namespace_utils.NsResolver.__init__(self,namespaces_tuple:NamespacesTuple|None=None,parent_namespace:MappingNamespace|None=None)
pydantic._internal._namespace_utils.NsResolver.push(self,typ:type[Any]|TypeAliasType,/)->Generator[None]
pydantic._internal._namespace_utils.NsResolver.types_namespace(self)->NamespacesTuple
pydantic._internal._namespace_utils.get_module_ns_of(obj:Any)->dict[str, Any]
pydantic._internal._namespace_utils.ns_for_function(obj:Callable[...,Any],parent_namespace:MappingNamespace|None=None)->NamespacesTuple


----------------------------------------/dataset/nuaa/anaconda3/envs/pydantic2.10.6/lib/python3.9/site-packages/pydantic/_internal/_generate_schema.py----------------------------------------
A:pydantic._internal._generate_schema.FieldDecoratorInfoType->TypeVar('FieldDecoratorInfoType', bound=FieldDecoratorInfo)
A:pydantic._internal._generate_schema.VALIDATE_CALL_SUPPORTED_TYPES->get_args(ValidateCallSupportedTypes)
A:pydantic._internal._generate_schema.fields->collect_dataclass_fields(dataclass, typevars_map=typevars_map)
A:pydantic._internal._generate_schema.schema['schema']->self._apply_field_serializers(inner_schema, serializers)
A:pydantic._internal._generate_schema.schema['items_schema'][variadic_item_index]->apply_validators(schema['items_schema'][variadic_item_index], each_item_validators, field_name)
A:pydantic._internal._generate_schema.inner_schema->apply_model_validators(inner_schema, model_validators, 'inner')
A:pydantic._internal._generate_schema.schema['items_schema']->apply_validators(inner_schema, each_item_validators, field_name)
A:pydantic._internal._generate_schema.schema['values_schema']->apply_validators(inner_schema, each_item_validators, field_name)
A:pydantic._internal._generate_schema.encoder->json_encoders.get(base)
A:pydantic._internal._generate_schema.schema['serialization']->pydantic_core.core_schema.plain_serializer_function_ser_schema(serializer.func, is_field_serializer=is_field_serializer, info_arg=info_arg, return_schema=return_schema, when_used=serializer.info.when_used)
A:pydantic._internal._generate_schema.self._config_wrapper_stack->ConfigWrapperStack(config_wrapper)
A:pydantic._internal._generate_schema.self.field_name_stack->_FieldNameStack()
A:pydantic._internal._generate_schema.self.model_type_stack->_ModelTypeStack()
A:pydantic._internal._generate_schema.self.defs->_Definitions()
A:pydantic._internal._generate_schema.enum_ref->get_type_ref(enum_type)
A:pydantic._internal._generate_schema.value_ser_type->pydantic_core.core_schema.plain_serializer_function_ser_schema(lambda x: x)
A:pydantic._internal._generate_schema.json_schema->smart_deepcopy(list_schema)
A:pydantic._internal._generate_schema.original_schema->handler.resolve_ref_schema(json_schema)
A:pydantic._internal._generate_schema.enum_schema->pydantic_core.core_schema.no_info_after_validator_function(attrgetter('value'), enum_schema, serialization=value_ser_type)
A:pydantic._internal._generate_schema.schema->pydantic_core.core_schema.no_info_after_validator_function(function=validator.func, schema=schema)
A:pydantic._internal._generate_schema.ref->get_type_ref(tp)
A:pydantic._internal._generate_schema.metadata->resolve_original_schema(schema, self.defs.definitions).get('metadata', {})
A:pydantic._internal._generate_schema.pydantic_js_functions->resolve_original_schema(schema, self.defs.definitions).get('metadata', {}).setdefault('pydantic_js_functions', [])
A:pydantic._internal._generate_schema.from_property->self._generate_schema_from_property(obj, source_type)
A:pydantic._internal._generate_schema.metadata_js_function->_extract_get_pydantic_json_schema(annotation, schema)
A:pydantic._internal._generate_schema.metadata_schema->resolve_original_schema(schema, self.defs.definitions)
A:pydantic._internal._generate_schema.config_wrapper->ConfigWrapper(cls.model_config, check=False)
A:pydantic._internal._generate_schema.core_config->self._config_wrapper.core_config(title=dataclass.__name__)
A:pydantic._internal._generate_schema.model_validators->_decorators.DecoratorInfos.build(typed_dict_cls).model_validators.values()
A:pydantic._internal._generate_schema.extras_annotation->_typing_extra.eval_type_backport(_typing_extra._make_forward_ref(extras_annotation, is_argument=False, is_class=True), *self._types_namespace)
A:pydantic._internal._generate_schema.tp->get_origin(extras_annotation)
A:pydantic._internal._generate_schema.extras_schema->self.generate_schema(extra_items_type)
A:pydantic._internal._generate_schema.root_field->self._common_field_schema('root', fields['root'], decorators)
A:pydantic._internal._generate_schema.model_schema->pydantic_core.core_schema.model_schema(cls, inner_schema, generic_origin=generic_origin, custom_init=getattr(cls, '__pydantic_custom_init__', None), root_model=False, post_init=getattr(cls, '__pydantic_post_init__', None), config=core_config, ref=model_ref)
A:pydantic._internal._generate_schema.new_inner_schema->define_expected_missing_refs(inner_schema, recursively_defined_type_refs())
A:pydantic._internal._generate_schema.obj->ForwardRef(obj)
A:pydantic._internal._generate_schema.args->sorted((self._generate_dc_field_schema(k, v, decorators) for (k, v) in fields.items()), key=lambda a: a.get('kw_only') is not False)
A:pydantic._internal._generate_schema.origin->get_origin(obj)
A:pydantic._internal._generate_schema.BaseModel->import_cached_base_model()
A:pydantic._internal._generate_schema.res->self._get_prepare_pydantic_annotations_for_known_type(source_type, tuple(annotations))
A:pydantic._internal._generate_schema.common_field->self._common_field_schema(name, field_info, decorators)
A:pydantic._internal._generate_schema.(alias, validation_alias, serialization_alias)->alias_generator.generate_aliases(computed_field_name)
A:pydantic._internal._generate_schema.alias->alias_generator(computed_field_name)
A:pydantic._internal._generate_schema.field_info.serialization_alias->_get_first_non_null(serialization_alias, alias)
A:pydantic._internal._generate_schema.field_info.validation_alias->_get_first_non_null(validation_alias, alias)
A:pydantic._internal._generate_schema.computed_field_info.alias->_get_first_non_null(serialization_alias, alias)
A:pydantic._internal._generate_schema.title->field_title_generator(field_name, field_info)
A:pydantic._internal._generate_schema.FieldInfo->import_cached_field_info()
A:pydantic._internal._generate_schema.evaluated_type->replace_types(evaluated_type, self._typevars_map)
A:pydantic._internal._generate_schema.new_field_info->import_cached_field_info().from_annotation(evaluated_type)
A:pydantic._internal._generate_schema.this_field_validators->filter_field_decorator_info_by_field(decorators.validators.values(), name)
A:pydantic._internal._generate_schema.(pydantic_js_updates, pydantic_js_extra)->_extract_json_schema_info_from_field_info(metadata)
A:pydantic._internal._generate_schema.validation_alias->fields.FieldInfo.from_annotation(annotation).validation_alias.convert_to_aliases()
A:pydantic._internal._generate_schema.tag->choice.get('metadata', {}).get(_core_utils.TAGGED_UNION_TAG_KEY)
A:pydantic._internal._generate_schema.s->pydantic_core.core_schema.nullable_schema(s)
A:pydantic._internal._generate_schema.typevars_map->get_standard_typevars_map(dataclass)
A:pydantic._internal._generate_schema.annotation->typing.cast(Any, Any)
A:pydantic._internal._generate_schema.expected->_typing_extra.literal_values(literal_type)
A:pydantic._internal._generate_schema.decorators->_decorators.DecoratorInfos.build(typed_dict_cls)
A:pydantic._internal._generate_schema.field_docstrings->extract_docstrings_from_cls(typed_dict_cls, use_inspect=True)
A:pydantic._internal._generate_schema.annotations->list(_known_annotated_metadata.expand_grouped_metadata(annotations))
A:pydantic._internal._generate_schema.field_info->import_cached_field_info().from_annotation(annotation)
A:pydantic._internal._generate_schema.fields[field_name]->self._generate_td_field_schema(field_name, field_info, decorators, required=required)
A:pydantic._internal._generate_schema.td_schema->pydantic_core.core_schema.typed_dict_schema(fields, cls=typed_dict_cls, computed_fields=[self._computed_field_schema(d, decorators.field_serializers) for d in decorators.computed_fields.values()], ref=typed_dict_ref, config=core_config)
A:pydantic._internal._generate_schema.arguments_schema->pydantic_core.core_schema.arguments_schema([self._generate_parameter_schema(field_name, annotation, default=namedtuple_cls._field_defaults.get(field_name, Parameter.empty)) for (field_name, annotation) in annotations.items()], metadata={'pydantic_js_prefer_positional_arguments': True})
A:pydantic._internal._generate_schema.field->import_cached_field_info().from_annotated_attribute(annotation, default)
A:pydantic._internal._generate_schema.parameter_schema->pydantic_core.core_schema.arguments_parameter(name, schema)
A:pydantic._internal._generate_schema.parameter_schema['alias']->alias_generator(name)
A:pydantic._internal._generate_schema.params->tuple((replace_types(param, typevars_map) for param in params))
A:pydantic._internal._generate_schema.type_param->self._resolve_self_type(type_param)
A:pydantic._internal._generate_schema.item_type_schema->self.generate_schema(items_type)
A:pydantic._internal._generate_schema.list_schema->pydantic_core.core_schema.list_schema(item_type_schema)
A:pydantic._internal._generate_schema.python_schema->pydantic_core.core_schema.chain_schema([python_schema, core_schema.no_info_wrap_validator_function(sequence_validator, list_schema)])
A:pydantic._internal._generate_schema.serialization->pydantic_core.core_schema.wrap_serializer_function_ser_schema(serialize_sequence_via_list, schema=item_type_schema, info_arg=True)
A:pydantic._internal._generate_schema.item_type->self._get_first_arg_or_any(type_)
A:pydantic._internal._generate_schema.ser->pydantic_core.core_schema.plain_serializer_function_ser_schema(attrgetter('pattern'), when_used='json', return_schema=core_schema.str_schema())
A:pydantic._internal._generate_schema.config->getattr(dataclass, '__pydantic_config__', None)
A:pydantic._internal._generate_schema.has_post_init->hasattr(dataclass, '__post_init__')
A:pydantic._internal._generate_schema.has_slots->hasattr(dataclass, '__slots__')
A:pydantic._internal._generate_schema.args_schema->pydantic_core.core_schema.dataclass_args_schema(dataclass.__name__, args, computed_fields=[self._computed_field_schema(d, decorators.field_serializers) for d in decorators.computed_fields.values()], collect_init_only=has_post_init)
A:pydantic._internal._generate_schema.dc_schema->pydantic_core.core_schema.dataclass_schema(dataclass, inner_schema, generic_origin=origin, post_init=has_post_init, ref=dataclass_ref, fields=[field.name for field in dataclasses.fields(dataclass)], slots=has_slots, config=core_config, frozen=self._config_wrapper_stack.tail.frozen)
A:pydantic._internal._generate_schema.sig->signature(function)
A:pydantic._internal._generate_schema.type_hints->_typing_extra.get_function_type_hints(function, globalns=globalns, localns=localns)
A:pydantic._internal._generate_schema.parameter_mode->mode_lookup.get(p.kind)
A:pydantic._internal._generate_schema.arg_schema->self._generate_parameter_schema(name, annotation, p.default, parameter_mode)
A:pydantic._internal._generate_schema.var_args_schema->self.generate_schema(annotation)
A:pydantic._internal._generate_schema.unpack_type->_typing_extra.unpack_type(annotation)
A:pydantic._internal._generate_schema.overlapping_params->non_pos_only_param_names.intersection(unpack_type.__annotations__)
A:pydantic._internal._generate_schema.var_kwargs_schema->self.generate_schema(annotation)
A:pydantic._internal._generate_schema.return_schema->self.generate_schema(return_type)
A:pydantic._internal._generate_schema.typevar_has_default->typevar.has_default()
A:pydantic._internal._generate_schema.return_type->_decorators.get_function_return_type(serializer.func, serializer.info.return_type, localns=self._types_namespace.locals)
A:pydantic._internal._generate_schema.d.info->dataclasses.replace(d.info, return_type=return_type)
A:pydantic._internal._generate_schema.return_type_schema->self._apply_field_serializers(return_type_schema, filter_field_decorator_info_by_field(field_serializers.values(), d.cls_var_name))
A:pydantic._internal._generate_schema.(source_type, *annotations)->self._get_args_resolving_forward_refs(annotated_type, required=True)
A:pydantic._internal._generate_schema.get_inner_schema->self._get_wrapped_inner_schema(get_inner_schema, annotation, pydantic_js_annotation_functions)
A:pydantic._internal._generate_schema.core_metadata->pydantic_core.core_schema.no_info_after_validator_function(function=validator.func, schema=schema).setdefault('metadata', {})
A:pydantic._internal._generate_schema.inner->self._apply_single_annotation(inner, metadata)
A:pydantic._internal._generate_schema.maybe_updated_schema->_known_annotated_metadata.apply_known_metadata(metadata, schema.copy())
A:pydantic._internal._generate_schema.(is_field_serializer, info_arg)->inspect_field_serializer(serializer.func, serializer.info.mode)
A:pydantic._internal._generate_schema.info_arg->inspect_validator(validator.func, validator.info.mode)
A:pydantic._internal._generate_schema.ser_schema->pydantic_core.core_schema.plain_serializer_function_ser_schema(serializer.func, info_arg=info_arg, return_schema=return_schema, when_used=serializer.info.when_used)
A:pydantic._internal._generate_schema.js_modify_function->getattr(tp, '__get_pydantic_json_schema__', None)
A:pydantic._internal._generate_schema.cls_name->getattr(tp, '__name__', None)
pydantic._internal._generate_schema.GenerateSchema(self,config_wrapper:ConfigWrapper,ns_resolver:NsResolver|None=None,typevars_map:dict[Any,Any]|None=None)
pydantic._internal._generate_schema.GenerateSchema.CollectedInvalid(Exception)
pydantic._internal._generate_schema.GenerateSchema.__init__(self,config_wrapper:ConfigWrapper,ns_resolver:NsResolver|None=None,typevars_map:dict[Any,Any]|None=None)
pydantic._internal._generate_schema.GenerateSchema.__init_subclass__(cls)->None
pydantic._internal._generate_schema.GenerateSchema._add_js_function(self,metadata_schema:CoreSchema,js_function:Callable[...,Any])->None
pydantic._internal._generate_schema.GenerateSchema._annotated_schema(self,annotated_type:Any)->core_schema.CoreSchema
pydantic._internal._generate_schema.GenerateSchema._apply_alias_generator_to_computed_field_info(alias_generator:Callable[[str],str]|AliasGenerator,computed_field_info:ComputedFieldInfo,computed_field_name:str)
pydantic._internal._generate_schema.GenerateSchema._apply_alias_generator_to_field_info(alias_generator:Callable[[str],str]|AliasGenerator,field_info:FieldInfo,field_name:str)->None
pydantic._internal._generate_schema.GenerateSchema._apply_annotations(self,source_type:Any,annotations:list[Any],transform_inner_schema:Callable[[CoreSchema],CoreSchema]=lambdax:x)->CoreSchema
pydantic._internal._generate_schema.GenerateSchema._apply_discriminator_to_union(self,schema:CoreSchema,discriminator:str|Discriminator|None)->CoreSchema
pydantic._internal._generate_schema.GenerateSchema._apply_field_serializers(self,schema:core_schema.CoreSchema,serializers:list[Decorator[FieldSerializerDecoratorInfo]])->core_schema.CoreSchema
pydantic._internal._generate_schema.GenerateSchema._apply_field_title_generator_to_field_info(config_wrapper:ConfigWrapper,field_info:FieldInfo|ComputedFieldInfo,field_name:str)->None
pydantic._internal._generate_schema.GenerateSchema._apply_model_serializers(self,schema:core_schema.CoreSchema,serializers:Iterable[Decorator[ModelSerializerDecoratorInfo]])->core_schema.CoreSchema
pydantic._internal._generate_schema.GenerateSchema._apply_single_annotation(self,schema:core_schema.CoreSchema,metadata:Any)->core_schema.CoreSchema
pydantic._internal._generate_schema.GenerateSchema._apply_single_annotation_json_schema(self,schema:core_schema.CoreSchema,metadata:Any)->core_schema.CoreSchema
pydantic._internal._generate_schema.GenerateSchema._arbitrary_type_schema(self,tp:Any)->CoreSchema
pydantic._internal._generate_schema.GenerateSchema._arbitrary_types(self)->bool
pydantic._internal._generate_schema.GenerateSchema._call_schema(self,function:ValidateCallSupportedTypes)->core_schema.CallSchema
pydantic._internal._generate_schema.GenerateSchema._common_field_schema(self,name:str,field_info:FieldInfo,decorators:DecoratorInfos)->_CommonField
pydantic._internal._generate_schema.GenerateSchema._computed_field_schema(self,d:Decorator[ComputedFieldInfo],field_serializers:dict[str,Decorator[FieldSerializerDecoratorInfo]])->core_schema.ComputedField
pydantic._internal._generate_schema.GenerateSchema._config_wrapper(self)->ConfigWrapper
pydantic._internal._generate_schema.GenerateSchema._dataclass_schema(self,dataclass:type[StandardDataclass],origin:type[StandardDataclass]|None)->core_schema.CoreSchema
pydantic._internal._generate_schema.GenerateSchema._dict_schema(self,keys_type:Any,values_type:Any)->CoreSchema
pydantic._internal._generate_schema.GenerateSchema._enum_schema(self,enum_type:type[Enum])->CoreSchema
pydantic._internal._generate_schema.GenerateSchema._fraction_schema(self)->CoreSchema
pydantic._internal._generate_schema.GenerateSchema._frozenset_schema(self,items_type:Any)->CoreSchema
pydantic._internal._generate_schema.GenerateSchema._generate_dc_field_schema(self,name:str,field_info:FieldInfo,decorators:DecoratorInfos)->core_schema.DataclassField
pydantic._internal._generate_schema.GenerateSchema._generate_md_field_schema(self,name:str,field_info:FieldInfo,decorators:DecoratorInfos)->core_schema.ModelField
pydantic._internal._generate_schema.GenerateSchema._generate_parameter_schema(self,name:str,annotation:type[Any],default:Any=Parameter.empty,mode:Literal['positional_only','positional_or_keyword','keyword_only']|None=None)->core_schema.ArgumentsParameter
pydantic._internal._generate_schema.GenerateSchema._generate_schema_from_property(self,obj:Any,source:Any)->core_schema.CoreSchema | None
pydantic._internal._generate_schema.GenerateSchema._generate_schema_inner(self,obj:Any)->core_schema.CoreSchema
pydantic._internal._generate_schema.GenerateSchema._generate_td_field_schema(self,name:str,field_info:FieldInfo,decorators:DecoratorInfos,*,required:bool=True)->core_schema.TypedDictField
pydantic._internal._generate_schema.GenerateSchema._get_args_resolving_forward_refs(self,obj:Any,required:bool=False)->tuple[Any, ...] | None
pydantic._internal._generate_schema.GenerateSchema._get_first_arg_or_any(self,obj:Any)->Any
pydantic._internal._generate_schema.GenerateSchema._get_first_two_args_or_any(self,obj:Any)->tuple[Any, Any]
pydantic._internal._generate_schema.GenerateSchema._get_prepare_pydantic_annotations_for_known_type(self,obj:Any,annotations:tuple[Any,...])->tuple[Any, list[Any]] | None
pydantic._internal._generate_schema.GenerateSchema._get_wrapped_inner_schema(self,get_inner_schema:GetCoreSchemaHandler,annotation:Any,pydantic_js_annotation_functions:list[GetJsonSchemaFunction])->CallbackGetCoreSchemaHandler
pydantic._internal._generate_schema.GenerateSchema._hashable_schema(self)->core_schema.CoreSchema
pydantic._internal._generate_schema.GenerateSchema._ip_schema(self,tp:Any)->CoreSchema
pydantic._internal._generate_schema.GenerateSchema._iterable_schema(self,type_:Any)->core_schema.GeneratorSchema
pydantic._internal._generate_schema.GenerateSchema._list_schema(self,items_type:Any)->CoreSchema
pydantic._internal._generate_schema.GenerateSchema._literal_schema(self,literal_type:Any)->CoreSchema
pydantic._internal._generate_schema.GenerateSchema._match_generic_type(self,obj:Any,origin:Any)->CoreSchema
pydantic._internal._generate_schema.GenerateSchema._model_schema(self,cls:type[BaseModel])->core_schema.CoreSchema
pydantic._internal._generate_schema.GenerateSchema._namedtuple_schema(self,namedtuple_cls:Any,origin:Any)->core_schema.CoreSchema
pydantic._internal._generate_schema.GenerateSchema._pattern_schema(self,pattern_type:Any)->core_schema.CoreSchema
pydantic._internal._generate_schema.GenerateSchema._resolve_forward_ref(self,obj:Any)->Any
pydantic._internal._generate_schema.GenerateSchema._resolve_self_type(self,obj:Any)->Any
pydantic._internal._generate_schema.GenerateSchema._sequence_schema(self,items_type:Any)->core_schema.CoreSchema
pydantic._internal._generate_schema.GenerateSchema._set_schema(self,items_type:Any)->CoreSchema
pydantic._internal._generate_schema.GenerateSchema._subclass_schema(self,type_:Any)->core_schema.CoreSchema
pydantic._internal._generate_schema.GenerateSchema._tuple_schema(self,tuple_type:Any)->core_schema.CoreSchema
pydantic._internal._generate_schema.GenerateSchema._type_alias_type_schema(self,obj:TypeAliasType)->CoreSchema
pydantic._internal._generate_schema.GenerateSchema._type_schema(self)->core_schema.CoreSchema
pydantic._internal._generate_schema.GenerateSchema._typed_dict_schema(self,typed_dict_cls:Any,origin:Any)->core_schema.CoreSchema
pydantic._internal._generate_schema.GenerateSchema._types_namespace(self)->NamespacesTuple
pydantic._internal._generate_schema.GenerateSchema._union_is_subclass_schema(self,union_type:Any)->core_schema.CoreSchema
pydantic._internal._generate_schema.GenerateSchema._union_schema(self,union_type:Any)->core_schema.CoreSchema
pydantic._internal._generate_schema.GenerateSchema._unknown_type_schema(self,obj:Any)->CoreSchema
pydantic._internal._generate_schema.GenerateSchema._unpack_refs_defs(self,schema:CoreSchema)->CoreSchema
pydantic._internal._generate_schema.GenerateSchema._unsubstituted_typevar_schema(self,typevar:typing.TypeVar)->core_schema.CoreSchema
pydantic._internal._generate_schema.GenerateSchema._zoneinfo_schema(self)->core_schema.CoreSchema
pydantic._internal._generate_schema.GenerateSchema.clean_schema(self,schema:CoreSchema)->CoreSchema
pydantic._internal._generate_schema.GenerateSchema.collect_definitions(self,schema:CoreSchema)->CoreSchema
pydantic._internal._generate_schema.GenerateSchema.generate_schema(self,obj:Any,from_dunder_get_core_schema:bool=True)->core_schema.CoreSchema
pydantic._internal._generate_schema.GenerateSchema.match_type(self,obj:Any)->core_schema.CoreSchema
pydantic._internal._generate_schema._CommonField(TypedDict)
pydantic._internal._generate_schema._Definitions(self)
pydantic._internal._generate_schema._Definitions.__init__(self)
pydantic._internal._generate_schema._Definitions.get_schema_or_ref(self,tp:Any)->Iterator[tuple[str, None] | tuple[str, CoreSchema]]
pydantic._internal._generate_schema._FieldNameStack(self)
pydantic._internal._generate_schema._FieldNameStack.__init__(self)
pydantic._internal._generate_schema._FieldNameStack.get(self)->str | None
pydantic._internal._generate_schema._FieldNameStack.push(self,field_name:str)->Iterator[None]
pydantic._internal._generate_schema._ModelTypeStack(self)
pydantic._internal._generate_schema._ModelTypeStack.__init__(self)
pydantic._internal._generate_schema._ModelTypeStack.get(self)->type | None
pydantic._internal._generate_schema._ModelTypeStack.push(self,type_obj:type)->Iterator[None]
pydantic._internal._generate_schema._add_custom_serialization_from_json_encoders(json_encoders:JsonEncoders|None,tp:Any,schema:CoreSchema)->CoreSchema
pydantic._internal._generate_schema._common_field(schema:core_schema.CoreSchema,*,validation_alias:str|list[str|int]|list[list[str|int]]|None=None,serialization_alias:str|None=None,serialization_exclude:bool|None=None,frozen:bool|None=None,metadata:Any=None)->_CommonField
pydantic._internal._generate_schema._extract_get_pydantic_json_schema(tp:Any,schema:CoreSchema)->GetJsonSchemaFunction | None
pydantic._internal._generate_schema._extract_json_schema_info_from_field_info(info:FieldInfo|ComputedFieldInfo)->tuple[JsonDict | None, JsonDict | JsonSchemaExtraCallable | None]
pydantic._internal._generate_schema._get_first_non_null(a:Any,b:Any)->Any
pydantic._internal._generate_schema._validators_require_validate_default(validators:Iterable[Decorator[ValidatorDecoratorInfo]])->bool
pydantic._internal._generate_schema.apply_each_item_validators(schema:core_schema.CoreSchema,each_item_validators:list[Decorator[ValidatorDecoratorInfo]],field_name:str|None)->core_schema.CoreSchema
pydantic._internal._generate_schema.apply_model_validators(schema:core_schema.CoreSchema,validators:Iterable[Decorator[ModelValidatorDecoratorInfo]],mode:Literal['inner','outer','all'])->core_schema.CoreSchema
pydantic._internal._generate_schema.apply_validators(schema:core_schema.CoreSchema,validators:Iterable[Decorator[RootValidatorDecoratorInfo]]|Iterable[Decorator[ValidatorDecoratorInfo]]|Iterable[Decorator[FieldValidatorDecoratorInfo]],field_name:str|None)->core_schema.CoreSchema
pydantic._internal._generate_schema.check_decorator_fields_exist(decorators:Iterable[AnyFieldDecorator],fields:Iterable[str])->None
pydantic._internal._generate_schema.check_validator_fields_against_field_name(info:FieldDecoratorInfo,field:str)->bool
pydantic._internal._generate_schema.filter_field_decorator_info_by_field(validator_functions:Iterable[Decorator[FieldDecoratorInfoType]],field:str)->list[Decorator[FieldDecoratorInfoType]]
pydantic._internal._generate_schema.resolve_original_schema(schema:CoreSchema,definitions:dict[str,CoreSchema])->CoreSchema | None
pydantic._internal._generate_schema.wrap_default(field_info:FieldInfo,schema:core_schema.CoreSchema)->core_schema.CoreSchema


----------------------------------------/dataset/nuaa/anaconda3/envs/pydantic2.10.6/lib/python3.9/site-packages/pydantic/_internal/_validate_call.py----------------------------------------
A:pydantic._internal._validate_call.wrapper_function.__name__->extract_function_name(wrapped)
A:pydantic._internal._validate_call.wrapper_function.__qualname__->extract_function_qualname(wrapped)
A:pydantic._internal._validate_call.qualname->extract_function_qualname(function)
A:pydantic._internal._validate_call.ns_resolver->NsResolver(namespaces_tuple=ns_for_function(schema_type, parent_namespace=parent_namespace))
A:pydantic._internal._validate_call.config_wrapper->ConfigWrapper(config)
A:pydantic._internal._validate_call.gen_schema->GenerateSchema(config_wrapper, ns_resolver)
A:pydantic._internal._validate_call.schema->GenerateSchema(config_wrapper, ns_resolver).clean_schema(gen_schema.generate_schema(return_type))
A:pydantic._internal._validate_call.core_config->ConfigWrapper(config).core_config(title=qualname)
A:pydantic._internal._validate_call.self.__pydantic_validator__->create_schema_validator(schema, schema_type, module, qualname, 'validate_call', core_config, config_wrapper.plugin_settings)
A:pydantic._internal._validate_call.signature->inspect.signature(function)
A:pydantic._internal._validate_call.validator->create_schema_validator(schema, schema_type, module, qualname, 'validate_call', core_config, config_wrapper.plugin_settings)
A:pydantic._internal._validate_call.res->self.__pydantic_validator__.validate_python(pydantic_core.ArgsKwargs(args, kwargs))
pydantic._internal._validate_call.ValidateCallWrapper(self,function:ValidateCallSupportedTypes,config:ConfigDict|None,validate_return:bool,parent_namespace:MappingNamespace|None)
pydantic._internal._validate_call.ValidateCallWrapper.__init__(self,function:ValidateCallSupportedTypes,config:ConfigDict|None,validate_return:bool,parent_namespace:MappingNamespace|None)
pydantic._internal._validate_call.extract_function_name(func:ValidateCallSupportedTypes)->str
pydantic._internal._validate_call.extract_function_qualname(func:ValidateCallSupportedTypes)->str
pydantic._internal._validate_call.update_wrapper_attributes(wrapped:ValidateCallSupportedTypes,wrapper:Callable[...,Any])


----------------------------------------/dataset/nuaa/anaconda3/envs/pydantic2.10.6/lib/python3.9/site-packages/pydantic/_internal/_docs_extraction.py----------------------------------------
A:pydantic._internal._docs_extraction.node_result->super().visit(node)
A:pydantic._internal._docs_extraction.self.previous_node_type->type(node)
A:pydantic._internal._docs_extraction.docstring->inspect.cleandoc(node.value.value)
A:pydantic._internal._docs_extraction.dedent_source->_dedent_source_lines(source)
A:pydantic._internal._docs_extraction.frame->inspect.currentframe()
A:pydantic._internal._docs_extraction.(lines, _)->inspect.findsource(frame)
A:pydantic._internal._docs_extraction.block_lines->inspect.getblock(lines[lnum - 1:])
A:pydantic._internal._docs_extraction.block_tree->ast.parse(dedent_source)
A:pydantic._internal._docs_extraction.(source, _)->inspect.getsourcelines(cls)
A:pydantic._internal._docs_extraction.source->_extract_source_from_frame(cls)
A:pydantic._internal._docs_extraction.visitor->DocstringVisitor()
pydantic._internal._docs_extraction.DocstringVisitor(self)
pydantic._internal._docs_extraction.DocstringVisitor.__init__(self)
pydantic._internal._docs_extraction.DocstringVisitor.visit(self,node:ast.AST)->Any
pydantic._internal._docs_extraction.DocstringVisitor.visit_AnnAssign(self,node:ast.AnnAssign)->Any
pydantic._internal._docs_extraction.DocstringVisitor.visit_Expr(self,node:ast.Expr)->Any
pydantic._internal._docs_extraction._dedent_source_lines(source:list[str])->str
pydantic._internal._docs_extraction._extract_source_from_frame(cls:type[Any])->list[str] | None
pydantic._internal._docs_extraction.extract_docstrings_from_cls(cls:type[Any],use_inspect:bool=False)->dict[str, str]


----------------------------------------/dataset/nuaa/anaconda3/envs/pydantic2.10.6/lib/python3.9/site-packages/pydantic/_internal/_discriminated_union.py----------------------------------------
A:pydantic._internal._discriminated_union.metadata->apply_discriminator(s, discriminator, global_definitions).get('metadata', {})
A:pydantic._internal._discriminated_union.s->apply_discriminator(s, discriminator, global_definitions)
A:pydantic._internal._discriminated_union.discriminator->apply_discriminator(s, discriminator, global_definitions).get('metadata', {}).pop(CORE_SCHEMA_METADATA_DISCRIMINATOR_PLACEHOLDER_KEY, None)
A:pydantic._internal._discriminated_union.schema->pydantic_core.core_schema.union_schema([schema])
A:pydantic._internal._discriminated_union.wrapped->self._apply_to_root(schema['schema'])
A:pydantic._internal._discriminated_union.nullable_wrapper->pydantic_core.core_schema.union_schema([schema]).copy()
A:pydantic._internal._discriminated_union.definitions_wrapper->pydantic_core.core_schema.union_schema([schema]).copy()
A:pydantic._internal._discriminated_union.choice->self._choices_to_handle.pop()
A:pydantic._internal._discriminated_union.inferred_discriminator_values->self._infer_discriminator_values_for_choice(choice, source_name=None)
A:pydantic._internal._discriminated_union.subchoice_values->self._infer_discriminator_values_for_choice(subchoice_schema, source_name=None)
A:pydantic._internal._discriminated_union.field->choice['fields'].get(self.discriminator)
A:pydantic._internal._discriminated_union.alias->choice['fields'].get(self.discriminator).get('validation_alias', self.discriminator)
A:pydantic._internal._discriminated_union.choice_values->self._infer_discriminator_values_for_inner_schema(choice_schema, source)
A:pydantic._internal._discriminated_union.validator_type->repr(schema['type'].split('-')[1])
pydantic._internal._discriminated_union.MissingDefinitionForUnionRef(self,ref:str)
pydantic._internal._discriminated_union.MissingDefinitionForUnionRef.__init__(self,ref:str)
pydantic._internal._discriminated_union._ApplyInferredDiscriminator(self,discriminator:str,definitions:dict[str,core_schema.CoreSchema])
pydantic._internal._discriminated_union._ApplyInferredDiscriminator.__init__(self,discriminator:str,definitions:dict[str,core_schema.CoreSchema])
pydantic._internal._discriminated_union._ApplyInferredDiscriminator._apply_to_root(self,schema:core_schema.CoreSchema)->core_schema.CoreSchema
pydantic._internal._discriminated_union._ApplyInferredDiscriminator._handle_choice(self,choice:core_schema.CoreSchema)->None
pydantic._internal._discriminated_union._ApplyInferredDiscriminator._infer_discriminator_values_for_choice(self,choice:core_schema.CoreSchema,source_name:str|None)->list[str | int]
pydantic._internal._discriminated_union._ApplyInferredDiscriminator._infer_discriminator_values_for_dataclass_choice(self,choice:core_schema.DataclassArgsSchema,source_name:str|None=None)->list[str | int]
pydantic._internal._discriminated_union._ApplyInferredDiscriminator._infer_discriminator_values_for_field(self,field:CoreSchemaField,source:str)->list[str | int]
pydantic._internal._discriminated_union._ApplyInferredDiscriminator._infer_discriminator_values_for_inner_schema(self,schema:core_schema.CoreSchema,source:str)->list[str | int]
pydantic._internal._discriminated_union._ApplyInferredDiscriminator._infer_discriminator_values_for_model_choice(self,choice:core_schema.ModelFieldsSchema,source_name:str|None=None)->list[str | int]
pydantic._internal._discriminated_union._ApplyInferredDiscriminator._infer_discriminator_values_for_typed_dict_choice(self,choice:core_schema.TypedDictSchema,source_name:str|None=None)->list[str | int]
pydantic._internal._discriminated_union._ApplyInferredDiscriminator._is_discriminator_shared(self,choice:core_schema.TaggedUnionSchema)->bool
pydantic._internal._discriminated_union._ApplyInferredDiscriminator._set_unique_choice_for_values(self,choice:core_schema.CoreSchema,values:Sequence[str|int])->None
pydantic._internal._discriminated_union._ApplyInferredDiscriminator.apply(self,schema:core_schema.CoreSchema)->core_schema.CoreSchema
pydantic._internal._discriminated_union.apply_discriminator(schema:core_schema.CoreSchema,discriminator:str|Discriminator,definitions:dict[str,core_schema.CoreSchema]|None=None)->core_schema.CoreSchema
pydantic._internal._discriminated_union.apply_discriminators(schema:core_schema.CoreSchema)->core_schema.CoreSchema
pydantic._internal._discriminated_union.set_discriminator_in_metadata(schema:CoreSchema,discriminator:Any)->None


----------------------------------------/dataset/nuaa/anaconda3/envs/pydantic2.10.6/lib/python3.9/site-packages/pydantic/_internal/_schema_generation_shared.py----------------------------------------
A:pydantic._internal._schema_generation_shared.json_schema->self.generate_json_schema.get_schema_from_definitions(ref)
A:pydantic._internal._schema_generation_shared.schema->self._handler(source_type)
A:pydantic._internal._schema_generation_shared.ref->self._handler(source_type).get('ref')
pydantic._internal._schema_generation_shared.CallbackGetCoreSchemaHandler(self,handler:Callable[[Any],core_schema.CoreSchema],generate_schema:GenerateSchema,ref_mode:Literal['to-def','unpack']='to-def')
pydantic._internal._schema_generation_shared.CallbackGetCoreSchemaHandler.__init__(self,handler:Callable[[Any],core_schema.CoreSchema],generate_schema:GenerateSchema,ref_mode:Literal['to-def','unpack']='to-def')
pydantic._internal._schema_generation_shared.CallbackGetCoreSchemaHandler._get_types_namespace(self)->NamespacesTuple
pydantic._internal._schema_generation_shared.CallbackGetCoreSchemaHandler.field_name(self)->str | None
pydantic._internal._schema_generation_shared.CallbackGetCoreSchemaHandler.generate_schema(self,source_type:Any,/)->core_schema.CoreSchema
pydantic._internal._schema_generation_shared.CallbackGetCoreSchemaHandler.resolve_ref_schema(self,maybe_ref_schema:core_schema.CoreSchema)->core_schema.CoreSchema
pydantic._internal._schema_generation_shared.GenerateJsonSchemaHandler(self,generate_json_schema:GenerateJsonSchema,handler_override:HandlerOverride|None)
pydantic._internal._schema_generation_shared.GenerateJsonSchemaHandler.__init__(self,generate_json_schema:GenerateJsonSchema,handler_override:HandlerOverride|None)
pydantic._internal._schema_generation_shared.GenerateJsonSchemaHandler.resolve_ref_schema(self,maybe_ref_json_schema:JsonSchemaValue)->JsonSchemaValue


----------------------------------------/dataset/nuaa/anaconda3/envs/pydantic2.10.6/lib/python3.9/site-packages/pydantic/_internal/_dataclasses.py----------------------------------------
A:pydantic._internal._dataclasses.typevars_map->get_standard_typevars_map(cls)
A:pydantic._internal._dataclasses.fields->collect_dataclass_fields(cls, ns_resolver=ns_resolver, typevars_map=typevars_map, config_wrapper=config_wrapper)
A:pydantic._internal._dataclasses.gen_schema->GenerateSchema(config_wrapper, ns_resolver=ns_resolver, typevars_map=typevars_map)
A:pydantic._internal._dataclasses.cls.__signature__->LazyClassAttribute('__signature__', partial(generate_pydantic_signature, init=original_init, fields=cls.__pydantic_fields__, populate_by_name=config_wrapper.populate_by_name, extra=config_wrapper.extra, is_dataclass=True))
A:pydantic._internal._dataclasses.get_core_schema->getattr(cls, '__get_pydantic_core_schema__', None)
A:pydantic._internal._dataclasses.schema->GenerateSchema(config_wrapper, ns_resolver=ns_resolver, typevars_map=typevars_map).clean_schema(schema)
A:pydantic._internal._dataclasses.core_config->config_wrapper.core_config(title=cls.__name__)
A:pydantic._internal._dataclasses.cls->typing.cast('type[PydanticDataclass]', cls)
A:pydantic._internal._dataclasses.cls.__pydantic_validator__validator->create_schema_validator(schema, cls, cls.__module__, cls.__qualname__, 'dataclass', core_config, config_wrapper.plugin_settings)
A:pydantic._internal._dataclasses.cls.__pydantic_serializer__->SchemaSerializer(schema, core_config)
A:pydantic._internal._dataclasses.cls.__setattr__->validated_setattr.__get__(None, cls)
pydantic._internal._dataclasses.complete_dataclass(cls:type[Any],config_wrapper:_config.ConfigWrapper,*,raise_errors:bool=True,ns_resolver:NsResolver|None=None,_force_build:bool=False)->bool
pydantic._internal._dataclasses.is_builtin_dataclass(_cls:type[Any])->TypeGuard[type[StandardDataclass]]
pydantic._internal._dataclasses.set_dataclass_fields(cls:type[StandardDataclass],ns_resolver:NsResolver|None=None,config_wrapper:_config.ConfigWrapper|None=None)->None


----------------------------------------/dataset/nuaa/anaconda3/envs/pydantic2.10.6/lib/python3.9/site-packages/pydantic/_internal/_model_construction.py----------------------------------------
A:pydantic._internal._model_construction.PydanticModelField->object()
A:pydantic._internal._model_construction.PydanticModelPrivateAttr->object()
A:pydantic._internal._model_construction.(base_field_names, class_vars, base_private_attributes)->mcs._collect_bases_data(bases)
A:pydantic._internal._model_construction.config_wrapper->_config.ConfigWrapper.for_model(bases, namespace, kwargs)
A:pydantic._internal._model_construction.private_attributes->self.__dict__.get('__private_attributes__')
A:pydantic._internal._model_construction.original_model_post_init->get_model_post_init(namespace, bases)
A:pydantic._internal._model_construction.cls->cast('type[BaseModel]', super().__new__(mcs, cls_name, bases, namespace, **kwargs))
A:pydantic._internal._model_construction.BaseModel_->import_cached_base_model()
A:pydantic._internal._model_construction.cls.__pydantic_decorators__->_decorators.DecoratorInfos.build(cls)
A:pydantic._internal._model_construction.parent_parameters->getattr(cls, '__pydantic_generic_metadata__', {}).get('parameters', ())
A:pydantic._internal._model_construction.missing_parameters->tuple((x for x in parameters if x not in parent_parameters))
A:pydantic._internal._model_construction.parameters_str->', '.join([str(x) for x in combined_parameters])
A:pydantic._internal._model_construction.bases_str->', '.join([x.__name__ for x in bases] + [generic_type_label])
A:pydantic._internal._model_construction.cls.__pydantic_parent_namespace__->build_lenient_weakvaluedict(parent_frame_namespace())
A:pydantic._internal._model_construction.parent_namespace->unpack_lenient_weakvaluedict(parent_namespace)
A:pydantic._internal._model_construction.ns_resolver->NsResolver(parent_namespace=parent_namespace)
A:pydantic._internal._model_construction.BaseModel->import_cached_base_model()
A:pydantic._internal._model_construction.attributes->list(super().__dir__())
A:pydantic._internal._model_construction.default->next((v for v in metadata if isinstance(v, ModelPrivateAttr)), None).get_default()
A:pydantic._internal._model_construction.model_post_init->get_attribute_from_bases(bases, 'model_post_init')
A:pydantic._internal._model_construction.FieldInfo->import_cached_field_info()
A:pydantic._internal._model_construction.raw_annotations->namespace.get('__annotations__', {})
A:pydantic._internal._model_construction.private_attributes[var_name]->cast(ModelPrivateAttr, PrivateAttr(default=value))
A:pydantic._internal._model_construction.frame->sys._getframe(2)
A:pydantic._internal._model_construction.ann_type->eval_type_backport(_make_forward_ref(ann_type, is_argument=False, is_class=True), globalns=frame.f_globals, localns=frame.f_locals)
A:pydantic._internal._model_construction.(_, *metadata)->get_args(ann_type)
A:pydantic._internal._model_construction.private_attr->next((v for v in metadata if isinstance(v, ModelPrivateAttr)), None)
A:pydantic._internal._model_construction.private_attributes[ann_name]->PrivateAttr()
A:pydantic._internal._model_construction.base_hash_func->get_attribute_from_bases(bases, '__hash__')
A:pydantic._internal._model_construction.new_hash_func->make_hash_func(cls)
A:pydantic._internal._model_construction.typevars_map->get_model_typevars_map(cls)
A:pydantic._internal._model_construction.(fields, class_vars)->collect_model_fields(cls, bases, config_wrapper, ns_resolver, typevars_map=typevars_map)
A:pydantic._internal._model_construction.value->cast('type[BaseModel]', super().__new__(mcs, cls_name, bases, namespace, **kwargs)).__private_attributes__.pop(k, None)
A:pydantic._internal._model_construction.gen_schema->GenerateSchema(config_wrapper, ns_resolver, typevars_map)
A:pydantic._internal._model_construction.handler->CallbackGetCoreSchemaHandler(partial(gen_schema.generate_schema, from_dunder_get_core_schema=False), gen_schema, ref_mode='unpack')
A:pydantic._internal._model_construction.schema->GenerateSchema(config_wrapper, ns_resolver, typevars_map).clean_schema(schema)
A:pydantic._internal._model_construction.core_config->_config.ConfigWrapper.for_model(bases, namespace, kwargs).core_config(title=cls.__name__)
A:pydantic._internal._model_construction.cls.__pydantic_validator__->create_schema_validator(schema, cls, create_model_module or cls.__module__, cls.__qualname__, 'create_model' if create_model_module else 'BaseModel', core_config, config_wrapper.plugin_settings)
A:pydantic._internal._model_construction.cls.__pydantic_serializer__->SchemaSerializer(schema, core_config)
A:pydantic._internal._model_construction.cls.__signature__->LazyClassAttribute('__signature__', partial(generate_pydantic_signature, init=cls.__init__, fields=cls.__pydantic_fields__, populate_by_name=config_wrapper.populate_by_name, extra=config_wrapper.extra))
A:pydantic._internal._model_construction.desc->_DeprecatedFieldDescriptor(msg, computed_field_info.wrapped_property)
A:pydantic._internal._model_construction.self._wr->weakref.ref(obj)
A:pydantic._internal._model_construction.proxy->_PydanticWeakRef(v)
A:pydantic._internal._model_construction.v->v()
pydantic._internal._model_construction.ModelMetaclass(mcs,cls_name:str,bases:tuple[type[Any],...],namespace:dict[str,Any],__pydantic_generic_metadata__:PydanticGenericMetadata|None=None,__pydantic_reset_parent_namespace__:bool=True,_create_model_module:str|None=None,**kwargs:Any)
pydantic._internal._model_construction.ModelMetaclass.__dir__(self)->list[str]
pydantic._internal._model_construction.ModelMetaclass.__fields__(self)->dict[str, FieldInfo]
pydantic._internal._model_construction.ModelMetaclass.__instancecheck__(self,instance:Any)->bool
pydantic._internal._model_construction.ModelMetaclass.__new__(mcs,cls_name:str,bases:tuple[type[Any],...],namespace:dict[str,Any],__pydantic_generic_metadata__:PydanticGenericMetadata|None=None,__pydantic_reset_parent_namespace__:bool=True,_create_model_module:str|None=None,**kwargs:Any)
pydantic._internal._model_construction.ModelMetaclass.__prepare__(cls,*args:Any,**kwargs:Any)->dict[str, object]
pydantic._internal._model_construction.ModelMetaclass._collect_bases_data(bases:tuple[type[Any],...])->tuple[set[str], set[str], dict[str, ModelPrivateAttr]]
pydantic._internal._model_construction.ModelMetaclass.model_computed_fields(self)->dict[str, ComputedFieldInfo]
pydantic._internal._model_construction.ModelMetaclass.model_fields(self)->dict[str, FieldInfo]
pydantic._internal._model_construction.NoInitField(*,init:Literal[False]=False)->Any
pydantic._internal._model_construction._DeprecatedFieldDescriptor(self,msg:str,wrapped_property:property|None=None)
pydantic._internal._model_construction._DeprecatedFieldDescriptor.__get__(self,obj:BaseModel|None,obj_type:type[BaseModel]|None=None)->Any
pydantic._internal._model_construction._DeprecatedFieldDescriptor.__init__(self,msg:str,wrapped_property:property|None=None)
pydantic._internal._model_construction._DeprecatedFieldDescriptor.__set__(self,obj:Any,value:Any)->NoReturn
pydantic._internal._model_construction._DeprecatedFieldDescriptor.__set_name__(self,cls:type[BaseModel],name:str)->None
pydantic._internal._model_construction._ModelNamespaceDict(dict)
pydantic._internal._model_construction._ModelNamespaceDict.__setitem__(self,k:str,v:object)->None
pydantic._internal._model_construction._PydanticWeakRef(self,obj:Any)
pydantic._internal._model_construction._PydanticWeakRef.__init__(self,obj:Any)
pydantic._internal._model_construction._PydanticWeakRef.__reduce__(self)->tuple[Callable, tuple[weakref.ReferenceType | None]]
pydantic._internal._model_construction.build_lenient_weakvaluedict(d:dict[str,Any]|None)->dict[str, Any] | None
pydantic._internal._model_construction.complete_model_class(cls:type[BaseModel],cls_name:str,config_wrapper:ConfigWrapper,*,raise_errors:bool=True,ns_resolver:NsResolver|None=None,create_model_module:str|None=None)->bool
pydantic._internal._model_construction.default_ignored_types()->tuple[type[Any], ...]
pydantic._internal._model_construction.get_model_post_init(namespace:dict[str,Any],bases:tuple[type[Any],...])->Callable[..., Any] | None
pydantic._internal._model_construction.init_private_attributes(self:BaseModel,context:Any,/)->None
pydantic._internal._model_construction.inspect_namespace(namespace:dict[str,Any],ignored_types:tuple[type[Any],...],base_class_vars:set[str],base_class_fields:set[str])->dict[str, ModelPrivateAttr]
pydantic._internal._model_construction.make_hash_func(cls:type[BaseModel])->Any
pydantic._internal._model_construction.set_default_hash_func(cls:type[BaseModel],bases:tuple[type[Any],...])->None
pydantic._internal._model_construction.set_deprecated_descriptors(cls:type[BaseModel])->None
pydantic._internal._model_construction.set_model_fields(cls:type[BaseModel],bases:tuple[type[Any],...],config_wrapper:ConfigWrapper,ns_resolver:NsResolver|None)->None
pydantic._internal._model_construction.unpack_lenient_weakvaluedict(d:dict[str,Any]|None)->dict[str, Any] | None


----------------------------------------/dataset/nuaa/anaconda3/envs/pydantic2.10.6/lib/python3.9/site-packages/pydantic/_internal/_typing_extra.py----------------------------------------
A:pydantic._internal._typing_extra.NoneType->type(None)
A:pydantic._internal._typing_extra.EllipsisType->type(Ellipsis)
A:pydantic._internal._typing_extra.result->tuple((getattr(module, name) for module in (typing, typing_extensions) if hasattr(module, name)))
A:pydantic._internal._typing_extra.values->get_args(tp)
A:pydantic._internal._typing_extra._classvar_re->re.compile('((\\w+\\.)?Annotated\\[)?(\\w+\\.)?ClassVar\\[')
A:pydantic._internal._typing_extra.frame->sys._getframe(parent_depth)
A:pydantic._internal._typing_extra.hints[name]->eval_type(value, globalns, localns)
A:pydantic._internal._typing_extra.value->eval_type_backport(value, globalns, localns)
A:pydantic._internal._typing_extra.(ev, _)->try_eval_type(value, globalns, localns)
A:pydantic._internal._typing_extra.msg->str(e)
A:pydantic._internal._typing_extra.type_hints->get_type_hints(function)
A:pydantic._internal._typing_extra.globalns->getattr(nsobj, '__globals__', {})
A:pydantic._internal._typing_extra.type_params->getattr(function, '__type_params__', ())
A:pydantic._internal._typing_extra.type_hints[name]->eval_type_backport(value, globalns, localns, type_params)
A:pydantic._internal._typing_extra.base_globals->getattr(sys.modules.get(base.__module__, None), '__dict__', {})
A:pydantic._internal._typing_extra.ann->base.__dict__.get('__annotations__', {})
A:pydantic._internal._typing_extra.hints->dict(hints)
A:pydantic._internal._typing_extra.defaults->typing._get_defaults(obj)
pydantic._internal._typing_extra._eval_type(value:Any,globalns:GlobalsNamespace|None=None,localns:MappingNamespace|None=None,type_params:tuple[Any,...]|None=None)->Any
pydantic._internal._typing_extra._eval_type_backport(value:Any,globalns:GlobalsNamespace|None=None,localns:MappingNamespace|None=None,type_params:tuple[Any,...]|None=None)->Any
pydantic._internal._typing_extra._get_typing_objects_by_name_of(name:str)->tuple[Any, ...]
pydantic._internal._typing_extra._is_typing_name(obj:object,name:str)->bool
pydantic._internal._typing_extra._type_convert(arg:Any)->Any
pydantic._internal._typing_extra.annotated_type(tp:Any,/)->Any | None
pydantic._internal._typing_extra.eval_type(value:Any,globalns:GlobalsNamespace|None=None,localns:MappingNamespace|None=None)->Any
pydantic._internal._typing_extra.eval_type_backport(value:Any,globalns:GlobalsNamespace|None=None,localns:MappingNamespace|None=None,type_params:tuple[Any,...]|None=None)->Any
pydantic._internal._typing_extra.eval_type_lenient(value:Any,globalns:GlobalsNamespace|None=None,localns:MappingNamespace|None=None)->Any
pydantic._internal._typing_extra.get_cls_type_hints(obj:type[Any],*,ns_resolver:NsResolver|None=None)->dict[str, Any]
pydantic._internal._typing_extra.get_function_type_hints(function:Callable[...,Any],*,include_keys:set[str]|None=None,globalns:GlobalsNamespace|None=None,localns:MappingNamespace|None=None)->dict[str, Any]
pydantic._internal._typing_extra.get_model_type_hints(obj:type[BaseModel],*,ns_resolver:NsResolver|None=None)->dict[str, tuple[Any, bool]]
pydantic._internal._typing_extra.is_annotated(tp:Any,/)->bool
pydantic._internal._typing_extra.is_any(tp:Any,/)->bool
pydantic._internal._typing_extra.is_backport_fixable_error(e:TypeError)->bool
pydantic._internal._typing_extra.is_callable(tp:Any,/)->bool
pydantic._internal._typing_extra.is_classvar(tp:Any,/)->bool
pydantic._internal._typing_extra.is_classvar_annotation(tp:Any,/)->bool
pydantic._internal._typing_extra.is_deprecated_instance(obj:Any,/)->TypeIs[deprecated]
pydantic._internal._typing_extra.is_finalvar(tp:Any,/)->bool
pydantic._internal._typing_extra.is_hashable(tp:Any,/)->bool
pydantic._internal._typing_extra.is_literal(tp:Any,/)->bool
pydantic._internal._typing_extra.is_namedtuple(tp:Any,/)->bool
pydantic._internal._typing_extra.is_never(tp:Any,/)->bool
pydantic._internal._typing_extra.is_new_type(tp:Any,/)->bool
pydantic._internal._typing_extra.is_no_return(tp:Any,/)->bool
pydantic._internal._typing_extra.is_none_type(tp:Any,/)->bool
pydantic._internal._typing_extra.is_not_required(tp:Any,/)->bool
pydantic._internal._typing_extra.is_paramspec(tp:Any,/)->bool
pydantic._internal._typing_extra.is_required(tp:Any,/)->bool
pydantic._internal._typing_extra.is_self(tp:Any,/)->bool
pydantic._internal._typing_extra.is_type_alias_type(tp:Any,/)->TypeIs[typing_extensions.TypeAliasType]
pydantic._internal._typing_extra.is_union(tp:Any,/)->bool
pydantic._internal._typing_extra.is_unpack(tp:Any,/)->bool
pydantic._internal._typing_extra.literal_values(tp:Any,/)->list[Any]
pydantic._internal._typing_extra.parent_frame_namespace(*,parent_depth:int=2,force:bool=False)->dict[str, Any] | None
pydantic._internal._typing_extra.try_eval_type(value:Any,globalns:GlobalsNamespace|None=None,localns:MappingNamespace|None=None)->tuple[Any, bool]
pydantic._internal._typing_extra.unpack_type(tp:Any,/)->Any | None


----------------------------------------/dataset/nuaa/anaconda3/envs/pydantic2.10.6/lib/python3.9/site-packages/pydantic/_internal/_config.py----------------------------------------
A:pydantic._internal._config.self.config_dict->cast(ConfigDict, config)
A:pydantic._internal._config.config_new->ConfigDict()
A:pydantic._internal._config.config->getattr(base, 'model_config', None)
A:pydantic._internal._config.config_class_from_namespace->namespace.get('Config')
A:pydantic._internal._config.config_dict_from_namespace->namespace.get('model_config')
A:pydantic._internal._config.raw_annotations->namespace.get('__annotations__', {})
A:pydantic._internal._config.config_new[k]->kwargs.pop(k)
A:pydantic._internal._config.c->', '.join((f'{k}={v!r}' for (k, v) in self.config_dict.items()))
A:pydantic._internal._config.config_wrapper->ConfigWrapper(config_wrapper, check=False)
A:pydantic._internal._config.config_defaults->ConfigDict(title=None, str_to_lower=False, str_to_upper=False, str_strip_whitespace=False, str_min_length=0, str_max_length=None, extra=None, frozen=False, populate_by_name=False, use_enum_values=False, validate_assignment=False, arbitrary_types_allowed=False, from_attributes=False, loc_by_alias=True, alias_generator=None, model_title_generator=None, field_title_generator=None, ignored_types=(), allow_inf_nan=True, json_schema_extra=None, strict=False, revalidate_instances='never', ser_json_timedelta='iso8601', ser_json_bytes='utf8', val_json_bytes='utf8', ser_json_inf_nan='null', validate_default=False, validate_return=False, protected_namespaces=('model_validate', 'model_dump'), hide_input_in_errors=False, json_encoders=None, defer_build=False, schema_generator=None, plugin_settings=None, json_schema_serialization_defaults_required=False, json_schema_mode_override=None, coerce_numbers_to_str=False, regex_engine='rust-regex', validation_error_cause=False, use_attribute_docstrings=False, cache_strings=True)
A:pydantic._internal._config.config_dict->cast(ConfigDict, config)
A:pydantic._internal._config.config_keys->set(ConfigDict.__annotations__.keys())
A:pydantic._internal._config.message->'\n'.join(['Valid config keys have changed in V2:'] + renamed_bullets + removed_bullets)
pydantic._internal._config.ConfigWrapper(self,config:ConfigDict|dict[str,Any]|type[Any]|None,*,check:bool=True)
pydantic._internal._config.ConfigWrapper.__init__(self,config:ConfigDict|dict[str,Any]|type[Any]|None,*,check:bool=True)
pydantic._internal._config.ConfigWrapper.__repr__(self)
pydantic._internal._config.ConfigWrapper.core_config(self,title:str|None)->core_schema.CoreConfig
pydantic._internal._config.ConfigWrapper.for_model(cls,bases:tuple[type[Any],...],namespace:dict[str,Any],kwargs:dict[str,Any])->Self
pydantic._internal._config.ConfigWrapperStack(self,config_wrapper:ConfigWrapper)
pydantic._internal._config.ConfigWrapperStack.__init__(self,config_wrapper:ConfigWrapper)
pydantic._internal._config.ConfigWrapperStack.push(self,config_wrapper:ConfigWrapper|ConfigDict|None)
pydantic._internal._config.ConfigWrapperStack.tail(self)->ConfigWrapper
pydantic._internal._config.check_deprecated(config_dict:ConfigDict)->None
pydantic._internal._config.prepare_config(config:ConfigDict|dict[str,Any]|type[Any]|None)->ConfigDict


----------------------------------------/dataset/nuaa/anaconda3/envs/pydantic2.10.6/lib/python3.9/site-packages/pydantic/_internal/_core_utils.py----------------------------------------
A:pydantic._internal._core_utils.generic_metadata->getattr(type_, '__pydantic_generic_metadata__', None)
A:pydantic._internal._core_utils.module_name->getattr(origin, '__module__', '<No __module__>')
A:pydantic._internal._core_utils.qualname->getattr(origin, '__qualname__', '<No __qualname__>')
A:pydantic._internal._core_utils.ref->get_ref(s)
A:pydantic._internal._core_utils.refs->collect_definitions(schema).keys()
A:pydantic._internal._core_utils.expected_missing_refs->allowed_missing_refs.difference(refs)
A:pydantic._internal._core_utils.T->TypeVar('T')
A:pydantic._internal._core_utils.CoreSchemaT->TypeVar('CoreSchemaT')
A:pydantic._internal._core_utils.self._schema_type_to_method->self._build_schema_type_to_method()
A:pydantic._internal._core_utils.mapping[key]->getattr(self, method_name, self._handle_other_schemas)
A:pydantic._internal._core_utils.schema->_strip_metadata(schema)
A:pydantic._internal._core_utils.schema['serialization']->self._handle_ser_schemas(ser_schema, f)
A:pydantic._internal._core_utils.sub_schema->_strip_metadata(schema).get('schema', None)
A:pydantic._internal._core_utils.schema['schema']->self.walk(schema['schema'], f)
A:pydantic._internal._core_utils.ser_schema->self._copy_schema(ser_schema)
A:pydantic._internal._core_utils.ser_schema['schema']->self.walk(schema, f)
A:pydantic._internal._core_utils.ser_schema['return_schema']->self.walk(return_schema, f)
A:pydantic._internal._core_utils.updated_definition->self.walk(definition, f)
A:pydantic._internal._core_utils.new_inner_schema->self.walk(schema['schema'], f)
A:pydantic._internal._core_utils.new_schema->self._copy_schema(schema)
A:pydantic._internal._core_utils.items_schema->_strip_metadata(schema).get('items_schema')
A:pydantic._internal._core_utils.schema['items_schema']->self.walk(items_schema, f)
A:pydantic._internal._core_utils.keys_schema->_strip_metadata(schema).get('keys_schema')
A:pydantic._internal._core_utils.schema['keys_schema']->self.walk(keys_schema, f)
A:pydantic._internal._core_utils.values_schema->_strip_metadata(schema).get('values_schema')
A:pydantic._internal._core_utils.schema['values_schema']->self.walk(values_schema, f)
A:pydantic._internal._core_utils.schema['json_schema_input_schema']->self.walk(schema['json_schema_input_schema'], f)
A:pydantic._internal._core_utils.schema['lax_schema']->self.walk(schema['lax_schema'], f)
A:pydantic._internal._core_utils.schema['strict_schema']->self.walk(schema['strict_schema'], f)
A:pydantic._internal._core_utils.schema['json_schema']->self.walk(schema['json_schema'], f)
A:pydantic._internal._core_utils.schema['python_schema']->self.walk(schema['python_schema'], f)
A:pydantic._internal._core_utils.extras_schema->_strip_metadata(schema).get('extras_schema')
A:pydantic._internal._core_utils.schema['extras_schema']->self.walk(extras_schema, f)
A:pydantic._internal._core_utils.replaced_field->self._copy_schema(field)
A:pydantic._internal._core_utils.replaced_field['return_schema']->self.walk(computed_field['return_schema'], f)
A:pydantic._internal._core_utils.replaced_field['schema']->self.walk(field['schema'], f)
A:pydantic._internal._core_utils.replaced_param->self._copy_schema(param)
A:pydantic._internal._core_utils.replaced_param['schema']->self.walk(param['schema'], f)
A:pydantic._internal._core_utils.schema['var_args_schema']->self.walk(schema['var_args_schema'], f)
A:pydantic._internal._core_utils.schema['var_kwargs_schema']->self.walk(schema['var_kwargs_schema'], f)
A:pydantic._internal._core_utils.schema['arguments_schema']->self.walk(schema['arguments_schema'], f)
A:pydantic._internal._core_utils.schema['return_schema']->self.walk(schema['return_schema'], f)
A:pydantic._internal._core_utils.new->definitions.pop(ref)
A:pydantic._internal._core_utils.new_ref->get_ref(new)
A:pydantic._internal._core_utils.s->s.copy().copy()
A:pydantic._internal._core_utils.computed_fields->s.copy().copy().get('computed_fields', None)
pydantic._internal._core_utils._WalkCoreSchema(self,*,copy:bool=True)
pydantic._internal._core_utils._WalkCoreSchema.__init__(self,*,copy:bool=True)
pydantic._internal._core_utils._WalkCoreSchema._build_schema_type_to_method(self)->dict[core_schema.CoreSchemaType, Recurse]
pydantic._internal._core_utils._WalkCoreSchema._copy_schema(self,schema:CoreSchemaT)->CoreSchemaT
pydantic._internal._core_utils._WalkCoreSchema._handle_other_schemas(self,schema:core_schema.CoreSchema,f:Walk)->core_schema.CoreSchema
pydantic._internal._core_utils._WalkCoreSchema._handle_ser_schemas(self,ser_schema:core_schema.SerSchema,f:Walk)->core_schema.SerSchema
pydantic._internal._core_utils._WalkCoreSchema._walk(self,schema:core_schema.CoreSchema,f:Walk)->core_schema.CoreSchema
pydantic._internal._core_utils._WalkCoreSchema.handle_arguments_schema(self,schema:core_schema.ArgumentsSchema,f:Walk)->core_schema.CoreSchema
pydantic._internal._core_utils._WalkCoreSchema.handle_call_schema(self,schema:core_schema.CallSchema,f:Walk)->core_schema.CoreSchema
pydantic._internal._core_utils._WalkCoreSchema.handle_chain_schema(self,schema:core_schema.ChainSchema,f:Walk)->core_schema.CoreSchema
pydantic._internal._core_utils._WalkCoreSchema.handle_dataclass_args_schema(self,schema:core_schema.DataclassArgsSchema,f:Walk)->core_schema.CoreSchema
pydantic._internal._core_utils._WalkCoreSchema.handle_definitions_schema(self,schema:core_schema.DefinitionsSchema,f:Walk)->core_schema.CoreSchema
pydantic._internal._core_utils._WalkCoreSchema.handle_dict_schema(self,schema:core_schema.DictSchema,f:Walk)->core_schema.CoreSchema
pydantic._internal._core_utils._WalkCoreSchema.handle_frozenset_schema(self,schema:core_schema.FrozenSetSchema,f:Walk)->core_schema.CoreSchema
pydantic._internal._core_utils._WalkCoreSchema.handle_function_after_schema(self,schema:core_schema.AfterValidatorFunctionSchema,f:Walk)->core_schema.CoreSchema
pydantic._internal._core_utils._WalkCoreSchema.handle_function_before_schema(self,schema:core_schema.BeforeValidatorFunctionSchema,f:Walk)->core_schema.CoreSchema
pydantic._internal._core_utils._WalkCoreSchema.handle_function_plain_schema(self,schema:core_schema.PlainValidatorFunctionSchema|core_schema.PlainSerializerFunctionSerSchema,f:Walk)->core_schema.CoreSchema
pydantic._internal._core_utils._WalkCoreSchema.handle_function_wrap_schema(self,schema:core_schema.WrapValidatorFunctionSchema|core_schema.WrapSerializerFunctionSerSchema,f:Walk)->core_schema.CoreSchema
pydantic._internal._core_utils._WalkCoreSchema.handle_generator_schema(self,schema:core_schema.GeneratorSchema,f:Walk)->core_schema.CoreSchema
pydantic._internal._core_utils._WalkCoreSchema.handle_json_or_python_schema(self,schema:core_schema.JsonOrPythonSchema,f:Walk)->core_schema.CoreSchema
pydantic._internal._core_utils._WalkCoreSchema.handle_lax_or_strict_schema(self,schema:core_schema.LaxOrStrictSchema,f:Walk)->core_schema.CoreSchema
pydantic._internal._core_utils._WalkCoreSchema.handle_list_schema(self,schema:core_schema.ListSchema,f:Walk)->core_schema.CoreSchema
pydantic._internal._core_utils._WalkCoreSchema.handle_model_fields_schema(self,schema:core_schema.ModelFieldsSchema,f:Walk)->core_schema.CoreSchema
pydantic._internal._core_utils._WalkCoreSchema.handle_set_schema(self,schema:core_schema.SetSchema,f:Walk)->core_schema.CoreSchema
pydantic._internal._core_utils._WalkCoreSchema.handle_tagged_union_schema(self,schema:core_schema.TaggedUnionSchema,f:Walk)->core_schema.CoreSchema
pydantic._internal._core_utils._WalkCoreSchema.handle_tuple_schema(self,schema:core_schema.TupleSchema,f:Walk)->core_schema.CoreSchema
pydantic._internal._core_utils._WalkCoreSchema.handle_typed_dict_schema(self,schema:core_schema.TypedDictSchema,f:Walk)->core_schema.CoreSchema
pydantic._internal._core_utils._WalkCoreSchema.handle_union_schema(self,schema:core_schema.UnionSchema,f:Walk)->core_schema.CoreSchema
pydantic._internal._core_utils._WalkCoreSchema.walk(self,schema:core_schema.CoreSchema,f:Walk)->core_schema.CoreSchema
pydantic._internal._core_utils._strip_metadata(schema:CoreSchema)->CoreSchema
pydantic._internal._core_utils.collect_definitions(schema:core_schema.CoreSchema)->dict[str, core_schema.CoreSchema]
pydantic._internal._core_utils.collect_invalid_schemas(schema:core_schema.CoreSchema)->bool
pydantic._internal._core_utils.define_expected_missing_refs(schema:core_schema.CoreSchema,allowed_missing_refs:set[str])->core_schema.CoreSchema | None
pydantic._internal._core_utils.get_ref(s:core_schema.CoreSchema)->None | str
pydantic._internal._core_utils.get_type_ref(type_:type[Any],args_override:tuple[type[Any],...]|None=None)->str
pydantic._internal._core_utils.is_core_schema(schema:CoreSchemaOrField)->TypeGuard[CoreSchema]
pydantic._internal._core_utils.is_core_schema_field(schema:CoreSchemaOrField)->TypeGuard[CoreSchemaField]
pydantic._internal._core_utils.is_function_with_inner_schema(schema:CoreSchemaOrField)->TypeGuard[FunctionSchemaWithInnerSchema]
pydantic._internal._core_utils.is_list_like_schema_with_items_schema(schema:CoreSchema)->TypeGuard[core_schema.ListSchema | core_schema.SetSchema | core_schema.FrozenSetSchema]
pydantic._internal._core_utils.pretty_print_core_schema(schema:CoreSchema,include_metadata:bool=False)->None
pydantic._internal._core_utils.simplify_schema_references(schema:core_schema.CoreSchema)->core_schema.CoreSchema
pydantic._internal._core_utils.validate_core_schema(schema:CoreSchema)->CoreSchema
pydantic._internal._core_utils.walk_core_schema(schema:core_schema.CoreSchema,f:Walk,*,copy:bool=True)->core_schema.CoreSchema


----------------------------------------/dataset/nuaa/anaconda3/envs/pydantic2.10.6/lib/python3.9/site-packages/pydantic/_internal/_import_utils.py----------------------------------------
pydantic._internal._import_utils.import_cached_base_model()->Type['BaseModel']
pydantic._internal._import_utils.import_cached_field_info()->Type['FieldInfo']


----------------------------------------/dataset/nuaa/anaconda3/envs/pydantic2.10.6/lib/python3.9/site-packages/pydantic/_internal/_std_types_schema.py----------------------------------------
A:pydantic._internal._std_types_schema.FieldInfo->import_cached_field_info()
A:pydantic._internal._std_types_schema.js_schema->handler(self.js_core_schema or self.core_schema)
A:pydantic._internal._std_types_schema.(metadata, remaining_annotations)->_known_annotated_metadata.collect_known_metadata(annotations)
A:pydantic._internal._std_types_schema.input_value->input_value.decode().decode()
A:pydantic._internal._std_types_schema.instance_schema->pydantic_core.core_schema.json_or_python_schema(json_schema=core_schema.no_info_after_validator_function(path_validator, constrained_schema), python_schema=core_schema.is_instance_schema(orig_source_type))
A:pydantic._internal._std_types_schema.schema->pydantic_core.core_schema.lax_or_strict_schema(lax_schema=lax, strict_schema=strict)
A:pydantic._internal._std_types_schema.maxlen->min(maxlens)
A:pydantic._internal._std_types_schema.items_schema->handler.generate_schema(self.item_source_type)
A:pydantic._internal._std_types_schema.coerce_instance_wrap->partial(core_schema.no_info_after_validator_function, self.mapped_origin)
A:pydantic._internal._std_types_schema.constrained_schema->pydantic_core.core_schema.dict_schema(keys_schema, values_schema, **metadata)
A:pydantic._internal._std_types_schema.check_instance->pydantic_core.core_schema.json_or_python_schema(json_schema=core_schema.dict_schema(), python_schema=core_schema.is_instance_schema(self.mapped_origin))
A:pydantic._internal._std_types_schema.serialization->pydantic_core.core_schema.wrap_serializer_function_ser_schema(self.serialize_mapping_via_dict, schema=core_schema.dict_schema(keys_schema or core_schema.any_schema(), values_schema or core_schema.any_schema()), info_arg=False)
A:pydantic._internal._std_types_schema.strict->pydantic_core.core_schema.chain_schema([check_instance, coerce_instance_wrap(constrained_schema)])
A:pydantic._internal._std_types_schema.lax->coerce_instance_wrap(constrained_schema)
A:pydantic._internal._std_types_schema.args->typing.cast(Tuple[Any, Any], (Any, Any))
A:pydantic._internal._std_types_schema.allowed_msg->', '.join([t.__name__ for t in set(allowed_default_types.values())])
A:pydantic._internal._std_types_schema.field_info->next((v for v in get_args(values_source_type) if isinstance(v, FieldInfo)), None)
A:pydantic._internal._std_types_schema.default_default_factory->get_defaultdict_default_default_factory(self.values_source_type)
A:pydantic._internal._std_types_schema.keys_schema->handler.generate_schema(self.keys_source_type)
A:pydantic._internal._std_types_schema.values_schema->handler.generate_schema(self.values_source_type)
pydantic._internal._std_types_schema.DequeValidator
pydantic._internal._std_types_schema.DequeValidator.__get_pydantic_core_schema__(self,source_type:Any,handler:GetCoreSchemaHandler)->CoreSchema
pydantic._internal._std_types_schema.InnerSchemaValidator
pydantic._internal._std_types_schema.InnerSchemaValidator.__get_pydantic_core_schema__(self,_source_type:Any,_handler:GetCoreSchemaHandler)->CoreSchema
pydantic._internal._std_types_schema.InnerSchemaValidator.__get_pydantic_json_schema__(self,_schema:CoreSchema,handler:GetJsonSchemaHandler)->JsonSchemaValue
pydantic._internal._std_types_schema.MappingValidator
pydantic._internal._std_types_schema.MappingValidator.__get_pydantic_core_schema__(self,source_type:Any,handler:GetCoreSchemaHandler)->CoreSchema
pydantic._internal._std_types_schema.MappingValidator.serialize_mapping_via_dict(self,v:Any,handler:core_schema.SerializerFunctionWrapHandler)->Any
pydantic._internal._std_types_schema.defaultdict_validator(input_value:Any,handler:core_schema.ValidatorFunctionWrapHandler,default_default_factory:Callable[[],Any])->collections.defaultdict[Any, Any]
pydantic._internal._std_types_schema.deque_schema_prepare_pydantic_annotations(source_type:Any,annotations:Iterable[Any])->tuple[Any, list[Any]] | None
pydantic._internal._std_types_schema.deque_validator(input_value:Any,handler:core_schema.ValidatorFunctionWrapHandler,maxlen:None|int)->collections.deque[Any]
pydantic._internal._std_types_schema.get_defaultdict_default_default_factory(values_source_type:Any)->Callable[[], Any]
pydantic._internal._std_types_schema.mapping_like_prepare_pydantic_annotations(source_type:Any,annotations:Iterable[Any])->tuple[Any, list[Any]] | None
pydantic._internal._std_types_schema.path_schema_prepare_pydantic_annotations(source_type:Any,annotations:Iterable[Any])->tuple[Any, list[Any]] | None


----------------------------------------/dataset/nuaa/anaconda3/envs/pydantic2.10.6/lib/python3.9/site-packages/pydantic/_internal/_forward_ref.py----------------------------------------
pydantic._internal._forward_ref.PydanticRecursiveRef(self)
pydantic._internal._forward_ref.PydanticRecursiveRef.__call__(self)
pydantic._internal._forward_ref.PydanticRecursiveRef.__or__(self,other)
pydantic._internal._forward_ref.PydanticRecursiveRef.__ror__(self,other)


----------------------------------------/dataset/nuaa/anaconda3/envs/pydantic2.10.6/lib/python3.9/site-packages/pydantic/_internal/_git.py----------------------------------------
pydantic._internal._git.git_revision(dir:str)->str
pydantic._internal._git.have_git()->bool
pydantic._internal._git.is_git_repo(dir:str)->bool


----------------------------------------/dataset/nuaa/anaconda3/envs/pydantic2.10.6/lib/python3.9/site-packages/pydantic/_internal/_generics.py----------------------------------------
A:pydantic._internal._generics.KT->TypeVar('KT')
A:pydantic._internal._generics.VT->TypeVar('VT')
A:pydantic._internal._generics._GENERIC_TYPES_CACHE->GenericTypesCache()
A:pydantic._internal._generics.(meta, ns, kwds)->prepare_class(model_name, bases)
A:pydantic._internal._generics.created_model->meta(model_name, bases, namespace, __pydantic_generic_metadata__={'origin': origin, 'args': args, 'parameters': params}, __pydantic_reset_parent_namespace__=False, **kwds)
A:pydantic._internal._generics.(model_module, called_globally)->_get_caller_frame_info(depth=3)
A:pydantic._internal._generics.object_by_reference->reference_module_globals.setdefault(reference_name, created_model)
A:pydantic._internal._generics.previous_caller_frame->sys._getframe(depth)
A:pydantic._internal._generics.args->get_args(v)
A:pydantic._internal._generics.origin->get_origin(cls)
A:pydantic._internal._generics.type_args->get_args(type_)
A:pydantic._internal._generics.annotated->replace_types(annotated_type, type_map)
A:pydantic._internal._generics.origin_type->getattr(typing, type_._name)
A:pydantic._internal._generics.resolved_type_args->tuple((replace_types(t, type_map) for t in parameters))
A:pydantic._internal._generics.actual->len(parameters)
A:pydantic._internal._generics.expected->len(cls.__pydantic_generic_metadata__['parameters'])
A:pydantic._internal._generics.previously_seen_type_refs->set()
A:pydantic._internal._generics.token->_generic_recursion_cache.set(previously_seen_type_refs)
A:pydantic._internal._generics.type_ref->get_type_ref(origin, args_override=args)
A:pydantic._internal._generics.self_type->PydanticRecursiveRef(type_ref=type_ref)
A:pydantic._internal._generics.visited->_generic_recursion_cache.get()
A:pydantic._internal._generics.cached->GenericTypesCache().get(_late_cache_key(origin, args, typevar_values))
pydantic._internal._generics.PydanticGenericMetadata(typing_extensions.TypedDict)
pydantic._internal._generics._early_cache_key(cls:type[BaseModel],typevar_values:Any)->GenericTypesCacheKey
pydantic._internal._generics._get_caller_frame_info(depth:int=2)->tuple[str | None, bool]
pydantic._internal._generics._late_cache_key(origin:type[BaseModel],args:tuple[Any,...],typevar_values:Any)->GenericTypesCacheKey
pydantic._internal._generics._union_orderings_key(typevar_values:Any)->Any
pydantic._internal._generics.check_parameters_count(cls:type[BaseModel],parameters:tuple[Any,...])->None
pydantic._internal._generics.create_generic_submodel(model_name:str,origin:type[BaseModel],args:tuple[Any,...],params:tuple[Any,...])->type[BaseModel]
pydantic._internal._generics.generic_recursion_self_type(origin:type[BaseModel],args:tuple[Any,...])->Iterator[PydanticRecursiveRef | None]
pydantic._internal._generics.get_args(v:Any)->Any
pydantic._internal._generics.get_cached_generic_type_early(parent:type[BaseModel],typevar_values:Any)->type[BaseModel] | None
pydantic._internal._generics.get_cached_generic_type_late(parent:type[BaseModel],typevar_values:Any,origin:type[BaseModel],args:tuple[Any,...])->type[BaseModel] | None
pydantic._internal._generics.get_model_typevars_map(cls:type[BaseModel])->dict[TypeVar, Any] | None
pydantic._internal._generics.get_origin(v:Any)->Any
pydantic._internal._generics.get_standard_typevars_map(cls:Any)->dict[TypeVar, Any] | None
pydantic._internal._generics.has_instance_in_type(type_:Any,isinstance_target:Any)->bool
pydantic._internal._generics.iter_contained_typevars(v:Any)->Iterator[TypeVar]
pydantic._internal._generics.recursively_defined_type_refs()->set[str]
pydantic._internal._generics.replace_types(type_:Any,type_map:Mapping[Any,Any]|None)->Any
pydantic._internal._generics.set_cached_generic_type(parent:type[BaseModel],typevar_values:tuple[Any,...],type_:type[BaseModel],origin:type[BaseModel]|None=None,args:tuple[Any,...]|None=None)->None


----------------------------------------/dataset/nuaa/anaconda3/envs/pydantic2.10.6/lib/python3.9/site-packages/pydantic/_internal/_repr.py----------------------------------------
A:pydantic._internal._repr.attrs_names->self.__dict__.keys()
A:pydantic._internal._repr.args->', '.join(map(display_as_type, typing_extensions.get_args(obj)))
pydantic._internal._repr.PlainRepr(str)
pydantic._internal._repr.PlainRepr.__repr__(self)->str
pydantic._internal._repr.Representation
pydantic._internal._repr.Representation.__pretty__(self,fmt:typing.Callable[[Any],Any],**kwargs:Any)->typing.Generator[Any, None, None]
pydantic._internal._repr.Representation.__repr__(self)->str
pydantic._internal._repr.Representation.__repr_args__(self)->ReprArgs
pydantic._internal._repr.Representation.__repr_name__(self)->str
pydantic._internal._repr.Representation.__repr_recursion__(self,object:Any)->str
pydantic._internal._repr.Representation.__repr_str__(self,join_str:str)->str
pydantic._internal._repr.Representation.__rich_repr__(self)->RichReprResult
pydantic._internal._repr.Representation.__str__(self)->str
pydantic._internal._repr.display_as_type(obj:Any)->str


----------------------------------------/dataset/nuaa/anaconda3/envs/pydantic2.10.6/lib/python3.9/site-packages/pydantic/_internal/_serializers.py----------------------------------------
A:pydantic._internal._serializers.mapped_origin->SEQUENCE_ORIGIN_MAP.get(type(v), None)
A:pydantic._internal._serializers.v->handler(item, index)
pydantic._internal._serializers.serialize_sequence_via_list(v:Any,handler:core_schema.SerializerFunctionWrapHandler,info:core_schema.SerializationInfo)->Any


----------------------------------------/dataset/nuaa/anaconda3/envs/pydantic2.10.6/lib/python3.9/site-packages/pydantic/_internal/_core_metadata.py----------------------------------------
A:pydantic._internal._core_metadata.core_metadata->cast(CoreMetadata, core_metadata)
A:pydantic._internal._core_metadata.existing_pydantic_js_extra->cast(CoreMetadata, core_metadata).get('pydantic_js_extra')
pydantic._internal._core_metadata.CoreMetadata(TypedDict,total=False)
pydantic._internal._core_metadata.update_core_metadata(core_metadata:Any,/,*,pydantic_js_functions:list[GetJsonSchemaFunction]|None=None,pydantic_js_annotation_functions:list[GetJsonSchemaFunction]|None=None,pydantic_js_updates:JsonDict|None=None,pydantic_js_extra:JsonDict|JsonSchemaExtraCallable|None=None)->None


----------------------------------------/dataset/nuaa/anaconda3/envs/pydantic2.10.6/lib/python3.9/site-packages/pydantic/_internal/_signature.py----------------------------------------
A:pydantic._internal._signature._HAS_DEFAULT_FACTORY->_HAS_DEFAULT_FACTORY_CLASS()
A:pydantic._internal._signature.present_params->signature(init).parameters.values()
A:pydantic._internal._signature.param->param.replace(annotation=Any).replace(annotation=Any)
A:pydantic._internal._signature.param_name->_field_name_for_signature(field_name, field)
A:pydantic._internal._signature.merged_params[param_name]->Parameter(param_name, Parameter.KEYWORD_ONLY, annotation=field.rebuild_annotation(), default=default)
A:pydantic._internal._signature.merged_params[var_kw_name]->var_kw.replace(name=var_kw_name)
A:pydantic._internal._signature.merged_params->_generate_signature_parameters(init, fields, populate_by_name, extra)
pydantic._internal._signature._HAS_DEFAULT_FACTORY_CLASS
pydantic._internal._signature._HAS_DEFAULT_FACTORY_CLASS.__repr__(self)
pydantic._internal._signature._field_name_for_signature(field_name:str,field_info:FieldInfo)->str
pydantic._internal._signature._generate_signature_parameters(init:Callable[...,None],fields:dict[str,FieldInfo],populate_by_name:bool,extra:ExtraValues|None)->dict[str, Parameter]
pydantic._internal._signature._process_param_defaults(param:Parameter)->Parameter
pydantic._internal._signature.generate_pydantic_signature(init:Callable[...,None],fields:dict[str,FieldInfo],populate_by_name:bool,extra:ExtraValues|None,is_dataclass:bool=False)->Signature


----------------------------------------/dataset/nuaa/anaconda3/envs/pydantic2.10.6/lib/python3.9/site-packages/pydantic/_internal/_validators.py----------------------------------------
A:pydantic._internal._validators.value_type->type(input_value)
A:pydantic._internal._validators.input_value->list(input_value)
A:pydantic._internal._validators.v_list->validator(input_value)
A:pydantic._internal._validators.components->dotted_path.strip().split(':')
A:pydantic._internal._validators.module->import_module(module_path)
A:pydantic._internal._validators.(maybe_module_path, maybe_attribute)->dotted_path.strip().rsplit('.', 1)
A:pydantic._internal._validators.PatternType->typing.TypeVar('PatternType', str, bytes)
A:pydantic._internal._validators.decimal_tuple->decimal.as_tuple()
A:pydantic._internal._validators.num_digits->max(num_digits, decimal_places)
A:pydantic._internal._validators.decimal_places->abs(exponent)
A:pydantic._internal._validators.(_, num_digits)->_extract_decimal_digits_info(x)
A:pydantic._internal._validators.(_, normalized_num_digits)->_extract_decimal_digits_info(x.normalize())
A:pydantic._internal._validators.(decimal_places_, _)->_extract_decimal_digits_info(x)
A:pydantic._internal._validators.(normalized_decimal_places, _)->_extract_decimal_digits_info(x.normalize())
pydantic._internal._validators._extract_decimal_digits_info(decimal:Decimal)->tuple[int, int]
pydantic._internal._validators._import_string_logic(dotted_path:str)->Any
pydantic._internal._validators._safe_repr(v:Any)->int | float | str
pydantic._internal._validators.compile_pattern(pattern:PatternType)->typing.Pattern[PatternType]
pydantic._internal._validators.decimal_places_validator(x:Any,decimal_places:Any)->Any
pydantic._internal._validators.forbid_inf_nan_check(x:Any)->Any
pydantic._internal._validators.fraction_validator(input_value:Any,/)->Fraction
pydantic._internal._validators.greater_than_or_equal_validator(x:Any,ge:Any)->Any
pydantic._internal._validators.greater_than_validator(x:Any,gt:Any)->Any
pydantic._internal._validators.import_string(value:Any)->Any
pydantic._internal._validators.ip_v4_address_validator(input_value:Any,/)->IPv4Address
pydantic._internal._validators.ip_v4_interface_validator(input_value:Any,/)->IPv4Interface
pydantic._internal._validators.ip_v4_network_validator(input_value:Any,/)->IPv4Network
pydantic._internal._validators.ip_v6_address_validator(input_value:Any,/)->IPv6Address
pydantic._internal._validators.ip_v6_interface_validator(input_value:Any,/)->IPv6Interface
pydantic._internal._validators.ip_v6_network_validator(input_value:Any,/)->IPv6Network
pydantic._internal._validators.less_than_or_equal_validator(x:Any,le:Any)->Any
pydantic._internal._validators.less_than_validator(x:Any,lt:Any)->Any
pydantic._internal._validators.max_digits_validator(x:Any,max_digits:Any)->Any
pydantic._internal._validators.max_length_validator(x:Any,max_length:Any)->Any
pydantic._internal._validators.min_length_validator(x:Any,min_length:Any)->Any
pydantic._internal._validators.multiple_of_validator(x:Any,multiple_of:Any)->Any
pydantic._internal._validators.pattern_bytes_validator(input_value:Any,/)->typing.Pattern[bytes]
pydantic._internal._validators.pattern_either_validator(input_value:Any,/)->typing.Pattern[Any]
pydantic._internal._validators.pattern_str_validator(input_value:Any,/)->typing.Pattern[str]
pydantic._internal._validators.sequence_validator(input_value:typing.Sequence[Any],/,validator:core_schema.ValidatorFunctionWrapHandler)->typing.Sequence[Any]


----------------------------------------/dataset/nuaa/anaconda3/envs/pydantic2.10.6/lib/python3.9/site-packages/pydantic/_internal/_internal_dataclass.py----------------------------------------


----------------------------------------/dataset/nuaa/anaconda3/envs/pydantic2.10.6/lib/python3.9/site-packages/pydantic/_internal/_mock_val_ser.py----------------------------------------
A:pydantic._internal._mock_val_ser.ValSer->TypeVar('ValSer', bound=Union[SchemaValidator, PluggableSchemaValidator, SchemaSerializer])
A:pydantic._internal._mock_val_ser.T->TypeVar('T')
A:pydantic._internal._mock_val_ser.schema->self._attempt_rebuild()
A:pydantic._internal._mock_val_ser.val_ser->self._attempt_rebuild()
A:pydantic._internal._mock_val_ser.adapter.core_schema->MockCoreSchema(undefined_type_error_message, code='class-not-fully-defined', attempt_rebuild=attempt_rebuild_fn(lambda ta: ta.core_schema))
A:pydantic._internal._mock_val_ser.adapter.validator->MockValSer(undefined_type_error_message, code='class-not-fully-defined', val_or_ser='validator', attempt_rebuild=attempt_rebuild_fn(lambda ta: ta.validator))
A:pydantic._internal._mock_val_ser.adapter.serializer->MockValSer(undefined_type_error_message, code='class-not-fully-defined', val_or_ser='serializer', attempt_rebuild=attempt_rebuild_fn(lambda ta: ta.serializer))
A:pydantic._internal._mock_val_ser.cls.__pydantic_core_schema__->MockCoreSchema(undefined_type_error_message, code='class-not-fully-defined', attempt_rebuild=attempt_rebuild_fn(lambda c: c.__pydantic_core_schema__))
A:pydantic._internal._mock_val_ser.cls.__pydantic_validator__->MockValSer(undefined_type_error_message, code='class-not-fully-defined', val_or_ser='validator', attempt_rebuild=attempt_rebuild_fn(lambda c: c.__pydantic_validator__))
A:pydantic._internal._mock_val_ser.cls.__pydantic_serializer__->MockValSer(undefined_type_error_message, code='class-not-fully-defined', val_or_ser='serializer', attempt_rebuild=attempt_rebuild_fn(lambda c: c.__pydantic_serializer__))
pydantic._internal._mock_val_ser.MockCoreSchema(self,error_message:str,*,code:PydanticErrorCodes,attempt_rebuild:Callable[[],CoreSchema|None]|None=None)
pydantic._internal._mock_val_ser.MockCoreSchema.__getitem__(self,key:str)->Any
pydantic._internal._mock_val_ser.MockCoreSchema.__init__(self,error_message:str,*,code:PydanticErrorCodes,attempt_rebuild:Callable[[],CoreSchema|None]|None=None)
pydantic._internal._mock_val_ser.MockCoreSchema.__iter__(self)->Iterator[str]
pydantic._internal._mock_val_ser.MockCoreSchema.__len__(self)->int
pydantic._internal._mock_val_ser.MockCoreSchema._get_built(self)->CoreSchema
pydantic._internal._mock_val_ser.MockCoreSchema.rebuild(self)->CoreSchema | None
pydantic._internal._mock_val_ser.MockValSer(self,error_message:str,*,code:PydanticErrorCodes,val_or_ser:Literal['validator','serializer'],attempt_rebuild:Callable[[],ValSer|None]|None=None)
pydantic._internal._mock_val_ser.MockValSer.__getattr__(self,item:str)->None
pydantic._internal._mock_val_ser.MockValSer.__init__(self,error_message:str,*,code:PydanticErrorCodes,val_or_ser:Literal['validator','serializer'],attempt_rebuild:Callable[[],ValSer|None]|None=None)
pydantic._internal._mock_val_ser.MockValSer.rebuild(self)->ValSer | None
pydantic._internal._mock_val_ser.set_dataclass_mocks(cls:type[PydanticDataclass],cls_name:str,undefined_name:str='allreferencedtypes')->None
pydantic._internal._mock_val_ser.set_model_mocks(cls:type[BaseModel],cls_name:str,undefined_name:str='allreferencedtypes')->None
pydantic._internal._mock_val_ser.set_type_adapter_mocks(adapter:TypeAdapter,type_repr:str)->None


----------------------------------------/dataset/nuaa/anaconda3/envs/pydantic2.10.6/lib/python3.9/site-packages/pydantic/v1/env_settings.py----------------------------------------
A:pydantic.v1.env_settings.env_file_sentinel->str(object())
A:pydantic.v1.env_settings.init_settings->InitSettingsSource(init_kwargs=init_kwargs)
A:pydantic.v1.env_settings.env_settings->EnvSettingsSource(env_file=_env_file if _env_file != env_file_sentinel else self.__config__.env_file, env_file_encoding=_env_file_encoding if _env_file_encoding is not None else self.__config__.env_file_encoding, env_nested_delimiter=_env_nested_delimiter if _env_nested_delimiter is not None else self.__config__.env_nested_delimiter, env_prefix_len=len(self.__config__.env_prefix))
A:pydantic.v1.env_settings.file_secret_settings->SecretsSettingsSource(secrets_dir=_secrets_dir or self.__config__.secrets_dir)
A:pydantic.v1.env_settings.sources->self.__config__.customise_sources(init_settings=init_settings, env_settings=env_settings, file_secret_settings=file_secret_settings)
A:pydantic.v1.env_settings.field_info_from_config->cls.get_field_info(field.name)
A:pydantic.v1.env_settings.env_names->env_names.__class__((n.lower() for n in env_names)).__class__((n.lower() for n in env_names))
A:pydantic.v1.env_settings.dotenv_vars->self._read_env_files(settings.__config__.case_sensitive)
A:pydantic.v1.env_settings.env_val->settings.__config__.parse_env_var(field.name, env_val)
A:pydantic.v1.env_settings.(is_complex, allow_parse_failure)->self.field_is_complex(field)
A:pydantic.v1.env_settings.env_val_built->self.explode_env_vars(field, env_vars)
A:pydantic.v1.env_settings.d[field.alias]->deep_update(env_val, self.explode_env_vars(field, env_vars))
A:pydantic.v1.env_settings.env_path->Path(env_file).expanduser()
A:pydantic.v1.env_settings.(_, *keys, last_key)->env_name_without_prefix.split(self.env_nested_delimiter)
A:pydantic.v1.env_settings.env_var->env_var.setdefault(key, {}).setdefault(key, {})
A:pydantic.v1.env_settings.secrets_path->Path(self.secrets_dir).expanduser()
A:pydantic.v1.env_settings.path->find_case_path(secrets_path, env_name, settings.__config__.case_sensitive)
A:pydantic.v1.env_settings.secret_value->settings.__config__.parse_env_var(field.name, secret_value)
pydantic.v1.BaseSettings(__pydantic_self__,_env_file:Optional[DotenvType]=env_file_sentinel,_env_file_encoding:Optional[str]=None,_env_nested_delimiter:Optional[str]=None,_secrets_dir:Optional[StrPath]=None,**values:Any)
pydantic.v1.BaseSettings.Config(BaseConfig)
pydantic.v1.BaseSettings.Config.customise_sources(cls,init_settings:SettingsSourceCallable,env_settings:SettingsSourceCallable,file_secret_settings:SettingsSourceCallable)->Tuple[SettingsSourceCallable, ...]
pydantic.v1.BaseSettings.Config.parse_env_var(cls,field_name:str,raw_val:str)->Any
pydantic.v1.BaseSettings.Config.prepare_field(cls,field:ModelField)->None
pydantic.v1.BaseSettings._build_values(self,init_kwargs:Dict[str,Any],_env_file:Optional[DotenvType]=None,_env_file_encoding:Optional[str]=None,_env_nested_delimiter:Optional[str]=None,_secrets_dir:Optional[StrPath]=None)->Dict[str, Any]
pydantic.v1.env_settings.BaseSettings(__pydantic_self__,_env_file:Optional[DotenvType]=env_file_sentinel,_env_file_encoding:Optional[str]=None,_env_nested_delimiter:Optional[str]=None,_secrets_dir:Optional[StrPath]=None,**values:Any)
pydantic.v1.env_settings.BaseSettings.Config(BaseConfig)
pydantic.v1.env_settings.BaseSettings.Config.customise_sources(cls,init_settings:SettingsSourceCallable,env_settings:SettingsSourceCallable,file_secret_settings:SettingsSourceCallable)->Tuple[SettingsSourceCallable, ...]
pydantic.v1.env_settings.BaseSettings.Config.parse_env_var(cls,field_name:str,raw_val:str)->Any
pydantic.v1.env_settings.BaseSettings.Config.prepare_field(cls,field:ModelField)->None
pydantic.v1.env_settings.BaseSettings.__init__(__pydantic_self__,_env_file:Optional[DotenvType]=env_file_sentinel,_env_file_encoding:Optional[str]=None,_env_nested_delimiter:Optional[str]=None,_secrets_dir:Optional[StrPath]=None,**values:Any)
pydantic.v1.env_settings.BaseSettings._build_values(self,init_kwargs:Dict[str,Any],_env_file:Optional[DotenvType]=None,_env_file_encoding:Optional[str]=None,_env_nested_delimiter:Optional[str]=None,_secrets_dir:Optional[StrPath]=None)->Dict[str, Any]
pydantic.v1.env_settings.EnvSettingsSource(self,env_file:Optional[DotenvType],env_file_encoding:Optional[str],env_nested_delimiter:Optional[str]=None,env_prefix_len:int=0)
pydantic.v1.env_settings.EnvSettingsSource.__init__(self,env_file:Optional[DotenvType],env_file_encoding:Optional[str],env_nested_delimiter:Optional[str]=None,env_prefix_len:int=0)
pydantic.v1.env_settings.EnvSettingsSource.__repr__(self)->str
pydantic.v1.env_settings.EnvSettingsSource._read_env_files(self,case_sensitive:bool)->Dict[str, Optional[str]]
pydantic.v1.env_settings.EnvSettingsSource.explode_env_vars(self,field:ModelField,env_vars:Mapping[str,Optional[str]])->Dict[str, Any]
pydantic.v1.env_settings.EnvSettingsSource.field_is_complex(self,field:ModelField)->Tuple[bool, bool]
pydantic.v1.env_settings.InitSettingsSource(self,init_kwargs:Dict[str,Any])
pydantic.v1.env_settings.InitSettingsSource.__init__(self,init_kwargs:Dict[str,Any])
pydantic.v1.env_settings.InitSettingsSource.__repr__(self)->str
pydantic.v1.env_settings.SecretsSettingsSource(self,secrets_dir:Optional[StrPath])
pydantic.v1.env_settings.SecretsSettingsSource.__init__(self,secrets_dir:Optional[StrPath])
pydantic.v1.env_settings.SecretsSettingsSource.__repr__(self)->str
pydantic.v1.env_settings.SettingsError(ValueError)
pydantic.v1.env_settings.find_case_path(dir_path:Path,file_name:str,case_sensitive:bool)->Optional[Path]
pydantic.v1.env_settings.read_env_file(file_path:StrPath,*,encoding:str=None,case_sensitive:bool=False)->Dict[str, Optional[str]]


----------------------------------------/dataset/nuaa/anaconda3/envs/pydantic2.10.6/lib/python3.9/site-packages/pydantic/v1/dataclasses.py----------------------------------------
A:pydantic.v1.dataclasses.DataclassT->TypeVar('DataclassT', bound='Dataclass')
A:pydantic.v1.dataclasses._T->TypeVar('_T')
A:pydantic.v1.dataclasses.the_config->get_config(config)
A:pydantic.v1.dataclasses.dc_cls->dataclasses.dataclass(cls, init=init, repr=repr, eq=eq, order=order, unsafe_hash=unsafe_hash, frozen=frozen)
A:pydantic.v1.dataclasses.initvars_and_values[f.name]->kwargs.get(f.name, f.default)
A:pydantic.v1.dataclasses.field_info->Field(default=default, default_factory=default_factory, **field.metadata)
A:pydantic.v1.dataclasses.validators->gather_all_validators(dc_cls)
A:pydantic.v1.dataclasses.(d, _, validation_error)->validate_model(self.__pydantic_model__, input_data, cls=self.__class__)
A:pydantic.v1.dataclasses.d->dict(self.__dict__)
A:pydantic.v1.dataclasses.known_field->self.__pydantic_model__.__fields__.get(name, None)
A:pydantic.v1.dataclasses.(value, error_)->self.__pydantic_model__.__fields__.get(name, None).validate(value, d, loc=name, cls=self.__class__)
pydantic.v1.dataclasses.DataclassProxy(self,dc_cls:Type['Dataclass'])
pydantic.v1.dataclasses.DataclassProxy.__copy__(self)->'DataclassProxy'
pydantic.v1.dataclasses.DataclassProxy.__deepcopy__(self,memo:Any)->'DataclassProxy'
pydantic.v1.dataclasses.DataclassProxy.__getattr__(self,name:str)->Any
pydantic.v1.dataclasses.DataclassProxy.__init__(self,dc_cls:Type['Dataclass'])
pydantic.v1.dataclasses.DataclassProxy.__instancecheck__(self,instance:Any)->bool
pydantic.v1.dataclasses.DataclassProxy.__setattr__(self,__name:str,__value:Any)->None
pydantic.v1.dataclasses._add_pydantic_validation_attributes(dc_cls:Type['Dataclass'],config:Type[BaseConfig],validate_on_init:bool,dc_cls_doc:str)->None
pydantic.v1.dataclasses._dataclass_validate_assignment_setattr(self:'Dataclass',name:str,value:Any)->None
pydantic.v1.dataclasses._dataclass_validate_values(self:'Dataclass')->None
pydantic.v1.dataclasses._get_validators(cls:'DataclassClassOrWrapper')->'CallableGenerator'
pydantic.v1.dataclasses._validate_dataclass(cls:Type['DataclassT'],v:Any)->'DataclassT'
pydantic.v1.dataclasses.create_pydantic_model_from_dataclass(dc_cls:Type['Dataclass'],config:Type[Any]=BaseConfig,dc_cls_doc:Optional[str]=None)->Type['BaseModel']
pydantic.v1.dataclasses.dataclass(_cls:Optional[Type[_T]]=None,*,init:bool=True,repr:bool=True,eq:bool=True,order:bool=False,unsafe_hash:bool=False,frozen:bool=False,config:Union[ConfigDict,Type[object],None]=None,validate_on_init:Optional[bool]=None,use_proxy:Optional[bool]=None,kw_only:bool=False)->Union[Callable[[Type[_T]], 'DataclassClassOrWrapper'], 'DataclassClassOrWrapper']
pydantic.v1.dataclasses.is_builtin_dataclass(_cls:Type[Any])->bool
pydantic.v1.dataclasses.make_dataclass_validator(dc_cls:Type['Dataclass'],config:Type[BaseConfig])->'CallableGenerator'
pydantic.v1.dataclasses.set_validation(cls:Type['DataclassT'],value:bool)->Generator[Type['DataclassT'], None, None]


----------------------------------------/dataset/nuaa/anaconda3/envs/pydantic2.10.6/lib/python3.9/site-packages/pydantic/v1/__init__.py----------------------------------------


----------------------------------------/dataset/nuaa/anaconda3/envs/pydantic2.10.6/lib/python3.9/site-packages/pydantic/v1/decorator.py----------------------------------------
A:pydantic.v1.decorator.AnyCallableT->TypeVar('AnyCallableT', bound=AnyCallable)
A:pydantic.v1.decorator.vd->ValidatedFunction(_func, config)
A:pydantic.v1.decorator.self.positional_only_args->set()
A:pydantic.v1.decorator.type_hints->get_all_type_hints(function)
A:pydantic.v1.decorator.values->self.build_values(args, kwargs)
A:pydantic.v1.decorator.m->self.init_model_instance(*args, **kwargs)
A:pydantic.v1.decorator.arg_iter->enumerate(args)
A:pydantic.v1.decorator.(i, a)->next(arg_iter)
A:pydantic.v1.decorator.arg_name->self.arg_mapping.get(i)
A:pydantic.v1.decorator.var_kwargs->d.pop(self.v_kwargs_name, {})
A:pydantic.v1.decorator.pos_args->len(self.arg_mapping)
A:pydantic.v1.decorator.CustomConfig->type('Config', (), config)
A:pydantic.v1.decorator.keys->', '.join(map(repr, v))
A:pydantic.v1.decorator.extra->getattr(CustomConfig, 'extra', Extra.forbid)
A:pydantic.v1.decorator.self.model->create_model(to_camel(self.raw_function.__name__), __base__=DecoratorBaseModel, **fields)
pydantic.v1.decorator.ValidatedFunction(self,function:'AnyCallableT',config:'ConfigType')
pydantic.v1.decorator.ValidatedFunction.__init__(self,function:'AnyCallableT',config:'ConfigType')
pydantic.v1.decorator.ValidatedFunction.build_values(self,args:Tuple[Any,...],kwargs:Dict[str,Any])->Dict[str, Any]
pydantic.v1.decorator.ValidatedFunction.call(self,*args:Any,**kwargs:Any)->Any
pydantic.v1.decorator.ValidatedFunction.create_model(self,fields:Dict[str,Any],takes_args:bool,takes_kwargs:bool,config:'ConfigType')->None
pydantic.v1.decorator.ValidatedFunction.execute(self,m:BaseModel)->Any
pydantic.v1.decorator.ValidatedFunction.init_model_instance(self,*args:Any,**kwargs:Any)->BaseModel
pydantic.v1.decorator.validate_arguments(func:Optional['AnyCallableT']=None,*,config:'ConfigType'=None)->Any
pydantic.v1.validate_arguments(func:Optional['AnyCallableT']=None,*,config:'ConfigType'=None)->Any


----------------------------------------/dataset/nuaa/anaconda3/envs/pydantic2.10.6/lib/python3.9/site-packages/pydantic/v1/parse.py----------------------------------------
A:pydantic.v1.parse.b->Path(path).read_bytes()
A:pydantic.v1.parse.path->Path(path)
pydantic.v1.Protocol(str,Enum)
pydantic.v1.parse.Protocol(str,Enum)
pydantic.v1.parse.load_file(path:Union[str,Path],*,content_type:str=None,encoding:str='utf8',proto:Protocol=None,allow_pickle:bool=False,json_loads:Callable[[str],Any]=json.loads)->Any
pydantic.v1.parse.load_str_bytes(b:StrBytes,*,content_type:str=None,encoding:str='utf8',proto:Protocol=None,allow_pickle:bool=False,json_loads:Callable[[str],Any]=json.loads)->Any


----------------------------------------/dataset/nuaa/anaconda3/envs/pydantic2.10.6/lib/python3.9/site-packages/pydantic/v1/validators.py----------------------------------------
A:pydantic.v1.validators.v->v.lower().lower()
A:pydantic.v1.validators.allow_inf_nan->getattr(field.type_, 'allow_inf_nan', None)
A:pydantic.v1.validators.v_len->len(v)
A:pydantic.v1.validators.enum_v->field.type_(v)
A:pydantic.v1.validators.required_version->getattr(field.type_, '_required_version', None)
A:pydantic.v1.validators.permitted_choices->all_literal_values(type_)
A:pydantic.v1.validators.T->TypeVar('T')
A:pydantic.v1.validators.str_value->str_validator(v)
A:pydantic.v1.validators.NamedTupleT->TypeVar('NamedTupleT', bound=NamedTuple)
A:pydantic.v1.validators.NamedTupleModel->create_model_from_namedtuple(namedtuple_cls, __config__=config, __module__=namedtuple_cls.__module__)
A:pydantic.v1.validators.TypedDictModel->create_model_from_typeddict(typeddict_cls, __config__=config, __module__=typeddict_cls.__module__)
A:pydantic.v1.validators.class_->get_class(type_)
pydantic.v1.validators.IfConfig(self,validator:AnyCallable,*config_attr_names:str,ignored_value:Any=False)
pydantic.v1.validators.IfConfig.__init__(self,validator:AnyCallable,*config_attr_names:str,ignored_value:Any=False)
pydantic.v1.validators.IfConfig.check(self,config:Type['BaseConfig'])->bool
pydantic.v1.validators.any_class_validator(v:Any)->Type[T]
pydantic.v1.validators.anystr_length_validator(v:'StrBytes',config:'BaseConfig')->'StrBytes'
pydantic.v1.validators.anystr_lower(v:'StrBytes')->'StrBytes'
pydantic.v1.validators.anystr_strip_whitespace(v:'StrBytes')->'StrBytes'
pydantic.v1.validators.anystr_upper(v:'StrBytes')->'StrBytes'
pydantic.v1.validators.bool_validator(v:Any)->bool
pydantic.v1.validators.bytes_validator(v:Any)->Union[bytes]
pydantic.v1.validators.callable_validator(v:Any)->AnyCallable
pydantic.v1.validators.constant_validator(v:'Any',field:'ModelField')->'Any'
pydantic.v1.validators.constr_length_validator(v:'StrBytes',field:'ModelField',config:'BaseConfig')->'StrBytes'
pydantic.v1.validators.constr_lower(v:'StrBytes',field:'ModelField',config:'BaseConfig')->'StrBytes'
pydantic.v1.validators.constr_strip_whitespace(v:'StrBytes',field:'ModelField',config:'BaseConfig')->'StrBytes'
pydantic.v1.validators.constr_upper(v:'StrBytes',field:'ModelField',config:'BaseConfig')->'StrBytes'
pydantic.v1.validators.decimal_validator(v:Any)->Decimal
pydantic.v1.validators.deque_validator(v:Any)->Deque[Any]
pydantic.v1.validators.dict_validator(v:Any)->Dict[Any, Any]
pydantic.v1.validators.enum_member_validator(v:Any,field:'ModelField',config:'BaseConfig')->Enum
pydantic.v1.validators.enum_validator(v:Any)->Enum
pydantic.v1.validators.find_validators(type_:Type[Any],config:Type['BaseConfig'])->Generator[AnyCallable, None, None]
pydantic.v1.validators.float_finite_validator(v:'Number',field:'ModelField',config:'BaseConfig')->'Number'
pydantic.v1.validators.float_validator(v:Any)->float
pydantic.v1.validators.frozenset_validator(v:Any)->FrozenSet[Any]
pydantic.v1.validators.hashable_validator(v:Any)->Hashable
pydantic.v1.validators.int_enum_validator(v:Any)->IntEnum
pydantic.v1.validators.int_validator(v:Any)->int
pydantic.v1.validators.ip_v4_address_validator(v:Any)->IPv4Address
pydantic.v1.validators.ip_v4_interface_validator(v:Any)->IPv4Interface
pydantic.v1.validators.ip_v4_network_validator(v:Any)->IPv4Network
pydantic.v1.validators.ip_v6_address_validator(v:Any)->IPv6Address
pydantic.v1.validators.ip_v6_interface_validator(v:Any)->IPv6Interface
pydantic.v1.validators.ip_v6_network_validator(v:Any)->IPv6Network
pydantic.v1.validators.list_validator(v:Any)->List[Any]
pydantic.v1.validators.make_arbitrary_type_validator(type_:Type[T])->Callable[[T], T]
pydantic.v1.validators.make_class_validator(type_:Type[T])->Callable[[Any], Type[T]]
pydantic.v1.validators.make_literal_validator(type_:Any)->Callable[[Any], Any]
pydantic.v1.validators.make_namedtuple_validator(namedtuple_cls:Type[NamedTupleT],config:Type['BaseConfig'])->Callable[[Tuple[Any, ...]], NamedTupleT]
pydantic.v1.validators.make_typeddict_validator(typeddict_cls:Type['TypedDict'],config:Type['BaseConfig'])->Callable[[Any], Dict[str, Any]]
pydantic.v1.validators.none_validator(v:Any)->'Literal[None]'
pydantic.v1.validators.number_multiple_validator(v:'Number',field:'ModelField')->'Number'
pydantic.v1.validators.number_size_validator(v:'Number',field:'ModelField')->'Number'
pydantic.v1.validators.ordered_dict_validator(v:Any)->'AnyOrderedDict'
pydantic.v1.validators.path_exists_validator(v:Any)->Path
pydantic.v1.validators.path_validator(v:Any)->Path
pydantic.v1.validators.pattern_validator(v:Any)->Pattern[str]
pydantic.v1.validators.set_validator(v:Any)->Set[Any]
pydantic.v1.validators.str_validator(v:Any)->Union[str]
pydantic.v1.validators.strict_bytes_validator(v:Any)->Union[bytes]
pydantic.v1.validators.strict_float_validator(v:Any)->float
pydantic.v1.validators.strict_int_validator(v:Any)->int
pydantic.v1.validators.strict_str_validator(v:Any)->Union[str]
pydantic.v1.validators.tuple_validator(v:Any)->Tuple[Any, ...]
pydantic.v1.validators.uuid_validator(v:Any,field:'ModelField')->UUID
pydantic.v1.validators.validate_json(v:Any,config:'BaseConfig')->Any


----------------------------------------/dataset/nuaa/anaconda3/envs/pydantic2.10.6/lib/python3.9/site-packages/pydantic/v1/networks.py----------------------------------------
A:pydantic.v1.networks._url_regex_cache->re.compile(f'{_scheme_regex}{_user_info_regex}{_host_regex}{_path_regex}{_query_regex}{_fragment_regex}', re.IGNORECASE)
A:pydantic.v1.networks._multi_host_url_regex_cache->re.compile(f'{_scheme_regex}{_user_info_regex}(?P<hosts>([^/]*)){_path_regex}{_query_regex}{_fragment_regex}', re.IGNORECASE)
A:pydantic.v1.networks._ascii_domain_regex_cache->re.compile(f'(?:{ascii_chunk}\\.)*?{ascii_chunk}{ascii_domain_ending}', re.IGNORECASE)
A:pydantic.v1.networks._int_domain_regex_cache->re.compile(f'(?:{int_chunk}\\.)*?{int_chunk}{int_domain_ending}', re.IGNORECASE)
A:pydantic.v1.networks._host_regex_cache->re.compile(_host_regex, re.IGNORECASE)
A:pydantic.v1.networks.parts->email_validator.validate_email(email, check_deliverability=False)
A:pydantic.v1.networks.value->str_validator(value)
A:pydantic.v1.networks.m->re.compile('([\\w ]*?) *<(.*)> *').fullmatch(value)
A:pydantic.v1.networks.original_parts->cast('Parts', m.groupdict())
A:pydantic.v1.networks.(host, tld, host_type, rebuild)->cls.validate_host(d)
A:pydantic.v1.networks.d->int_domain_regex().fullmatch(host)
A:pydantic.v1.networks.tld->tld.encode('idna').decode('ascii').encode('idna').decode('ascii')
A:pydantic.v1.networks.host->host.encode('idna').decode('ascii').encode('idna').decode('ascii')
A:pydantic.v1.networks.extra->', '.join((f'{n}={getattr(self, n)!r}' for n in self.__slots__ if getattr(self, n) is not None))
A:pydantic.v1.networks.host_re->host_regex()
A:pydantic.v1.networks.port->int_domain_regex().fullmatch(host).get('port')
A:pydantic.v1.networks.namespace->dict(strip_whitespace=strip_whitespace, min_length=min_length, max_length=max_length, tld_required=tld_required, host_required=host_required, allowed_schemes=allowed_schemes)
A:pydantic.v1.networks.pretty_email_regex->re.compile('([\\w ]*?) *<(.*)> *')
A:pydantic.v1.networks.(name, value)->re.compile('([\\w ]*?) *<(.*)> *').fullmatch(value).groups()
A:pydantic.v1.networks.email->str_validator(value).strip()
A:pydantic.v1.networks.at_index->str_validator(value).strip().index('@')
A:pydantic.v1.networks.global_part->email[at_index:].lower()
pydantic.v1.AmqpDsn(AnyUrl)
pydantic.v1.AnyHttpUrl(AnyUrl)
pydantic.v1.AnyUrl(self,url:str,*,scheme:str,user:Optional[str]=None,password:Optional[str]=None,host:Optional[str]=None,tld:Optional[str]=None,host_type:str='domain',port:Optional[str]=None,path:Optional[str]=None,query:Optional[str]=None,fragment:Optional[str]=None)
pydantic.v1.AnyUrl.__get_validators__(cls)->'CallableGenerator'
pydantic.v1.AnyUrl.__modify_schema__(cls,field_schema:Dict[str,Any])->None
pydantic.v1.AnyUrl.__repr__(self)->str
pydantic.v1.AnyUrl._build_url(cls,m:Match[str],url:str,parts:'Parts')->'AnyUrl'
pydantic.v1.AnyUrl._match_url(url:str)->Optional[Match[str]]
pydantic.v1.AnyUrl._validate_port(port:Optional[str])->None
pydantic.v1.AnyUrl.apply_default_parts(cls,parts:'Parts')->'Parts'
pydantic.v1.AnyUrl.build(cls,*,scheme:str,user:Optional[str]=None,password:Optional[str]=None,host:str,port:Optional[str]=None,path:Optional[str]=None,query:Optional[str]=None,fragment:Optional[str]=None,**_kwargs:str)->str
pydantic.v1.AnyUrl.get_default_parts(parts:'Parts')->'Parts'
pydantic.v1.AnyUrl.validate(cls,value:Any,field:'ModelField',config:'BaseConfig')->'AnyUrl'
pydantic.v1.AnyUrl.validate_host(cls,parts:'Parts')->Tuple[str, Optional[str], str, bool]
pydantic.v1.AnyUrl.validate_parts(cls,parts:'Parts',validate_port:bool=True)->'Parts'
pydantic.v1.CockroachDsn(AnyUrl)
pydantic.v1.EmailStr(str)
pydantic.v1.EmailStr.__get_validators__(cls)->'CallableGenerator'
pydantic.v1.EmailStr.__modify_schema__(cls,field_schema:Dict[str,Any])->None
pydantic.v1.EmailStr.validate(cls,value:Union[str])->str
pydantic.v1.FileUrl(AnyUrl)
pydantic.v1.HttpUrl(AnyHttpUrl)
pydantic.v1.HttpUrl.get_default_parts(parts:'Parts')->'Parts'
pydantic.v1.IPvAnyAddress(_BaseAddress)
pydantic.v1.IPvAnyAddress.__get_validators__(cls)->'CallableGenerator'
pydantic.v1.IPvAnyAddress.__modify_schema__(cls,field_schema:Dict[str,Any])->None
pydantic.v1.IPvAnyAddress.validate(cls,value:Union[str,bytes,int])->Union[IPv4Address, IPv6Address]
pydantic.v1.IPvAnyInterface(_BaseAddress)
pydantic.v1.IPvAnyInterface.__get_validators__(cls)->'CallableGenerator'
pydantic.v1.IPvAnyInterface.__modify_schema__(cls,field_schema:Dict[str,Any])->None
pydantic.v1.IPvAnyInterface.validate(cls,value:NetworkType)->Union[IPv4Interface, IPv6Interface]
pydantic.v1.IPvAnyNetwork(_BaseNetwork)
pydantic.v1.IPvAnyNetwork.__get_validators__(cls)->'CallableGenerator'
pydantic.v1.IPvAnyNetwork.__modify_schema__(cls,field_schema:Dict[str,Any])->None
pydantic.v1.IPvAnyNetwork.validate(cls,value:NetworkType)->Union[IPv4Network, IPv6Network]
pydantic.v1.KafkaDsn(AnyUrl)
pydantic.v1.KafkaDsn.get_default_parts(parts:'Parts')->'Parts'
pydantic.v1.MongoDsn(AnyUrl)
pydantic.v1.MongoDsn.get_default_parts(parts:'Parts')->'Parts'
pydantic.v1.MultiHostDsn(self,*args:Any,hosts:Optional[List['HostParts']]=None,**kwargs:Any)
pydantic.v1.MultiHostDsn._build_url(cls,m:Match[str],url:str,parts:'Parts')->'MultiHostDsn'
pydantic.v1.MultiHostDsn._match_url(url:str)->Optional[Match[str]]
pydantic.v1.MultiHostDsn.validate_parts(cls,parts:'Parts',validate_port:bool=True)->'Parts'
pydantic.v1.NameEmail(self,name:str,email:str)
pydantic.v1.NameEmail.__eq__(self,other:Any)->bool
pydantic.v1.NameEmail.__get_validators__(cls)->'CallableGenerator'
pydantic.v1.NameEmail.__modify_schema__(cls,field_schema:Dict[str,Any])->None
pydantic.v1.NameEmail.__str__(self)->str
pydantic.v1.NameEmail.validate(cls,value:Any)->'NameEmail'
pydantic.v1.PostgresDsn(MultiHostDsn)
pydantic.v1.RedisDsn(AnyUrl)
pydantic.v1.RedisDsn.get_default_parts(parts:'Parts')->'Parts'
pydantic.v1.ascii_domain_regex()->Pattern[str]
pydantic.v1.host_regex()->Pattern[str]
pydantic.v1.import_email_validator()->None
pydantic.v1.int_domain_regex()->Pattern[str]
pydantic.v1.multi_host_url_regex()->Pattern[str]
pydantic.v1.networks.AmqpDsn(AnyUrl)
pydantic.v1.networks.AnyHttpUrl(AnyUrl)
pydantic.v1.networks.AnyUrl(self,url:str,*,scheme:str,user:Optional[str]=None,password:Optional[str]=None,host:Optional[str]=None,tld:Optional[str]=None,host_type:str='domain',port:Optional[str]=None,path:Optional[str]=None,query:Optional[str]=None,fragment:Optional[str]=None)
pydantic.v1.networks.AnyUrl.__get_validators__(cls)->'CallableGenerator'
pydantic.v1.networks.AnyUrl.__init__(self,url:str,*,scheme:str,user:Optional[str]=None,password:Optional[str]=None,host:Optional[str]=None,tld:Optional[str]=None,host_type:str='domain',port:Optional[str]=None,path:Optional[str]=None,query:Optional[str]=None,fragment:Optional[str]=None)
pydantic.v1.networks.AnyUrl.__modify_schema__(cls,field_schema:Dict[str,Any])->None
pydantic.v1.networks.AnyUrl.__repr__(self)->str
pydantic.v1.networks.AnyUrl._build_url(cls,m:Match[str],url:str,parts:'Parts')->'AnyUrl'
pydantic.v1.networks.AnyUrl._match_url(url:str)->Optional[Match[str]]
pydantic.v1.networks.AnyUrl._validate_port(port:Optional[str])->None
pydantic.v1.networks.AnyUrl.apply_default_parts(cls,parts:'Parts')->'Parts'
pydantic.v1.networks.AnyUrl.build(cls,*,scheme:str,user:Optional[str]=None,password:Optional[str]=None,host:str,port:Optional[str]=None,path:Optional[str]=None,query:Optional[str]=None,fragment:Optional[str]=None,**_kwargs:str)->str
pydantic.v1.networks.AnyUrl.get_default_parts(parts:'Parts')->'Parts'
pydantic.v1.networks.AnyUrl.validate(cls,value:Any,field:'ModelField',config:'BaseConfig')->'AnyUrl'
pydantic.v1.networks.AnyUrl.validate_host(cls,parts:'Parts')->Tuple[str, Optional[str], str, bool]
pydantic.v1.networks.AnyUrl.validate_parts(cls,parts:'Parts',validate_port:bool=True)->'Parts'
pydantic.v1.networks.CockroachDsn(AnyUrl)
pydantic.v1.networks.EmailStr(str)
pydantic.v1.networks.EmailStr.__get_validators__(cls)->'CallableGenerator'
pydantic.v1.networks.EmailStr.__modify_schema__(cls,field_schema:Dict[str,Any])->None
pydantic.v1.networks.EmailStr.validate(cls,value:Union[str])->str
pydantic.v1.networks.FileUrl(AnyUrl)
pydantic.v1.networks.HttpUrl(AnyHttpUrl)
pydantic.v1.networks.HttpUrl.get_default_parts(parts:'Parts')->'Parts'
pydantic.v1.networks.IPvAnyAddress(_BaseAddress)
pydantic.v1.networks.IPvAnyAddress.__get_validators__(cls)->'CallableGenerator'
pydantic.v1.networks.IPvAnyAddress.__modify_schema__(cls,field_schema:Dict[str,Any])->None
pydantic.v1.networks.IPvAnyAddress.validate(cls,value:Union[str,bytes,int])->Union[IPv4Address, IPv6Address]
pydantic.v1.networks.IPvAnyInterface(_BaseAddress)
pydantic.v1.networks.IPvAnyInterface.__get_validators__(cls)->'CallableGenerator'
pydantic.v1.networks.IPvAnyInterface.__modify_schema__(cls,field_schema:Dict[str,Any])->None
pydantic.v1.networks.IPvAnyInterface.validate(cls,value:NetworkType)->Union[IPv4Interface, IPv6Interface]
pydantic.v1.networks.IPvAnyNetwork(_BaseNetwork)
pydantic.v1.networks.IPvAnyNetwork.__get_validators__(cls)->'CallableGenerator'
pydantic.v1.networks.IPvAnyNetwork.__modify_schema__(cls,field_schema:Dict[str,Any])->None
pydantic.v1.networks.IPvAnyNetwork.validate(cls,value:NetworkType)->Union[IPv4Network, IPv6Network]
pydantic.v1.networks.KafkaDsn(AnyUrl)
pydantic.v1.networks.KafkaDsn.get_default_parts(parts:'Parts')->'Parts'
pydantic.v1.networks.MongoDsn(AnyUrl)
pydantic.v1.networks.MongoDsn.get_default_parts(parts:'Parts')->'Parts'
pydantic.v1.networks.MultiHostDsn(self,*args:Any,hosts:Optional[List['HostParts']]=None,**kwargs:Any)
pydantic.v1.networks.MultiHostDsn.__init__(self,*args:Any,hosts:Optional[List['HostParts']]=None,**kwargs:Any)
pydantic.v1.networks.MultiHostDsn._build_url(cls,m:Match[str],url:str,parts:'Parts')->'MultiHostDsn'
pydantic.v1.networks.MultiHostDsn._match_url(url:str)->Optional[Match[str]]
pydantic.v1.networks.MultiHostDsn.validate_parts(cls,parts:'Parts',validate_port:bool=True)->'Parts'
pydantic.v1.networks.NameEmail(self,name:str,email:str)
pydantic.v1.networks.NameEmail.__eq__(self,other:Any)->bool
pydantic.v1.networks.NameEmail.__get_validators__(cls)->'CallableGenerator'
pydantic.v1.networks.NameEmail.__init__(self,name:str,email:str)
pydantic.v1.networks.NameEmail.__modify_schema__(cls,field_schema:Dict[str,Any])->None
pydantic.v1.networks.NameEmail.__str__(self)->str
pydantic.v1.networks.NameEmail.validate(cls,value:Any)->'NameEmail'
pydantic.v1.networks.PostgresDsn(MultiHostDsn)
pydantic.v1.networks.RedisDsn(AnyUrl)
pydantic.v1.networks.RedisDsn.get_default_parts(parts:'Parts')->'Parts'
pydantic.v1.networks.ascii_domain_regex()->Pattern[str]
pydantic.v1.networks.host_regex()->Pattern[str]
pydantic.v1.networks.import_email_validator()->None
pydantic.v1.networks.int_domain_regex()->Pattern[str]
pydantic.v1.networks.multi_host_url_regex()->Pattern[str]
pydantic.v1.networks.stricturl(*,strip_whitespace:bool=True,min_length:int=1,max_length:int=2**16,tld_required:bool=True,host_required:bool=True,allowed_schemes:Optional[Collection[str]]=None)->Type[AnyUrl]
pydantic.v1.networks.url_regex()->Pattern[str]
pydantic.v1.networks.validate_email(value:Union[str])->Tuple[str, str]
pydantic.v1.stricturl(*,strip_whitespace:bool=True,min_length:int=1,max_length:int=2**16,tld_required:bool=True,host_required:bool=True,allowed_schemes:Optional[Collection[str]]=None)->Type[AnyUrl]
pydantic.v1.url_regex()->Pattern[str]
pydantic.v1.validate_email(value:Union[str])->Tuple[str, str]


----------------------------------------/dataset/nuaa/anaconda3/envs/pydantic2.10.6/lib/python3.9/site-packages/pydantic/v1/datetime_parse.py----------------------------------------
A:pydantic.v1.datetime_parse.date_re->re.compile(f'{date_expr}$')
A:pydantic.v1.datetime_parse.time_re->re.compile(time_expr)
A:pydantic.v1.datetime_parse.datetime_re->re.compile(f'{date_expr}[T ]{time_expr}')
A:pydantic.v1.datetime_parse.standard_duration_re->re.compile('^(?:(?P<days>-?\\d+) (days?, )?)?((?:(?P<hours>-?\\d+):)(?=\\d+:\\d+))?(?:(?P<minutes>-?\\d+):)?(?P<seconds>-?\\d+)(?:\\.(?P<microseconds>\\d{1,6})\\d{0,6})?$')
A:pydantic.v1.datetime_parse.iso8601_duration_re->re.compile('^(?P<sign>[-+]?)P(?:(?P<days>\\d+(.\\d+)?)D)?(?:T(?:(?P<hours>\\d+(.\\d+)?)H)?(?:(?P<minutes>\\d+(.\\d+)?)M)?(?:(?P<seconds>\\d+(.\\d+)?)S)?)?$')
A:pydantic.v1.datetime_parse.EPOCH->datetime(1970, 1, 1)
A:pydantic.v1.datetime_parse.MS_WATERSHED->int(20000000000.0)
A:pydantic.v1.datetime_parse.MAX_NUMBER->int(3e+20)
A:pydantic.v1.datetime_parse.number->get_numeric(value, 'datetime')
A:pydantic.v1.datetime_parse.value->value.decode().decode()
A:pydantic.v1.datetime_parse.match->re.compile(f'{date_expr}[T ]{time_expr}').match(value)
A:pydantic.v1.datetime_parse.kw->re.compile(f'{date_expr}[T ]{time_expr}').match(value).groupdict()
A:pydantic.v1.datetime_parse.kw['microsecond']->kw['microsecond'].ljust(6, '0').ljust(6, '0')
A:pydantic.v1.datetime_parse.tzinfo->_parse_timezone(kw.pop('tzinfo'), errors.DateTimeError)
A:pydantic.v1.datetime_parse.kw['microseconds']->kw['microseconds'].ljust(6, '0').ljust(6, '0')
pydantic.v1.datetime_parse._parse_timezone(value:Optional[str],error:Type[Exception])->Union[None, int, timezone]
pydantic.v1.datetime_parse.from_unix_seconds(seconds:Union[int,float])->datetime
pydantic.v1.datetime_parse.get_numeric(value:StrBytesIntFloat,native_expected_type:str)->Union[None, int, float]
pydantic.v1.datetime_parse.parse_date(value:Union[date,StrBytesIntFloat])->date
pydantic.v1.datetime_parse.parse_datetime(value:Union[datetime,StrBytesIntFloat])->datetime
pydantic.v1.datetime_parse.parse_duration(value:StrBytesIntFloat)->timedelta
pydantic.v1.datetime_parse.parse_time(value:Union[time,StrBytesIntFloat])->time


----------------------------------------/dataset/nuaa/anaconda3/envs/pydantic2.10.6/lib/python3.9/site-packages/pydantic/v1/utils.py----------------------------------------
A:pydantic.v1.utils.(module_path, class_name)->dotted_path.strip(' ').rsplit('.', 1)
A:pydantic.v1.utils.module->import_module(module_path)
A:pydantic.v1.utils.v->v.__class__.__repr__(v).__class__.__repr__(v)
A:pydantic.v1.utils.KeyType->TypeVar('KeyType')
A:pydantic.v1.utils.updated_mapping->mapping.copy()
A:pydantic.v1.utils.updated_mapping[k]->deep_update(updated_mapping[k], v)
A:pydantic.v1.utils.present_params->signature(init).parameters.values()
A:pydantic.v1.utils.merged_params[param_name]->Parameter(param_name, Parameter.KEYWORD_ONLY, annotation=field.annotation, **kwargs)
A:pydantic.v1.utils.merged_params[var_kw_name]->var_kw.replace(name=var_kw_name)
A:pydantic.v1.utils.pascal_string->to_camel(string)
A:pydantic.v1.utils.T->TypeVar('T')
A:pydantic.v1.utils.v_name->name_factory(v)
A:pydantic.v1.utils.items->dict.fromkeys(items, ...)
A:pydantic.v1.utils.item->self._items.get(e)
A:pydantic.v1.utils.all_items->self._coerce_value(v)
A:pydantic.v1.utils.normalized_items[normalized_i]->self.merge(v, normalized_items.get(normalized_i))
A:pydantic.v1.utils.normalized_item->normalized_items.setdefault(i, {})
A:pydantic.v1.utils.normalized_items[i]->self.merge(all_items, normalized_item)
A:pydantic.v1.utils.override->cls._coerce_value(override)
A:pydantic.v1.utils.base->cls._coerce_value(base)
A:pydantic.v1.utils.merged_item->cls.merge(base.get(k), override.get(k), intersect=intersect)
A:pydantic.v1.utils.class_name->getattr(items, '__class__', '???')
A:pydantic.v1.utils.Obj->TypeVar('Obj')
A:pydantic.v1.utils._EMPTY->object()
A:pydantic.v1.utils.unique_aliases->set(all_aliases)
A:pydantic.v1.utils.is_root_model->getattr(tp, '__custom_root_type__', False)
A:pydantic.v1.utils.(alias, all_values)->_get_union_alias_and_all_values(union_type, discriminator_key)
A:pydantic.v1.utils.(all_aliases, all_values)->zip(*zipped_aliases_values)
pydantic.v1.utils.ClassAttribute(self,name:str,value:Any)
pydantic.v1.utils.ClassAttribute.__get__(self,instance:Any,owner:Type[Any])->None
pydantic.v1.utils.ClassAttribute.__init__(self,name:str,value:Any)
pydantic.v1.utils.GetterDict(self,obj:Any)
pydantic.v1.utils.GetterDict.__contains__(self,item:Any)->bool
pydantic.v1.utils.GetterDict.__eq__(self,other:Any)->bool
pydantic.v1.utils.GetterDict.__getitem__(self,key:str)->Any
pydantic.v1.utils.GetterDict.__init__(self,obj:Any)
pydantic.v1.utils.GetterDict.__iter__(self)->Iterator[str]
pydantic.v1.utils.GetterDict.__len__(self)->int
pydantic.v1.utils.GetterDict.__repr_args__(self)->'ReprArgs'
pydantic.v1.utils.GetterDict.__repr_name__(self)->str
pydantic.v1.utils.GetterDict.extra_keys(self)->Set[Any]
pydantic.v1.utils.GetterDict.get(self,key:Any,default:Any=None)->Any
pydantic.v1.utils.GetterDict.items(self)->Iterator[Tuple[str, Any]]
pydantic.v1.utils.GetterDict.keys(self)->List[Any]
pydantic.v1.utils.GetterDict.values(self)->List[Any]
pydantic.v1.utils.PyObjectStr(str)
pydantic.v1.utils.PyObjectStr.__repr__(self)->str
pydantic.v1.utils.Representation
pydantic.v1.utils.Representation.__pretty__(self,fmt:Callable[[Any],Any],**kwargs:Any)->Generator[Any, None, None]
pydantic.v1.utils.Representation.__repr__(self)->str
pydantic.v1.utils.Representation.__repr_args__(self)->'ReprArgs'
pydantic.v1.utils.Representation.__repr_name__(self)->str
pydantic.v1.utils.Representation.__repr_str__(self,join_str:str)->str
pydantic.v1.utils.Representation.__rich_repr__(self)->'RichReprResult'
pydantic.v1.utils.Representation.__str__(self)->str
pydantic.v1.utils.ValueItems(self,value:Any,items:Union['AbstractSetIntStr','MappingIntStrAny'])
pydantic.v1.utils.ValueItems.__init__(self,value:Any,items:Union['AbstractSetIntStr','MappingIntStrAny'])
pydantic.v1.utils.ValueItems.__repr_args__(self)->'ReprArgs'
pydantic.v1.utils.ValueItems._coerce_items(items:Union['AbstractSetIntStr','MappingIntStrAny'])->'MappingIntStrAny'
pydantic.v1.utils.ValueItems._coerce_value(cls,value:Any)->Any
pydantic.v1.utils.ValueItems._normalize_indexes(self,items:'MappingIntStrAny',v_length:int)->'DictIntStrAny'
pydantic.v1.utils.ValueItems.for_element(self,e:'IntStr')->Optional[Union['AbstractSetIntStr', 'MappingIntStrAny']]
pydantic.v1.utils.ValueItems.is_excluded(self,item:Any)->bool
pydantic.v1.utils.ValueItems.is_included(self,item:Any)->bool
pydantic.v1.utils.ValueItems.is_true(v:Any)->bool
pydantic.v1.utils.ValueItems.merge(cls,base:Any,override:Any,intersect:bool=False)->Any
pydantic.v1.utils._get_union_alias_and_all_values(union_type:Type[Any],discriminator_key:str)->Tuple[str, Tuple[Tuple[str, ...], ...]]
pydantic.v1.utils.all_identical(left:Iterable[Any],right:Iterable[Any])->bool
pydantic.v1.utils.almost_equal_floats(value_1:float,value_2:float,*,delta:float=1e-08)->bool
pydantic.v1.utils.assert_never(obj:NoReturn,msg:str)->NoReturn
pydantic.v1.utils.deep_update(mapping:Dict[KeyType,Any],*updating_mappings:Dict[KeyType,Any])->Dict[KeyType, Any]
pydantic.v1.utils.generate_model_signature(init:Callable[...,None],fields:Dict[str,'ModelField'],config:Type['BaseConfig'])->'Signature'
pydantic.v1.utils.get_discriminator_alias_and_values(tp:Any,discriminator_key:str)->Tuple[str, Tuple[str, ...]]
pydantic.v1.utils.get_model(obj:Union[Type['BaseModel'],Type['Dataclass']])->Type['BaseModel']
pydantic.v1.utils.get_unique_discriminator_alias(all_aliases:Collection[str],discriminator_key:str)->str
pydantic.v1.utils.import_string(dotted_path:str)->Any
pydantic.v1.utils.in_ipython()->bool
pydantic.v1.utils.is_valid_field(name:str)->bool
pydantic.v1.utils.is_valid_identifier(identifier:str)->bool
pydantic.v1.utils.is_valid_private_name(name:str)->bool
pydantic.v1.utils.lenient_isinstance(o:Any,class_or_tuple:Union[Type[Any],Tuple[Type[Any],...],None])->bool
pydantic.v1.utils.lenient_issubclass(cls:Any,class_or_tuple:Union[Type[Any],Tuple[Type[Any],...],None])->bool
pydantic.v1.utils.path_type(p:'Path')->str
pydantic.v1.utils.sequence_like(v:Any)->bool
pydantic.v1.utils.smart_deepcopy(obj:Obj)->Obj
pydantic.v1.utils.to_camel(string:str)->str
pydantic.v1.utils.to_lower_camel(string:str)->str
pydantic.v1.utils.truncate(v:Union[str],*,max_len:int=80)->str
pydantic.v1.utils.unique_list(input_list:Union[List[T],Tuple[T,...]],*,name_factory:Callable[[T],str]=str)->List[T]
pydantic.v1.utils.update_not_none(mapping:Dict[Any,Any],**update:Any)->None
pydantic.v1.utils.validate_field_name(bases:List[Type['BaseModel']],field_name:str)->None


----------------------------------------/dataset/nuaa/anaconda3/envs/pydantic2.10.6/lib/python3.9/site-packages/pydantic/v1/color.py----------------------------------------
A:pydantic.v1.color.self._rgba->parse_str(value)
A:pydantic.v1.color.rgb->cast(Tuple[int, int, int], self.as_rgb_tuple())
A:pydantic.v1.color.as_hex->''.join((as_hex[c] for c in range(0, len(as_hex), 2)))
A:pydantic.v1.color.(h, s, li)->self.as_hsl_tuple(alpha=False)
A:pydantic.v1.color.(h, s, li, a)->self.as_hsl_tuple(alpha=True)
A:pydantic.v1.color.(h, l, s)->rgb_to_hls(self._rgba.r, self._rgba.g, self._rgba.b)
A:pydantic.v1.color.value_lower->value.lower()
A:pydantic.v1.color.m->re.fullmatch(r_hsla, value_lower)
A:pydantic.v1.color.(*rgb, a)->re.fullmatch(r_hsla, value_lower).groups()
A:pydantic.v1.color.(h, h_units, s, l_)->re.fullmatch(r_hsla, value_lower).groups()
A:pydantic.v1.color.(h, h_units, s, l_, a)->re.fullmatch(r_hsla, value_lower).groups()
A:pydantic.v1.color.color->float(value)
A:pydantic.v1.color.alpha->float(value)
A:pydantic.v1.color.h_value->float(h)
A:pydantic.v1.color.(r, g, b)->hls_to_rgb(h_value, l_value, s_value)
pydantic.v1.color.Color(self,value:ColorType)
pydantic.v1.color.Color.__eq__(self,other:Any)->bool
pydantic.v1.color.Color.__get_validators__(cls)->'CallableGenerator'
pydantic.v1.color.Color.__hash__(self)->int
pydantic.v1.color.Color.__init__(self,value:ColorType)
pydantic.v1.color.Color.__modify_schema__(cls,field_schema:Dict[str,Any])->None
pydantic.v1.color.Color.__repr_args__(self)->'ReprArgs'
pydantic.v1.color.Color.__str__(self)->str
pydantic.v1.color.Color._alpha_float(self)->float
pydantic.v1.color.Color.as_hex(self)->str
pydantic.v1.color.Color.as_hsl(self)->str
pydantic.v1.color.Color.as_hsl_tuple(self,*,alpha:Optional[bool]=None)->HslColorTuple
pydantic.v1.color.Color.as_named(self,*,fallback:bool=False)->str
pydantic.v1.color.Color.as_rgb(self)->str
pydantic.v1.color.Color.as_rgb_tuple(self,*,alpha:Optional[bool]=None)->ColorTuple
pydantic.v1.color.Color.original(self)->ColorType
pydantic.v1.color.RGBA(self,r:float,g:float,b:float,alpha:Optional[float])
pydantic.v1.color.RGBA.__getitem__(self,item:Any)->Any
pydantic.v1.color.RGBA.__init__(self,r:float,g:float,b:float,alpha:Optional[float])
pydantic.v1.color.float_to_255(c:float)->int
pydantic.v1.color.ints_to_rgba(r:Union[int,str],g:Union[int,str],b:Union[int,str],alpha:Optional[float])->RGBA
pydantic.v1.color.parse_color_value(value:Union[int,str],max_val:int=255)->float
pydantic.v1.color.parse_float_alpha(value:Union[None,str,float,int])->Optional[float]
pydantic.v1.color.parse_hsl(h:str,h_units:str,sat:str,light:str,alpha:Optional[float]=None)->RGBA
pydantic.v1.color.parse_str(value:str)->RGBA
pydantic.v1.color.parse_tuple(value:Tuple[Any,...])->RGBA


----------------------------------------/dataset/nuaa/anaconda3/envs/pydantic2.10.6/lib/python3.9/site-packages/pydantic/v1/schema.py----------------------------------------
A:pydantic.v1.schema.sig->signature(modify_schema)
A:pydantic.v1.schema.args->get_args(field_type)
A:pydantic.v1.schema.flat_models->get_flat_models_from_model(model)
A:pydantic.v1.schema.model_name_map->get_model_name_map(flat_models)
A:pydantic.v1.schema.(m_schema, m_definitions, m_nested_models)->model_process_schema(model, by_alias=by_alias, model_name_map=model_name_map, ref_prefix=ref_prefix, ref_template=ref_template)
A:pydantic.v1.schema.model->cast(Type['BaseModel'], model)
A:pydantic.v1.schema.(m_schema, m_definitions, nested_models)->model_type_schema(model, by_alias=by_alias, model_name_map=model_name_map, ref_prefix=ref_prefix, ref_template=ref_template, known_models=known_models)
A:pydantic.v1.schema.m_schema->get_schema_ref(model_name, ref_prefix, ref_template, False)
A:pydantic.v1.schema.schema_['default']->encode_default(field.default)
A:pydantic.v1.schema.(s, schema_overrides)->get_field_info_schema(field)
A:pydantic.v1.schema.validation_schema->get_field_schema_validations(field)
A:pydantic.v1.schema.(f_schema, f_definitions, f_nested_models)->field_schema(f, by_alias=by_alias, model_name_map=model_name_map, ref_prefix=ref_prefix, ref_template=ref_template, known_models=known_models)
A:pydantic.v1.schema.attr->getattr(field.field_info, attr_name, None)
A:pydantic.v1.schema.modify_schema->getattr(field_type, '__modify_schema__', None)
A:pydantic.v1.schema.model_name->get_long_model_name(model)
A:pydantic.v1.schema.conflicting_model->name_model_map.pop(model_name)
A:pydantic.v1.schema.fields->cast(Sequence[ModelField], model.__fields__.values())
A:pydantic.v1.schema.(items_schema, f_definitions, f_nested_models)->field_singleton_schema(field, by_alias=by_alias, model_name_map=model_name_map, ref_prefix=ref_prefix, ref_template=ref_template, known_models=known_models)
A:pydantic.v1.schema.key_field->cast(ModelField, field.key_field)
A:pydantic.v1.schema.regex->getattr(key_field.type_, 'regex', None)
A:pydantic.v1.schema.sub_fields->cast(List[ModelField], field.sub_fields)
A:pydantic.v1.schema.(sf_schema, sf_definitions, sf_nested_models)->field_type_schema(sf, by_alias=by_alias, model_name_map=model_name_map, ref_prefix=ref_prefix, ref_template=ref_template, known_models=known_models)
A:pydantic.v1.schema.sub_fields_len->len(sub_fields)
A:pydantic.v1.schema.s->enum_process_schema(model, field=field)
A:pydantic.v1.schema.doc->getdoc(model)
A:pydantic.v1.schema.discriminator_value->str(discriminator_value.value)
A:pydantic.v1.schema.sub_models->get_sub_types(sub_field.type_)
A:pydantic.v1.schema.discriminator_model_ref->get_schema_ref(discriminator_model_name, ref_prefix, ref_template, False)
A:pydantic.v1.schema.(sub_schema, sub_definitions, sub_nested_models)->model_process_schema(field_type, by_alias=by_alias, model_name_map=model_name_map, ref_prefix=ref_prefix, ref_template=ref_template, known_models=known_models, field=field)
A:pydantic.v1.schema.values->tuple((x.value if isinstance(x, Enum) else x for x in all_literal_values(field_type)))
A:pydantic.v1.schema.f_schema['enum']->list(values)
A:pydantic.v1.schema.(f_schema, schema_overrides)->get_field_info_schema(field, schema_overrides)
A:pydantic.v1.schema.definitions[enum_name]->enum_process_schema(field_type, field=field)
A:pydantic.v1.schema.(sub_schema, *_)->model_process_schema(field_type.__pydantic_model__, by_alias=by_alias, model_name_map=model_name_map, ref_prefix=ref_prefix, ref_template=ref_template, known_models=known_models, field=field)
A:pydantic.v1.schema.items_schemas->list(sub_schema['properties'].values())
A:pydantic.v1.schema.schema_ref->get_schema_ref(model_name, ref_prefix, ref_template, schema_overrides)
A:pydantic.v1.schema.literal_distinct_types->defaultdict(list)
A:pydantic.v1.schema.dft->cast('dict[str, Any]', pydantic_encoder(dft))
A:pydantic.v1.schema.constraints->field_info.get_constraints()
A:pydantic.v1.schema.(annotation, used_constraints)->get_annotation_with_constraints(annotation, field_info)
A:pydantic.v1.schema.origin->get_origin(type_)
A:pydantic.v1.schema.numeric_type->next((t for t in numeric_types if issubclass(type_, t)))
A:pydantic.v1.schema.constraint_func->cast(Callable[..., type], constraint_func)
pydantic.v1.schema.SkipField(self,message:str)
pydantic.v1.schema.SkipField.__init__(self,message:str)
pydantic.v1.schema._apply_modify_schema(modify_schema:Callable[...,None],field:Optional[ModelField],field_schema:Dict[str,Any])->None
pydantic.v1.schema.add_field_type_to_schema(field_type:Any,schema_:Dict[str,Any])->None
pydantic.v1.schema.encode_default(dft:Any)->Any
pydantic.v1.schema.enum_process_schema(enum:Type[Enum],*,field:Optional[ModelField]=None)->Dict[str, Any]
pydantic.v1.schema.field_schema(field:ModelField,*,by_alias:bool=True,model_name_map:Dict[TypeModelOrEnum,str],ref_prefix:Optional[str]=None,ref_template:str=default_ref_template,known_models:Optional[TypeModelSet]=None)->Tuple[Dict[str, Any], Dict[str, Any], Set[str]]
pydantic.v1.schema.field_singleton_schema(field:ModelField,*,by_alias:bool,model_name_map:Dict[TypeModelOrEnum,str],ref_template:str,schema_overrides:bool=False,ref_prefix:Optional[str]=None,known_models:TypeModelSet)->Tuple[Dict[str, Any], Dict[str, Any], Set[str]]
pydantic.v1.schema.field_singleton_sub_fields_schema(field:ModelField,*,by_alias:bool,model_name_map:Dict[TypeModelOrEnum,str],ref_template:str,schema_overrides:bool=False,ref_prefix:Optional[str]=None,known_models:TypeModelSet)->Tuple[Dict[str, Any], Dict[str, Any], Set[str]]
pydantic.v1.schema.field_type_schema(field:ModelField,*,by_alias:bool,model_name_map:Dict[TypeModelOrEnum,str],ref_template:str,schema_overrides:bool=False,ref_prefix:Optional[str]=None,known_models:TypeModelSet)->Tuple[Dict[str, Any], Dict[str, Any], Set[str]]
pydantic.v1.schema.get_annotation_from_field_info(annotation:Any,field_info:FieldInfo,field_name:str,validate_assignment:bool=False)->Type[Any]
pydantic.v1.schema.get_annotation_with_constraints(annotation:Any,field_info:FieldInfo)->Tuple[Type[Any], Set[str]]
pydantic.v1.schema.get_field_info_schema(field:ModelField,schema_overrides:bool=False)->Tuple[Dict[str, Any], bool]
pydantic.v1.schema.get_field_schema_validations(field:ModelField)->Dict[str, Any]
pydantic.v1.schema.get_flat_models_from_field(field:ModelField,known_models:TypeModelSet)->TypeModelSet
pydantic.v1.schema.get_flat_models_from_fields(fields:Sequence[ModelField],known_models:TypeModelSet)->TypeModelSet
pydantic.v1.schema.get_flat_models_from_model(model:Type['BaseModel'],known_models:Optional[TypeModelSet]=None)->TypeModelSet
pydantic.v1.schema.get_flat_models_from_models(models:Sequence[Type['BaseModel']])->TypeModelSet
pydantic.v1.schema.get_long_model_name(model:TypeModelOrEnum)->str
pydantic.v1.schema.get_model_name_map(unique_models:TypeModelSet)->Dict[TypeModelOrEnum, str]
pydantic.v1.schema.get_schema_ref(name:str,ref_prefix:Optional[str],ref_template:str,schema_overrides:bool)->Dict[str, Any]
pydantic.v1.schema.model_process_schema(model:TypeModelOrEnum,*,by_alias:bool=True,model_name_map:Dict[TypeModelOrEnum,str],ref_prefix:Optional[str]=None,ref_template:str=default_ref_template,known_models:Optional[TypeModelSet]=None,field:Optional[ModelField]=None)->Tuple[Dict[str, Any], Dict[str, Any], Set[str]]
pydantic.v1.schema.model_schema(model:Union[Type['BaseModel'],Type['Dataclass']],by_alias:bool=True,ref_prefix:Optional[str]=None,ref_template:str=default_ref_template)->Dict[str, Any]
pydantic.v1.schema.model_type_schema(model:Type['BaseModel'],*,by_alias:bool,model_name_map:Dict[TypeModelOrEnum,str],ref_template:str,ref_prefix:Optional[str]=None,known_models:TypeModelSet)->Tuple[Dict[str, Any], Dict[str, Any], Set[str]]
pydantic.v1.schema.multitypes_literal_field_for_schema(values:Tuple[Any,...],field:ModelField)->ModelField
pydantic.v1.schema.normalize_name(name:str)->str
pydantic.v1.schema.schema(models:Sequence[Union[Type['BaseModel'],Type['Dataclass']]],*,by_alias:bool=True,title:Optional[str]=None,description:Optional[str]=None,ref_prefix:Optional[str]=None,ref_template:str=default_ref_template)->Dict[str, Any]


----------------------------------------/dataset/nuaa/anaconda3/envs/pydantic2.10.6/lib/python3.9/site-packages/pydantic/v1/version.py----------------------------------------
pydantic.v1.version.version_info()->str


----------------------------------------/dataset/nuaa/anaconda3/envs/pydantic2.10.6/lib/python3.9/site-packages/pydantic/v1/class_validators.py----------------------------------------
A:pydantic.v1.class_validators.f_cls->_prepare_validator(f, allow_reuse)
A:pydantic.v1.class_validators.validators->self.validators.get(name, [])
A:pydantic.v1.class_validators.unused_validators->set(chain.from_iterable(((getattr(v.func, '__name__', f'<No __name__: id:{id(v.func)}>') for v in self.validators[f] if v.check_fields) for f in self.validators.keys() - self.used_validators)))
A:pydantic.v1.class_validators.fn->', '.join(unused_validators)
A:pydantic.v1.class_validators.validator_config->getattr(value, VALIDATOR_CONFIG_KEY, None)
A:pydantic.v1.class_validators.sig->signature(validator.func)
A:pydantic.v1.class_validators.args->list(sig.parameters.keys())
A:pydantic.v1.class_validators.first_arg->list(sig.parameters.keys()).pop(0)
A:pydantic.v1.class_validators.all_attributes->ChainMap(*[cls.__dict__ for cls in type_.__mro__])
pydantic.v1.class_validators.Validator(self,func:AnyCallable,pre:bool=False,each_item:bool=False,always:bool=False,check_fields:bool=False,skip_on_failure:bool=False)
pydantic.v1.class_validators.Validator.__init__(self,func:AnyCallable,pre:bool=False,each_item:bool=False,always:bool=False,check_fields:bool=False,skip_on_failure:bool=False)
pydantic.v1.class_validators.ValidatorGroup(self,validators:'ValidatorListDict')
pydantic.v1.class_validators.ValidatorGroup.__init__(self,validators:'ValidatorListDict')
pydantic.v1.class_validators.ValidatorGroup.check_for_unused(self)->None
pydantic.v1.class_validators.ValidatorGroup.get_validators(self,name:str)->Optional[Dict[str, Validator]]
pydantic.v1.class_validators._generic_validator_basic(validator:AnyCallable,sig:'Signature',args:Set[str])->'ValidatorCallable'
pydantic.v1.class_validators._generic_validator_cls(validator:AnyCallable,sig:'Signature',args:Set[str])->'ValidatorCallable'
pydantic.v1.class_validators._prepare_validator(function:AnyCallable,allow_reuse:bool)->'AnyClassMethod'
pydantic.v1.class_validators.extract_root_validators(namespace:Dict[str,Any])->Tuple[List[AnyCallable], List[Tuple[bool, AnyCallable]]]
pydantic.v1.class_validators.extract_validators(namespace:Dict[str,Any])->Dict[str, List[Validator]]
pydantic.v1.class_validators.gather_all_validators(type_:'ModelOrDc')->Dict[str, 'AnyClassMethod']
pydantic.v1.class_validators.inherit_validators(base_validators:'ValidatorListDict',validators:'ValidatorListDict')->'ValidatorListDict'
pydantic.v1.class_validators.make_generic_validator(validator:AnyCallable)->'ValidatorCallable'
pydantic.v1.class_validators.prep_validators(v_funcs:Iterable[AnyCallable])->'ValidatorsList'
pydantic.v1.class_validators.root_validator(_func:Optional[AnyCallable]=None,*,pre:bool=False,allow_reuse:bool=False,skip_on_failure:bool=False)->Union['AnyClassMethod', Callable[[AnyCallable], 'AnyClassMethod']]
pydantic.v1.class_validators.validator(*fields:str,pre:bool=False,each_item:bool=False,always:bool=False,check_fields:bool=True,whole:Optional[bool]=None,allow_reuse:bool=False)->Callable[[AnyCallable], 'AnyClassMethod']
pydantic.v1.root_validator(_func:Optional[AnyCallable]=None,*,pre:bool=False,allow_reuse:bool=False,skip_on_failure:bool=False)->Union['AnyClassMethod', Callable[[AnyCallable], 'AnyClassMethod']]
pydantic.v1.validator(*fields:str,pre:bool=False,each_item:bool=False,always:bool=False,check_fields:bool=True,whole:Optional[bool]=None,allow_reuse:bool=False)->Callable[[AnyCallable], 'AnyClassMethod']


----------------------------------------/dataset/nuaa/anaconda3/envs/pydantic2.10.6/lib/python3.9/site-packages/pydantic/v1/annotated_types.py----------------------------------------
pydantic.v1.annotated_types.create_model_from_namedtuple(namedtuple_cls:Type['NamedTuple'],**kwargs:Any)->Type['BaseModel']
pydantic.v1.annotated_types.create_model_from_typeddict(typeddict_cls:Type['TypedDict'],**kwargs:Any)->Type['BaseModel']
pydantic.v1.create_model_from_namedtuple(namedtuple_cls:Type['NamedTuple'],**kwargs:Any)->Type['BaseModel']
pydantic.v1.create_model_from_typeddict(typeddict_cls:Type['TypedDict'],**kwargs:Any)->Type['BaseModel']


----------------------------------------/dataset/nuaa/anaconda3/envs/pydantic2.10.6/lib/python3.9/site-packages/pydantic/v1/config.py----------------------------------------
A:pydantic.v1.config.fields_value->cls.fields.get(name)
A:pydantic.v1.config.alias->cls.alias_generator(name)
A:pydantic.v1.config.config.extra->Extra(config.extra)
pydantic.v1.BaseConfig
pydantic.v1.BaseConfig.get_field_info(cls,name:str)->Dict[str, Any]
pydantic.v1.BaseConfig.prepare_field(cls,field:'ModelField')->None
pydantic.v1.Extra(str,Enum)
pydantic.v1.config.BaseConfig
pydantic.v1.config.BaseConfig.get_field_info(cls,name:str)->Dict[str, Any]
pydantic.v1.config.BaseConfig.prepare_field(cls,field:'ModelField')->None
pydantic.v1.config.Extra(str,Enum)
pydantic.v1.config.get_config(config:Union[ConfigDict,Type[object],None])->Type[BaseConfig]
pydantic.v1.config.inherit_config(self_config:'ConfigType',parent_config:'ConfigType',**namespace:Any)->'ConfigType'
pydantic.v1.config.prepare_config(config:Type[BaseConfig],cls_name:str)->None


----------------------------------------/dataset/nuaa/anaconda3/envs/pydantic2.10.6/lib/python3.9/site-packages/pydantic/v1/generics.py----------------------------------------
A:pydantic.v1.generics.GenericModelT->TypeVar('GenericModelT', bound='GenericModel')
A:pydantic.v1.generics._generic_types_cache->GenericTypesCache()
A:pydantic.v1.generics._assigned_parameters->AssignedParameters()
A:pydantic.v1.generics.args->get_args(v)
A:pydantic.v1.generics.cached->GenericTypesCache().get(_cache_key(params))
A:pydantic.v1.generics.model_name->cls.__concrete_name__(params)
A:pydantic.v1.generics.validators->gather_all_validators(cls)
A:pydantic.v1.generics.type_hints->get_all_type_hints(cls).items()
A:pydantic.v1.generics.(model_module, called_globally)->get_caller_frame_info()
A:pydantic.v1.generics.created_model->cast(Type[GenericModel], create_model(model_name, __module__=model_module or cls.__module__, __base__=(cls,) + tuple(cls.__parameterized_bases__(typevars_map)), __config__=None, __validators__=validators, __cls_kwargs__=None, **fields))
A:pydantic.v1.generics.object_by_reference->reference_module_globals.setdefault(reference_name, created_model)
A:pydantic.v1.generics.new_params->tuple({param: None for param in iter_contained_typevars(typevars_map.values())})
A:pydantic.v1.generics.params_component->', '.join(param_names)
A:pydantic.v1.generics.base_parameters->tuple((mapped_types[param] for param in base_model.__parameters__))
A:pydantic.v1.generics.parameterized_base->base_model.__class_getitem__(base_parameters)
A:pydantic.v1.generics.type_args->get_args(type_)
A:pydantic.v1.generics.origin_type->getattr(typing, type_._name)
A:pydantic.v1.generics.resolved_type_args->tuple((replace_types(t, type_map) for t in type_args))
A:pydantic.v1.generics.resolved_list->list((replace_types(element, type_map) for element in type_))
A:pydantic.v1.generics.type_.inner_type->replace_types(type_.inner_type, type_map)
A:pydantic.v1.generics.new_type->type_map.get(type_, type_)
A:pydantic.v1.generics.actual->len(parameters)
A:pydantic.v1.generics.expected->len(cls.__parameters__)
A:pydantic.v1.generics.previous_caller_frame->sys._getframe(2)
A:pydantic.v1.generics.concrete_type->replace_types(field_type_hint, typevars_map)
pydantic.v1.generics.GenericModel(BaseModel)
pydantic.v1.generics.GenericModel.__class_getitem__(cls:Type[GenericModelT],params:Union[Type[Any],Tuple[Type[Any],...]])->Type[Any]
pydantic.v1.generics.GenericModel.__concrete_name__(cls:Type[Any],params:Tuple[Type[Any],...])->str
pydantic.v1.generics.GenericModel.__parameterized_bases__(cls,typevars_map:Parametrization)->Iterator[Type[Any]]
pydantic.v1.generics._prepare_model_fields(created_model:Type[GenericModel],fields:Mapping[str,Any],instance_type_hints:Mapping[str,type],typevars_map:Mapping[Any,type])->None
pydantic.v1.generics.check_parameters_count(cls:Type[GenericModel],parameters:Tuple[Any,...])->None
pydantic.v1.generics.get_caller_frame_info()->Tuple[Optional[str], bool]
pydantic.v1.generics.iter_contained_typevars(v:Any)->Iterator[TypeVarType]
pydantic.v1.generics.replace_types(type_:Any,type_map:Mapping[Any,Any])->Any


----------------------------------------/dataset/nuaa/anaconda3/envs/pydantic2.10.6/lib/python3.9/site-packages/pydantic/v1/_hypothesis_plugin.py----------------------------------------
A:pydantic.v1._hypothesis_plugin._color_regexes->'|'.join((pydantic.color.r_hex_short, pydantic.color.r_hex_long, pydantic.color.r_rgb, pydantic.color.r_rgba, pydantic.color.r_hsl, pydantic.color.r_hsla)).replace(pydantic.color._r_sl, '(?:(\\d\\d?(?:\\.\\d+)?|100(?:\\.0+)?)%)').replace(pydantic.color._r_alpha, '(?:(0(?:\\.\\d+)?|1(?:\\.0+)?|\\.\\d+|\\d{1,2}%))').replace(pydantic.color._r_255, '(?:((?:\\d|\\d\\d|[01]\\d\\d|2[0-4]\\d|25[0-4])(?:\\.\\d+)?|255(?:\\.0+)?))')
A:pydantic.v1._hypothesis_plugin.finite->hypothesis.strategies.floats(allow_infinity=False, allow_nan=False)
A:pydantic.v1._hypothesis_plugin.inner->hypothesis.strategies.recursive(base=st.one_of(st.none(), st.booleans(), st.integers(), finite, st.text()), extend=lambda x: st.lists(x) | st.dictionaries(st.text(), x))
A:pydantic.v1._hypothesis_plugin.inner_type->getattr(cls, 'inner_type', None)
A:pydantic.v1._hypothesis_plugin.repeats->'{{{},{}}}'.format(min_size - 2 if min_size > 2 else 0, max_size - 2 if (max_size or 0) > 2 else '')
A:pydantic.v1._hypothesis_plugin.s->s.filter(lambda d: cls.gt < d).filter(lambda d: cls.gt < d)
A:pydantic.v1._hypothesis_plugin.min_value->math.ceil(Fraction(min_value) / Fraction(cls.multiple_of))
A:pydantic.v1._hypothesis_plugin.max_value->math.floor(Fraction(max_value) / Fraction(cls.multiple_of))
A:pydantic.v1._hypothesis_plugin.strategy->hypothesis.strategies.from_regex(f'(\\W(.{repeats}\\W)?)?')
pydantic.v1._hypothesis_plugin._registered(typ:Union[Type[pydantic.types.T],pydantic.types.ConstrainedNumberMeta])->Union[Type[pydantic.types.T], pydantic.types.ConstrainedNumberMeta]
pydantic.v1._hypothesis_plugin.add_luhn_digit(card_number:str)->str
pydantic.v1._hypothesis_plugin.resolve_conbytes(cls)
pydantic.v1._hypothesis_plugin.resolve_condate(cls)
pydantic.v1._hypothesis_plugin.resolve_condecimal(cls)
pydantic.v1._hypothesis_plugin.resolve_confloat(cls)
pydantic.v1._hypothesis_plugin.resolve_conint(cls)
pydantic.v1._hypothesis_plugin.resolve_constr(cls)
pydantic.v1._hypothesis_plugin.resolve_json(cls)
pydantic.v1._hypothesis_plugin.resolves(typ:Union[type,pydantic.types.ConstrainedNumberMeta])->Callable[[Callable[..., st.SearchStrategy]], Callable[..., st.SearchStrategy]]


----------------------------------------/dataset/nuaa/anaconda3/envs/pydantic2.10.6/lib/python3.9/site-packages/pydantic/v1/errors.py----------------------------------------
A:pydantic.v1.errors.permitted->', '.join((repr(v.value) for v in self.enum_values))
pydantic.v1.AnyStrMaxLengthError(self,*,limit_value:int)
pydantic.v1.AnyStrMinLengthError(self,*,limit_value:int)
pydantic.v1.ArbitraryTypeError(self,*,expected_arbitrary_type:Type[Any])
pydantic.v1.BoolError(PydanticTypeError)
pydantic.v1.BytesError(PydanticTypeError)
pydantic.v1.CallableError(PydanticTypeError)
pydantic.v1.ClassError(PydanticTypeError)
pydantic.v1.ColorError(PydanticValueError)
pydantic.v1.ConfigError(RuntimeError)
pydantic.v1.DataclassTypeError(PydanticTypeError)
pydantic.v1.DateError(PydanticValueError)
pydantic.v1.DateNotInTheFutureError(PydanticValueError)
pydantic.v1.DateNotInThePastError(PydanticValueError)
pydantic.v1.DateTimeError(PydanticValueError)
pydantic.v1.DecimalError(PydanticTypeError)
pydantic.v1.DecimalIsNotFiniteError(PydanticValueError)
pydantic.v1.DecimalMaxDigitsError(self,*,max_digits:int)
pydantic.v1.DecimalMaxPlacesError(self,*,decimal_places:int)
pydantic.v1.DecimalWholeDigitsError(self,*,whole_digits:int)
pydantic.v1.DequeError(PydanticTypeError)
pydantic.v1.DictError(PydanticTypeError)
pydantic.v1.DurationError(PydanticValueError)
pydantic.v1.EmailError(PydanticValueError)
pydantic.v1.EnumError(PydanticTypeError)
pydantic.v1.EnumMemberError(PydanticTypeError)
pydantic.v1.EnumMemberError.__str__(self)->str
pydantic.v1.ExtraError(PydanticValueError)
pydantic.v1.FloatError(PydanticTypeError)
pydantic.v1.FrozenSetError(PydanticTypeError)
pydantic.v1.FrozenSetMaxLengthError(self,*,limit_value:int)
pydantic.v1.FrozenSetMinLengthError(self,*,limit_value:int)
pydantic.v1.HashableError(PydanticTypeError)
pydantic.v1.IPv4AddressError(PydanticValueError)
pydantic.v1.IPv4InterfaceError(PydanticValueError)
pydantic.v1.IPv4NetworkError(PydanticValueError)
pydantic.v1.IPv6AddressError(PydanticValueError)
pydantic.v1.IPv6InterfaceError(PydanticValueError)
pydantic.v1.IPv6NetworkError(PydanticValueError)
pydantic.v1.IPvAnyAddressError(PydanticValueError)
pydantic.v1.IPvAnyInterfaceError(PydanticValueError)
pydantic.v1.IPvAnyNetworkError(PydanticValueError)
pydantic.v1.IntEnumError(PydanticTypeError)
pydantic.v1.IntegerError(PydanticTypeError)
pydantic.v1.InvalidByteSize(PydanticValueError)
pydantic.v1.InvalidByteSizeUnit(PydanticValueError)
pydantic.v1.InvalidDiscriminator(self,*,discriminator_key:str,discriminator_value:Any,allowed_values:Sequence[Any])
pydantic.v1.InvalidLengthForBrand(PydanticValueError)
pydantic.v1.IterableError(PydanticTypeError)
pydantic.v1.JsonError(PydanticValueError)
pydantic.v1.JsonTypeError(PydanticTypeError)
pydantic.v1.ListError(PydanticTypeError)
pydantic.v1.ListMaxLengthError(self,*,limit_value:int)
pydantic.v1.ListMinLengthError(self,*,limit_value:int)
pydantic.v1.ListUniqueItemsError(PydanticValueError)
pydantic.v1.LuhnValidationError(PydanticValueError)
pydantic.v1.MissingDiscriminator(PydanticValueError)
pydantic.v1.MissingError(PydanticValueError)
pydantic.v1.NoneIsAllowedError(PydanticTypeError)
pydantic.v1.NoneIsNotAllowedError(PydanticTypeError)
pydantic.v1.NotDigitError(PydanticValueError)
pydantic.v1.NotNoneError(PydanticTypeError)
pydantic.v1.NumberNotFiniteError(PydanticValueError)
pydantic.v1.NumberNotGeError(_NumberBoundError)
pydantic.v1.NumberNotGtError(_NumberBoundError)
pydantic.v1.NumberNotLeError(_NumberBoundError)
pydantic.v1.NumberNotLtError(_NumberBoundError)
pydantic.v1.NumberNotMultipleError(self,*,multiple_of:Union[int,float,Decimal])
pydantic.v1.PathError(PydanticTypeError)
pydantic.v1.PathNotADirectoryError(_PathValueError)
pydantic.v1.PathNotAFileError(_PathValueError)
pydantic.v1.PathNotExistsError(_PathValueError)
pydantic.v1.PatternError(PydanticValueError)
pydantic.v1.PyObjectError(PydanticTypeError)
pydantic.v1.PydanticErrorMixin(self,**ctx:Any)
pydantic.v1.PydanticErrorMixin.__reduce__(self)->Tuple[Callable[..., 'PydanticErrorMixin'], Tuple[Type['PydanticErrorMixin'], 'DictStrAny']]
pydantic.v1.PydanticErrorMixin.__str__(self)->str
pydantic.v1.PydanticTypeError(PydanticErrorMixin,TypeError)
pydantic.v1.PydanticValueError(PydanticErrorMixin,ValueError)
pydantic.v1.SequenceError(PydanticTypeError)
pydantic.v1.SetError(PydanticTypeError)
pydantic.v1.SetMaxLengthError(self,*,limit_value:int)
pydantic.v1.SetMinLengthError(self,*,limit_value:int)
pydantic.v1.StrError(PydanticTypeError)
pydantic.v1.StrRegexError(self,*,pattern:str)
pydantic.v1.StrictBoolError(PydanticValueError)
pydantic.v1.SubclassError(self,*,expected_class:Type[Any])
pydantic.v1.TimeError(PydanticValueError)
pydantic.v1.TupleError(PydanticTypeError)
pydantic.v1.TupleLengthError(self,*,actual_length:int,expected_length:int)
pydantic.v1.UUIDError(PydanticTypeError)
pydantic.v1.UUIDVersionError(self,*,required_version:int)
pydantic.v1.UrlError(PydanticValueError)
pydantic.v1.UrlExtraError(UrlError)
pydantic.v1.UrlHostError(UrlError)
pydantic.v1.UrlHostTldError(UrlError)
pydantic.v1.UrlPortError(UrlError)
pydantic.v1.UrlSchemeError(UrlError)
pydantic.v1.UrlSchemePermittedError(self,allowed_schemes:Set[str])
pydantic.v1.UrlUserInfoError(UrlError)
pydantic.v1.WrongConstantError(PydanticValueError)
pydantic.v1.WrongConstantError.__str__(self)->str
pydantic.v1._NumberBoundError(self,*,limit_value:Union[int,float,Decimal])
pydantic.v1._PathValueError(self,*,path:Path)
pydantic.v1.cls_kwargs(cls:Type['PydanticErrorMixin'],ctx:'DictStrAny')->'PydanticErrorMixin'
pydantic.v1.errors.AnyStrMaxLengthError(self,*,limit_value:int)
pydantic.v1.errors.AnyStrMaxLengthError.__init__(self,*,limit_value:int)
pydantic.v1.errors.AnyStrMinLengthError(self,*,limit_value:int)
pydantic.v1.errors.AnyStrMinLengthError.__init__(self,*,limit_value:int)
pydantic.v1.errors.ArbitraryTypeError(self,*,expected_arbitrary_type:Type[Any])
pydantic.v1.errors.ArbitraryTypeError.__init__(self,*,expected_arbitrary_type:Type[Any])
pydantic.v1.errors.BoolError(PydanticTypeError)
pydantic.v1.errors.BytesError(PydanticTypeError)
pydantic.v1.errors.CallableError(PydanticTypeError)
pydantic.v1.errors.ClassError(PydanticTypeError)
pydantic.v1.errors.ColorError(PydanticValueError)
pydantic.v1.errors.ConfigError(RuntimeError)
pydantic.v1.errors.DataclassTypeError(PydanticTypeError)
pydantic.v1.errors.DateError(PydanticValueError)
pydantic.v1.errors.DateNotInTheFutureError(PydanticValueError)
pydantic.v1.errors.DateNotInThePastError(PydanticValueError)
pydantic.v1.errors.DateTimeError(PydanticValueError)
pydantic.v1.errors.DecimalError(PydanticTypeError)
pydantic.v1.errors.DecimalIsNotFiniteError(PydanticValueError)
pydantic.v1.errors.DecimalMaxDigitsError(self,*,max_digits:int)
pydantic.v1.errors.DecimalMaxDigitsError.__init__(self,*,max_digits:int)
pydantic.v1.errors.DecimalMaxPlacesError(self,*,decimal_places:int)
pydantic.v1.errors.DecimalMaxPlacesError.__init__(self,*,decimal_places:int)
pydantic.v1.errors.DecimalWholeDigitsError(self,*,whole_digits:int)
pydantic.v1.errors.DecimalWholeDigitsError.__init__(self,*,whole_digits:int)
pydantic.v1.errors.DequeError(PydanticTypeError)
pydantic.v1.errors.DictError(PydanticTypeError)
pydantic.v1.errors.DurationError(PydanticValueError)
pydantic.v1.errors.EmailError(PydanticValueError)
pydantic.v1.errors.EnumError(PydanticTypeError)
pydantic.v1.errors.EnumMemberError(PydanticTypeError)
pydantic.v1.errors.EnumMemberError.__str__(self)->str
pydantic.v1.errors.ExtraError(PydanticValueError)
pydantic.v1.errors.FloatError(PydanticTypeError)
pydantic.v1.errors.FrozenSetError(PydanticTypeError)
pydantic.v1.errors.FrozenSetMaxLengthError(self,*,limit_value:int)
pydantic.v1.errors.FrozenSetMaxLengthError.__init__(self,*,limit_value:int)
pydantic.v1.errors.FrozenSetMinLengthError(self,*,limit_value:int)
pydantic.v1.errors.FrozenSetMinLengthError.__init__(self,*,limit_value:int)
pydantic.v1.errors.HashableError(PydanticTypeError)
pydantic.v1.errors.IPv4AddressError(PydanticValueError)
pydantic.v1.errors.IPv4InterfaceError(PydanticValueError)
pydantic.v1.errors.IPv4NetworkError(PydanticValueError)
pydantic.v1.errors.IPv6AddressError(PydanticValueError)
pydantic.v1.errors.IPv6InterfaceError(PydanticValueError)
pydantic.v1.errors.IPv6NetworkError(PydanticValueError)
pydantic.v1.errors.IPvAnyAddressError(PydanticValueError)
pydantic.v1.errors.IPvAnyInterfaceError(PydanticValueError)
pydantic.v1.errors.IPvAnyNetworkError(PydanticValueError)
pydantic.v1.errors.IntEnumError(PydanticTypeError)
pydantic.v1.errors.IntegerError(PydanticTypeError)
pydantic.v1.errors.InvalidByteSize(PydanticValueError)
pydantic.v1.errors.InvalidByteSizeUnit(PydanticValueError)
pydantic.v1.errors.InvalidDiscriminator(self,*,discriminator_key:str,discriminator_value:Any,allowed_values:Sequence[Any])
pydantic.v1.errors.InvalidDiscriminator.__init__(self,*,discriminator_key:str,discriminator_value:Any,allowed_values:Sequence[Any])
pydantic.v1.errors.InvalidLengthForBrand(PydanticValueError)
pydantic.v1.errors.IterableError(PydanticTypeError)
pydantic.v1.errors.JsonError(PydanticValueError)
pydantic.v1.errors.JsonTypeError(PydanticTypeError)
pydantic.v1.errors.ListError(PydanticTypeError)
pydantic.v1.errors.ListMaxLengthError(self,*,limit_value:int)
pydantic.v1.errors.ListMaxLengthError.__init__(self,*,limit_value:int)
pydantic.v1.errors.ListMinLengthError(self,*,limit_value:int)
pydantic.v1.errors.ListMinLengthError.__init__(self,*,limit_value:int)
pydantic.v1.errors.ListUniqueItemsError(PydanticValueError)
pydantic.v1.errors.LuhnValidationError(PydanticValueError)
pydantic.v1.errors.MissingDiscriminator(PydanticValueError)
pydantic.v1.errors.MissingError(PydanticValueError)
pydantic.v1.errors.NoneIsAllowedError(PydanticTypeError)
pydantic.v1.errors.NoneIsNotAllowedError(PydanticTypeError)
pydantic.v1.errors.NotDigitError(PydanticValueError)
pydantic.v1.errors.NotNoneError(PydanticTypeError)
pydantic.v1.errors.NumberNotFiniteError(PydanticValueError)
pydantic.v1.errors.NumberNotGeError(_NumberBoundError)
pydantic.v1.errors.NumberNotGtError(_NumberBoundError)
pydantic.v1.errors.NumberNotLeError(_NumberBoundError)
pydantic.v1.errors.NumberNotLtError(_NumberBoundError)
pydantic.v1.errors.NumberNotMultipleError(self,*,multiple_of:Union[int,float,Decimal])
pydantic.v1.errors.NumberNotMultipleError.__init__(self,*,multiple_of:Union[int,float,Decimal])
pydantic.v1.errors.PathError(PydanticTypeError)
pydantic.v1.errors.PathNotADirectoryError(_PathValueError)
pydantic.v1.errors.PathNotAFileError(_PathValueError)
pydantic.v1.errors.PathNotExistsError(_PathValueError)
pydantic.v1.errors.PatternError(PydanticValueError)
pydantic.v1.errors.PyObjectError(PydanticTypeError)
pydantic.v1.errors.PydanticErrorMixin(self,**ctx:Any)
pydantic.v1.errors.PydanticErrorMixin.__init__(self,**ctx:Any)
pydantic.v1.errors.PydanticErrorMixin.__reduce__(self)->Tuple[Callable[..., 'PydanticErrorMixin'], Tuple[Type['PydanticErrorMixin'], 'DictStrAny']]
pydantic.v1.errors.PydanticErrorMixin.__str__(self)->str
pydantic.v1.errors.PydanticTypeError(PydanticErrorMixin,TypeError)
pydantic.v1.errors.PydanticValueError(PydanticErrorMixin,ValueError)
pydantic.v1.errors.SequenceError(PydanticTypeError)
pydantic.v1.errors.SetError(PydanticTypeError)
pydantic.v1.errors.SetMaxLengthError(self,*,limit_value:int)
pydantic.v1.errors.SetMaxLengthError.__init__(self,*,limit_value:int)
pydantic.v1.errors.SetMinLengthError(self,*,limit_value:int)
pydantic.v1.errors.SetMinLengthError.__init__(self,*,limit_value:int)
pydantic.v1.errors.StrError(PydanticTypeError)
pydantic.v1.errors.StrRegexError(self,*,pattern:str)
pydantic.v1.errors.StrRegexError.__init__(self,*,pattern:str)
pydantic.v1.errors.StrictBoolError(PydanticValueError)
pydantic.v1.errors.SubclassError(self,*,expected_class:Type[Any])
pydantic.v1.errors.SubclassError.__init__(self,*,expected_class:Type[Any])
pydantic.v1.errors.TimeError(PydanticValueError)
pydantic.v1.errors.TupleError(PydanticTypeError)
pydantic.v1.errors.TupleLengthError(self,*,actual_length:int,expected_length:int)
pydantic.v1.errors.TupleLengthError.__init__(self,*,actual_length:int,expected_length:int)
pydantic.v1.errors.UUIDError(PydanticTypeError)
pydantic.v1.errors.UUIDVersionError(self,*,required_version:int)
pydantic.v1.errors.UUIDVersionError.__init__(self,*,required_version:int)
pydantic.v1.errors.UrlError(PydanticValueError)
pydantic.v1.errors.UrlExtraError(UrlError)
pydantic.v1.errors.UrlHostError(UrlError)
pydantic.v1.errors.UrlHostTldError(UrlError)
pydantic.v1.errors.UrlPortError(UrlError)
pydantic.v1.errors.UrlSchemeError(UrlError)
pydantic.v1.errors.UrlSchemePermittedError(self,allowed_schemes:Set[str])
pydantic.v1.errors.UrlSchemePermittedError.__init__(self,allowed_schemes:Set[str])
pydantic.v1.errors.UrlUserInfoError(UrlError)
pydantic.v1.errors.WrongConstantError(PydanticValueError)
pydantic.v1.errors.WrongConstantError.__str__(self)->str
pydantic.v1.errors._NumberBoundError(self,*,limit_value:Union[int,float,Decimal])
pydantic.v1.errors._NumberBoundError.__init__(self,*,limit_value:Union[int,float,Decimal])
pydantic.v1.errors._PathValueError(self,*,path:Path)
pydantic.v1.errors._PathValueError.__init__(self,*,path:Path)
pydantic.v1.errors.cls_kwargs(cls:Type['PydanticErrorMixin'],ctx:'DictStrAny')->'PydanticErrorMixin'


----------------------------------------/dataset/nuaa/anaconda3/envs/pydantic2.10.6/lib/python3.9/site-packages/pydantic/v1/types.py----------------------------------------
A:pydantic.v1.types.T->TypeVar('T')
A:pydantic.v1.types.new_cls->cast('ConstrainedInt', type.__new__(cls, name, bases, dct))
A:pydantic.v1.types.namespace->dict(gt=gt, ge=ge, lt=lt, le=le)
A:pydantic.v1.types.v->list_validator(v)
A:pydantic.v1.types.v_len->len(v)
A:pydantic.v1.types.value->bytes_validator(value)
A:pydantic.v1.types.normalized_value->bytes_validator(value).normalize()
A:pydantic.v1.types.digitsdecimals->abs(exponent)
A:pydantic.v1.types.digits->len(digit_tuple)
A:pydantic.v1.types.decimals->abs(exponent)
A:pydantic.v1.types.self.brand->self._get_brand(card_number)
A:pydantic.v1.types.sum_->int(card_number[-1])
A:pydantic.v1.types.length->len(card_number)
A:pydantic.v1.types.digit->int(card_number[i])
A:pydantic.v1.types.byte_string_re->re.compile('^\\s*(\\d*\\.?\\d+)\\s*(\\w+)?', re.IGNORECASE)
A:pydantic.v1.types.str_match->re.compile('^\\s*(\\d*\\.?\\d+)\\s*(\\w+)?', re.IGNORECASE).match(str(v))
A:pydantic.v1.types.(scalar, unit)->re.compile('^\\s*(\\d*\\.?\\d+)\\s*(\\w+)?', re.IGNORECASE).match(str(v)).groups()
A:pydantic.v1.types.num->float(self)
pydantic.v1.ByteSize(int)
pydantic.v1.ByteSize.__get_validators__(cls)->'CallableGenerator'
pydantic.v1.ByteSize.human_readable(self,decimal:bool=False)->str
pydantic.v1.ByteSize.to(self,unit:str)->float
pydantic.v1.ByteSize.validate(cls,v:StrIntFloat)->'ByteSize'
pydantic.v1.ConstrainedBytes(bytes)
pydantic.v1.ConstrainedBytes.__get_validators__(cls)->'CallableGenerator'
pydantic.v1.ConstrainedBytes.__modify_schema__(cls,field_schema:Dict[str,Any])->None
pydantic.v1.ConstrainedDate(date,metaclass=ConstrainedNumberMeta)
pydantic.v1.ConstrainedDate.__get_validators__(cls)->'CallableGenerator'
pydantic.v1.ConstrainedDate.__modify_schema__(cls,field_schema:Dict[str,Any])->None
pydantic.v1.ConstrainedDecimal(Decimal,metaclass=ConstrainedNumberMeta)
pydantic.v1.ConstrainedDecimal.__get_validators__(cls)->'CallableGenerator'
pydantic.v1.ConstrainedDecimal.__modify_schema__(cls,field_schema:Dict[str,Any])->None
pydantic.v1.ConstrainedDecimal.validate(cls,value:Decimal)->Decimal
pydantic.v1.ConstrainedFloat(float,metaclass=ConstrainedNumberMeta)
pydantic.v1.ConstrainedFloat.__get_validators__(cls)->'CallableGenerator'
pydantic.v1.ConstrainedFloat.__modify_schema__(cls,field_schema:Dict[str,Any])->None
pydantic.v1.ConstrainedFrozenSet(frozenset)
pydantic.v1.ConstrainedFrozenSet.__get_validators__(cls)->'CallableGenerator'
pydantic.v1.ConstrainedFrozenSet.__modify_schema__(cls,field_schema:Dict[str,Any])->None
pydantic.v1.ConstrainedFrozenSet.frozenset_length_validator(cls,v:'Optional[FrozenSet[T]]')->'Optional[FrozenSet[T]]'
pydantic.v1.ConstrainedInt(int,metaclass=ConstrainedNumberMeta)
pydantic.v1.ConstrainedInt.__get_validators__(cls)->'CallableGenerator'
pydantic.v1.ConstrainedInt.__modify_schema__(cls,field_schema:Dict[str,Any])->None
pydantic.v1.ConstrainedList(list)
pydantic.v1.ConstrainedList.__get_validators__(cls)->'CallableGenerator'
pydantic.v1.ConstrainedList.__modify_schema__(cls,field_schema:Dict[str,Any])->None
pydantic.v1.ConstrainedList.list_length_validator(cls,v:'Optional[List[T]]')->'Optional[List[T]]'
pydantic.v1.ConstrainedList.unique_items_validator(cls,v:'Optional[List[T]]')->'Optional[List[T]]'
pydantic.v1.ConstrainedNumberMeta(cls,name:str,bases:Any,dct:Dict[str,Any])
pydantic.v1.ConstrainedSet(set)
pydantic.v1.ConstrainedSet.__get_validators__(cls)->'CallableGenerator'
pydantic.v1.ConstrainedSet.__modify_schema__(cls,field_schema:Dict[str,Any])->None
pydantic.v1.ConstrainedSet.set_length_validator(cls,v:'Optional[Set[T]]')->'Optional[Set[T]]'
pydantic.v1.ConstrainedStr(str)
pydantic.v1.ConstrainedStr.__get_validators__(cls)->'CallableGenerator'
pydantic.v1.ConstrainedStr.__modify_schema__(cls,field_schema:Dict[str,Any])->None
pydantic.v1.ConstrainedStr._get_pattern(regex:Union[str,Pattern[str]])->str
pydantic.v1.ConstrainedStr.validate(cls,value:Union[str])->Union[str]
pydantic.v1.JsonMeta(type)
pydantic.v1.JsonMeta.__getitem__(self,t:Type[Any])->Type[JsonWrapper]
pydantic.v1.JsonWrapper
pydantic.v1.PaymentCardBrand(str,Enum)
pydantic.v1.PaymentCardBrand.__str__(self)->str
pydantic.v1.PaymentCardNumber(self,card_number:str)
pydantic.v1.PaymentCardNumber.__get_validators__(cls)->'CallableGenerator'
pydantic.v1.PaymentCardNumber._get_brand(card_number:str)->PaymentCardBrand
pydantic.v1.PaymentCardNumber.masked(self)->str
pydantic.v1.PaymentCardNumber.validate_digits(cls,card_number:str)->str
pydantic.v1.PaymentCardNumber.validate_length_for_brand(cls,card_number:'PaymentCardNumber')->'PaymentCardNumber'
pydantic.v1.PaymentCardNumber.validate_luhn_check_digit(cls,card_number:str)->str
pydantic.v1.SecretBytes(self,value:bytes)
pydantic.v1.SecretBytes.__get_validators__(cls)->'CallableGenerator'
pydantic.v1.SecretBytes.__len__(self)->int
pydantic.v1.SecretBytes.__modify_schema__(cls,field_schema:Dict[str,Any])->None
pydantic.v1.SecretBytes.__repr__(self)->str
pydantic.v1.SecretBytes.display(self)->str
pydantic.v1.SecretBytes.get_secret_value(self)->bytes
pydantic.v1.SecretBytes.validate(cls,value:Any)->'SecretBytes'
pydantic.v1.SecretField(abc.ABC)
pydantic.v1.SecretField.__eq__(self,other:Any)->bool
pydantic.v1.SecretField.__hash__(self)->int
pydantic.v1.SecretField.__str__(self)->str
pydantic.v1.SecretField.get_secret_value(self)->Any
pydantic.v1.SecretStr(self,value:str)
pydantic.v1.SecretStr.__get_validators__(cls)->'CallableGenerator'
pydantic.v1.SecretStr.__len__(self)->int
pydantic.v1.SecretStr.__modify_schema__(cls,field_schema:Dict[str,Any])->None
pydantic.v1.SecretStr.__repr__(self)->str
pydantic.v1.SecretStr.display(self)->str
pydantic.v1.SecretStr.get_secret_value(self)->str
pydantic.v1.SecretStr.validate(cls,value:Any)->'SecretStr'
pydantic.v1._registered(typ:Union[Type[T],'ConstrainedNumberMeta'])->Union[Type[T], 'ConstrainedNumberMeta']
pydantic.v1.conbytes(*,strip_whitespace:bool=False,to_upper:bool=False,to_lower:bool=False,min_length:Optional[int]=None,max_length:Optional[int]=None,strict:bool=False)->Type[bytes]
pydantic.v1.condate(*,gt:date=None,ge:date=None,lt:date=None,le:date=None)->Type[date]
pydantic.v1.condecimal(*,gt:Decimal=None,ge:Decimal=None,lt:Decimal=None,le:Decimal=None,max_digits:Optional[int]=None,decimal_places:Optional[int]=None,multiple_of:Decimal=None)->Type[Decimal]
pydantic.v1.confloat(*,strict:bool=False,gt:float=None,ge:float=None,lt:float=None,le:float=None,multiple_of:float=None,allow_inf_nan:Optional[bool]=None)->Type[float]
pydantic.v1.confrozenset(item_type:Type[T],*,min_items:Optional[int]=None,max_items:Optional[int]=None)->Type[FrozenSet[T]]
pydantic.v1.conint(*,strict:bool=False,gt:Optional[int]=None,ge:Optional[int]=None,lt:Optional[int]=None,le:Optional[int]=None,multiple_of:Optional[int]=None)->Type[int]
pydantic.v1.conlist(item_type:Type[T],*,min_items:Optional[int]=None,max_items:Optional[int]=None,unique_items:bool=None)->Type[List[T]]
pydantic.v1.conset(item_type:Type[T],*,min_items:Optional[int]=None,max_items:Optional[int]=None)->Type[Set[T]]
pydantic.v1.constr(*,strip_whitespace:bool=False,to_upper:bool=False,to_lower:bool=False,strict:bool=False,min_length:Optional[int]=None,max_length:Optional[int]=None,curtail_length:Optional[int]=None,regex:Optional[str]=None)->Type[str]
pydantic.v1.types.ByteSize(int)
pydantic.v1.types.ByteSize.__get_validators__(cls)->'CallableGenerator'
pydantic.v1.types.ByteSize.human_readable(self,decimal:bool=False)->str
pydantic.v1.types.ByteSize.to(self,unit:str)->float
pydantic.v1.types.ByteSize.validate(cls,v:StrIntFloat)->'ByteSize'
pydantic.v1.types.ConstrainedBytes(bytes)
pydantic.v1.types.ConstrainedBytes.__get_validators__(cls)->'CallableGenerator'
pydantic.v1.types.ConstrainedBytes.__modify_schema__(cls,field_schema:Dict[str,Any])->None
pydantic.v1.types.ConstrainedDate(date,metaclass=ConstrainedNumberMeta)
pydantic.v1.types.ConstrainedDate.__get_validators__(cls)->'CallableGenerator'
pydantic.v1.types.ConstrainedDate.__modify_schema__(cls,field_schema:Dict[str,Any])->None
pydantic.v1.types.ConstrainedDecimal(Decimal,metaclass=ConstrainedNumberMeta)
pydantic.v1.types.ConstrainedDecimal.__get_validators__(cls)->'CallableGenerator'
pydantic.v1.types.ConstrainedDecimal.__modify_schema__(cls,field_schema:Dict[str,Any])->None
pydantic.v1.types.ConstrainedDecimal.validate(cls,value:Decimal)->Decimal
pydantic.v1.types.ConstrainedFloat(float,metaclass=ConstrainedNumberMeta)
pydantic.v1.types.ConstrainedFloat.__get_validators__(cls)->'CallableGenerator'
pydantic.v1.types.ConstrainedFloat.__modify_schema__(cls,field_schema:Dict[str,Any])->None
pydantic.v1.types.ConstrainedFrozenSet(frozenset)
pydantic.v1.types.ConstrainedFrozenSet.__get_validators__(cls)->'CallableGenerator'
pydantic.v1.types.ConstrainedFrozenSet.__modify_schema__(cls,field_schema:Dict[str,Any])->None
pydantic.v1.types.ConstrainedFrozenSet.frozenset_length_validator(cls,v:'Optional[FrozenSet[T]]')->'Optional[FrozenSet[T]]'
pydantic.v1.types.ConstrainedInt(int,metaclass=ConstrainedNumberMeta)
pydantic.v1.types.ConstrainedInt.__get_validators__(cls)->'CallableGenerator'
pydantic.v1.types.ConstrainedInt.__modify_schema__(cls,field_schema:Dict[str,Any])->None
pydantic.v1.types.ConstrainedList(list)
pydantic.v1.types.ConstrainedList.__get_validators__(cls)->'CallableGenerator'
pydantic.v1.types.ConstrainedList.__modify_schema__(cls,field_schema:Dict[str,Any])->None
pydantic.v1.types.ConstrainedList.list_length_validator(cls,v:'Optional[List[T]]')->'Optional[List[T]]'
pydantic.v1.types.ConstrainedList.unique_items_validator(cls,v:'Optional[List[T]]')->'Optional[List[T]]'
pydantic.v1.types.ConstrainedNumberMeta(cls,name:str,bases:Any,dct:Dict[str,Any])
pydantic.v1.types.ConstrainedNumberMeta.__new__(cls,name:str,bases:Any,dct:Dict[str,Any])
pydantic.v1.types.ConstrainedSet(set)
pydantic.v1.types.ConstrainedSet.__get_validators__(cls)->'CallableGenerator'
pydantic.v1.types.ConstrainedSet.__modify_schema__(cls,field_schema:Dict[str,Any])->None
pydantic.v1.types.ConstrainedSet.set_length_validator(cls,v:'Optional[Set[T]]')->'Optional[Set[T]]'
pydantic.v1.types.ConstrainedStr(str)
pydantic.v1.types.ConstrainedStr.__get_validators__(cls)->'CallableGenerator'
pydantic.v1.types.ConstrainedStr.__modify_schema__(cls,field_schema:Dict[str,Any])->None
pydantic.v1.types.ConstrainedStr._get_pattern(regex:Union[str,Pattern[str]])->str
pydantic.v1.types.ConstrainedStr.validate(cls,value:Union[str])->Union[str]
pydantic.v1.types.JsonMeta(type)
pydantic.v1.types.JsonMeta.__getitem__(self,t:Type[Any])->Type[JsonWrapper]
pydantic.v1.types.JsonWrapper
pydantic.v1.types.PaymentCardBrand(str,Enum)
pydantic.v1.types.PaymentCardBrand.__str__(self)->str
pydantic.v1.types.PaymentCardNumber(self,card_number:str)
pydantic.v1.types.PaymentCardNumber.__get_validators__(cls)->'CallableGenerator'
pydantic.v1.types.PaymentCardNumber.__init__(self,card_number:str)
pydantic.v1.types.PaymentCardNumber._get_brand(card_number:str)->PaymentCardBrand
pydantic.v1.types.PaymentCardNumber.masked(self)->str
pydantic.v1.types.PaymentCardNumber.validate_digits(cls,card_number:str)->str
pydantic.v1.types.PaymentCardNumber.validate_length_for_brand(cls,card_number:'PaymentCardNumber')->'PaymentCardNumber'
pydantic.v1.types.PaymentCardNumber.validate_luhn_check_digit(cls,card_number:str)->str
pydantic.v1.types.SecretBytes(self,value:bytes)
pydantic.v1.types.SecretBytes.__get_validators__(cls)->'CallableGenerator'
pydantic.v1.types.SecretBytes.__init__(self,value:bytes)
pydantic.v1.types.SecretBytes.__len__(self)->int
pydantic.v1.types.SecretBytes.__modify_schema__(cls,field_schema:Dict[str,Any])->None
pydantic.v1.types.SecretBytes.__repr__(self)->str
pydantic.v1.types.SecretBytes.display(self)->str
pydantic.v1.types.SecretBytes.get_secret_value(self)->bytes
pydantic.v1.types.SecretBytes.validate(cls,value:Any)->'SecretBytes'
pydantic.v1.types.SecretField(abc.ABC)
pydantic.v1.types.SecretField.__eq__(self,other:Any)->bool
pydantic.v1.types.SecretField.__hash__(self)->int
pydantic.v1.types.SecretField.__str__(self)->str
pydantic.v1.types.SecretField.get_secret_value(self)->Any
pydantic.v1.types.SecretStr(self,value:str)
pydantic.v1.types.SecretStr.__get_validators__(cls)->'CallableGenerator'
pydantic.v1.types.SecretStr.__init__(self,value:str)
pydantic.v1.types.SecretStr.__len__(self)->int
pydantic.v1.types.SecretStr.__modify_schema__(cls,field_schema:Dict[str,Any])->None
pydantic.v1.types.SecretStr.__repr__(self)->str
pydantic.v1.types.SecretStr.display(self)->str
pydantic.v1.types.SecretStr.get_secret_value(self)->str
pydantic.v1.types.SecretStr.validate(cls,value:Any)->'SecretStr'
pydantic.v1.types._registered(typ:Union[Type[T],'ConstrainedNumberMeta'])->Union[Type[T], 'ConstrainedNumberMeta']
pydantic.v1.types.conbytes(*,strip_whitespace:bool=False,to_upper:bool=False,to_lower:bool=False,min_length:Optional[int]=None,max_length:Optional[int]=None,strict:bool=False)->Type[bytes]
pydantic.v1.types.condate(*,gt:date=None,ge:date=None,lt:date=None,le:date=None)->Type[date]
pydantic.v1.types.condecimal(*,gt:Decimal=None,ge:Decimal=None,lt:Decimal=None,le:Decimal=None,max_digits:Optional[int]=None,decimal_places:Optional[int]=None,multiple_of:Decimal=None)->Type[Decimal]
pydantic.v1.types.confloat(*,strict:bool=False,gt:float=None,ge:float=None,lt:float=None,le:float=None,multiple_of:float=None,allow_inf_nan:Optional[bool]=None)->Type[float]
pydantic.v1.types.confrozenset(item_type:Type[T],*,min_items:Optional[int]=None,max_items:Optional[int]=None)->Type[FrozenSet[T]]
pydantic.v1.types.conint(*,strict:bool=False,gt:Optional[int]=None,ge:Optional[int]=None,lt:Optional[int]=None,le:Optional[int]=None,multiple_of:Optional[int]=None)->Type[int]
pydantic.v1.types.conlist(item_type:Type[T],*,min_items:Optional[int]=None,max_items:Optional[int]=None,unique_items:bool=None)->Type[List[T]]
pydantic.v1.types.conset(item_type:Type[T],*,min_items:Optional[int]=None,max_items:Optional[int]=None)->Type[Set[T]]
pydantic.v1.types.constr(*,strip_whitespace:bool=False,to_upper:bool=False,to_lower:bool=False,strict:bool=False,min_length:Optional[int]=None,max_length:Optional[int]=None,curtail_length:Optional[int]=None,regex:Optional[str]=None)->Type[str]


----------------------------------------/dataset/nuaa/anaconda3/envs/pydantic2.10.6/lib/python3.9/site-packages/pydantic/v1/tools.py----------------------------------------
A:pydantic.v1.tools.type_name->type_name(type_)
A:pydantic.v1.tools.T->TypeVar('T')
A:pydantic.v1.tools.model_type->_get_parsing_type(type_, type_name=type_name)
A:pydantic.v1.tools.obj->load_str_bytes(b, proto=proto, content_type=content_type, encoding=encoding, allow_pickle=allow_pickle, json_loads=json_loads)
pydantic.v1._generate_parsing_type_name(type_:Any)->str
pydantic.v1._get_parsing_type(type_:Any,*,type_name:Optional[NameFactory]=None)->Any
pydantic.v1.parse_file_as(type_:Type[T],path:Union[str,Path],*,content_type:str=None,encoding:str='utf8',proto:Protocol=None,allow_pickle:bool=False,json_loads:Callable[[str],Any]=json.loads,type_name:Optional[NameFactory]=None)->T
pydantic.v1.parse_obj_as(type_:Type[T],obj:Any,*,type_name:Optional[NameFactory]=None)->T
pydantic.v1.parse_raw_as(type_:Type[T],b:StrBytes,*,content_type:str=None,encoding:str='utf8',proto:Protocol=None,allow_pickle:bool=False,json_loads:Callable[[str],Any]=json.loads,type_name:Optional[NameFactory]=None)->T
pydantic.v1.schema_json_of(type_:Any,*,title:Optional[NameFactory]=None,**schema_json_kwargs:Any)->str
pydantic.v1.schema_of(type_:Any,*,title:Optional[NameFactory]=None,**schema_kwargs:Any)->'DictStrAny'
pydantic.v1.tools._generate_parsing_type_name(type_:Any)->str
pydantic.v1.tools._get_parsing_type(type_:Any,*,type_name:Optional[NameFactory]=None)->Any
pydantic.v1.tools.parse_file_as(type_:Type[T],path:Union[str,Path],*,content_type:str=None,encoding:str='utf8',proto:Protocol=None,allow_pickle:bool=False,json_loads:Callable[[str],Any]=json.loads,type_name:Optional[NameFactory]=None)->T
pydantic.v1.tools.parse_obj_as(type_:Type[T],obj:Any,*,type_name:Optional[NameFactory]=None)->T
pydantic.v1.tools.parse_raw_as(type_:Type[T],b:StrBytes,*,content_type:str=None,encoding:str='utf8',proto:Protocol=None,allow_pickle:bool=False,json_loads:Callable[[str],Any]=json.loads,type_name:Optional[NameFactory]=None)->T
pydantic.v1.tools.schema_json_of(type_:Any,*,title:Optional[NameFactory]=None,**schema_json_kwargs:Any)->str
pydantic.v1.tools.schema_of(type_:Any,*,title:Optional[NameFactory]=None,**schema_kwargs:Any)->'DictStrAny'


----------------------------------------/dataset/nuaa/anaconda3/envs/pydantic2.10.6/lib/python3.9/site-packages/pydantic/v1/json.py----------------------------------------
A:pydantic.v1.json.(minutes, seconds)->divmod(td.seconds, 60)
A:pydantic.v1.json.(hours, minutes)->divmod(minutes, 60)
pydantic.v1.json.custom_pydantic_encoder(type_encoders:Dict[Any,Callable[[Type[Any]],Any]],obj:Any)->Any
pydantic.v1.json.decimal_encoder(dec_value:Decimal)->Union[int, float]
pydantic.v1.json.isoformat(o:Union[datetime.date,datetime.time])->str
pydantic.v1.json.pydantic_encoder(obj:Any)->Any
pydantic.v1.json.timedelta_isoformat(td:datetime.timedelta)->str


----------------------------------------/dataset/nuaa/anaconda3/envs/pydantic2.10.6/lib/python3.9/site-packages/pydantic/v1/fields.py----------------------------------------
A:pydantic.v1.fields.T->TypeVar('T')
A:pydantic.v1.fields.Undefined->UndefinedType()
A:pydantic.v1.fields.self.default_factory->kwargs.pop('default_factory', None)
A:pydantic.v1.fields.self.alias->kwargs.pop('alias', None)
A:pydantic.v1.fields.self.alias_priority->kwargs.pop('alias_priority', 2 if self.alias is not None else None)
A:pydantic.v1.fields.self.title->kwargs.pop('title', None)
A:pydantic.v1.fields.self.description->kwargs.pop('description', None)
A:pydantic.v1.fields.self.exclude->pydantic.v1.utils.ValueItems.merge(value, current_value)
A:pydantic.v1.fields.self.include->pydantic.v1.utils.ValueItems.merge(value, current_value, intersect=True)
A:pydantic.v1.fields.self.const->kwargs.pop('const', None)
A:pydantic.v1.fields.self.gt->kwargs.pop('gt', None)
A:pydantic.v1.fields.self.ge->kwargs.pop('ge', None)
A:pydantic.v1.fields.self.lt->kwargs.pop('lt', None)
A:pydantic.v1.fields.self.le->kwargs.pop('le', None)
A:pydantic.v1.fields.self.multiple_of->kwargs.pop('multiple_of', None)
A:pydantic.v1.fields.self.allow_inf_nan->kwargs.pop('allow_inf_nan', None)
A:pydantic.v1.fields.self.max_digits->kwargs.pop('max_digits', None)
A:pydantic.v1.fields.self.decimal_places->kwargs.pop('decimal_places', None)
A:pydantic.v1.fields.self.min_items->kwargs.pop('min_items', None)
A:pydantic.v1.fields.self.max_items->kwargs.pop('max_items', None)
A:pydantic.v1.fields.self.unique_items->kwargs.pop('unique_items', None)
A:pydantic.v1.fields.self.min_length->kwargs.pop('min_length', None)
A:pydantic.v1.fields.self.max_length->kwargs.pop('max_length', None)
A:pydantic.v1.fields.self.allow_mutation->kwargs.pop('allow_mutation', True)
A:pydantic.v1.fields.self.regex->kwargs.pop('regex', None)
A:pydantic.v1.fields.self.discriminator->kwargs.pop('discriminator', None)
A:pydantic.v1.fields.self.repr->kwargs.pop('repr', True)
A:pydantic.v1.fields.current_value->getattr(self, attr_name)
A:pydantic.v1.fields.field_info->FieldInfo(value, **field_info_from_config)
A:pydantic.v1.fields.field_info_from_config->config.get_field_info(field_name)
A:pydantic.v1.fields.(field_info, value)->cls._get_field_info(name, annotation, value, config)
A:pydantic.v1.fields.annotation->get_annotation_from_field_info(annotation, field_info, name, config.validate_assignment)
A:pydantic.v1.fields.info_from_config->config.get_field_info(self.name)
A:pydantic.v1.fields.new_alias->config.get_field_info(self.name).get('alias')
A:pydantic.v1.fields.new_exclude->config.get_field_info(self.name).get('exclude')
A:pydantic.v1.fields.self.field_info.exclude->pydantic.v1.utils.ValueItems.merge(self.field_info.exclude, new_exclude)
A:pydantic.v1.fields.new_include->config.get_field_info(self.name).get('include')
A:pydantic.v1.fields.self.field_info.include->pydantic.v1.utils.ValueItems.merge(self.field_info.include, new_include, intersect=True)
A:pydantic.v1.fields.default_value->self.get_default()
A:pydantic.v1.fields.self.type_->new_type_supertype(self.type_)
A:pydantic.v1.fields.origin->get_origin(self.type_)
A:pydantic.v1.fields.args->get_args(self.type_)
A:pydantic.v1.fields.get_validators->getattr(self.type_, '__get_validators__', None)
A:pydantic.v1.fields.self.key_field->self._create_sub_type(get_args(self.type_)[0], 'key_' + self.name, for_keys=True)
A:pydantic.v1.fields.(alias, discriminator_values)->get_discriminator_alias_and_values(t, self.discriminator_key)
A:pydantic.v1.fields.self.discriminator_alias->get_unique_discriminator_alias(all_aliases, self.discriminator_key)
A:pydantic.v1.fields.(field_info, _)->self._get_field_info(name, type_, None, self.model_config)
A:pydantic.v1.fields.class_validators_->self.class_validators.values()
A:pydantic.v1.fields.self.validators->prep_validators(v_funcs)
A:pydantic.v1.fields.(v, errors)->self._apply_validators(v, values, loc, cls, self.post_validators)
A:pydantic.v1.fields.e->pydantic.v1.errors.TupleLengthError(actual_length=actual_length, expected_length=expected_length)
A:pydantic.v1.fields.(r, ee)->field.validate(v_, values, loc=v_loc, cls=cls)
A:pydantic.v1.fields.converted->deque(result, maxlen=getattr(v, 'maxlen', None))
A:pydantic.v1.fields.iterable->iter(v)
A:pydantic.v1.fields.v_iter->dict_validator(v)
A:pydantic.v1.fields.(key_result, key_errors)->self.key_field.validate(k, values, loc=v_loc, cls=cls)
A:pydantic.v1.fields.(value_result, value_errors)->self._validate_singleton(v_, values, v_loc, cls)
A:pydantic.v1.fields.(value, error)->field.validate(v, values, loc=loc, cls=cls)
A:pydantic.v1.fields.discriminator_value->getattr(v, self.discriminator_key)
A:pydantic.v1.fields.v->validator(cls, v, values, self, self.model_config)
A:pydantic.v1.fields.t->SHAPE_NAME_LOOKUP[self.shape].format(t)
pydantic.v1.Field(default:Any=Undefined,*,default_factory:Optional[NoArgAnyCallable]=None,alias:Optional[str]=None,title:Optional[str]=None,description:Optional[str]=None,exclude:Optional[Union['AbstractSetIntStr','MappingIntStrAny',Any]]=None,include:Optional[Union['AbstractSetIntStr','MappingIntStrAny',Any]]=None,const:Optional[bool]=None,gt:Optional[float]=None,ge:Optional[float]=None,lt:Optional[float]=None,le:Optional[float]=None,multiple_of:Optional[float]=None,allow_inf_nan:Optional[bool]=None,max_digits:Optional[int]=None,decimal_places:Optional[int]=None,min_items:Optional[int]=None,max_items:Optional[int]=None,unique_items:Optional[bool]=None,min_length:Optional[int]=None,max_length:Optional[int]=None,allow_mutation:bool=True,regex:Optional[str]=None,discriminator:Optional[str]=None,repr:bool=True,**extra:Any)->Any
pydantic.v1.FieldInfo(self,default:Any=Undefined,**kwargs:Any)
pydantic.v1.FieldInfo.__repr_args__(self)->'ReprArgs'
pydantic.v1.FieldInfo._validate(self)->None
pydantic.v1.FieldInfo.get_constraints(self)->Set[str]
pydantic.v1.FieldInfo.update_from_config(self,from_config:Dict[str,Any])->None
pydantic.v1.PrivateAttr(default:Any=Undefined,*,default_factory:Optional[NoArgAnyCallable]=None)->Any
pydantic.v1.fields.DeferredType
pydantic.v1.fields.Field(default:Any=Undefined,*,default_factory:Optional[NoArgAnyCallable]=None,alias:Optional[str]=None,title:Optional[str]=None,description:Optional[str]=None,exclude:Optional[Union['AbstractSetIntStr','MappingIntStrAny',Any]]=None,include:Optional[Union['AbstractSetIntStr','MappingIntStrAny',Any]]=None,const:Optional[bool]=None,gt:Optional[float]=None,ge:Optional[float]=None,lt:Optional[float]=None,le:Optional[float]=None,multiple_of:Optional[float]=None,allow_inf_nan:Optional[bool]=None,max_digits:Optional[int]=None,decimal_places:Optional[int]=None,min_items:Optional[int]=None,max_items:Optional[int]=None,unique_items:Optional[bool]=None,min_length:Optional[int]=None,max_length:Optional[int]=None,allow_mutation:bool=True,regex:Optional[str]=None,discriminator:Optional[str]=None,repr:bool=True,**extra:Any)->Any
pydantic.v1.fields.FieldInfo(self,default:Any=Undefined,**kwargs:Any)
pydantic.v1.fields.FieldInfo.__init__(self,default:Any=Undefined,**kwargs:Any)
pydantic.v1.fields.FieldInfo.__repr_args__(self)->'ReprArgs'
pydantic.v1.fields.FieldInfo._validate(self)->None
pydantic.v1.fields.FieldInfo.get_constraints(self)->Set[str]
pydantic.v1.fields.FieldInfo.update_from_config(self,from_config:Dict[str,Any])->None
pydantic.v1.fields.ModelField(self,*,name:str,type_:Type[Any],class_validators:Optional[Dict[str,Validator]],model_config:Type['BaseConfig'],default:Any=None,default_factory:Optional[NoArgAnyCallable]=None,required:'BoolUndefined'=Undefined,final:bool=False,alias:Optional[str]=None,field_info:Optional[FieldInfo]=None)
pydantic.v1.fields.ModelField.__init__(self,*,name:str,type_:Type[Any],class_validators:Optional[Dict[str,Validator]],model_config:Type['BaseConfig'],default:Any=None,default_factory:Optional[NoArgAnyCallable]=None,required:'BoolUndefined'=Undefined,final:bool=False,alias:Optional[str]=None,field_info:Optional[FieldInfo]=None)
pydantic.v1.fields.ModelField.__repr_args__(self)->'ReprArgs'
pydantic.v1.fields.ModelField._apply_validators(self,v:Any,values:Dict[str,Any],loc:'LocStr',cls:Optional['ModelOrDc'],validators:'ValidatorsList')->'ValidateReturn'
pydantic.v1.fields.ModelField._create_sub_type(self,type_:Type[Any],name:str,*,for_keys:bool=False)->'ModelField'
pydantic.v1.fields.ModelField._get_field_info(field_name:str,annotation:Any,value:Any,config:Type['BaseConfig'])->Tuple[FieldInfo, Any]
pydantic.v1.fields.ModelField._get_mapping_value(self,original:T,converted:Dict[Any,Any])->Union[T, Dict[Any, Any]]
pydantic.v1.fields.ModelField._set_default_and_type(self)->None
pydantic.v1.fields.ModelField._type_analysis(self)->None
pydantic.v1.fields.ModelField._type_display(self)->PyObjectStr
pydantic.v1.fields.ModelField._validate_discriminated_union(self,v:Any,values:Dict[str,Any],loc:'LocStr',cls:Optional['ModelOrDc'])->'ValidateReturn'
pydantic.v1.fields.ModelField._validate_iterable(self,v:Any,values:Dict[str,Any],loc:'LocStr',cls:Optional['ModelOrDc'])->'ValidateReturn'
pydantic.v1.fields.ModelField._validate_mapping_like(self,v:Any,values:Dict[str,Any],loc:'LocStr',cls:Optional['ModelOrDc'])->'ValidateReturn'
pydantic.v1.fields.ModelField._validate_sequence_like(self,v:Any,values:Dict[str,Any],loc:'LocStr',cls:Optional['ModelOrDc'])->'ValidateReturn'
pydantic.v1.fields.ModelField._validate_singleton(self,v:Any,values:Dict[str,Any],loc:'LocStr',cls:Optional['ModelOrDc'])->'ValidateReturn'
pydantic.v1.fields.ModelField._validate_tuple(self,v:Any,values:Dict[str,Any],loc:'LocStr',cls:Optional['ModelOrDc'])->'ValidateReturn'
pydantic.v1.fields.ModelField.alt_alias(self)->bool
pydantic.v1.fields.ModelField.get_default(self)->Any
pydantic.v1.fields.ModelField.infer(cls,*,name:str,value:Any,annotation:Any,class_validators:Optional[Dict[str,Validator]],config:Type['BaseConfig'])->'ModelField'
pydantic.v1.fields.ModelField.is_complex(self)->bool
pydantic.v1.fields.ModelField.populate_validators(self)->None
pydantic.v1.fields.ModelField.prepare(self)->None
pydantic.v1.fields.ModelField.prepare_discriminated_union_sub_fields(self)->None
pydantic.v1.fields.ModelField.set_config(self,config:Type['BaseConfig'])->None
pydantic.v1.fields.ModelField.validate(self,v:Any,values:Dict[str,Any],*,loc:'LocStr',cls:Optional['ModelOrDc']=None)->'ValidateReturn'
pydantic.v1.fields.ModelPrivateAttr(self,default:Any=Undefined,*,default_factory:Optional[NoArgAnyCallable]=None)
pydantic.v1.fields.ModelPrivateAttr.__eq__(self,other:Any)->bool
pydantic.v1.fields.ModelPrivateAttr.__init__(self,default:Any=Undefined,*,default_factory:Optional[NoArgAnyCallable]=None)
pydantic.v1.fields.ModelPrivateAttr.get_default(self)->Any
pydantic.v1.fields.PrivateAttr(default:Any=Undefined,*,default_factory:Optional[NoArgAnyCallable]=None)->Any
pydantic.v1.fields.UndefinedType
pydantic.v1.fields.UndefinedType.__copy__(self:T)->T
pydantic.v1.fields.UndefinedType.__deepcopy__(self:T,_:Any)->T
pydantic.v1.fields.UndefinedType.__reduce__(self)->str
pydantic.v1.fields.UndefinedType.__repr__(self)->str
pydantic.v1.fields.is_finalvar_with_default_val(type_:Type[Any],val:Any)->bool


----------------------------------------/dataset/nuaa/anaconda3/envs/pydantic2.10.6/lib/python3.9/site-packages/pydantic/v1/error_wrappers.py----------------------------------------
A:pydantic.v1.error_wrappers.self._error_cache->list(flatten_errors(self.raw_errors, config))
A:pydantic.v1.error_wrappers.errors->self.errors()
A:pydantic.v1.error_wrappers.no_errors->len(errors)
A:pydantic.v1.error_wrappers.ctx->error.get('ctx')
A:pydantic.v1.error_wrappers.error_loc->error.loc_tuple()
A:pydantic.v1.error_wrappers.type_->get_exc_type(exc.__class__)
A:pydantic.v1.error_wrappers.msg->str(exc)
A:pydantic.v1.error_wrappers.r->_get_exc_type(cls)
pydantic.v1.ValidationError(self,errors:Sequence[ErrorList],model:'ModelOrDc')
pydantic.v1.ValidationError.__repr_args__(self)->'ReprArgs'
pydantic.v1.ValidationError.__str__(self)->str
pydantic.v1.ValidationError.errors(self)->List['ErrorDict']
pydantic.v1.ValidationError.json(self,*,indent:Union[None,int,str]=2)->str
pydantic.v1.error_wrappers.ErrorWrapper(self,exc:Exception,loc:Union[str,'Loc'])
pydantic.v1.error_wrappers.ErrorWrapper.__init__(self,exc:Exception,loc:Union[str,'Loc'])
pydantic.v1.error_wrappers.ErrorWrapper.__repr_args__(self)->'ReprArgs'
pydantic.v1.error_wrappers.ErrorWrapper.loc_tuple(self)->'Loc'
pydantic.v1.error_wrappers.ValidationError(self,errors:Sequence[ErrorList],model:'ModelOrDc')
pydantic.v1.error_wrappers.ValidationError.__init__(self,errors:Sequence[ErrorList],model:'ModelOrDc')
pydantic.v1.error_wrappers.ValidationError.__repr_args__(self)->'ReprArgs'
pydantic.v1.error_wrappers.ValidationError.__str__(self)->str
pydantic.v1.error_wrappers.ValidationError.errors(self)->List['ErrorDict']
pydantic.v1.error_wrappers.ValidationError.json(self,*,indent:Union[None,int,str]=2)->str
pydantic.v1.error_wrappers._display_error_loc(error:'ErrorDict')->str
pydantic.v1.error_wrappers._display_error_type_and_ctx(error:'ErrorDict')->str
pydantic.v1.error_wrappers._get_exc_type(cls:Type[Exception])->str
pydantic.v1.error_wrappers.display_errors(errors:List['ErrorDict'])->str
pydantic.v1.error_wrappers.error_dict(exc:Exception,config:Type['BaseConfig'],loc:'Loc')->'ErrorDict'
pydantic.v1.error_wrappers.flatten_errors(errors:Sequence[Any],config:Type['BaseConfig'],loc:Optional['Loc']=None)->Generator['ErrorDict', None, None]
pydantic.v1.error_wrappers.get_exc_type(cls:Type[Exception])->str


----------------------------------------/dataset/nuaa/anaconda3/envs/pydantic2.10.6/lib/python3.9/site-packages/pydantic/v1/mypy.py----------------------------------------
A:pydantic.v1.mypy.MYPY_VERSION_TUPLE->parse_mypy_version(mypy_version)
A:pydantic.v1.mypy.self.plugin_config->PydanticPluginConfig(options)
A:pydantic.v1.mypy.self._plugin_data->self.plugin_config.to_data()
A:pydantic.v1.mypy.sym->SymbolTableNode(MDEF, func)
A:pydantic.v1.mypy.transformer->PydanticModelTransformer(ctx, self.plugin_config)
A:pydantic.v1.mypy.args->getattr(ret_type, 'args', None)
A:pydantic.v1.mypy.ret_type.args->tuple((default_any_type for _ in args))
A:pydantic.v1.mypy.toml_config->parse_toml(options.config_file)
A:pydantic.v1.mypy.config->ModelConfigData()
A:pydantic.v1.mypy.setting->ConfigParser().getboolean(CONFIGFILE_KEY, key, fallback=False)
A:pydantic.v1.mypy.plugin_config->ConfigParser()
A:pydantic.v1.mypy.pydantic_metadata->model_type.type.metadata.get(METADATA_KEY)
A:pydantic.v1.mypy.orm_mode->model_type.type.metadata.get(METADATA_KEY).get('config', {}).get('orm_mode')
A:pydantic.v1.mypy.fields->self.collect_fields(config)
A:pydantic.v1.mypy.is_settings->any((get_fullname(base) == BASESETTINGS_FULLNAME for base in info.mro[:-1]))
A:pydantic.v1.mypy.known_fields->set()
A:pydantic.v1.mypy.is_required->self.get_is_required(cls, stmt, lhs)
A:pydantic.v1.mypy.(alias, has_dynamic_alias)->self.get_alias_info(stmt)
A:pydantic.v1.mypy.all_fields->self.collect_fields(config).copy()
A:pydantic.v1.mypy.field->PydanticModelField.deserialize(info, data)
A:pydantic.v1.mypy.init_arguments->self.get_field_arguments(fields, typed=typed, force_all_optional=force_all_optional, use_alias=use_alias)
A:pydantic.v1.mypy.var->PydanticModelField.deserialize(info, data).to_var(info, use_alias=False)
A:pydantic.v1.mypy.set_str->ctx.api.named_type(f'{BUILTINS_NAME}.set', [ctx.api.named_type(f'{BUILTINS_NAME}.str')])
A:pydantic.v1.mypy.optional_set_str->UnionType([set_str, NoneType()])
A:pydantic.v1.mypy.fields_set_argument->Argument(Var('_fields_set', optional_set_str), optional_set_str, None, ARG_OPT)
A:pydantic.v1.mypy.construct_arguments->self.get_field_arguments(fields, typed=True, force_all_optional=False, use_alias=False)
A:pydantic.v1.mypy.obj_type->ctx.api.named_type(f'{BUILTINS_NAME}.object')
A:pydantic.v1.mypy.tvd->TypeVarDef(self_tvar_name, tvar_fullname, -1, [], obj_type)
A:pydantic.v1.mypy.self_tvar_expr->TypeVarExpr(self_tvar_name, tvar_fullname, [], obj_type)
A:pydantic.v1.mypy.ctx.cls.info.names[self_tvar_name]->SymbolTableNode(MDEF, self_tvar_expr)
A:pydantic.v1.mypy.self_type->TypeVarType(tvd)
A:pydantic.v1.mypy.sym_node->info.names.get(field.name)
A:pydantic.v1.mypy.var_str->repr(var)
A:pydantic.v1.mypy.info.names[get_name(var)]->SymbolTableNode(MDEF, var)
A:pydantic.v1.mypy.value_type->get_proper_type(cls.info[lhs.name].type)
A:pydantic.v1.mypy.type_annotation->AnyType(TypeOfAny.explicit)
A:pydantic.v1.mypy.ERROR_ORM->ErrorCode('pydantic-orm', 'Invalid from_orm call', 'Pydantic')
A:pydantic.v1.mypy.ERROR_CONFIG->ErrorCode('pydantic-config', 'Invalid config value', 'Pydantic')
A:pydantic.v1.mypy.ERROR_ALIAS->ErrorCode('pydantic-alias', 'Dynamic alias disallowed', 'Pydantic')
A:pydantic.v1.mypy.ERROR_UNEXPECTED->ErrorCode('pydantic-unexpected', 'Unexpected behavior', 'Pydantic')
A:pydantic.v1.mypy.ERROR_UNTYPED->ErrorCode('pydantic-field', 'Untyped field disallowed', 'Pydantic')
A:pydantic.v1.mypy.ERROR_FIELD_DEFAULTS->ErrorCode('pydantic-field', 'Invalid Field defaults', 'Pydantic')
A:pydantic.v1.mypy.function_type->ctx.api.named_type(f'{BUILTINS_NAME}.function')
A:pydantic.v1.mypy.signature->CallableType(arg_types, arg_kinds, arg_names, return_type, function_type)
A:pydantic.v1.mypy.func->FuncDef(name, args, Block([PassStmt()]))
A:pydantic.v1.mypy.func.type->set_callable_name(signature, func)
A:pydantic.v1.mypy.r_name->get_unique_redefinition_name(name, info.names)
A:pydantic.v1.mypy.v->Var(name, func.type)
A:pydantic.v1.mypy.dec->Decorator(func, [NameExpr('classmethod')], v)
pydantic.v1.mypy.ModelConfigData(self,forbid_extra:Optional[bool]=None,allow_mutation:Optional[bool]=None,frozen:Optional[bool]=None,orm_mode:Optional[bool]=None,allow_population_by_field_name:Optional[bool]=None,has_alias_generator:Optional[bool]=None)
pydantic.v1.mypy.ModelConfigData.__init__(self,forbid_extra:Optional[bool]=None,allow_mutation:Optional[bool]=None,frozen:Optional[bool]=None,orm_mode:Optional[bool]=None,allow_population_by_field_name:Optional[bool]=None,has_alias_generator:Optional[bool]=None)
pydantic.v1.mypy.ModelConfigData.set_values_dict(self)->Dict[str, Any]
pydantic.v1.mypy.ModelConfigData.setdefault(self,key:str,value:Any)->None
pydantic.v1.mypy.ModelConfigData.update(self,config:Optional['ModelConfigData'])->None
pydantic.v1.mypy.PydanticModelField(self,name:str,is_required:bool,alias:Optional[str],has_dynamic_alias:bool,line:int,column:int)
pydantic.v1.mypy.PydanticModelField.__init__(self,name:str,is_required:bool,alias:Optional[str],has_dynamic_alias:bool,line:int,column:int)
pydantic.v1.mypy.PydanticModelField.deserialize(cls,info:TypeInfo,data:JsonDict)->'PydanticModelField'
pydantic.v1.mypy.PydanticModelField.serialize(self)->JsonDict
pydantic.v1.mypy.PydanticModelField.to_argument(self,info:TypeInfo,typed:bool,force_optional:bool,use_alias:bool)->Argument
pydantic.v1.mypy.PydanticModelField.to_var(self,info:TypeInfo,use_alias:bool)->Var
pydantic.v1.mypy.PydanticModelTransformer(self,ctx:ClassDefContext,plugin_config:PydanticPluginConfig)
pydantic.v1.mypy.PydanticModelTransformer.__init__(self,ctx:ClassDefContext,plugin_config:PydanticPluginConfig)
pydantic.v1.mypy.PydanticModelTransformer.add_construct_method(self,fields:List['PydanticModelField'])->None
pydantic.v1.mypy.PydanticModelTransformer.add_initializer(self,fields:List['PydanticModelField'],config:'ModelConfigData',is_settings:bool)->None
pydantic.v1.mypy.PydanticModelTransformer.adjust_validator_signatures(self)->None
pydantic.v1.mypy.PydanticModelTransformer.collect_config(self)->'ModelConfigData'
pydantic.v1.mypy.PydanticModelTransformer.collect_fields(self,model_config:'ModelConfigData')->List['PydanticModelField']
pydantic.v1.mypy.PydanticModelTransformer.get_alias_info(stmt:AssignmentStmt)->Tuple[Optional[str], bool]
pydantic.v1.mypy.PydanticModelTransformer.get_config_update(self,substmt:AssignmentStmt)->Optional['ModelConfigData']
pydantic.v1.mypy.PydanticModelTransformer.get_field_arguments(self,fields:List['PydanticModelField'],typed:bool,force_all_optional:bool,use_alias:bool)->List[Argument]
pydantic.v1.mypy.PydanticModelTransformer.get_is_required(cls:ClassDef,stmt:AssignmentStmt,lhs:NameExpr)->bool
pydantic.v1.mypy.PydanticModelTransformer.is_dynamic_alias_present(fields:List['PydanticModelField'],has_alias_generator:bool)->bool
pydantic.v1.mypy.PydanticModelTransformer.set_frozen(self,fields:List['PydanticModelField'],frozen:bool)->None
pydantic.v1.mypy.PydanticModelTransformer.should_init_forbid_extra(self,fields:List['PydanticModelField'],config:'ModelConfigData')->bool
pydantic.v1.mypy.PydanticModelTransformer.transform(self)->None
pydantic.v1.mypy.PydanticModelTransformer.type_has_implicit_default(type_:Optional[ProperType])->bool
pydantic.v1.mypy.PydanticPlugin(self,options:Options)
pydantic.v1.mypy.PydanticPlugin.__init__(self,options:Options)
pydantic.v1.mypy.PydanticPlugin._pydantic_field_callback(self,ctx:FunctionContext)->'Type'
pydantic.v1.mypy.PydanticPlugin._pydantic_model_class_maker_callback(self,ctx:ClassDefContext)->None
pydantic.v1.mypy.PydanticPlugin._pydantic_model_metaclass_marker_callback(self,ctx:ClassDefContext)->None
pydantic.v1.mypy.PydanticPlugin.get_base_class_hook(self,fullname:str)->'Optional[Callable[[ClassDefContext], None]]'
pydantic.v1.mypy.PydanticPlugin.get_class_decorator_hook(self,fullname:str)->Optional[Callable[[ClassDefContext], None]]
pydantic.v1.mypy.PydanticPlugin.get_function_hook(self,fullname:str)->'Optional[Callable[[FunctionContext], Type]]'
pydantic.v1.mypy.PydanticPlugin.get_metaclass_hook(self,fullname:str)->Optional[Callable[[ClassDefContext], None]]
pydantic.v1.mypy.PydanticPlugin.get_method_hook(self,fullname:str)->Optional[Callable[[MethodContext], Type]]
pydantic.v1.mypy.PydanticPlugin.report_config_data(self,ctx:ReportConfigContext)->Dict[str, Any]
pydantic.v1.mypy.PydanticPluginConfig(self,options:Options)
pydantic.v1.mypy.PydanticPluginConfig.__init__(self,options:Options)
pydantic.v1.mypy.PydanticPluginConfig.to_data(self)->Dict[str, Any]
pydantic.v1.mypy.add_method(ctx:ClassDefContext,name:str,args:List[Argument],return_type:Type,self_type:Optional[Type]=None,tvar_def:Optional[TypeVarDef]=None,is_classmethod:bool=False,is_new:bool=False)->None
pydantic.v1.mypy.error_default_and_default_factory_specified(api:CheckerPluginInterface,context:Context)->None
pydantic.v1.mypy.error_from_orm(model_name:str,api:CheckerPluginInterface,context:Context)->None
pydantic.v1.mypy.error_invalid_config_value(name:str,api:SemanticAnalyzerPluginInterface,context:Context)->None
pydantic.v1.mypy.error_required_dynamic_aliases(api:SemanticAnalyzerPluginInterface,context:Context)->None
pydantic.v1.mypy.error_unexpected_behavior(detail:str,api:Union[CheckerPluginInterface,SemanticAnalyzerPluginInterface],context:Context)->None
pydantic.v1.mypy.error_untyped_fields(api:SemanticAnalyzerPluginInterface,context:Context)->None
pydantic.v1.mypy.from_orm_callback(ctx:MethodContext)->Type
pydantic.v1.mypy.get_fullname(x:Union[FuncBase,SymbolNode])->str
pydantic.v1.mypy.get_name(x:Union[FuncBase,SymbolNode])->str
pydantic.v1.mypy.parse_mypy_version(version:str)->Tuple[int, ...]
pydantic.v1.mypy.parse_toml(config_file:str)->Optional[Dict[str, Any]]
pydantic.v1.mypy.plugin(version:str)->'TypingType[Plugin]'


----------------------------------------/dataset/nuaa/anaconda3/envs/pydantic2.10.6/lib/python3.9/site-packages/pydantic/v1/typing.py----------------------------------------
A:pydantic.v1.typing._T->TypeVar('_T')
A:pydantic.v1.typing.origin->get_origin(tp)
A:pydantic.v1.typing.args->get_args(type_)
A:pydantic.v1.typing.converted->tuple((ForwardRef(arg) if isinstance(arg, str) and isinstance(tp, TypingGenericAlias) else convert_generics(arg) for arg in args))
A:pydantic.v1.typing.value->_eval_type(value, base_globals, None)
A:pydantic.v1.typing.values->literal_values(type_)
A:pydantic.v1.typing.test_type->NewType('test_type', str)
A:pydantic.v1.typing.field.type_->evaluate_forwardref(field.type_, globalns, localns or None)
A:pydantic.v1.typing.field.outer_type_->evaluate_forwardref(field.outer_type_, globalns, localns or None)
A:pydantic.v1.typing.globalns->sys.modules[model.__module__].__dict__.copy()
A:pydantic.v1.typing.new_key->evaluate_forwardref(fr, globalns, localns or None)
A:pydantic.v1.typing.json_encoders[new_key]->json_encoders.pop(key)
pydantic.v1.typing._check_classvar(v:Optional[Type[Any]])->bool
pydantic.v1.typing._check_finalvar(v:Optional[Type[Any]])->bool
pydantic.v1.typing._check_typeddict_special(type_:Any)->bool
pydantic.v1.typing.all_literal_values(type_:Type[Any])->Tuple[Any, ...]
pydantic.v1.typing.display_as_type(v:Type[Any])->str
pydantic.v1.typing.get_class(type_:Type[Any])->Union[None, bool, Type[Any]]
pydantic.v1.typing.get_sub_types(tp:Any)->List[Any]
pydantic.v1.typing.is_callable_type(type_:Type[Any])->bool
pydantic.v1.typing.is_classvar(ann_type:Type[Any])->bool
pydantic.v1.typing.is_finalvar(ann_type:Type[Any])->bool
pydantic.v1.typing.is_literal_type(type_:Type[Any])->bool
pydantic.v1.typing.is_namedtuple(type_:Type[Any])->bool
pydantic.v1.typing.is_new_type(type_:Type[Any])->bool
pydantic.v1.typing.is_typeddict(type_:Type[Any])->bool
pydantic.v1.typing.is_typeddict_special(type_:Any)->bool
pydantic.v1.typing.literal_values(type_:Type[Any])->Tuple[Any, ...]
pydantic.v1.typing.new_type_supertype(type_:Type[Any])->Type[Any]
pydantic.v1.typing.resolve_annotations(raw_annotations:Dict[str,Type[Any]],module_name:Optional[str])->Dict[str, Type[Any]]
pydantic.v1.typing.update_field_forward_refs(field:'ModelField',globalns:Any,localns:Any)->None
pydantic.v1.typing.update_model_forward_refs(model:Type[Any],fields:Iterable['ModelField'],json_encoders:Dict[Union[Type[Any],str,ForwardRef],AnyCallable],localns:'DictStrAny',exc_to_suppress:Tuple[Type[BaseException],...]=())->None


----------------------------------------/dataset/nuaa/anaconda3/envs/pydantic2.10.6/lib/python3.9/site-packages/pydantic/v1/main.py----------------------------------------
A:pydantic.v1.main.Model->TypeVar('Model', bound='BaseModel')
A:pydantic.v1.main._T->TypeVar('_T')
A:pydantic.v1.main.config->inherit_config(config_from_namespace, config, **config_kwargs)
A:pydantic.v1.main.validators->inherit_validators(extract_validators(namespace), validators)
A:pydantic.v1.main.resolve_forward_refs->kwargs.pop('__resolve_forward_refs__', True)
A:pydantic.v1.main.config_from_namespace->namespace.get('Config')
A:pydantic.v1.main.vg->ValidatorGroup(validators)
A:pydantic.v1.main.extra_validators->ValidatorGroup(validators).get_validators(f.name)
A:pydantic.v1.main.annotations->resolve_annotations(namespace.get('__annotations__', {}), namespace.get('__module__', None))
A:pydantic.v1.main.value->field.get_default()
A:pydantic.v1.main.fields[ann_name]->pydantic.v1.fields.ModelField.infer(name=ann_name, value=value, annotation=ann_type, class_validators=vg.get_validators(ann_name), config=config)
A:pydantic.v1.main.private_attributes[ann_name]->PrivateAttr()
A:pydantic.v1.main.private_attributes[var_name]->PrivateAttr(default=value)
A:pydantic.v1.main.inferred->pydantic.v1.fields.ModelField.infer(name=var_name, value=value, annotation=annotations.get(var_name, Undefined), class_validators=vg.get_validators(var_name), config=config)
A:pydantic.v1.main.json_encoder->partial(custom_pydantic_encoder, config.json_encoders)
A:pydantic.v1.main.(pre_rv_new, post_rv_new)->extract_root_validators(namespace)
A:pydantic.v1.main.hash_func->generate_hash_function(config.frozen)
A:pydantic.v1.main.cls->super().__new__(mcs, name, bases, new_namespace, **kwargs)
A:pydantic.v1.main.cls.__signature__->ClassAttribute('__signature__', generate_model_signature(cls.__init__, fields, config))
A:pydantic.v1.main.set_name->getattr(obj, '__set_name__', None)
A:pydantic.v1.main.(values, fields_set, validation_error)->validate_model(cls, obj)
A:pydantic.v1.main.new_values->validator(self.__class__, new_values)
A:pydantic.v1.main.known_field->self.__fields__.get(name, None)
A:pydantic.v1.main.(value, error_)->self.__fields__.get(name, None).validate(value, dict_without_original_value, loc=name, cls=self.__class__)
A:pydantic.v1.main.default->private_attr.get_default()
A:pydantic.v1.main.encoder->cast(Callable[[Any], Any], encoder or self.__json_encoder__)
A:pydantic.v1.main.data->dict(self._iter(to_dict=models_as_dict, by_alias=by_alias, include=include, exclude=exclude, exclude_unset=exclude_unset, exclude_defaults=exclude_defaults, exclude_none=exclude_none))
A:pydantic.v1.main.obj->load_file(path, proto=proto, content_type=content_type, encoding=encoding, allow_pickle=allow_pickle, json_loads=cls.__config__.json_loads)
A:pydantic.v1.main.exc->TypeError(f'{cls.__name__} expected dict not {obj.__class__.__name__}')
A:pydantic.v1.main.m->super().__new__(mcs, name, bases, new_namespace, **kwargs).__new__(cls)
A:pydantic.v1.main.fields_values[name]->field.get_default()
A:pydantic.v1.main._fields_set->set(values.keys())
A:pydantic.v1.main.values->validator(cls_, values)
A:pydantic.v1.main.fields_set->set()
A:pydantic.v1.main.cached->super().__new__(mcs, name, bases, new_namespace, **kwargs).__schema_cache__.get((by_alias, ref_template))
A:pydantic.v1.main.s->model_schema(cls, by_alias=by_alias, ref_template=ref_template)
A:pydantic.v1.main.value_as_dict->dict(value)
A:pydantic.v1.main.v_dict->self._get_value(v, to_dict=to_dict, by_alias=by_alias, include=value_include and value_include.for_element(field_key), exclude=value_exclude and value_exclude.for_element(field_key), exclude_unset=exclude_unset, exclude_defaults=exclude_defaults, exclude_none=exclude_none).dict(by_alias=by_alias, exclude_unset=exclude_unset, exclude_defaults=exclude_defaults, include=include, exclude=exclude, exclude_none=exclude_none)
A:pydantic.v1.main.exclude->pydantic.v1.utils.ValueItems.merge(self.__exclude_fields__, exclude)
A:pydantic.v1.main.include->pydantic.v1.utils.ValueItems.merge(self.__include_fields__, include, intersect=True)
A:pydantic.v1.main.allowed_keys->self._calculate_keys(include=include, exclude=exclude, exclude_unset=exclude_unset)
A:pydantic.v1.main.model_field->self.__fields__.get(field_key)
A:pydantic.v1.main.v->self._get_value(v, to_dict=to_dict, by_alias=by_alias, include=value_include and value_include.for_element(field_key), exclude=value_exclude and value_exclude.for_element(field_key), exclude_unset=exclude_unset, exclude_defaults=exclude_defaults, exclude_none=exclude_none)
A:pydantic.v1.main.keys->self.__dict__.keys()
A:pydantic.v1.main.namespace['Config']->inherit_config(__config__, BaseConfig)
A:pydantic.v1.main.resolved_bases->resolve_bases(__base__)
A:pydantic.v1.main.(meta, ns, kwds)->prepare_class(__model_name, resolved_bases, kwds=__cls_kwargs__)
A:pydantic.v1.main._missing->object()
A:pydantic.v1.main.names_used->set()
A:pydantic.v1.main.input_data->validator(cls_, input_data)
A:pydantic.v1.main.(v_, errors_)->field.validate(value, values, loc=field.alias, cls=cls_)
pydantic.v1.BaseModel(__pydantic_self__,**data:Any)
pydantic.v1.BaseModel.__eq__(self,other:Any)->bool
pydantic.v1.BaseModel.__get_validators__(cls)->'CallableGenerator'
pydantic.v1.BaseModel.__getstate__(self)->'DictAny'
pydantic.v1.BaseModel.__iter__(self)->'TupleGenerator'
pydantic.v1.BaseModel.__repr_args__(self)->'ReprArgs'
pydantic.v1.BaseModel.__setattr__(self,name,value)
pydantic.v1.BaseModel.__setstate__(self,state:'DictAny')->None
pydantic.v1.BaseModel.__try_update_forward_refs__(cls,**localns:Any)->None
pydantic.v1.BaseModel._calculate_keys(self,include:Optional['MappingIntStrAny'],exclude:Optional['MappingIntStrAny'],exclude_unset:bool,update:Optional['DictStrAny']=None)->Optional[AbstractSet[str]]
pydantic.v1.BaseModel._copy_and_set_values(self:'Model',values:'DictStrAny',fields_set:'SetStr',*,deep:bool)->'Model'
pydantic.v1.BaseModel._decompose_class(cls:Type['Model'],obj:Any)->GetterDict
pydantic.v1.BaseModel._enforce_dict_if_root(cls,obj:Any)->Any
pydantic.v1.BaseModel._get_value(cls,v:Any,to_dict:bool,by_alias:bool,include:Optional[Union['AbstractSetIntStr','MappingIntStrAny']],exclude:Optional[Union['AbstractSetIntStr','MappingIntStrAny']],exclude_unset:bool,exclude_defaults:bool,exclude_none:bool)->Any
pydantic.v1.BaseModel._init_private_attributes(self)->None
pydantic.v1.BaseModel._iter(self,to_dict:bool=False,by_alias:bool=False,include:Optional[Union['AbstractSetIntStr','MappingIntStrAny']]=None,exclude:Optional[Union['AbstractSetIntStr','MappingIntStrAny']]=None,exclude_unset:bool=False,exclude_defaults:bool=False,exclude_none:bool=False)->'TupleGenerator'
pydantic.v1.BaseModel.construct(cls:Type['Model'],_fields_set:Optional['SetStr']=None,**values:Any)->'Model'
pydantic.v1.BaseModel.copy(self:'Model',*,include:Optional[Union['AbstractSetIntStr','MappingIntStrAny']]=None,exclude:Optional[Union['AbstractSetIntStr','MappingIntStrAny']]=None,update:Optional['DictStrAny']=None,deep:bool=False)->'Model'
pydantic.v1.BaseModel.dict(self,*,include:Optional[Union['AbstractSetIntStr','MappingIntStrAny']]=None,exclude:Optional[Union['AbstractSetIntStr','MappingIntStrAny']]=None,by_alias:bool=False,skip_defaults:Optional[bool]=None,exclude_unset:bool=False,exclude_defaults:bool=False,exclude_none:bool=False)->'DictStrAny'
pydantic.v1.BaseModel.from_orm(cls:Type['Model'],obj:Any)->'Model'
pydantic.v1.BaseModel.json(self,*,include:Optional[Union['AbstractSetIntStr','MappingIntStrAny']]=None,exclude:Optional[Union['AbstractSetIntStr','MappingIntStrAny']]=None,by_alias:bool=False,skip_defaults:Optional[bool]=None,exclude_unset:bool=False,exclude_defaults:bool=False,exclude_none:bool=False,encoder:Optional[Callable[[Any],Any]]=None,models_as_dict:bool=True,**dumps_kwargs:Any)->str
pydantic.v1.BaseModel.parse_file(cls:Type['Model'],path:Union[str,Path],*,content_type:str=None,encoding:str='utf8',proto:Protocol=None,allow_pickle:bool=False)->'Model'
pydantic.v1.BaseModel.parse_obj(cls:Type['Model'],obj:Any)->'Model'
pydantic.v1.BaseModel.parse_raw(cls:Type['Model'],b:StrBytes,*,content_type:str=None,encoding:str='utf8',proto:Protocol=None,allow_pickle:bool=False)->'Model'
pydantic.v1.BaseModel.schema(cls,by_alias:bool=True,ref_template:str=default_ref_template)->'DictStrAny'
pydantic.v1.BaseModel.schema_json(cls,*,by_alias:bool=True,ref_template:str=default_ref_template,**dumps_kwargs:Any)->str
pydantic.v1.BaseModel.update_forward_refs(cls,**localns:Any)->None
pydantic.v1.BaseModel.validate(cls:Type['Model'],value:Any)->'Model'
pydantic.v1.ModelMetaclass(mcs,name,bases,namespace,**kwargs)
pydantic.v1.ModelMetaclass.__instancecheck__(self,instance:Any)->bool
pydantic.v1.create_model(__model_name:str,*,__config__:Optional[Type[BaseConfig]]=None,__base__:Union[None,Type['Model'],Tuple[Type['Model'],...]]=None,__module__:str=__name__,__validators__:Dict[str,'AnyClassMethod']=None,__cls_kwargs__:Dict[str,Any]=None,__slots__:Optional[Tuple[str,...]]=None,**field_definitions:Any)->Type['Model']
pydantic.v1.generate_hash_function(frozen:bool)->Optional[Callable[[Any], int]]
pydantic.v1.main.BaseModel(__pydantic_self__,**data:Any)
pydantic.v1.main.BaseModel.__eq__(self,other:Any)->bool
pydantic.v1.main.BaseModel.__get_validators__(cls)->'CallableGenerator'
pydantic.v1.main.BaseModel.__getstate__(self)->'DictAny'
pydantic.v1.main.BaseModel.__init__(__pydantic_self__,**data:Any)
pydantic.v1.main.BaseModel.__iter__(self)->'TupleGenerator'
pydantic.v1.main.BaseModel.__repr_args__(self)->'ReprArgs'
pydantic.v1.main.BaseModel.__setattr__(self,name,value)
pydantic.v1.main.BaseModel.__setstate__(self,state:'DictAny')->None
pydantic.v1.main.BaseModel.__try_update_forward_refs__(cls,**localns:Any)->None
pydantic.v1.main.BaseModel._calculate_keys(self,include:Optional['MappingIntStrAny'],exclude:Optional['MappingIntStrAny'],exclude_unset:bool,update:Optional['DictStrAny']=None)->Optional[AbstractSet[str]]
pydantic.v1.main.BaseModel._copy_and_set_values(self:'Model',values:'DictStrAny',fields_set:'SetStr',*,deep:bool)->'Model'
pydantic.v1.main.BaseModel._decompose_class(cls:Type['Model'],obj:Any)->GetterDict
pydantic.v1.main.BaseModel._enforce_dict_if_root(cls,obj:Any)->Any
pydantic.v1.main.BaseModel._get_value(cls,v:Any,to_dict:bool,by_alias:bool,include:Optional[Union['AbstractSetIntStr','MappingIntStrAny']],exclude:Optional[Union['AbstractSetIntStr','MappingIntStrAny']],exclude_unset:bool,exclude_defaults:bool,exclude_none:bool)->Any
pydantic.v1.main.BaseModel._init_private_attributes(self)->None
pydantic.v1.main.BaseModel._iter(self,to_dict:bool=False,by_alias:bool=False,include:Optional[Union['AbstractSetIntStr','MappingIntStrAny']]=None,exclude:Optional[Union['AbstractSetIntStr','MappingIntStrAny']]=None,exclude_unset:bool=False,exclude_defaults:bool=False,exclude_none:bool=False)->'TupleGenerator'
pydantic.v1.main.BaseModel.construct(cls:Type['Model'],_fields_set:Optional['SetStr']=None,**values:Any)->'Model'
pydantic.v1.main.BaseModel.copy(self:'Model',*,include:Optional[Union['AbstractSetIntStr','MappingIntStrAny']]=None,exclude:Optional[Union['AbstractSetIntStr','MappingIntStrAny']]=None,update:Optional['DictStrAny']=None,deep:bool=False)->'Model'
pydantic.v1.main.BaseModel.dict(self,*,include:Optional[Union['AbstractSetIntStr','MappingIntStrAny']]=None,exclude:Optional[Union['AbstractSetIntStr','MappingIntStrAny']]=None,by_alias:bool=False,skip_defaults:Optional[bool]=None,exclude_unset:bool=False,exclude_defaults:bool=False,exclude_none:bool=False)->'DictStrAny'
pydantic.v1.main.BaseModel.from_orm(cls:Type['Model'],obj:Any)->'Model'
pydantic.v1.main.BaseModel.json(self,*,include:Optional[Union['AbstractSetIntStr','MappingIntStrAny']]=None,exclude:Optional[Union['AbstractSetIntStr','MappingIntStrAny']]=None,by_alias:bool=False,skip_defaults:Optional[bool]=None,exclude_unset:bool=False,exclude_defaults:bool=False,exclude_none:bool=False,encoder:Optional[Callable[[Any],Any]]=None,models_as_dict:bool=True,**dumps_kwargs:Any)->str
pydantic.v1.main.BaseModel.parse_file(cls:Type['Model'],path:Union[str,Path],*,content_type:str=None,encoding:str='utf8',proto:Protocol=None,allow_pickle:bool=False)->'Model'
pydantic.v1.main.BaseModel.parse_obj(cls:Type['Model'],obj:Any)->'Model'
pydantic.v1.main.BaseModel.parse_raw(cls:Type['Model'],b:StrBytes,*,content_type:str=None,encoding:str='utf8',proto:Protocol=None,allow_pickle:bool=False)->'Model'
pydantic.v1.main.BaseModel.schema(cls,by_alias:bool=True,ref_template:str=default_ref_template)->'DictStrAny'
pydantic.v1.main.BaseModel.schema_json(cls,*,by_alias:bool=True,ref_template:str=default_ref_template,**dumps_kwargs:Any)->str
pydantic.v1.main.BaseModel.update_forward_refs(cls,**localns:Any)->None
pydantic.v1.main.BaseModel.validate(cls:Type['Model'],value:Any)->'Model'
pydantic.v1.main.ModelMetaclass(mcs,name,bases,namespace,**kwargs)
pydantic.v1.main.ModelMetaclass.__instancecheck__(self,instance:Any)->bool
pydantic.v1.main.ModelMetaclass.__new__(mcs,name,bases,namespace,**kwargs)
pydantic.v1.main.create_model(__model_name:str,*,__config__:Optional[Type[BaseConfig]]=None,__base__:Union[None,Type['Model'],Tuple[Type['Model'],...]]=None,__module__:str=__name__,__validators__:Dict[str,'AnyClassMethod']=None,__cls_kwargs__:Dict[str,Any]=None,__slots__:Optional[Tuple[str,...]]=None,**field_definitions:Any)->Type['Model']
pydantic.v1.main.generate_hash_function(frozen:bool)->Optional[Callable[[Any], int]]
pydantic.v1.main.validate_custom_root_type(fields:Dict[str,ModelField])->None
pydantic.v1.main.validate_model(model:Type[BaseModel],input_data:'DictStrAny',cls:'ModelOrDc'=None)->Tuple['DictStrAny', 'SetStr', Optional[ValidationError]]
pydantic.v1.validate_custom_root_type(fields:Dict[str,ModelField])->None
pydantic.v1.validate_model(model:Type[BaseModel],input_data:'DictStrAny',cls:'ModelOrDc'=None)->Tuple['DictStrAny', 'SetStr', Optional[ValidationError]]

